<!DOCTYPE html>
<html lang="ja" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>ロスレス音声コーデックの開発メモ - Aiki's Blog</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">




<style type="text/css">

/*some stuff for output/input prompts*/
div.cell{border:1px solid transparent;display:-webkit-box;-webkit-box-orient:vertical;-webkit-box-align:stretch;display:-moz-box;-moz-box-orient:vertical;-moz-box-align:stretch;display:box;box-orient:vertical;box-align:stretch;display:flex;flex-direction:column;align-items:stretch}div.cell.selected{border-radius:4px;border:thin #ababab solid}
div.cell.edit_mode{border-radius:4px;border:thin #008000 solid}
div.cell{width:100%;padding:5px 5px 5px 0;margin:0;outline:none}
div.prompt{min-width:11ex;padding:.4em;margin:0;font-family:monospace;text-align:right;line-height:1.21429em}
@media (max-width:480px){div.prompt{text-align:left}}div.inner_cell{display:-webkit-box;-webkit-box-orient:vertical;-webkit-box-align:stretch;display:-moz-box;-moz-box-orient:vertical;-moz-box-align:stretch;display:box;box-orient:vertical;box-align:stretch;display:flex;flex-direction:column;align-items:stretch;-webkit-box-flex:1;-moz-box-flex:1;box-flex:1;flex:1}
div.input_area{border:1px solid #cfcfcf;border-radius:4px;background:#f7f7f7;line-height:1.21429em}
div.prompt:empty{padding-top:0;padding-bottom:0}
div.input{page-break-inside:avoid;display:-webkit-box;-webkit-box-orient:horizontal;-webkit-box-align:stretch;display:-moz-box;-moz-box-orient:horizontal;-moz-box-align:stretch;display:box;box-orient:horizontal;box-align:stretch;}
div.inner_cell{width:90%;}
div.input_area{border:1px solid #cfcfcf;border-radius:4px;background:#f7f7f7;}
div.input_prompt{color:navy;border-top:1px solid transparent;}
div.output_wrapper{margin-top:5px;position:relative;display:-webkit-box;-webkit-box-orient:vertical;-webkit-box-align:stretch;display:-moz-box;-moz-box-orient:vertical;-moz-box-align:stretch;display:box;box-orient:vertical;box-align:stretch;width:100%;}
div.output_scroll{height:24em;width:100%;overflow:auto;border-radius:4px;-webkit-box-shadow:inset 0 2px 8px rgba(0, 0, 0, 0.8);-moz-box-shadow:inset 0 2px 8px rgba(0, 0, 0, 0.8);box-shadow:inset 0 2px 8px rgba(0, 0, 0, 0.8);}
div.output_collapsed{margin:0px;padding:0px;display:-webkit-box;-webkit-box-orient:vertical;-webkit-box-align:stretch;display:-moz-box;-moz-box-orient:vertical;-moz-box-align:stretch;display:box;box-orient:vertical;box-align:stretch;width:100%;}
div.out_prompt_overlay{height:100%;padding:0px 0.4em;position:absolute;border-radius:4px;}
div.out_prompt_overlay:hover{-webkit-box-shadow:inset 0 0 1px #000000;-moz-box-shadow:inset 0 0 1px #000000;box-shadow:inset 0 0 1px #000000;background:rgba(240, 240, 240, 0.5);}
div.output_prompt{color:darkred;}

a.anchor-link:link{text-decoration:none;padding:0px 20px;visibility:hidden;}
h1:hover .anchor-link,h2:hover .anchor-link,h3:hover .anchor-link,h4:hover .anchor-link,h5:hover .anchor-link,h6:hover .anchor-link{visibility:visible;}
/* end stuff for output/input prompts*/


.highlight-ipynb .hll { background-color: #ffffcc }
.highlight-ipynb  { background: #f8f8f8; }
.highlight-ipynb .c { color: #408080; font-style: italic } /* Comment */
.highlight-ipynb .err { border: 1px solid #FF0000 } /* Error */
.highlight-ipynb .k { color: #008000; font-weight: bold } /* Keyword */
.highlight-ipynb .o { color: #666666 } /* Operator */
.highlight-ipynb .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight-ipynb .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight-ipynb .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight-ipynb .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight-ipynb .gd { color: #A00000 } /* Generic.Deleted */
.highlight-ipynb .ge { font-style: italic } /* Generic.Emph */
.highlight-ipynb .gr { color: #FF0000 } /* Generic.Error */
.highlight-ipynb .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight-ipynb .gi { color: #00A000 } /* Generic.Inserted */
.highlight-ipynb .go { color: #888888 } /* Generic.Output */
.highlight-ipynb .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight-ipynb .gs { font-weight: bold } /* Generic.Strong */
.highlight-ipynb .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight-ipynb .gt { color: #0044DD } /* Generic.Traceback */
.highlight-ipynb .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight-ipynb .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight-ipynb .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight-ipynb .kp { color: #008000 } /* Keyword.Pseudo */
.highlight-ipynb .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight-ipynb .kt { color: #B00040 } /* Keyword.Type */
.highlight-ipynb .m { color: #666666 } /* Literal.Number */
.highlight-ipynb .s { color: #BA2121 } /* Literal.String */
.highlight-ipynb .na { color: #7D9029 } /* Name.Attribute */
.highlight-ipynb .nb { color: #008000 } /* Name.Builtin */
.highlight-ipynb .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight-ipynb .no { color: #880000 } /* Name.Constant */
.highlight-ipynb .nd { color: #AA22FF } /* Name.Decorator */
.highlight-ipynb .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight-ipynb .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight-ipynb .nf { color: #0000FF } /* Name.Function */
.highlight-ipynb .nl { color: #A0A000 } /* Name.Label */
.highlight-ipynb .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight-ipynb .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight-ipynb .nv { color: #19177C } /* Name.Variable */
.highlight-ipynb .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight-ipynb .w { color: #bbbbbb } /* Text.Whitespace */
.highlight-ipynb .mf { color: #666666 } /* Literal.Number.Float */
.highlight-ipynb .mh { color: #666666 } /* Literal.Number.Hex */
.highlight-ipynb .mi { color: #666666 } /* Literal.Number.Integer */
.highlight-ipynb .mo { color: #666666 } /* Literal.Number.Oct */
.highlight-ipynb .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight-ipynb .sc { color: #BA2121 } /* Literal.String.Char */
.highlight-ipynb .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight-ipynb .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight-ipynb .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight-ipynb .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight-ipynb .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight-ipynb .sx { color: #008000 } /* Literal.String.Other */
.highlight-ipynb .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight-ipynb .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight-ipynb .ss { color: #19177C } /* Literal.String.Symbol */
.highlight-ipynb .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight-ipynb .vc { color: #19177C } /* Name.Variable.Class */
.highlight-ipynb .vg { color: #19177C } /* Name.Variable.Global */
.highlight-ipynb .vi { color: #19177C } /* Name.Variable.Instance */
.highlight-ipynb .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>

<style type="text/css">
/* Overrides of notebook CSS for static HTML export */
div.entry-content {
  overflow: visible;
  padding: 8px;
}
.input_area {
  padding: 0.2em;
}

a.heading-anchor {
 white-space: normal;
}

.rendered_html
code {
 font-size: .8em;
}

pre.ipynb {
  color: black;
  background: #f7f7f7;
  border: none;
  box-shadow: none;
  margin-bottom: 0;
  padding: 0;
  margin: 0px;
  font-size: 13px;
}

/* remove the prompt div from text cells */
div.text_cell .prompt {
    display: none;
}

/* remove horizontal padding from text cells, */
/* so it aligns with outer body text */
div.text_cell_render {
    padding: 0.5em 0em;
}

img.anim_icon{padding:0; border:0; vertical-align:middle; -webkit-box-shadow:none; -box-shadow:none}

div.collapseheader {
    width=100%;
    padding: 2px;
    cursor: pointer;
    font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;
}

</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
<script type="text/javascript">
init_mathjax = function() {
    if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            displayAlign: 'left', // Change this to 'center' to center equations.
            "HTML-CSS": {
                styles: {'.MathJax_Display': {"margin": 0}}
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    }
}
init_mathjax();
</script>

<link rel="canonical" href="/rosuresuyin-sheng-kodetsukunokai-fa-memo.html">

        <meta name="author" content="aiki" />
        <meta name="keywords" content="Lossless audio codec" />
        <meta name="description" content="技術書典7に向けたロスレス音声コーデックの作成日誌。はてなブログから移行。" />

        <meta property="og:site_name" content="Aiki's Blog" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="ロスレス音声コーデックの開発メモ"/>
        <meta property="og:url" content="/rosuresuyin-sheng-kodetsukunokai-fa-memo.html"/>
        <meta property="og:description" content="技術書典7に向けたロスレス音声コーデックの作成日誌。はてなブログから移行。"/>
        <meta property="article:published_time" content="2022-03-05" />
            <meta property="article:section" content="記事" />
            <meta property="article:tag" content="Lossless audio codec" />
            <meta property="article:author" content="aiki" />



    <!-- Bootstrap -->
        <link rel="stylesheet" href="/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="/theme/css/pygments/native.css" rel="stylesheet">
    <link href="/theme/tipuesearch/tipuesearch.css" rel="stylesheet">
    <link rel="stylesheet" href="/theme/css/style.css" type="text/css"/>

        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Aiki's Blog ATOM Feed"/>

        <link href="/feeds/ji-shi.atom.xml" type="application/atom+xml" rel="alternate"
              title="Aiki's Blog 記事 ATOM Feed"/></head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="/" class="navbar-brand">
Aiki's Blog            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="/category/ji-shi.html">記事</a>
                        </li>
                        <li >
                            <a href="/category/qu-wei.html">趣味</a>
                        </li>
                        <li >
                            <a href="/category/za-ji.html">雑記</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><span>
                <form class="navbar-search" action="/search.html">
                  <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input" required>
                </form></span>
              </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<!-- Banner -->
<!-- End Banner -->

<!-- Content Container -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="/rosuresuyin-sheng-kodetsukunokai-fa-memo.html"
                       rel="bookmark"
                       title="Permalink to ロスレス音声コーデックの開発メモ">
                        ロスレス音声コーデックの開発メモ
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2022-03-05T00:00:00+09:00"> Sat 05 March 2022</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="/tag/lossless-audio-codec.html">Lossless audio codec</a>
    
</footer><!-- /.post-info -->                    </div>
                </div>
                <main>
                <h2>主な成果物リンク</h2>
<ul>
<li><a href="https://ec.toranoana.jp/tora_r/ec/item/040030776670/">できた本（とらのあな通販）</a></li>
<li><a href="https://github.com/MrAiki/ALA">できたもの(github)</a></li>
<li><a href="https://github.com/MrAiki/SLA">できたもの2(github)</a></li>
<li><a href="https://github.com/aikiriao/introduction_to_lossless_audio_compression/releases">本をpdfで無料公開しました</a></li>
</ul>
<h2>要件</h2>
<ul>
<li>ロスレス</li>
<li>16bit, 24bit深度</li>
<li>192kHz</li>
<li>16ch</li>
<li>ストリーミング</li>
<li>ブロック単位に分ける</li>
<li>各ブロックの破損確認(CRCでOK)</li>
</ul>
<p>まずは、16bit, 48k, 1ch, ブロック単位分割でできるのが良いのでは？</p>
<h2>比較研究</h2>
<ul>
<li><a href="http://wiki.hydrogenaud.io/index.php?title=Lossless_comparison">比較wiki</a></li>
<li><a href="http://www.audiograaf.nl/downloads.html">比較レポート</a></li>
<li>OptimFROGという圧縮率重視のコーデックがあることを知る。他にもTTA, TAKも強力か。FLACはデコード速度重視の様相。</li>
<li><a href="http://www.firstpr.com.au/audiocomp/lossless/">古い比較レポート</a></li>
<li><a href="https://xiph.org/flac/comparison.html">FLACと他のフォーマットの比較</a></li>
<li><a href="http://www7a.biglobe.ne.jp/~fortywinks/music4.htm">houyhnhnmのエキセントリックらぶらぶ音声データ講座 第4回 ～ WAVE・音楽CD→可逆圧縮 ～</a></li>
<li><a href="http://mi.eng.cam.ac.uk/reports/svr-ftp/auto-pdf/robinson_tr156.pdf">SHORTEN - FLACの基礎</a></li>
<li><a href="https://codecs.multimedia.cx/2010/11/why-lossless-audio-codecs-generally-suck/">Why Lossless Audio Codecs generally suck</a></li>
<li>何でロスレスオーディオは総じてひどいのか。</li>
</ul>
<h3>色々なロスレス音声コーデック</h3>
<ul>
<li><a href="http://read.pudn.com/downloads167/ebook/769449/dataCompress.pdf">データ圧縮全般（犯罪では）</a></li>
<li><a href="https://xiph.org/flac/">FLAC</a></li>
<li><a href="http://www.lossless-audio.com/">La</a></li>
<li><a href="http://elvera.nue.tu-berlin.de/files/0737Liebchen2005.pdf">MPEG-4 ALS</a></li>
<li><a href="https://www.monkeysaudio.com/index.html">Monkey's Audio</a></li>
<li><a href="https://github.com/fernandotcl/monkeys-audio">CIツール</a></li>
<li><a href="http://www.wavpack.com">WavPack</a></li>
<li><a href="http://www.wavpack.com/WavPack.pdf">背景理論についての作者の開発論文</a></li>
<li><a href="https://wiki.hydrogenaud.io/index.php?title=TAK">TAK</a></li>
<li>高圧縮率・高速デコード。バランスが取れていて、現段階で最強に見える。</li>
<li><a href="https://ja.wikipedia.org/wiki/Apple_Lossless">Apple lossless(ALAC)</a></li>
<li><a href="https://ja.wikipedia.org/wiki/TTA">TTA</a></li>
<li>酷評...なぜ</li>
<li><a href="https://ja.wikipedia.org/wiki/ATRAC#ATRAC_Advanced_Lossless">ATRAC Advanced Lossless</a></li>
<li><a href="http://www.mega-nerd.com/libsndfile/">libsndfile</a></li>
<li><a href="http://www.mega-nerd.com/libsndfile/#Features">変換対応表</a></li>
<li><a href="https://www.nue.tu-berlin.de/menue/research/research_topic/compression_and_transmission/mpeg_4_audio_lossless_coding_als/parameter/en/#c230252">MPEG-4 ALSのエンコーダ</a></li>
</ul>
<h2>手法妄想</h2>
<h3>2018.10.6</h3>
<ul>
<li>
<p>MPEG4-ALSを真似てPARCORとLong-term PARCORを組み合わせる。Long-term PARCORは最初のPARCORの誤差をFFTしてピークに出た周波数に対応するラグで予測する。</p>
</li>
<li>
<p>FLACはどうもゴロム符号化（→ライス符号化だった。高速化の為）を使用している。より良いエントロピー符号化を使用すべき。</p>
</li>
<li>
<p>高次の自己相関を使えないか？高橋治久教授の。</p>
</li>
<li>
<p>LPCの計算はつまるところ標本自己相関の計算負荷に尽きる。ウィーナ・ヒンチンの定理を使用して早くできないか？真のパワースペクトルは計算できないことは知っているが、ゼロ埋めか平均回数を多くすることで近似精度を上げられないか？</p>
</li>
<li>この話はエンコード時にのみ起こる問題なので、置いといていいか。</li>
</ul>
<h2>日記</h2>
<h3>2018.10.14</h3>
<p>下回りの整備をしていた。wavファイル読み込みモジュールと、LPC解析（+PARCOR係数計算、音声合成）まではいけている。</p>
<p>次にやるべきは単純なロスレス音声コーデックを作ること。ブロック分割しないで係数を出し、係数と予測誤差を記録してみる。恐らく量子化誤差が大きな敵になるであろう。</p>
<ul>
<li><a href="http://www.fon.hum.uva.nl/praat/old/src/sources_4623/FLAC/flac_lpc.c">FLACのLPC実装</a></li>
</ul>
<h3>2018.10.21</h3>
<p>家に帰って早速エントロピー計算モジュールとLPCのnan問題にあたっていた。エントロピー計算モジュールはOK。頻度の計算に二分木を使用。nan問題はfloatの精度の問題だった。サンプル数を増やしたとき、自己相関関数の値に誤差が出ているのが原因。内部的な結果は全てdoubleで持つように修正することで解決。</p>
<p>floatを簡単に整数量子化して予測するルーチンも完成している。
改めて単純なロスレスコーデックを作るべし。</p>
<h3>2018.10.23</h3>
<p>音声処理とDSPという本を読んでいたら、LSPはPARCORと比べ（ロッシーだけど）60%の情報量圧縮ができるとの文面あり。
恐らく量子化感度に鈍いというのと補間が効くのが理由？LSPも試してみたい。</p>
<h3>2018.10.28</h3>
<p>音声符号化（守谷）をチラチラ見ている。面白い結果が少し出ているので精査したい。特にPARCOR係数から予測利得（予測によって残差利得がどれくらい減ったか）が勘弁に計算できるのは大きい。係数評価に使えそう。</p>
<p>いつもの海ベローチェで作業。一番簡単なロスレスコーデックが完成した。</p>
<p>仕様：</p>
<ul>
<li>入力wav全体を一つのPARCOR係数で予測符号化</li>
<li>PARCOR係数の次数は10, 係数は全て[-1,1]の範囲で16bit線形量子化（符号化する時は浮動小数点数を15bit左シフト）</li>
<li>残差は適応型ハフマンで符号化</li>
</ul>
<p>フォーマットは以下：</p>
<table>
<thead>
<tr>
<th align="right">サイズ(bits)</th>
<th align="center">内容</th>
<th align="center">補足</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">32</td>
<td align="center">シグネチャ <code>"SolA"</code></td>
<td align="center">Soleil Aikatsuの略（Sound of lossless Audioの略）</td>
</tr>
<tr>
<td align="right">16</td>
<td align="center">フォーマットバージョン番号</td>
<td align="center">バージョン1では1。フォーマットに変更がある度に上げる</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">チャンネル数</td>
<td align="center">足りるでしょ…（怠慢）</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">サンプル数</td>
<td align="center">全チャンネルでサンプル数は同一とする</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">サンプリングレート</td>
<td align="center">足りるでしょ…（怠慢）</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">サンプルあたりビット数</td>
<td align="center">wavに戻すときに必要</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">符号化（復号）に必要なビット数</td>
<td align="center">適応型ハフマンの初期化に必要</td>
</tr>
<tr>
<td align="right">チャンネル数 * 16 * 11</td>
<td align="center">PARCOR係数</td>
<td align="center">各チャンネル毎のPARCOR係数[-1,1]の数値を16bit固定小数点数で符号化</td>
</tr>
<tr>
<td align="right">不定</td>
<td align="center">ハフマン符号化された残差</td>
<td align="center">チャンネルインターリーブではない。1ch目の符号化された信号列先頭, ..., 1ch目の符号化された信号列末尾, 2ch目の符号化された信号先頭, ..., 2ch目の符号化された信号末尾,...という並び。</td>
</tr>
</tbody>
</table>
<p>ブロック化するにあたり、ストリームを意識するのでCRCチェックを入れたい。ファイル全体ではCRC32でいいけど、データブロックの破損チェックはCRC16でいいかなと。</p>
<p>CRC16の実装で大ハマリ。CRC16には各種の規格がある...とりあえずCCITT-FALSEの実装を目指す...
HCAはCRC16-IBM(多項式0x8005)だった。揃えるべきかも。</p>
<p>色々CRC16について見ていて、良質な纏めは以下（それ以外は <strong>どの</strong> CRC16を実装したのかわからない）:</p>
<ul>
<li><a href="http://doc.plasticheart.info/crc-16">CRC-16のおぼえがき</a></li>
<li><a href="http://reveng.sourceforge.net/crc-catalogue/16.htm">Catalogue of parametrised CRC algorithms with 16 bits</a></li>
</ul>
<p>Linuxは流石に嘘ついてなさそうだからリファレンスに：</p>
<ul>
<li><a href="https://github.com/torvalds/linux/blob/master/include/linux/crc-ccitt.h">linux/include/linux/crc-ccitt.h</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/lib/crc-ccitt.c">linux/lib/crc-ccitt.c</a></li>
</ul>
<h3>2018.11.3</h3>
<p>version2.のフォーマットを以下のようにしてみた。（ドラフト）</p>
<h4>SolAヘッダ</h4>
<table>
<thead>
<tr>
<th align="right">サイズ(bits)</th>
<th align="center">内容</th>
<th align="center">補足</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">32</td>
<td align="center">シグネチャ <code>"SolA"</code></td>
<td align="center">Soleil Aikatsuの略（Sound of lossless Audioの略）</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">一番最初のデータブロックまでのオフセット（自分除く）</td>
<td align="center">240bit = 30byteSのはず</td>
</tr>
<tr>
<td align="right">16</td>
<td align="center">フォーマットバージョン番号</td>
<td align="center">2</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">チャンネル数</td>
<td align="center">足りるでしょ…（怠慢）</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">全サンプル数</td>
<td align="center">足りるでしょ…（怠慢）</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">サンプリングレート</td>
<td align="center">足りるでしょ…（怠慢）</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">1サンプルあたりのビット数</td>
<td align="center">wavへの復元で必要</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">符号化（復号）に必要なビット数</td>
<td align="center">適応型ハフマンの初期化に必要</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">PARCOR係数次数</td>
<td align="center">全ブロックで同一</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">SolAブロック数</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">SolAブロックあたりの最大サンプル数</td>
<td align="center">等ビットレート実現のため末尾以外は最大サンプル数に揃える。</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">ヘッダ以降のCRC32値</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">ヘッダのCRC32値（自分除く）</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<h4>SolAブロック</h4>
<table>
<thead>
<tr>
<th align="right">サイズ(bits)</th>
<th align="center">内容</th>
<th align="center">補足</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">8</td>
<td align="center">同期コード<code>0xFF</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">次のデータブロックまでのオフセット</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">16</td>
<td align="center">これ以降のフィールドで、次のブロック先頭までのCRC16値</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">このブロックのサンプル数</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">16 * チャンネル数 * PARCOR係数次数</td>
<td align="center">PARCOR係数</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">不定</td>
<td align="center">適応型ハフマン符号化された残差</td>
<td align="center">チャンネルインターリーブではない。1ch目の符号化された信号列先頭, ..., 1ch目の符号化された信号列末尾, 2ch目の符号化された信号先頭, ..., 2ch目の符号化された信号末尾,...という並び。</td>
</tr>
</tbody>
</table>
<p>フォーマットはOK。やるべきはメモリ上での解析実装かも。
メモリ上に読み込まれた要素に対してヘッダの解析とブロックのデコードを行うように実装する。そうなると適応型ハフマン、もしくはBitStreamをメモリ上で動かす必要がある。できるか…？</p>
<p>MemoryBitStreamを作るか、BitStreamを機能拡張するかに分かれる。恐らくBitStreamを機能拡張して、今までと同じ操作で透過的にメモリに書き読みできるのがスマート。この期にテスト追加しとく。</p>
<h3>2018.11.25</h3>
<p>メモリ上の書き込み/読み込み形式で復号ができず（同期コードをうまく発見できない不具合あり）、ひとまずファイル書き込み式で実装した。それでも復号に失敗するときがあり、原因を追っていたところ適応型ハフマンの量子化ビット数が足りないことが原因であることがわかった。</p>
<p>適応型ハフマンのビット数を増やすことで復号が上手く行くことを確認した。が、符号化のサイズと負荷が激増。ハフマン木が大きくなったのが原因。各ブロックごとに最大誤差を求めてビット数を変える事が考えられるが、それは等ビットレート（負荷変動最小化）に反する。</p>
<p>こうなるとやはりゴロム（ライス）符号化を試さざるを得ない印象を受ける。バージョン3としてゴロム符号化を使う。</p>
<p>version3のフォーマットは以下:</p>
<h4>SolAヘッダ</h4>
<table>
<thead>
<tr>
<th align="right">サイズ(bits)</th>
<th align="center">内容</th>
<th align="center">補足</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">32</td>
<td align="center">シグネチャ <code>"SolA"</code></td>
<td align="center">Soleil Aikatsuの略（Sound of lossless Audioの略）</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">一番最初のデータブロックまでのオフセット（自分除く）</td>
<td align="center">240bit = 30byteSのはず</td>
</tr>
<tr>
<td align="right">16</td>
<td align="center">フォーマットバージョン番号</td>
<td align="center">3</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">チャンネル数</td>
<td align="center">足りるでしょ…（怠慢）</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">全サンプル数</td>
<td align="center">足りるでしょ…（怠慢）</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">サンプリングレート</td>
<td align="center">足りるでしょ…（怠慢）</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">1サンプルあたりのビット数</td>
<td align="center">wavへの復元で必要</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">ゴロム符号のパラメータ</td>
<td align="center">全ブロックで同一。負荷が変わらないのならば、ブロックごとに変えることも検討。</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">PARCOR係数次数</td>
<td align="center">全ブロックで同一</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">SolAブロック数</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">SolAブロックあたりの最大サンプル数</td>
<td align="center">等ビットレート実現のため末尾以外は最大サンプル数に揃える。</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">ヘッダ以降のCRC32値</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">ヘッダのCRC32値（自分除く）</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<h4>SolAブロック</h4>
<table>
<thead>
<tr>
<th align="right">サイズ(bits)</th>
<th align="center">内容</th>
<th align="center">補足</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">8</td>
<td align="center">同期コード<code>0xFF</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">次のデータブロックまでのオフセット</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">16</td>
<td align="center">これ以降のフィールドで、次のブロック先頭までのCRC16値</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">このブロックのサンプル数</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">16 * チャンネル数 * PARCOR係数次数</td>
<td align="center">PARCOR係数</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">不定</td>
<td align="center">ゴロム符号化された残差</td>
<td align="center">チャンネルインターリーブではない。1ch目の符号化された信号列先頭, ..., 1ch目の符号化された信号列末尾, 2ch目の符号化された信号先頭, ..., 2ch目の符号化された信号末尾,...という並び。</td>
</tr>
</tbody>
</table>
<p>ゴロム符号で復号が失敗する…ワイル符号で上手く復号できることから、ゴロム符号にバグがあるとしか…デバッグ中。…してたら、<code>Golomb_GetCode</code>の結果を一回変数に受ける必要があるみたい。完全に謎。</p>
<p>```c:ok
        uint64_t bitsbuf;
        bitsbuf = Golomb_GetCode(strm, golomb_m);
        residual[ch][smpl] = UINT32_TO_SINT32(bitsbuf);</p>
<div class="highlight"><pre><span></span><code><span class="err">```</span><span class="nl">c</span><span class="p">:</span><span class="n">NG</span><span class="err">（</span><span class="n">は</span><span class="err">？）</span><span class="w"></span>
<span class="w">        </span><span class="n">residual</span><span class="o">[</span><span class="n">ch</span><span class="o">][</span><span class="n">smpl</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UINT32_TO_SINT32</span><span class="p">(</span><span class="n">Golomb_GetCode</span><span class="p">(</span><span class="n">strm</span><span class="p">,</span><span class="w"> </span><span class="n">golomb_m</span><span class="p">));</span><span class="w"></span>
</code></pre></div>

<p><strong>→マクロに展開すると展開された分読んじゃうから。</strong></p>
<p>また、ワイル符号の圧縮率が悪い！これはブロック先頭部分の誤差を出力しているからかも...→やったけど微減。</p>
<h3>2018.11.29</h3>
<p>ゴロム符号を使ったときのバグを直した。それでエンコード時のエントロピーを見ていたら、エントロピーの減少を確認したが、まだ削れそうな予感がある。</p>
<p>Monkey Audioでは単純な差分符号化を行っている...参考にして、差分符号化でエントロピーが減るか観察してみる。</p>
<p>→手元のデータではエントロピーが増えた。。。</p>
<p>ゴロム符号パラメータの最適化手法を探した。</p>
<ul>
<li><a href="https://ipnpr.jpl.nasa.gov/progress_report/42-159/159E.pdf">Selecting the Golomb Parameter in Rice Coding</a></li>
</ul>
<p>どうも次の式を満たす最大の<span class="math">\(k\)</span>が最適パラメータのようです（<span class="math">\(2^k\)</span>をパラメータに使う。<strong>ライス符号のみで有効なので注意。</strong>）:</p>
<div class="math">$$
2^{k} \leq \mu + f^{\ast}
$$</div>
<p><span class="math">\(\mu\)</span>は非負整数の平均、<span class="math">\(f^{\ast}\)</span>は理論（実験かも…）によって求められた0.382という値で、49/128, 34/89, 3/8で近似できる。<span class="math">\(f^{\ast} = A / B, \mu = S / J\)</span>とおく（<span class="math">\(S\)</span>:和、<span class="math">\(J\)</span>:標本数）と、不等式は、</p>
<div class="math">$$
JB \times 2^{k} \leq BS + JA
$$</div>
<p>と書ける。<span class="math">\(k\)</span>は次のプログラムで求まる</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">J</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</code></pre></div>

<p><span class="math">\(f^{\ast} = 49/128\)</span>とすれば、<span class="math">\(A=49,B=128\)</span>より、</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">J</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">128</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">49</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</code></pre></div>

<p>さらに128をシフトに置き換えて</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">(</span><span class="n">J</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">S</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">49</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</code></pre></div>

<p>（他にもDNNでパラメータ調節するのがあったけど死ねとしか思えなかった。）</p>
<p>ライスでは2の冪が前提だが、ゴロムでは次でいけるのでは？（理論的根拠なし）：</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">((</span><span class="n">J</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">S</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">49</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</code></pre></div>

<p>早速試してみる。ブロックごとにゴロム符号パラメータを調節してみた。単純なサイン波はあんまり結果が良くないように見える。と思ったら、実践的音声でかなりのパフォーマンス改善が見られた…嘘だろ…？エンコード速度が激減し、エントロピーもいきなり8(理想値)に近くなった。</p>
<p>俺の声では</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff     50360 Nov 30 00:05 kisaragi_chihaya.ape
-rw-r--r--@  1 *  staff     60808 Nov 26 23:26 kisaragi_chihaya.flac
-rw-r--r--@  1 *  staff     54369 Nov 30 00:05 kisaragi_chihaya.sol
-rw-r--r--@  1 *  staff    109612 Nov 26 23:26 kisaragi_chihaya.wav
</code></pre></div>

<p>桃山みらいのワン・ツー・スウィーツでは</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  38305036 Nov 30 00:04 one_two_sweets_offvocal.ape
-rw-r--r--@  1 *  staff  40645286 Nov 30 00:03 one_two_sweets_offvocal.flac
-rw-r--r--@  1 *  staff  43886946 Nov 30 00:03 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  54566444 Nov 30 00:03 one_two_sweets_offvocal.wav
</code></pre></div>

<p>山下達郎のSPARKLEでは</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  28436216 Nov 30 00:01 SPARKLE.ape
-rw-r--r--@  1 *  staff  30704598 Sep 17 16:06 SPARKLE.flac
-rw-r--r--@  1 *  staff  34847916 Nov 30 00:01 SPARKLE.sol
-rw-r--r--@  1 *  staff  49080364 Sep 17 16:06 SPARKLE.wav
</code></pre></div>

<p>短いモノ音声でflacに勝った。工夫を重ねていきたい。
ステレオはmonkey audioがやっているようなMS変換が有利に働くかも。</p>
<p>ひとまずVersion.3は可変ゴロム符号デコーダを作ったらfixとしたい。</p>
<h3>2018.11.30</h3>
<p>結果からも明らかだったけど、<a href="https://ipnpr.jpl.nasa.gov/progress_report/42-159/159E.pdf">上の論文</a>曰く、平均が1未満のときはランレングス符号化が効率的。</p>
<p>ゴロム符号のパラメータを入れたフォーマットは次：</p>
<h4>SolAヘッダ</h4>
<table>
<thead>
<tr>
<th align="right">サイズ(bits)</th>
<th align="center">内容</th>
<th align="center">補足</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">32</td>
<td align="center">シグネチャ <code>"SolA"</code></td>
<td align="center">Soleil Aikatsuの略（Sound of lossless Audioの略）</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">一番最初のデータブロックまでのオフセット（自分除く）</td>
<td align="center">240bit = 30byteSのはず</td>
</tr>
<tr>
<td align="right">16</td>
<td align="center">フォーマットバージョン番号</td>
<td align="center">3</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">チャンネル数</td>
<td align="center">足りるでしょ…（怠慢）</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">全サンプル数</td>
<td align="center">足りるでしょ…（怠慢）</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">サンプリングレート</td>
<td align="center">足りるでしょ…（怠慢）</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">1サンプルあたりのビット数</td>
<td align="center">wavへの復元で必要</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">PARCOR係数次数</td>
<td align="center">全ブロックで同一</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">SolAブロック数</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">SolAブロックあたりの最大サンプル数</td>
<td align="center">等ビットレート実現のため末尾以外は最大サンプル数に揃える。</td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">ヘッダ以降のCRC32値</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">ヘッダのCRC32値（自分除く）</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<h4>SolAブロック</h4>
<table>
<thead>
<tr>
<th align="right">サイズ(bits)</th>
<th align="center">内容</th>
<th align="center">補足</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">8</td>
<td align="center">同期コード<code>0xFF</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">次のデータブロックまでのオフセット</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">16</td>
<td align="center">これ以降のフィールドで、次のブロック先頭までのCRC16値</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">32</td>
<td align="center">このブロックのサンプル数</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">16 * チャンネル数 * PARCOR係数次数</td>
<td align="center">PARCOR係数</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">16 * チャンネル数</td>
<td align="center">ゴロム符号のパラメータ</td>
<td align="center"></td>
</tr>
<tr>
<td align="right">不定</td>
<td align="center">ゴロム符号化された残差</td>
<td align="center">チャンネルインターリーブではない。1ch目の符号化された信号列先頭, ..., 1ch目の符号化された信号列末尾, 2ch目の符号化された信号先頭, ..., 2ch目の符号化された信号末尾,...という並び。</td>
</tr>
</tbody>
</table>
<p>デコーダやっつけで作ったけどだめだ！なぜかデコード結果が一致しない！サイズは一致するけど途中で差分が出る！</p>
<h3>2018.12.1</h3>
<p>PARCOR係数の非線形量子化に先立ち、いろんな音のPARCOR係数分布を見てみた。</p>
<p><img alt="20190929123143p" src="./images/la_first_attempts/20190929123143.png" /></p>
<p><img alt="20190929123232p" src="./images/la_first_attempts/20190929123232.png" /></p>
<p><img alt="20190929123256p" src="./images/la_first_attempts/20190929123256.png" /></p>
<h5>見れること</h5>
<ul>
<li>1次成分は1の近傍になる</li>
<li>2次成分は-1の近傍になるが、偏りは1次ほどではない</li>
<li>高次になるに従い、ほぼ振動しながら0に近づく。</li>
</ul>
<p>--</p>
<p>バグを直す。追っていたところ、</p>
<ol>
<li>予測誤差計算時に32bit整数でオーバーフローしていた</li>
<li>計算時に一旦64bit整数に受けることで修正。</li>
<li>予測誤差先頭出力時に入力wavと同一bit数を超える数値が出ていた（16bit wavで69410を出そうとした）</li>
<li>差分は2倍の値域が出るので+1bitして出力することで修正。</li>
</ol>
<p>2.については、修正できたが先頭を（ゴロム符号化しない）生のビットで出力すること自体細かな最適化にしかなっていないので、一旦先頭を生のビットで出力するのをやめることにした。これにより圧縮率は悪化するが、それほど大きなダメージではない。</p>
<p>圧縮効率を上げるアイデアを挙げると：</p>
<ul>
<li>PARCOR係数を非線形量子化する</li>
<li>分布を見れば分かるようにPARCOR係数の分布には偏りがある。偏りに合わせて非線形に量子化すれば予測精度が高まる。『音声の高効率符号化』では等ひずみとなるビット数がかなり減ったとのこと。</li>
<li>
<p>ビット割当ても低次係数には多く割り振る。</p>
</li>
<li>
<p>MS処理を行う</p>
</li>
<li>M = L + R, S = L - R として処理する</li>
<li>
<p>Mでは逆相関が除去され、Sでは正相関が除去される。</p>
</li>
<li>
<p>無音部でランレングス符号化を使う</p>
</li>
<li>ゴロム符号のパラメータ計算のときに正値化した差分信号の平均を計算する。平均が1より小さければ無音のはず。ランレングスで符号化する。</li>
<li>
<p>等ビットレート原則が崩れるかも...</p>
</li>
<li>
<p>ロングターム（ピッチ情報）を使う</p>
</li>
<li>ピッチ解析を行い、その長さによる予測符号化を行う。MPEG4-LSで使われている手法。</li>
</ul>
<p>ロングタームは少し重たそうだけど、他はすぐにやれそう。12/2はPARCOR係数の非線形量子化に取り組む。</p>
<h3>2018.12.2</h3>
<p>非線形量子化を検証中...しっかしまだ非線形量子化のイメージが掴みきれてない。gnuplotでグラフを出してみる。</p>
<p><img alt="20190929123320p" src="./images/la_first_attempts/20190929123320.png" /></p>
<p>```bash:ソース
set samples 41
set xtics 0.2
set ytics 0.2
set grid
set xrange[-1:1]
set yrange[-1:1]
plot tanh(x * pi) w p, atanh(x) / pi w p, asin(x) / (pi/2) w p, sin(x * (pi/2)) w p, x w p</p>
<div class="highlight"><pre><span></span><code>求まった係数値$<span class="nv">x</span> \<span class="nv">in</span> [<span class="o">-</span><span class="mi">1</span>,<span class="mi">1</span>]$に対して、$\<span class="nv">tanh</span><span class="o">^</span>{<span class="o">-</span><span class="mi">1</span>}<span class="ss">(</span><span class="nv">x</span><span class="ss">)</span>$を計算すると$<span class="o">-</span><span class="mi">1</span>,<span class="mi">1</span>$の近傍で粗くなるようにしか見えない...（それどころか$\<span class="nv">tanh</span><span class="o">^</span>{<span class="o">-</span><span class="mi">1</span>}<span class="ss">(</span><span class="mi">1</span><span class="ss">)</span> <span class="o">=</span> <span class="o">+</span>\<span class="nv">infty</span>$だし...）もしかして$\<span class="nv">tanh</span><span class="ss">(</span><span class="nv">x</span><span class="ss">)</span>$の誤りでは...？

→いや、合ってる。$\<span class="nv">tanh</span><span class="o">^</span>{<span class="o">-</span><span class="mi">1</span>}<span class="ss">(</span><span class="nv">x</span><span class="ss">)</span>$で変換をかませると、<span class="mh">$0</span>$近傍の値はほとんど同じになる。すなわち近い値が割り当てられやすくなる。逆に$<span class="o">-</span><span class="mi">1</span>,<span class="mi">1</span>$近傍では急激に値が変化するから少しの$<span class="nv">x</span>$のずれで全く違う値が割り当てられる。即ち$<span class="o">-</span><span class="mi">1</span>,<span class="mi">1</span>$近くの情報量が多くなる。

<span class="nv">ruby</span>で符号化関数を試作してみた。

```<span class="nv">ruby</span>:符号化関数
# <span class="nv">f_val</span>は[<span class="mi">0</span>,<span class="mi">1</span>]の値を期待
<span class="nv">def</span> <span class="nv">encode</span><span class="ss">(</span><span class="nv">n_bits</span>, <span class="nv">f_val</span><span class="ss">)</span>
    <span class="nv">max</span> <span class="o">=</span> <span class="ss">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nv">n_bits</span><span class="ss">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nv">max</span> <span class="k">if</span> <span class="nv">f_val</span> <span class="o">&gt;=</span> <span class="nv">max</span>.<span class="nv">to_f</span> <span class="o">/</span> <span class="ss">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nv">n_bits</span><span class="ss">)</span>
    <span class="k">return</span> <span class="ss">((</span><span class="nv">max</span> <span class="o">*</span> <span class="nv">Math</span>::<span class="nv">atanh</span><span class="ss">(</span><span class="nv">f_val</span><span class="ss">))</span> <span class="o">/</span> <span class="nv">Math</span>::<span class="nv">atanh</span><span class="ss">(</span><span class="nv">max</span>.<span class="nv">to_f</span> <span class="o">/</span> <span class="ss">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nv">n_bits</span><span class="ss">)))</span>.<span class="nv">to_i</span>
<span class="k">end</span>
</code></pre></div>

<p>→除算を行っているので桁落ちが無視できない...</p>
<p>1近傍で<span class="math">\(+\infty\)</span>にすっ飛んでるのが危険。<span class="math">\(\tanh(\pi x)\)</span>のテーブルを作っておき、範囲検索で正規化値に該当するインデックスを符号化するのが良さそう。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># テーブル作成</span>
<span class="n">table</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">65536</span><span class="p">)</span><span class="o">.</span><span class="n">map!</span><span class="p">{</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="p">};</span>
<span class="mi">0</span><span class="o">.</span><span class="n">upto</span><span class="p">(</span><span class="mi">65535</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="no">Math</span><span class="o">::</span><span class="n">tanh</span><span class="p">(</span><span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">*</span> <span class="n">i</span><span class="o">.</span><span class="n">to_f</span> <span class="o">/</span> <span class="mi">65536</span><span class="p">);</span> <span class="p">}</span>
<span class="c1"># 符号化関数</span>
<span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">f_val</span><span class="p">)</span>
    <span class="k">raise</span> <span class="k">if</span> <span class="n">f_val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span>
    <span class="n">inx</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">index</span> <span class="p">{</span><span class="o">|</span><span class="n">v</span><span class="o">|</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">f_val</span> <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">inx</span><span class="o">.</span><span class="n">nil?</span>
    <span class="k">return</span> <span class="n">inx</span>
<span class="k">end</span>
<span class="c1"># 復号関数</span>
<span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="k">if</span> <span class="n">code</span> <span class="o">&gt;=</span> <span class="n">table</span><span class="o">.</span><span class="n">size</span>
    <span class="k">return</span> <span class="n">table</span><span class="o">[</span><span class="n">code</span><span class="o">]</span>
<span class="k">end</span>
</code></pre></div>

<p><span class="math">\(1\)</span>近傍で取りこぼした（区間<span class="math">\([65535/65536,1.0]\)</span>の値）値が多いけど、これは量子化故仕方がないよな...？</p>
<p>```ruby:符号化値の密度
irb(main):294:0&gt; 0.upto(10) {|v| puts "#{v.to_f/10}- #{encode(table, v.to_f / 10)}" }
0.0- 0
0.1- 2094
0.2- 4230
0.3- 6457
0.4- 8838
0.5- 11459
0.6- 14460
0.7- 18093
0.8- 22918
0.9- 30712
1.0- 65535</p>
<div class="highlight"><pre><span></span><code><span class="mf">0.9</span><span class="n">から1</span><span class="mf">.0</span><span class="n">の間に約35000個割り当てていることが分かる。</span><span class="w"></span>

<span class="n">さて、C言語での実装を考える。標準ライブラリ関数の</span><span class="n n-Quoted">`tanh`</span><span class="n">はプラットフォーム依存でどんな結果を返すか分からないので、自前で</span><span class="n n-Quoted">`tanh`</span><span class="n">を実装したい。自前</span><span class="n n-Quoted">`tanh`</span><span class="n">は奥村先生の「標準アルゴリズム辞典」を参考にしようと思ったが、実装内部で</span><span class="n n-Quoted">`exp`</span><span class="n">を使っているので結局プラットフォーム依存であることを免れない。</span><span class="w"></span>

<span class="n">やはりテイラー展開を使うしか</span><span class="p">...</span><span class="n">いや$0$近傍以外での誤差がやばいし。</span><span class="w"></span>

<span class="n">悩んだところ、</span><span class="n n-Quoted">`tanh`</span><span class="n">の返す値が$1</span><span class="o">/</span><span class="mi">65536</span><span class="err">\</span><span class="n">approx</span><span class="w"> </span><span class="mf">1.526</span><span class="w"> </span><span class="err">\</span><span class="n">times</span><span class="w"> </span><span class="mi">10</span><span class="o">^</span><span class="err">{</span><span class="o">-</span><span class="mi">6</span><span class="err">}</span><span class="n">$より大きな誤差となるプラットフォームは少ないと考え、ナイーブに</span><span class="n n-Quoted">`tanh`</span><span class="n">でテーブルを作ることにした。</span><span class="w"></span>

<span class="n n-Quoted">`tanh`</span><span class="n">の$</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">1$付近の誤差がでかいことに悩んでたら、</span><span class="n n-Quoted">`tanh`</span><span class="n">ってそもそもシグモイド関数と同じように$</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">1$に漸近するするだけで通過しないことに気づいた。それじゃだめだ。変換関数を再検討。必ず$</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="n">$を通るようにしたい。</span><span class="w"></span>

<span class="c1">### 2018.12.4</span><span class="w"></span>

<span class="n">悩んでいたら、良いページがあった</span><span class="w"></span>

<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">[</span><span class="n">その19</span><span class="w"> </span><span class="n">補間関数あれこれ</span><span class="err">]</span><span class="p">(</span><span class="n">http</span><span class="o">://</span><span class="n">marupeke296</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">TIPS_No19_interpolation</span><span class="p">.</span><span class="n">html</span><span class="p">)</span><span class="w"></span>

<span class="n">結論、以下の曲線で決まり。$a$をパラメータとして、</span><span class="w"></span>

<span class="n">$$</span><span class="w"></span>
<span class="n">t</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">\</span><span class="n">frac</span><span class="err">{</span><span class="mi">1</span><span class="err">}{</span><span class="mi">2</span><span class="err">}</span><span class="w"> </span><span class="err">\</span><span class="k">left</span><span class="err">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">\</span><span class="n">frac</span><span class="err">{</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">\</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">ax</span><span class="p">)</span><span class="err">}{</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">\</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">ax</span><span class="p">)</span><span class="err">}\</span><span class="n">frac</span><span class="err">{</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">\</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="err">}{</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">\</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="err">}\</span><span class="k">right</span><span class="err">]</span><span class="w"> </span><span class="err">\\</span><span class="w"></span>
<span class="n">y</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">2t</span><span class="o">^</span><span class="err">{</span><span class="mi">2</span><span class="err">}</span><span class="p">(</span><span class="n">x</span><span class="p">)(</span><span class="mi">3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">2t</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="n">$$</span><span class="w"></span>

<span class="o">!</span><span class="err">[</span><span class="n">20190929123351p</span><span class="err">]</span><span class="p">(.</span><span class="o">/</span><span class="n">images</span><span class="o">/</span><span class="n">la_first_attempts</span><span class="o">/</span><span class="mf">20190929123351.</span><span class="n">png</span><span class="p">)</span><span class="w"></span>

<span class="n">aは3か4かなあ。→</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">1の近傍で32bit数値に差が出る3</span><span class="mf">.0</span><span class="n">を採用。極端だから2</span><span class="mf">.0</span><span class="n">に訂正。（2018</span><span class="mf">.12.4</span><span class="n">）</span><span class="w"></span>

<span class="n">テーブル引きによる非線形変換を使うために、PARCOR係数の計算実装を見ているが、固定シフト</span><span class="n n-Quoted">`PARCOR_COEF_FIXED_SHIFT`</span><span class="n">が15よりも大きいと戻らない現象を観察している。これは多分16bit値を15bitよりも大きく左シフトすると32bit値として表現できないから</span><span class="p">...</span><span class="n">。</span><span class="w"></span>
<span class="n">フィルタ計算のときには64bit値で持つ必要があるかも。</span><span class="w"></span>

<span class="c1">### 2018.12.4</span><span class="w"></span>

<span class="n">係数シフト量</span><span class="n n-Quoted">`PARCOR_COEF_FIXED_SHIFT`</span><span class="n">を大きくする修正。大きくして戻らなくなった原因はPARCOR係数の出力ビット数。今までは16bitで出していたが、それでは15bit</span><span class="p">(</span><span class="o">+</span><span class="n">符号1bit</span><span class="p">)</span><span class="n">までしか記録できない。</span><span class="w"></span>

<span class="n">修正して様子を見たところ5分尺データの圧縮率が改善した。（逆に短いデータでは悪化）。これはPARCOR係数の精度改善とその保存コストのトレードオフだろう。</span><span class="w"></span>

<span class="n">非線形変換しようとしているが足踏み。テーブル引きにすることを考えると、</span><span class="n n-Quoted">`PARCOR_COEF_FIXED_SHIFT`</span><span class="n">ビットサイズのテーブルを保存する必要がある</span><span class="p">...</span><span class="n">。31bitだと超巨大になる。</span><span class="w"></span>

<span class="n">これに対するアイデアは、16bitで記録するけど、テーブルによって32bit値に拡張（補完）するというもの。（非線形変換しないときは線形補間；単純な左シフト）だから記録に使うビット幅</span><span class="p">(</span><span class="n">16bit</span><span class="p">)</span><span class="n">と計算時にシフトする量</span><span class="p">(</span><span class="n">31bit</span><span class="p">)</span><span class="n">に違いが出る。というかこれしかいい方法がなさそうに見える。</span><span class="w"></span>

<span class="n">テーブル引きによる方法と、生の31bit保存でどちらが圧縮率が良いかは検証する必要がある。</span><span class="w"></span>

<span class="c1">### 2018.12.5</span><span class="w"></span>

<span class="n">非線形テーブル対応。効果あり。</span><span class="w"></span>

<span class="n n-Quoted">`</span><span class="n n-Quoted n-Quoted-Escape">``</span><span class="n n-Quoted">:非線形テーブル</span>
<span class="n n-Quoted">-rw-r--r--@  1 *  staff     54344 Dec  6 00:05 kisaragi_chihaya.sol</span>
<span class="n n-Quoted">-rw-r--r--@  1 *  staff  33292840 Dec  6 00:07 SPARKLE.sol</span>
<span class="n n-Quoted">-rw-r--r--@  1 *  staff  42188584 Dec  6 00:05 one_two_sweets_offvocal.sol</span>
</code></pre></div>

<p>早速単純な31bitシフト時と比較する。結果、非線形テーブルの方が良い結果：</p>
<p>```:単純な31bitシフト
-rw-r--r--@  1 *  staff     54653 Dec  6 00:17 kisaragi_chihaya.sol
-rw-r--r--@  1 *  staff  33424610 Dec  6 00:16 SPARKLE.sol
-rw-r--r--@  1 *  staff  42335099 Dec  6 00:17 one_two_sweets_offvocal.sol</p>
<div class="highlight"><pre><span></span><code><span class="s s-Atom">最初に算出されるPARCOR係数が</span><span class="err">`</span><span class="s s-Atom">float</span><span class="err">`</span><span class="s s-Atom">精度なのがまだ気になる。。→取り急ぎ</span><span class="err">`</span><span class="s s-Atom">double</span><span class="err">`</span><span class="s s-Atom">に変えたけどさしたる変化なし（それどころかSPARKLE</span><span class="p">.</span><span class="s s-Atom">wavは1バイト増えた</span><span class="p">...</span><span class="s s-Atom">）。もしかして</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="s s-Atom">の</span><span class="err">`</span><span class="s s-Atom">float</span><span class="err">`</span><span class="s s-Atom">は情報が落ちないのか？でも、精度的には嘘がないので今後は</span><span class="err">`</span><span class="s s-Atom">double</span><span class="err">`</span><span class="s s-Atom">でいく。</span>

<span class="s s-Atom">次はMS処理、もしくはランレングス？MS処理は劇的に効きそう。</span>

<span class="s s-Atom">###</span> <span class="mf">2018.12.16</span>

<span class="s s-Atom">本日はMS処理を入れてみる。これで数MBは削れてほしい…。</span><span class="nv">MS処理はブロック毎に変えることはしない</span><span class="s s-Atom">。全体で同一の処理方式を取るようにする。ヘッダに修正が入る：</span>

<span class="s s-Atom">####</span> <span class="nv">SolAヘッダ</span>

<span class="p">|</span> <span class="nf">サイズ</span><span class="p">(</span><span class="s s-Atom">bits</span><span class="p">)</span> <span class="p">|</span> <span class="s s-Atom">内容</span> <span class="p">|</span> <span class="s s-Atom">補足</span> <span class="p">|</span>
<span class="p">|</span><span class="s s-Atom">--:</span><span class="p">|:-</span><span class="s s-Atom">:</span><span class="p">|:-</span><span class="s s-Atom">:</span><span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="s s-Atom">シグネチャ</span> <span class="err">`</span><span class="s2">&quot;SolA&quot;</span><span class="err">`</span> <span class="p">|</span> <span class="nv">Soleil</span> <span class="nv">Aikatsuの略</span><span class="s s-Atom">（Sound</span> <span class="s s-Atom">of</span> <span class="s s-Atom">lossless</span> <span class="nv">Audioの略</span><span class="s s-Atom">）</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="s s-Atom">一番最初のデータブロックまでのオフセット（自分除く）</span> <span class="p">|</span> <span class="mi">240</span><span class="s s-Atom">bit</span> <span class="o">=</span> <span class="mi">30</span><span class="s s-Atom">byteSのはず</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">16</span> <span class="p">|</span> <span class="s s-Atom">フォーマットバージョン番号</span> <span class="p">|</span> <span class="mi">4</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">8</span>  <span class="p">|</span> <span class="s s-Atom">チャンネル数</span> <span class="p">|</span> <span class="s s-Atom">足りるでしょ…（怠慢）</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="s s-Atom">全サンプル数</span> <span class="p">|</span> <span class="s s-Atom">足りるでしょ…（怠慢）</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="s s-Atom">サンプリングレート</span> <span class="p">|</span> <span class="s s-Atom">足りるでしょ…（怠慢）</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">8</span>  <span class="p">|</span> <span class="mi">1</span><span class="s s-Atom">サンプルあたりのビット数</span> <span class="p">|</span> <span class="s s-Atom">wavへの復元で必要</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">8</span>  <span class="p">|</span> <span class="nv">PARCOR係数次数</span> <span class="p">|</span> <span class="s s-Atom">全ブロックで同一</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">4</span>  <span class="p">|</span> <span class="s s-Atom">チャンネル毎の処理方法</span> <span class="p">|</span> <span class="s s-Atom">今は何もしないか、</span><span class="nv">MS処理するかのどちらか</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="nv">SolAブロック数</span> <span class="p">|</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="nv">SolAブロックあたりの最大サンプル数</span> <span class="p">|</span> <span class="s s-Atom">等ビットレート実現のため末尾以外は最大サンプル数に揃える。</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="s s-Atom">ヘッダ以降のCRC32値</span> <span class="p">|</span>  <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="s s-Atom">ヘッダのCRC32値（自分除く）</span> <span class="p">|</span>  <span class="p">|</span>

<span class="s s-Atom">やった…が速報で結果が渋い…。ロスレスになったら結果をば…。</span>
<span class="s s-Atom">と思ったら元に戻らず、ハマる。間違いなくどこかでクリップしているのが原因だが、根本原因が追えず。これからピアノ。</span>

<span class="s s-Atom">###</span> <span class="mf">2018.12.19</span>

<span class="nv">MSを使ったときに戻らない原因を調査</span><span class="s s-Atom">。簡単なループのミスだった。。。（Sideが決まる前に出力計算していた）</span>

<span class="s s-Atom">ロスレスになったけどいかんせん**圧縮率が悪化**。理由はMidをL</span><span class="o">+</span><span class="nv">Rで作っているからでダイナミックレンジが広がって結果誤差増大につながったものと思われる</span><span class="s s-Atom">。</span>

<span class="s s-Atom">対応は、wavpackが如く、</span><span class="err">`</span><span class="nv">Mid</span><span class="s s-Atom">=</span><span class="p">(</span><span class="nv">L</span><span class="o">+</span><span class="nv">R</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="err">`</span><span class="s s-Atom">とする。これにより最下位1bitの情報が落ちるが、</span><span class="err">`</span><span class="nv">Side</span><span class="o">=</span><span class="nv">L</span><span class="o">-</span><span class="nv">R</span><span class="err">`</span><span class="s s-Atom">の結果から、</span><span class="err">`</span><span class="nv">Side</span><span class="err">`</span><span class="s s-Atom">の最下位1bitが</span><span class="err">`</span><span class="nv">Mid</span><span class="err">`</span><span class="s s-Atom">の最下位1bitと一致することを用いてもとに戻せる。次はこれを試す。</span>

<span class="s s-Atom">後、高次のPARCOR係数も非線形量子化したい。</span>

<span class="s s-Atom">###</span> <span class="mf">2018.12.22</span>

<span class="s s-Atom">秋葉原製作所なるところで作業してみる。</span><span class="mi">3</span><span class="s s-Atom">時間で1250円。</span>
<span class="nv">MS処理をうまくやるのが今日の目標</span><span class="s s-Atom">。</span>

<span class="err">`</span><span class="nv">M</span><span class="s s-Atom">=</span><span class="p">(</span><span class="nv">L</span><span class="o">+</span><span class="nv">R</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="err">`</span><span class="s s-Atom">としたときにどうしても戻らなく、苦戦していた。flacのエンコーダソースを見ていたところ、全てをシフト演算でやりきっていたので真似をしたら何と元に戻った。**原因は除算による0方向の丸め**。</span>

<span class="err">```</span><span class="nn">c</span><span class="p">:</span><span class="s s-Atom">flacエンコーダのMS処理</span>
            <span class="nf">for</span><span class="p">(</span><span class="s s-Atom">i</span> <span class="o">=</span> <span class="s s-Atom">encoder-&gt;private_-&gt;current_sample_number</span><span class="p">;</span> <span class="s s-Atom">i</span> <span class="s s-Atom">&lt;=</span> <span class="s s-Atom">blocksize</span> <span class="s s-Atom">&amp;&amp;</span> <span class="s s-Atom">j</span> <span class="o">&lt;</span> <span class="s s-Atom">samples</span><span class="p">;</span> <span class="s s-Atom">i++</span><span class="p">,</span> <span class="s s-Atom">j++</span><span class="p">)</span> <span class="p">{</span>
                <span class="s s-Atom">encoder-&gt;private_-&gt;integer_signal</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s s-Atom">i</span><span class="p">]</span> <span class="o">=</span> <span class="s s-Atom">mid</span> <span class="o">=</span> <span class="s s-Atom">side</span> <span class="o">=</span> <span class="s s-Atom">buffer</span><span class="p">[</span><span class="s s-Atom">k++</span><span class="p">];</span>
                <span class="s s-Atom">x</span> <span class="o">=</span> <span class="s s-Atom">buffer</span><span class="p">[</span><span class="s s-Atom">k++</span><span class="p">];</span>
                <span class="s s-Atom">encoder-&gt;private_-&gt;integer_signal</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s s-Atom">i</span><span class="p">]</span> <span class="o">=</span> <span class="s s-Atom">x</span><span class="p">;</span>
                <span class="s s-Atom">mid</span> <span class="s s-Atom">+=</span> <span class="s s-Atom">x</span><span class="p">;</span>
                <span class="s s-Atom">side</span> <span class="s s-Atom">-=</span> <span class="s s-Atom">x</span><span class="p">;</span>
                <span class="s s-Atom">mid</span> <span class="s s-Atom">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* NOTE: not the same as &#39;mid = (left + right) / 2&#39; ! */</span>
                <span class="s s-Atom">encoder-&gt;private_-&gt;integer_signal_mid_side</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s s-Atom">i</span><span class="p">]</span> <span class="o">=</span> <span class="s s-Atom">side</span><span class="p">;</span>
                <span class="s s-Atom">encoder-&gt;private_-&gt;integer_signal_mid_side</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s s-Atom">i</span><span class="p">]</span> <span class="o">=</span> <span class="s s-Atom">mid</span><span class="p">;</span>
            <span class="p">}</span>
</code></pre></div>

<p>NOTE:に注目。実例で行くと、<code>L=-741, R=322, M=L+R=-419</code>のとき、<code>(L+R)/2=-209</code>だが<code>(L+R)&gt;&gt;1=-210</code>。<code>0xFFFFFE5D(-419) &gt;&gt; 1 = 0xFFFFFF2E(-210)</code>となるから、下位1bitをSideから補えば元に戻る！</p>
<p>特に著しいのは<code>L+R=-1</code>のときで、<code>(-1&gt;&gt;1)=-1</code>だから<strong><code>M</code>の符号の情報が飛ばないのがうまくいく理由。</strong>単純な除算だと<code>(L+R)/2=0</code>のときにMの符号が分からなくなってしまう。</p>
<p>早速修正を取り入れる：</p>
<p>```sh:MS処理追加
-rw-r--r--@  1 *  staff  41939426 Dec 22 18:02 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  32534982 Dec 22 18:04 SPARKLE.sol</p>
<div class="highlight"><pre><span></span><code>数百<span class="n">KB単位の削減になった</span>。

<span class="c1">### 2018.12.27</span>

ロスレス音声では<span class="n">LSPが気になる</span>。試すだけはしてみないと。

<span class="c1">### 2019.1.2</span>

実家で<span class="n">LSP係数の計算を試している</span>。と言っても理論抜きで<span class="n">LPC係数からLSP係数に変換するのを試している</span>。

<span class="n">LSP係数は多項式P</span><span class="p">,</span><span class="n">Qの根を求めることで得ている</span>。ここでは<span class="n">DFTした結果のゼロ点を探すことでLSP係数を求めている</span>。

<span class="n">LPC</span> <span class="o">&lt;-&gt;</span> <span class="n">LSPの相互変換はできた感じ</span>。しかしワーク領域がでかい（<span class="n">FFT使うから</span>）ため、変換用ハンドルを新しく作った。

さて、これからやりたいことを列挙すると次のようになる：

 <span class="o">-</span> 窓を試す
  <span class="o">-</span> <span class="n">LPC</span><span class="p">,</span> <span class="n">PARCOR係数を求める際に窓をかけてから処理を行う</span>。
  <span class="o">-</span> 解析精度が上がることで誤差が減るかも。

 <span class="o">-</span> 高次係数も非線形量子化する

 <span class="o">-</span> ゴロム符号パラメータをサンプル単位で変える
  <span class="o">-</span> <span class="n">wavpackではこちらの方式でやっている</span>。試す価値はある。

 <span class="o">-</span> <span class="n">LSP係数で保存する</span>
  <span class="o">-</span> <span class="n">LSP係数は誤差の感度が低く</span>、<span class="n">PARCOR係数と比べて等ビットレートでより良い音質を実現しているとの報告がある</span>。
  <span class="o">-</span> <span class="n">LSPの前向き誤差計算は複雑なので却下</span>。ここでは、<span class="n">LSP係数</span><span class="o">&lt;-&gt;</span><span class="n">LPC係数の相互変換を使って</span>、係数保存の際に<span class="n">LSP係数を使用することを考える</span>。

 <span class="o">-</span> 無音部でランレングス符号化を使う
  <span class="o">-</span> ゴロム符号のパラメータ計算のときに正値化した差分信号の平均を計算する。平均が<span class="m">1</span>より小さければ無音のはず。ランレングスで符号化する。
  <span class="o">-</span> 等ビットレート原則が崩れるかも<span class="kc">...</span>

 <span class="o">-</span> ロングターム（ピッチ情報）を使う
  <span class="o">-</span> ピッチ解析を行い、その長さによる予測符号化を行う。<span class="n">MPEG4</span><span class="o">-</span><span class="n">LSで使われている手法</span>。

<span class="c1">### 2019.1.5</span>

本日はいつもの海沿いベローチェで作業。窓掛けを試すのと、<span class="n">LPCモジュールの出力一致確認をおこなうテストを追加したい</span>。

窓掛け…簡単にハン窓で試したら効果あり！
</code></pre></div>

<p>-rw-r--r--@  1 *  staff  41586969 Jan  5 15:38 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31990780 Jan  5 15:39 SPARKLE.sol
-rw-r--r--@  1 *  staff     54991 Jan  5 15:44 kisaragi_chihaya.sol</p>
<div class="highlight"><pre><span></span><code>ブラックマン窓の結果は以下。ハン窓より軒並み悪い。
</code></pre></div>

<p>-rw-r--r--@  1 *  staff  41595943 Jan  5 15:49 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  32015488 Jan  5 15:50 SPARKLE.sol
-rw-r--r--@  1 *  staff     55317 Jan  5 15:50 kisaragi_chihaya.sol</p>
<div class="highlight"><pre><span></span><code>再び数百<span class="nv">KBの削減</span>（短い音声では増加<span class="o">...</span>）。結果をまとめると：<span class="w"></span>

<span class="o">|</span><span class="w"> </span>窓の種類<span class="w"> </span><span class="o">|</span><span class="w"> </span>ワン・ツー・スウィーツ<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nv">SPARKLE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>俺の声<span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="o">|--:|--:|--:|--:|</span><span class="w"></span>
<span class="o">|</span><span class="w"> </span>矩形窓（窓なし）<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">41939426</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">32534982</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">54345</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="o">|</span><span class="w"> </span>ハン窓<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">41586969</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">31990780</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">54991</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="o">|</span><span class="w"> </span>ブラックマン窓<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">41595943</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">32015488</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">55317</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="o">|</span><span class="w"> </span>サイン窓<span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">41575639</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">31957294</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">54468</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="o">|</span><span class="w"> </span><span class="nv">Vorbis窓</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">41580579</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">31975238</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">54785</span><span class="w"> </span><span class="o">|</span><span class="w"></span>

サイン窓を採用する。<span class="nv">Princen</span><span class="o">-</span><span class="nv">Bradley条件</span>（完全再構成条件）を満たす窓が良いのか？<span class="w"></span>

テスト書こうと思ったけど時間が中途半端（<span class="mi">19</span><span class="o">:</span><span class="mi">00</span>閉店で今<span class="mi">17</span><span class="o">:</span><span class="mi">42</span>）。<span class="nv">PARCORの高次係数の非線形量子化を検討する</span>。<span class="w"></span>

単純には低次非線形量子化関数の逆関数でいいかなと思ったけど、非常に複雑になりそうだったから一旦やめて、単純な関数から見る。<span class="w"></span>

<span class="w"> </span><span class="o">-</span><span class="w"> </span>ロジット関数：ロジスティックシグモイド関数の逆関数。<span class="p">$</span><span class="nf">f</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>\<span class="nf">log</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span>\<span class="nf">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nv">x</span><span class="p">)$</span><span class="w"></span>

余談：その後プレエンファシスを試すも性能悪化。<span class="w"></span>
</code></pre></div>

<p>-rw-r--r--@  1 *  staff  47930310 Jan  5 22:49 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  36947366 Jan  5 22:54 SPARKLE.sol
-rw-r--r--@  1 *  staff     65086 Jan  5 22:59 kisaragi_chihaya.sol</p>
<div class="highlight"><pre><span></span><code>### 2019.1.8

高次成分の非線形量子化を試みる。変換曲線は、ロジット関数をベースに、必ず$(-1,-1), (1,1)$を通過する曲線を作る。作り方は、まず$2 * sigmoid(x) - 1$として値域を$(-1,1)$に制限してから、$sigmoid(1)$で割ることで$(-1,-1), (1,1)$を通過するようになる。この関数は$a$をパラメータ、$B=\frac{1 + \exp(-a)}{1 - \exp(-a)}$として、$y = B \frac{1 - \exp(-ax)}{1 + \exp(-ax)}$。これを$x$について解けば、得られた曲線式は、$y = \frac{1}{a} \left\{ \log(B + x) - \log(B - x) \right}$。

いろんな$a$に対してグラフを書いてみると：

![20190929123415p](./images/la_first_attempts/20190929123415.png)

a=4,5,6あたりが狙い目？ひとまず5で様子見。

### 2019.1.9

高次成分もロジット関数で非線形量子化したけど...効果が限りなく薄いどころか効率悪化も見られた...
</code></pre></div>

<p>-rw-r--r--@  1 *  staff  41575637 Jan 10 00:34 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31957302 Jan 10 00:34 SPARKLE.sol
-rw-r--r--@  1 *  staff     54469 Jan 10 00:35 kisaragi_chihaya.sol</p>
<div class="highlight"><pre><span></span><code>そもそも、高次成分も精度良く記録する方針が間違ってる？低次成分に多くのビットを割り当てた方が良い方針かも。一旦高次の非線形量子化は取り下げる。

### 2019.1.10

低次係数に32bitを割り当ててみる。...書いていて思ったが、そろそろ圧縮の検証（元に戻るか？+圧縮率計測）プログラムを作るべきかも。

32bitの結果...**悪化。**
</code></pre></div>

<p>-rw-r--r--@  1 *  staff  41615559 Jan 10 23:02 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31993291 Jan 10 23:06 SPARKLE.sol
-rw-r--r--@  1 *  staff     54554 Jan 10 23:08 kisaragi_chihaya.sol</p>
<div class="highlight"><pre><span></span><code><span class="n">厳しい</span><span class="err">。</span><span class="n">ビット割当の試作は一旦置いておく</span><span class="p">...</span><span class="err">。</span><span class="w"></span>

<span class="n">ゴロム符号のパラメータをサンプル単位で切り替える対応をやってみる</span><span class="err">。</span><span class="n">更新式はwavpackのものをぱくって</span><span class="err">、</span><span class="n">以下のようにした</span><span class="err">。</span><span class="w"></span>

<span class="err">```</span><span class="nl">c</span><span class="p">:</span><span class="n">パラメータ更新</span><span class="o">+</span><span class="n">エンコード</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 各チャンネルごとにゴロム符号化 */</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_channels</span><span class="p">;</span><span class="w"> </span><span class="n">ch</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">      </span><span class="n">uint32_t</span><span class="w"> </span><span class="n">golomb_param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">golomb_m</span><span class="o">[</span><span class="n">ch</span><span class="o">]</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">uint32_t</span><span class="w"> </span><span class="n">res_code</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">smpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">smpl</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_encode_samples</span><span class="p">;</span><span class="w"> </span><span class="n">smpl</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">        </span><span class="n">res_code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SINT32_TO_UINT32</span><span class="p">(</span><span class="n">residual</span><span class="o">[</span><span class="n">ch</span><span class="o">][</span><span class="n">smpl</span><span class="o">]</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">Golomb_PutCode</span><span class="p">(</span><span class="n">strm</span><span class="p">,</span><span class="w"> </span><span class="n">golomb_param</span><span class="p">,</span><span class="w"> </span><span class="n">res_code</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res_code</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">golomb_param</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">          </span><span class="n">golomb_param</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">golomb_param</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">127</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="err">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">          </span><span class="n">golomb_param</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="p">(</span><span class="n">golomb_param</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">126</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="err">}</span><span class="w"></span>
<span class="w">      </span><span class="err">}</span><span class="w"></span>
<span class="w">    </span><span class="err">}</span><span class="w"></span>
</code></pre></div>

<p>（wavpackでは、更に急激な誤差変動対策が入っている。連続した1は15個までしか続かないようになっている。それ以上はElias符号化する。）</p>
<p>すると、やはりというか…性能改善。長い音源で500KBくらい減っているし、短い音源でも効果あり。
FLACとかMonkey's Audioの適応式も見てみたい。後少し気になったのが符号付き整数を符号なしに変換する式。偶数が正で奇数が負の式だけど、もしかしたら幾何分布に従ってないかもしれない。上手く変換すれば減りそう...というか、符号ビット+絶対値（負数は+1して符号反転すると◎。wavpackに書いてあった）の方が絶対値の頻度的に有利かも。</p>
<h3>2019.1.11</h3>
<p>ワン・ツー・スウィーツの1ch目の500000-550000サンプルにおける符号の頻度を調べてみた。</p>
<p><img alt="20190929123436p" src="./images/la_first_attempts/20190929123436.png" /></p>
<p>青線は偶数を正、奇数を負とする変換、橙線は絶対値（負数は+1して符号反転）して得られた分布。橙が有利なのは以下の点で明らかだろう：</p>
<ul>
<li>小さい値の頻度が高い</li>
<li>より幾何分布に近い</li>
</ul>
<p>これに符号ビットを1bit付加しても、おそらく効率よく圧縮できるだろう。3連休はこれを試す。</p>
<p>...やっつけで、符号1bit+絶対値でやってみたのだが、増加...</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  41280406 Jan 12 00:28 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31399579 Jan 12 00:28 SPARKLE.sol
-rw-r--r--@  1 *  staff     53348 Jan 12 00:29 kisaragi_chihaya.sol
</code></pre></div>

<p>符号bitの1bitが馬鹿にならないかも。ワン・ツー・スウィーツは2x13641600=27283200サンプルあるが、全てに符号bitをつけると27283200bit = 3410400byte。約3.4MBが符号ビットになっているので、符号ビットの圧縮が次？2値符号化だからランレングスする？
符号ビットを抜いたら37870006バイトで整合性あり。</p>
<p>TODO:</p>
<ul>
<li>符号ビットのランレングス？符号化</li>
<li>上のグラフから分かると思うけど、絶対値のピークは0でないことがわかっている（→<strong>大嘘</strong>。ヒストグラムの作り方を間違っていて0が抜けていた。0にピークがある。）。ピークを0にシフトして符号化する。シフトして負になる部分は別の符号を使う。</li>
</ul>
<h3>2019.1.12</h3>
<p>符号ビットの圧縮を試す。ランレングス的に、符号の切り替わりのときだけ1を出力するようにしてみる。そうすることで確実に減る（減らないのは正負が交互に出るときだけ）。</p>
<p>すると、flacを超え、当初の目的であるワン・ツー・スウィーツ40MBを切った。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  39463779 Jan 12 15:39 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  29681677 Jan 12 15:40 SPARKLE.sol
-rw-r--r--@  1 *  staff     50121 Jan 12 15:42 kisaragi_chihaya.sol
</code></pre></div>

<p>短い素材についてはMonkey's Audioを超えている。また、符号ビットはワン・ツー・スウィーツで1593773byteになっており半分以下になっている。</p>
<p>復号ができればいけるが、ゴロム符号に上記のビット列を入れたときにどうするか...。ゴロム符号前半のunary符号部分で切り替わりを表現する？</p>
<p>考えたが、どうやってもunary符号部分が不定な0の連続になっているので、切り替わりの1を挟む余地が無いことに気付いた。PackBits的にやらざるを得ない...やったら増えた。最大ランレングス長を3としたPackBitsでこんな感じ。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  42793987 Jan 12 17:50 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  32595117 Jan 12 17:50 SPARKLE.sol
-rw-r--r--@  1 *  staff     55704 Jan 12 17:49 kisaragi_chihaya.sol
</code></pre></div>

<p>うーん、厳しい。ゴロム符号のアレンジでなんとかならないか...</p>
<p>困ってMonkey Audioのソースを見る...と、レンジコーダ使っていることに気づく。それじゃあデコードが遅いではないか...。</p>
<h3>2019.1.13</h3>
<p>wavpackの論文を読んだら以下の示唆があった。</p>
<ul>
<li>中央値の更新式</li>
<li>固定小数を使うことで平滑化し小さい値でのジャンプを防ぐ。</li>
<li>今の中央値の更新式は最適か？検討が必要。</li>
<li>Recursive Golomb Coding</li>
<li>エンコード値のunary部が2より長い（現在の中央値を超えた）場合は、エンコード値から中央値を引いてこれを新しい中央値としてゴロム符号化する。新しい中央値も適応的に変える。</li>
<li>これは減りそう...</li>
</ul>
<p>Recursive Golomb Codingの手順：</p>
<ol>
<li>パラメータ配列<code>m[MAX_QUOT]</code>を用意</li>
<li>符号ビットを1bit出力</li>
<li><code>abs &lt;- 絶対値</code></li>
<li><code>quot &lt;- abs / m</code></li>
<li><code>quot</code>をunary符号出力</li>
<li><code>for q 0 to MAX_QUOT</code></li>
<li><code>if (abs &lt; m[q] or q &gt;= MAX_QUOT) break</code></li>
<li><code>abs &lt;- abs - m[q]</code></li>
<li><code>end for</code></li>
<li><code>abs % m[quot]</code>をゴロム符号と同様に出力</li>
<li><code>m</code>の更新</li>
</ol>
<p>中央値の更新式を固定小数化することで微減。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  41276050 Jan 14 00:23 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31390861 Jan 14 00:23 SPARKLE.sol
-rw-r--r--@  1 *  staff     53282 Jan 14 00:23 kisaragi_chihaya.sol
</code></pre></div>

<p>wavpackでは4bitを小数部に使っている。自分は12bitを割り当てている。4bitの方が追従が良く、よい結果を出している感触があるが、精度重視で12bitにしてみた。</p>
<p>（記憶に行き違いがないか、念の為記録）符号bit+絶対値ではなく、偶数を正に、奇数を負に割り当てる方針で行くと、以下のように微増する：</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  41349156 Jan 14 02:24 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31557247 Jan 14 02:26 SPARKLE.sol
-rw-r--r--@  1 *  staff     53354 Jan 14 02:26 kisaragi_chihaya.sol
</code></pre></div>

<h3>2019.1.14</h3>
<p>符号ビットはランレングスで圧縮できそうだという信念の元、ランの長さをγ符号あたりで符号化することを検討中。</p>
<ul>
<li><a href="http://d.hatena.ne.jp/naoya/touch/20090804/1249380645">γ符号、δ符号、ゴロム符号による圧縮効果</a></li>
</ul>
<p>色々ガチャガチャやり始める前にランの長さの統計を取る。</p>
<p><img alt="20190929123450p" src="./images/la_first_attempts/20190929123450.png" /></p>
<p><strong>これ、1/(2^x)と比較すれば分かるが、一様乱数列のランレングスでは...</strong></p>
<p>（ランの長さnは同一符号がn連続していることを示す。ランの長さ1は連続していないことを示す。）</p>
<p>さらに平均ラン長を計算してみると…（長さ64以上のランは除外）</p>
<table>
<thead>
<tr>
<th align="right">入力音声</th>
<th align="right">平均ラン長</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">ワン・ツー・スウィーツ</td>
<td align="right">2.055</td>
</tr>
<tr>
<td align="right">SPARKLE</td>
<td align="right">2.260</td>
</tr>
<tr>
<td align="right">俺の声</td>
<td align="right">1.976</td>
</tr>
</tbody>
</table>
<p>約2。これは何を意味するか...</p>
<ul>
<li><a href="https://www.quora.com/How-do-you-evaluate-the-sum-of-n-2-n-from-n-1-to-infinity">級数の収束</a></li>
</ul>
<p>これによると、一様乱数列の平均に一致している…。</p>
<p>γ符号の実装に2時間ほど持ってかれる...<code>GetBits</code>の引数が64bitで型が合わずメモリ破壊を起こしていた。</p>
<p>実装できてランレングスをγ符号で出すようにした。が、増加...</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  41783849 Jan 14 17:41 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31753911 Jan 14 17:41 SPARKLE.sol
-rw-r--r--@  1 *  staff     54026 Jan 14 17:41 kisaragi_chihaya.sol
</code></pre></div>

<p>うむ、厳しい。いや、長すぎるランを出している可能性がある。その回避を打ってから次を考える。</p>
<p>悲しくなってナイーブに符号ビット0,1の頻度を計測したら僅かながら<strong>偏りがあった。</strong>
さらに2bitパターンにしたら更に<strong>偏りが大きくなった。</strong></p>
<p>早速8bitパターン化して頻度を見たところ、音源に依存せず現れないパターンを観測した。（どうしてその様なパターンが表れるのかは<strong>謎</strong>。あとグラフは中心で<strong>対称</strong>になっていないか？）</p>
<p><img alt="20190929123511" src="./images/la_first_attempts/20190929123511.png" /></p>
<p>8bit使ったときのエントロピーは以下：</p>
<p>| 音源 | 8bit符号ビットパターンのエントロピー | 
|--:|--:|--:|
| ワン・ツー・スウィーツ | 7.827755 |
| SPARKLE | 7.772168 |
| 俺の声 | 7.752156 |</p>
<p>ハフマン等で上手く割り当てれば3%くらい減らせる余地がある。費用対効果的にきついか？これは最後の手段として取っておこう。先に、効果の有りそうなRecursive Golomb Codingに手を出す。</p>
<h3>2019.1.15</h3>
<p>Recursive Golomb Codingに実装着手。アルゴリズムを紙に書いて終わり。</p>
<h3>2019.1.16</h3>
<p>Recursive Golomb Codingのテストを書きながら実装中。大阪行きながら実装できるとベストだが…大阪で実装する余裕はあるだろうか。大阪にはルベグ積分だけ持っていこう。</p>
<h3>2019.1.17</h3>
<p>Recursive Golomb Coding実装...と行きたいけど寄り道。</p>
<p>shotenの論文を読んでたら、ゴロム符号の商部分はアルファ符号よりもガンマ符号で出したほうが良いとの記述あり。早速試してみたがサイズ増加。ガンマ符号の実装が誤っている可能性がまだあるため、あとで再度検証したい。</p>
<p>また、shotenではまず入力データから平均を差っ引くというのを見た。これはもしかしたらLPC解析時に効くかもしれないと思って、窓掛け前に平均除去を入れてみた。結果はさしたる変化なし。（増えるケースもあった）
念の為窓掛け後に平均除去を入れたら、窓掛け後のほうが性能が良かった。</p>
<table>
<thead>
<tr>
<th align="right">音源</th>
<th align="right">変更前</th>
<th align="right">窓掛け前に平均</th>
<th align="right">窓掛け後に平均</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">ワン・ツー・スウィーツ</td>
<td align="right">41276050</td>
<td align="right">41275937</td>
<td align="right">41275904</td>
</tr>
<tr>
<td align="right">SPARKLE</td>
<td align="right">31390861</td>
<td align="right">31392892</td>
<td align="right">31391996</td>
</tr>
<tr>
<td align="right">俺の声</td>
<td align="right">53282</td>
<td align="right">53283</td>
<td align="right">53282</td>
</tr>
</tbody>
</table>
<p>FLACの実装を見ているとテューキー窓を使用していた。試す価値はあるかもしれない。</p>
<p>次数を増やしたら1MB近くの減少が観測された。その際に自己相関計算時のバグが見られたので修正（float同士の乗算により精度が落ち、PARCOR係数の絶対値が1よりも大きくなった。もっと言うとwavからデータを取るときにdoubleにすべき。）。またブロックサイズを変更することでかなりのパフォーマンス差が見られた。…しかしこれらは最後の手段。高次のPARCOR係数の傾向を見ておくのは良いことかも。</p>
<p>全く集中できなくてネットをウロウロしていたらexp-golomb符号（Elias-Teuhola符号）が目に止まった。H.264に使われているらしい。</p>
<ul>
<li><a href="http://www.hpl.hp.com/techreports/2006/HPL-2006-74.pdf">On the Determination of Optimal Parameterized Prefix Codes for Adaptive Entropy Coding</a></li>
</ul>
<p>中央値の逐次計算手法：</p>
<ul>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.91.853&amp;rep=rep1&amp;type=pdf">Effective Computation of Biased Quantiles over Data Streams</a></li>
</ul>
<p>そして、依然として絶対値+符号ビットじゃなくて正を偶数、負を奇数に割り当てた方が圧縮率が良い...。一体どういうことだろうか。符号ビットも混ぜて符号化できるから効率が良い？</p>
<p><strong>一旦立ち返って符号語の分布を見てみるべきかも。幾何分布の尤度を計算して当てはまりを見るのも良い。</strong></p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  41242708 Jan 18 01:05 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31367692 Jan 18 01:06 SPARKLE.sol
-rw-r--r--@  1 *  staff     53246 Jan 18 01:06 kisaragi_chihaya.sol
</code></pre></div>

<p>最適なゴロム符号パラメータの決定法の資料があったぞ...</p>
<ul>
<li><a href="http://l.web.umkc.edu/lizhu/teaching/2016sp.video-communication/notes/lec03.pdf">Lec 03 Entropy and Coding II Hoffman and Golomb Coding</a></li>
</ul>
<h3>2018.1.18</h3>
<p>1時間ほど作業ができるので誤差分布の統計を取る。</p>
<p>まずは符号語の分布。</p>
<p><img alt="20190929123528p" src="./images/la_first_attempts/20190929123528.png" /></p>
<p>u2が正を偶数、奇を負とする符号語、absが絶対値…ってなんだこりゃ。<strong>正負で分布が違うように見えるのだが</strong>。</p>
<p>正負が非対称になっている可能性があるので、誤差のヒストグラムをそのまま出したところ…</p>
<p><img alt="20190929123542p" src="./images/la_first_attempts/20190929123542.png" /></p>
<p>0は最頻値（俺の声では最頻値すらずれている）だけど、平均がずれて存在している…？どういうこと？予測の間違い？</p>
<h3>2018.1.20</h3>
<p>秋葉原製作所。平均がずれているのはかなりクリティカルだと思っている。PARCOR係数の次数を変えて観察してみる。音源はSPARKLE（上のグラフで山がわかりやすかったから）</p>
<p><img alt="20190929123559p" src="./images/la_first_attempts/20190929123559.png" /></p>
<p>0がピークであることは変わりない。次数を増やすと山が正側に動いていく。差分生成のときに引き残しが発生している？実装を調査。</p>
<p>SPARKLEに対して整数版の関数を使用すると、確かに正にずれているのが確認できる。</p>
<div class="highlight"><pre><span></span><code>residual sum:107071606 count:24540160
</code></pre></div>

<p>というか、和が減る瞬間がない。。。次数10のときの誤差の和をグラフにすると、</p>
<p><img alt="20190929123617p" src="./images/la_first_attempts/20190929123617.png" /></p>
<p>傾きを見れば分かるが、サンプル当り平均4の正の誤差が出ている。グラフを見るにどうもこれは音源に依存しないようだ。</p>
<p>浮動小数点版の予測関数を使い、誤差の和と平均を取った。これでも正にずれている。</p>
<div class="highlight"><pre><span></span><code>residual sum:7.148294 sum(fix32):15350843823 count:24540160 mean:0.000000 mean(fix32):625
</code></pre></div>

<p>気になったのは係数の非線形量子化。非線形量子化して再度floatに戻すと誤差が出るのでは？と思い誤差の和を計測したら、誤差は正で（仕様。必ず大きい方に割り当てているから）和を取ると結構シャレにならない大きさになっていた。（SPARKLE, 次数10）</p>
<div class="highlight"><pre><span></span><code><span class="n">err_sum</span><span class="o">:</span><span class="mf">1.306255</span><span class="n">e</span><span class="o">-</span><span class="mi">01</span><span class="w"></span>
</code></pre></div>

<p>2分探索で無条件にtable[index] &lt;= valを満たす値を割り振るのではなく、table[index+1]の方が近ければそちらを割り振るように修正したところ誤差値は改善（誤差分布にさしたる変化なし）：</p>
<div class="highlight"><pre><span></span><code><span class="nf">err_sum</span><span class="o">:-</span><span class="mf">6.461394e-02</span>
</code></pre></div>

<p>根本的にズレを直すにはアルゴリズムを見直すしか無い？</p>
<p>実装を次のように、係数の符号を反転して計算してみると山が反転...アルゴリズムに問題ありなのは間違いなさそう。</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cm">/* 前向き誤差計算 */</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">ord</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">ord</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">gamma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">parcor_coef</span><span class="p">[</span><span class="n">ord</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">mul_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">gamma</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">backward_residual</span><span class="p">[</span><span class="n">ord</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">coef_quantize_shift</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">forward_residual</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">forward_residual</span><span class="p">[</span><span class="n">ord</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mul_temp</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="c1">// mul_temp = (parcor_coef[ord] * backward_residual[ord - 1]) &gt;&gt; coef_quantize_shift;</span>
<span class="w">      </span><span class="c1">// forward_residual[ord] = forward_residual[ord - 1] - mul_temp;</span>
<span class="w">      </span><span class="n">assert</span><span class="p">(</span><span class="n">forward_residual</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">INT32_MAX</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">assert</span><span class="p">(</span><span class="n">forward_residual</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">INT32_MIN</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 後ろ向き誤差計算 */</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">order</span><span class="p">;</span><span class="w"> </span><span class="n">ord</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ord</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">gamma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">parcor_coef</span><span class="p">[</span><span class="n">ord</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">mul_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">gamma</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">forward_residual</span><span class="p">[</span><span class="n">ord</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">coef_quantize_shift</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">backward_residual</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">backward_residual</span><span class="p">[</span><span class="n">ord</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mul_temp</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="c1">// mul_temp = (parcor_coef[ord] * forward_residual[ord - 1]) &gt;&gt; coef_quantize_shift;</span>
<span class="w">      </span><span class="c1">// backward_residual[ord] = backward_residual[ord - 1] - mul_temp;</span>
<span class="w">      </span><span class="n">assert</span><span class="p">(</span><span class="n">backward_residual</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">INT32_MAX</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">assert</span><span class="p">(</span><span class="n">backward_residual</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">INT32_MIN</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</code></pre></div>

<p><img alt="20190929123633p" src="./images/la_first_attempts/20190929123633.png" /></p>
<p>入力データとしては16bit幅しか無いデータを入れているので、固定小数的に怪しい（小数部の余裕がない）と思い、入力データの左16bitシフトを入れた：</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="cm">/* 誤差計算 */</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">samp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">samp</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_samples</span><span class="p">;</span><span class="w"> </span><span class="n">samp</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 格子型フィルタにデータ入力 */</span><span class="w"></span>
<span class="w">    </span><span class="n">forward_residual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="n">samp</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 前向き誤差計算 */</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">ord</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">ord</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">mul_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">parcor_coef</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">backward_residual</span><span class="p">[</span><span class="n">ord</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">coef_quantize_shift</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">forward_residual</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">forward_residual</span><span class="p">[</span><span class="n">ord</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mul_temp</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">assert</span><span class="p">((</span><span class="n">forward_residual</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">INT32_MAX</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">assert</span><span class="p">((</span><span class="n">forward_residual</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">INT32_MIN</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 後ろ向き誤差計算 */</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">order</span><span class="p">;</span><span class="w"> </span><span class="n">ord</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ord</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">mul_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">parcor_coef</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">forward_residual</span><span class="p">[</span><span class="n">ord</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">coef_quantize_shift</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">backward_residual</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">backward_residual</span><span class="p">[</span><span class="n">ord</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mul_temp</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">assert</span><span class="p">((</span><span class="n">backward_residual</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">INT32_MAX</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">assert</span><span class="p">((</span><span class="n">backward_residual</span><span class="p">[</span><span class="n">ord</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">INT32_MIN</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 後ろ向き誤差計算部にデータ入力 */</span><span class="w"></span>
<span class="w">    </span><span class="n">backward_residual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="n">samp</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 残差信号 */</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">((</span><span class="n">forward_residual</span><span class="p">[</span><span class="n">order</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">INT32_MAX</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">((</span><span class="n">forward_residual</span><span class="p">[</span><span class="n">order</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">INT32_MIN</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">residual</span><span class="p">[</span><span class="n">samp</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int32_t</span><span class="p">)(</span><span class="n">forward_residual</span><span class="p">[</span><span class="n">order</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>分布はほぼ対称になり、0の頻度が向上。が、<strong>裾の減衰が遅くなって音源依存で圧縮率が悪化した。</strong>（SPARKLEは改善、ワン・ツー・スウィーツは悪化）</p>
<p><img alt="20190929123648p" src="./images/la_first_attempts/20190929123648.png" /></p>
<p>固定小数の扱いがまずそう。丸めを忘れている：</p>
<ul>
<li><a href="http://www.sage-p.com/compone/toda/fixdec.htm">固定小数</a></li>
</ul>
<p>丸めを入れたところ、山のピークは0に近づいた。微妙にサイズは増加。</p>
<p><img alt="20190929123701p" src="./images/la_first_attempts/20190929123701.png" /></p>
<p>丸め+16bitシフトではSPARKLE、ワン・ツー・スウィーツ共に30KBほどサイズ減少。</p>
<p><img alt="20190929123717p" src="./images/la_first_attempts/20190929123717.png" /></p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  41219742 Jan 21 01:23 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31336925 Jan 21 01:19 SPARKLE.sol
-rw-r--r--@  1 *  staff     53089 Jan 21 01:24 kisaragi_chihaya.sol
</code></pre></div>

<p>もう一度誤差平均を見てみよう。</p>
<h3>2019.1.22</h3>
<p>先輩社員のアドバイスにより、16bit左シフトは必須であることが分かった。小数点が揃わず意図しない計算になっていた。間違いをなくすために32bit固定小数点型を使うべきとも。</p>
<p>今一度誤差平均を計算してみる。</p>
<table>
<thead>
<tr>
<th align="right">音源</th>
<th align="right">誤差平均</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">ワン・ツー・スウィーツ</td>
<td align="right">-0.455</td>
</tr>
<tr>
<td align="right">SPARKLE</td>
<td align="right">-0.474</td>
</tr>
<tr>
<td align="right">俺の声</td>
<td align="right">-0.442</td>
</tr>
</tbody>
</table>
<h3>2019.1.23</h3>
<p>そして、整数版LPC予測合成関数で、データの固定小数ビット幅を可変にできるようにしているが、テストが失敗している…。修復には時間がかかりそう。</p>
<h3>2019.1.24</h3>
<p><a href="https://xiph.org/flac/documentation_tools_flac.html#encoding_options">FLACのエンコーディングオプション</a>を見ると-rでライス符号の分割数を決めている。これはwavpackの再帰的ゴロムと同義では？</p>
<p>帰りが遅くなり何も手が付かない…昨日との落差がありすぎてつらい…。</p>
<p>で、気付いたのだけど32bit整数だと最大<code>INT32_MAX - INT32_MIN</code>の誤差が出るはずで、それは32bit整数では表現できない。だから、表現する固定小数ビット数を30bitに、整数ビット数を2bitに妥協することにした。</p>
<h3>2019.1.26</h3>
<p>ピアノもコーデックも進まなかったが、ようやく自由になる。</p>
<p>LPCのライス符号の分割は、網羅探索のことだった。指定した最小分割数から最大分割数でライス符号パラメータを変更してエンコードし、最もサイズが小さくなった分割を採用する、というもの。エンコード速度は犠牲になるけど、確かにデコード速度は早くなる発想だわ…。</p>
<h3>2019.1.27</h3>
<p>秋葉原製作所5時間コース。なんとしても今日で直す。
なんとなく起きていることは分かった。</p>
<table>
<thead>
<tr>
<th align="center">No.</th>
<th align="center">データbit(整数部, 固定小数部)</th>
<th align="center">得られた誤差の右シフト量</th>
<th align="center">係数bit(整数部, 固定小数部)</th>
<th align="center">結果</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">①</td>
<td align="center">(1,31)</td>
<td align="center">0</td>
<td align="center">(1,31)</td>
<td align="center">NG。フィルタ値が[-1.0, 1.0]を超えるケースがある</td>
</tr>
<tr>
<td align="center">②</td>
<td align="center">(1,31) &gt;&gt; (32-データのビット幅)</td>
<td align="center">0</td>
<td align="center">(1,31)</td>
<td align="center">OK。元に戻る</td>
</tr>
<tr>
<td align="center">③</td>
<td align="center">(1,31) &gt;&gt; (31-データのビット幅)</td>
<td align="center">0</td>
<td align="center">(1,31)</td>
<td align="center">OK。元に戻る<strong>が、圧縮率が悪い</strong></td>
</tr>
<tr>
<td align="center">④</td>
<td align="center">(1,31) &gt;&gt; (31-データのビット幅)</td>
<td align="center">1</td>
<td align="center">(1,31)</td>
<td align="center"><strong>NG。</strong>②より圧縮率良いが、誤差の最下位ビットが吹っ飛ぶので元に戻らない</td>
</tr>
<tr>
<td align="center">⑤</td>
<td align="center">(1,31) &gt;&gt; (33-データのビット幅)</td>
<td align="center">0</td>
<td align="center">(1,31)</td>
<td align="center"><strong>NG。</strong>④よりさらに圧縮率が良いが、データ側の最下位ビットが吹っ飛ぶので元に戻らない</td>
</tr>
</tbody>
</table>
<p>これらの結果より、</p>
<ul>
<li>誤差のbit数は入力データのbit吸うと同一である必要がある。</li>
<li>誤差を右シフトすると情報が失われる。左シフトすると無駄な情報が増える。</li>
</ul>
<p>ことが分かるし、②以外の形態にするのは無しという方針で。また、2019.1.20の計算中の左シフトも、誤差記録時に右シフトしたときに情報が失われて、デコード結果が元に戻らないから採用できない。</p>
<p><strong>でも結局誤差分布の偏りは解消されない…。</strong></p>
<p>有力なヒントは、PARCOR係数の符号を反転させると山が反転することだろう。アルゴリズム内になにかの原因があるはず。
→原因が見えてきた。今の演算では32bit精度が求められる状態になっているのでは。32bitの最下位桁のずれがダイレクトに誤差になっている。</p>
<p>また、色々試していて非線形量子化が原因かと思って非線形量子化をやめてみたら、誤差の分布があまり変わらず、しかもなぜか圧縮率が向上した…そんな馬鹿な…。1MB程度の差が出るはずなのに。。。</p>
<p>これで5時間タイムアップ。今の作業項目をまとめるとこんな感じ：</p>
<p>直近のTODO:</p>
<ul>
<li>誤差の分布が非対称になる現象の調査</li>
<li>非線形量子化が効いていない原因の調査</li>
<li>ゴロム符号を再帰的にする</li>
<li>ゴロム符号のパラメータ決定を変更。→統計論的に最適な <span class="math">\(\log_{e} 2 E[|res|]\)</span> を使う。</li>
<li>テューキー窓の使用</li>
<li>無音部でランレングス符号化を使う</li>
<li>ゴロム符号のパラメータ計算のときに正値化した差分信号の平均を計算する。平均が1より小さければ無音のはず。ランレングスで符号化する。</li>
<li>
<p>等ビットレート原則が崩れるかも...</p>
</li>
<li>
<p>ロングターム（ピッチ情報）を使う</p>
</li>
<li>ピッチ解析を行い、その長さによる予測符号化を行う。MPEG4-LSで使われている手法。</li>
</ul>
<p>帰って、誤差分布のズレがどうしても諦められず追っていた。積和の途中でビット幅を広げるのを試したけど、結局、誤差を右シフトする必要があって情報が落ちてしまう。</p>
<p>で、今は前向き誤差を出すときに減算を重ねた結果正のオフセットが出ていることから、じゃあ丸め分大きくしてやるぜで試したら<strong>誤差分布が対称になった。</strong></p>
<p>```c:変更前
    /<em> 前向き誤差計算 </em>/
    for (ord = 1; ord &lt;= order; ord++) {
      mul_temp = (parcor_coef[ord] * backward_residual[ord - 1]) &gt;&gt; 31;
      forward_residual[ord] = forward_residual[ord - 1] - mul_temp;
    }</p>
<div class="highlight"><pre><span></span><code><span class="err">```</span><span class="nl">c</span><span class="p">:</span><span class="n">変更後</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 前向き誤差計算 */</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">ord</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="k">order</span><span class="p">;</span><span class="w"> </span><span class="n">ord</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">      </span><span class="n">mul_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parcor_coef</span><span class="o">[</span><span class="n">ord</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">backward_residual</span><span class="o">[</span><span class="n">ord - 1</span><span class="o">]</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">mul_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">mul_temp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="n">UL</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">30</span><span class="p">)</span><span class="cm">/* 丸めhalf */</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">31</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">forward_residual</span><span class="o">[</span><span class="n">ord</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">forward_residual</span><span class="o">[</span><span class="n">ord - 1</span><span class="o">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mul_temp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="err">}</span><span class="w"></span>
</code></pre></div>

<p>これが根本原因なのかはまだ分からない…。結果は以下でちゃんと戻ることは確認済み。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  41216562 Jan 28 01:05 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31339500 Jan 28 01:06 SPARKLE.sol
-rw-r--r--@  1 *  staff     53097 Jan 28 01:05 kisaragi_chihaya.sol
</code></pre></div>

<p>分布はこんな感じで、概形としては理想と考えられる。</p>
<p><img alt="20190929123732p" src="./images/la_first_attempts/20190929123732.png" /></p>
<h3>2019.1.28</h3>
<p>何故丸めが必要なのか。以下のサイトでは0.5足してからFIRの積和演算をしている。</p>
<ul>
<li><a href="https://sestevenson.wordpress.com/implementation-of-fir-filtering-in-c-part-2/">Implementation of FIR Filtering in C (Part 2)</a></li>
</ul>
<p>丸めはどうも加算する方向しかだめなようだ。丸めには色々方法があるらしいが、今回の原因となっていていたのは、</p>
<ul>
<li><a href="https://sestevenson.wordpress.com/rounding-in-fixed-point-number-conversions/">Rounding in Fixed Point Number Conversions</a></li>
</ul>
<p>の、</p>
<blockquote>
<p>truncate(1.25) = 0x0001 = 1</p>
<p>truncate(1.5) = 0x0001 = 1</p>
<p>truncate(1.75) = 0x0001 = 1</p>
<p>truncate(-1.25) = 0xFFFE = -2</p>
<p>truncate(-1.5) = 0xFFFE = -2</p>
<p>truncate(-1.75) = 0xFFFE = -2</p>
<p>For the positive numbers, the result of truncation is that the fractional part is discarded. The negative number results are more interesting. The result is that the fractional part is lost, and the integer part has been reduced by one. If a series of these numbers had a mean of zero before truncation, then the series would have a mean of less than zero after truncation. Rounding is used to avoid this problem of introduced bias and to make results more accurate.</p>
</blockquote>
<p>にあるように、どうも負方向に寄ってしまうのが原因らしい(-1.5の例を注目）。特に3と-3を小数部を2bitとして2bitシフトしてみると、<code>3&gt;&gt;2=0</code>に対して<code>-3&gt;&gt;2=-1</code>。だから右シフトでは-1のオフセットが乗ってしまう。だから小数部で加算することで精度を上げることができていたと想像する。3,-3の場合だと1を加算することになるから、<code>(3+1)&gt;&gt;2=1</code>、<code>(-3+1)&gt;&gt;2=-1</code>だから精度が上がっている。</p>
<p>良い窓関数を探そうとして会社の『音声のディジタル信号処理（下）』を読んでいたら、格子型フィルタのより効率的な構成が見つかった。何でも乗算回数がN回（今2N回）で済むらしい。</p>
<ul>
<li><a href="https://www.quora.com/What-is-the-application-of-Lattice-structure-for-digital-filters-I-find-lattice-in-a-lot-of-books-but-none-of-them-explains-why-it-is-important">質問サイト</a></li>
<li><a href="http://zone.ni.com/reference/en-XX/help/371325F-01/lvdfdtconcepts/lattice_allpass/">Lattice Allpass Structures (Digital Filter Design Toolkit)</a></li>
<li><a href="https://cas.tudelft.nl/Education/courses/ee2s31/slides/DSP9.pdf">Filter realizations: lattice filter structures</a></li>
</ul>
<p>頭にいれるだけ入れておく。</p>
<h3>2019.1.29</h3>
<p>窓関数をテューキー窓に置き換える前に資料を覗く。</p>
<ul>
<li><a href="https://org-technology.com/posts/scipy-window-function.html">SciPy で使用可能な窓関数</a></li>
<li><a href="https://community.plm.automation.siemens.com/t5/Testing-Knowledge-Base/Window-Types-Hanning-Flattop-Uniform-Tukey-and-Exponential/ta-p/445063">Window Types: Hanning, Flattop, Uniform, Tukey, and Exponential</a></li>
<li><a href="https://en.wikipedia.org/wiki/Window_function#Tukey_window">Wikipedia</a></li>
</ul>
<p>要はテューキー窓は矩形窓に近く、過渡的な信号に強いようだ。</p>
<p>早速0.5を設定して試してみる。うーん。ワン・ツー・スイーツ以外ではサイン窓の方が性能が良い。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  41214648 Jan 29 22:15 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31342212 Jan 29 22:16 SPARKLE.sol
-rw-r--r--@  1 *  staff     53141 Jan 29 22:14 kisaragi_chihaya.sol
</code></pre></div>

<p>ゴロム符号のパラメータを log_{e}2E[|res|] に変えてみると、悪化。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  41258145 Jan 29 22:53 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31420823 Jan 29 22:54 SPARKLE.sol
-rw-r--r--@  1 *  staff     53145 Jan 29 22:54 kisaragi_chihaya.sol
</code></pre></div>

<p><a href="https://ipnpr.jpl.nasa.gov/progress_report/42-159/159E.pdf">今の手法</a>の方が良かった。</p>
<p>また、改めて符号1bit+絶対値符号すると性能が悪化する。何故？符号bitは実は冗長？</p>
<p>小手先のアイデアは通用しなさそう。さて、再帰的ゴロムの実装に戻ろう。</p>
<h3>2019.1.30</h3>
<p>FLACのソースを読んでたらLPC乗算時の右シフトは、積和演算の後に行われていた。</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cm">/* Here&#39;s a slower but clearer version:</span>
<span class="cm">    for(i = 0; i &lt; data_len; i++) {</span>
<span class="cm">        sum = 0;</span>
<span class="cm">        for(j = 0; j &lt; order; j++)</span>
<span class="cm">            sum += qlp_coeff[j] * data[i-j-1];</span>
<span class="cm">        residual[i] = data[i] - (sum &gt;&gt; lp_quantization);</span>
<span class="cm">    }</span>
<span class="cm">    */</span><span class="w"></span>
</code></pre></div>

<p>最後に右シフトするので精度が高いはず。
これはLPCが予測誤差算出と復号を同一のアルゴリズムできるから？PARCORでできない理由があるだろうか。
また個人的には非線形量子化があんまり効いていないように見えるのが引っかかっている。</p>
<h3>2019.1.31</h3>
<p>再帰的ゴロムの実装。テスト追加しながらやっている。まだ実装途中だが、時間があれなので練る。</p>
<h3>2019.2.1</h3>
<p>中央値mはE[|X-m|]を最小化することが知られている。適応的に求められないか？
LMSは適応的に求められる手法が良く知られているが、絶対値はそうはいかない。</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Least_absolute_deviations">Least absolute deviations - Wiki</a></li>
</ul>
<h3>2019.2.16</h3>
<p>再帰的ゴロムが何となく動き始めている。次のように符号を割り当てると考えたらうまく行った：</p>
<table>
<thead>
<tr>
<th align="center">値域</th>
<th align="center">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0 &lt;= val &lt; m</td>
<td align="center">1  (val % m)</td>
</tr>
<tr>
<td align="center">m &lt;= val &lt; m + m'</td>
<td align="center">01 ((val - m) % m')</td>
</tr>
<tr>
<td align="center">m + m' &lt;= val</td>
<td align="center">001 (((val - (m + m')) をパラメータ(m + m')でゴロム符号出力)</td>
</tr>
</tbody>
</table>
<p>パラメータの変動を見ていたら、現在値より大きいか小さいかだけで更新値を決めるので追従が遅い。</p>
<p>やっぱり中央値の逐次修正を改善したい。幾何分布の性質に注目すると、p&gt;=0.5では、必ず平均値が中央値よりも小さくなる結果が見えている。下限を平均値、上限を平均+分散の平方根として、どうにか逐次推定できないか？</p>
<h3>2019.2.17</h3>
<p>再帰的ゴロム符号にテスト追加。また、符号割当をループの形で書き直す。
→OK。良好に動いている。で、パラメータを増やしていくと、増やしただけ良くなっていく傾向が見られる。（当然、大きすぎる値は増加に転じる）</p>
<p>さっそく再帰的ゴロム符号を組み込んだが…結果悪化…。まだ整理しきれてない・あがける部分はありそうなので、一週間粘ってみる。</p>
<h3>2019.2.18</h3>
<p>再帰的ゴロム符号の実装を修正。修正前は全パラメータの和に達したらパラメータ和のゴロム符号をしていたが、そうではなく、末尾のパラメータを使用してゴロム符号化するようにした。</p>
<p>それでパラメータ段数を8にしたら、全体的に減少。長い音声では百KBオーダーで減少が見られた。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  41085053 Feb 20 02:05 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31287228 Feb 20 02:09 SPARKLE.sol
-rw-r--r--@  1 *  staff     53068 Feb 20 02:10 kisaragi_chihaya.sol
</code></pre></div>

<p>まだ改良点がある。パラメータ数で剰余部のアルファ符号は打ち切りができるはず。他にもパラメータ初期値のとり方でだいぶ性能が違っていた。また、パラメータ末尾で符号化するときには、ゴロム符号を使わず、その場で商を計算してアルファ符号化すべきかも。</p>
<h3>2019.2.20</h3>
<p>再帰的ゴロム符号の改良に取り掛かる。末尾パラメータ符号化の際に1bit減らした。長い音声では十KBオーダーで減少。</p>
<p>パラメータは末尾の利を活かすべく（というか今まで損していた）少なめの3つとしている。パラメータ初期値でだいぶパフォーマンスが異なるのが気になる…。更新式も再考の余地がありそう。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  41032143 Feb 21 00:19 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31245120 Feb 21 00:21 SPARKLE.sol
-rw-r--r--@  1 *  staff     52997 Feb 21 00:22 kisaragi_chihaya.sol
</code></pre></div>

<p>後、確実に減らせるのはランレングス分。</p>
<h3>2019.2.21</h3>
<p>パラメータが小さければランレングス符号化するように修正。当然減る。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  41006713 Feb 22 00:56 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31233963 Feb 22 00:56 SPARKLE.sol
-rw-r--r--@  1 *  staff     52997 Feb 22 00:56 kisaragi_chihaya.sol
</code></pre></div>

<p>減らすアイデアあり。末尾のパラメータで符号化するときに、商部分が大きくなりすぎることがある（32より大きいものがたくさん出てきた。アルファ符号を使うからかなりのロス）から、長過ぎる商はガンマ符号化する。（wavpackと同じアイデア）
あと、PARCOR係数最初の1つ目は1.0fなのに符号化しているのがもったいない。2つ目以降を符号化するように修正したい。</p>
<h3>2019.2.24</h3>
<p>圧縮も佳境だ。
まずは、商部分が長すぎる場合はガンマ符号を使う修正。長い音源で十KBオーダーで減少。wavpackに倣って商が16以上ならばガンマ符号化している。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  40967452 Feb 24 14:19 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31133035 Feb 24 14:26 SPARKLE.sol
-rw-r--r--@  1 *  staff     52962 Feb 24 14:27 kisaragi_chihaya.sol
</code></pre></div>

<p>さらに、係数先頭が0であるからそれを保存しないようにして、係数先頭1つ分の保存を省いた。微減。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  40954128 Feb 24 15:10 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31121051 Feb 24 15:11 SPARKLE.sol
-rw-r--r--@  1 *  staff     52934 Feb 24 15:10 kisaragi_chihaya.sol
</code></pre></div>

<p>あと、桜川駅から大阪港までバスで行く途中で思いついたけど、自己相関の計算で情報落ちが起きているから、それを軽減するように修正しよう。→確かに情報落ちは起きていたけど、積み残しは10^-16程度で圧縮率改善には至らず。</p>
<p>また、LSPで係数保存してLPCで予測・合成すれば、計算負荷は低く、かつ精度良くやれそう。これは次世代バージョンでのアイデア。</p>
<h3>2019.2.26</h3>
<p>PARCOR係数の不均一なビット割当てを試そう。</p>
<p><strong>非線形量子化は切ったほうが性能が高いことが分かっている。</strong>この機会に非線形量子化を廃止した。</p>
<p>非線形量子化を切った結果：</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  40954119 Feb 26 23:12 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31121021 Feb 26 23:13 SPARKLE.sol
-rw-r--r--@  1 *  staff     52936 Feb 26 23:09 kisaragi_chihaya.sol
</code></pre></div>

<p>不均一なビット割当てをやってみた。減る。係数ビットは増やすことで予測精度向上を狙うのではなく、ビット数を減らして係数ビットの領域を減らす意図でいくと良い感じ（体感16bitよりも大きいビットでは、予測精度が向上するメリットよりもビット数を増やすことによるデメリットの方が大きくなる）。以下の結果は、4次成分まで16bit, それ以降を8bit割り当ててている。また、double-&gt;int32_tの際ににroundを使用したら結果が改善したことを注記しておく。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  40907480 Feb 27 00:16 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31079276 Feb 27 00:17 SPARKLE.sol
-rw-r--r--@  1 *  staff     52832 Feb 27 00:15 kisaragi_chihaya.sol
</code></pre></div>

<p>残りの策は…ロングタームか。
後、格子型フィルタの計算負荷をアルゴリズム的に少しでも下げたい。1乗算型を実装したい。</p>
<ul>
<li><a href="http://www.ee.ic.ac.uk/hp/staff/dmb/courses/dspdf/01000_structures.pdf">10: Digital Filter Structures</a></li>
<li><a href="https://www.ece.ucsb.edu/Faculty/Rabiner/ece259/digital%20speech%20processing%20course/lectures_new/Lecture%2014_winter_2012_6tp.pdf">Digital Speech Processing - Lecture 14 Linear Predictive Coding (LPC)-Lattice Methods, Applications</a></li>
</ul>
<p>共分散法もやろうかと考えたけど、<a href="http://www.ee.imperial.ac.uk/naylor/notes/5_lpc.pdf">ここ</a> によると、共分散では不安定になることがあり、またPARCOR係数を求めることができない。</p>
<h3>2019.3.2</h3>
<p>秋葉原製作所。ロングタームの実装に手を出す。まずはピッチ予測を試す。残差信号の自己相関（もしくは相互相関）を計算してargmaxを取得し、それをピッチとする。</p>
<p>自己相関の計算にはパワースペクトルを使用する（ウィーナー・ヒンチン）。ピッチ検出のやり方はよーく知られている <a href="https://qiita.com/programanx1/items/096c68fa935addc1f121">この手法</a>。
かなーり適当にピッチ検出を作ったけど、それなりの結果が出ている。</p>
<h3>2019.3.3</h3>
<p>ピッチ解析結果からロングターム予測を試してみる。そして、元の誤差から減少するのかどうか簡単に検証してみた…結果は、なんと減ったよ。。。</p>
<ul>
<li>ロングタームを使用しない場合に比べて、ロングターム予測（1タップ）を使用した場合は誤差のRMS値がほぼすべてのフレームで減少。（増えてしまったフレームは1,2ほどしかない）</li>
<li>RMS値は音源依存で減少。SPARKLEはRMS値で5、ワン・ツー・スゥイーツは15、俺の声は2減るという結果。それすなわち、1サンプルあたり平均でそれだけ誤差が減っているということ…？当然かも知れないけど、凄いのでは？</li>
</ul>
<p>この検証結果から、ロングタームを採用する方針に動きたい。減るのは間違いなさそうだ。</p>
<p>MPEG-4 ALSのエンコーダを入手した。<a href="https://www.nue.tu-berlin.de/menue/research/research_topic/compression_and_transmission/mpeg_4_audio_lossless_coding_als/parameter/en/#c230252">ここ</a> からexeが手に入る。
圧縮率はFLACより良くて、Monkey's Audioよりは悪いくらい。（最大圧縮-7でもMonkey's Audioのinsameより悪いし実行時間が長すぎる。高圧縮にするときはギルバート・ムーア（算術）符号使っているのではなかったのか？）</p>
<h3>2019.3.5</h3>
<p>LPCモジュールにロングタームを追加する。処理自体は大体まとまっているから、APIをがっちり固めて、単体でテストできるようにする。</p>
<p>```c:API案
/<em> ロングタームの最大タップ数 </em>/</p>
<h1>define LPC_LONGTERM_MAX_NUM_TAP (5)</h1>
<p>/<em> ロングターム計算ハンドル </em>/
struct LPCLongTermCalculator;</p>
<p>/<em> ピッチ解析結果（内部） </em>/
struct LPCLongTermPitchCalculationResult {
    uint32_t    pitch_num_samples;                          /<em> ピッチに該当するサンプル数 </em>/
    double      ltm_coef[LPCLONGTERM_MAX_NUM_TAP];          /<em> ロングターム係数 </em>/
    double      head_acf[LPCLONGTERM_MAX_NUM_TAP];          /<em> 自己相関の先頭からの並び </em>/
    double      around_pitch_acf[LPCLONGTERM_MAX_NUM_TAP];  /<em> ピッチ周辺の自己相関。タップ数0ならば先頭にピッチの自己相関、3ならば-1,0,1、5ならば-2,-1,0,-1,2が並ぶ </em>/
};</p>
<p>/<em> ロングターム計算ハンドルの作成 </em>/
struct LPCLongTermCalculator* LPCLongTermCalculator_Create(uint32_t fft_size);</p>
<p>/<em> ロングターム計算ハンドルの破棄 </em>/
void LPCLongTermCalculator_Destroy(struct LPCLongTermCalculator* ltm_calculator);</p>
<p>/<em> ロングターム係数の計算（内部的にピッチ解析が走る） </em>/
LPCApiResult LPCLongTermCalculator_CalculateLongTermCoefficients(
    struct LPCLongTermCalculator<em> ltm_calculator,
    const int32_t</em> data, uint32_t num_samples,
    uint32_t<em> pitch_num_samples, double</em> ltm_coef, uint32_t num_taps);</p>
<p>/<em> 残差信号の計算 </em>/
LPCApiResult LPCLongTerm_PredictInt32(
    const int32_t<em> data, uint32_t num_samples,
    uint32_t pitch_num_samples, 
    const LPCFixedFloat1_31</em> ltm_coef, uint32_t num_taps, int32_t* residual);</p>
<p>/<em> 残差信号から音声合成 </em>/
LPCApiResult LPCLongTerm_SynthesizeInt32(
    const int32_t<em> residual, uint32_t num_samples,
    uint32_t pitch_num_samples,
    const LPCFixedFloat1_31</em> ltm_coef, uint32_t num_taps, int32_t* output);</p>
<div class="highlight"><pre><span></span><code>### 2019.3.6

上記API案に従って、既存の実験的実装を関数化。テストを作って、週末辺りに組み込みたい。

### 2019.3.8

秋葉原製作所で2hほど作業。

ロングタームは自己相関に基づいてやってるけど、よく見なくても、低次の自己相関値の方が大きくないか。最悪、直前の値で予測してもまだ減るんじゃないかと思っている。要自己相関確認。

### 2019.3.9

秋葉原製作所5hコース。意外に人がおる。

ロングタームのテストを作りきって元に戻ることを確認次第、組み込む。
2hほど作業して自己相関のピーク検知を微修正。はよ予測合成テストに入らんと…。
→17:40予測までOKぽい。組み込む。

フォーマットに変化もある点に注意。

急ぎ実装で軽く試したら、微妙。というか長い音声ではガッツリ悪化。
</code></pre></div>

<p>-rw-r--r--@  1 *  staff  41123054 Mar  9 19:22 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31461853 Mar  9 19:20 SPARKLE.sol
-rw-r--r--@  1 *  staff     52811 Mar  9 19:22 kisaragi_chihaya.sol</p>
<div class="highlight"><pre><span></span><code>ピッチ周期を見ていると短い結果（10未満）があまりにも多い。短いピッチは有用な結果ではないとして切り捨てるのが良いか？（俺の声はピッチ周期10以上が多かった。）

そこで、以下の修正を取り込んだ所、安定して減るようになった。

 - 短いピッチを切り捨て
  - 3以上の周期を採用するように変えたら良くなった。
  - 2以下だと悲惨。
 - 「最大の自己相関値から何割以上の自己相関値をピッチとするか」をやめ、単純に最大の自己相関を与えるラグを採用する

あと、自己相関値自体も判定材料にできそう。

ひとまず、上記の修正を取り込んだところの結果を見ると、
</code></pre></div>

<p>-rw-r--r--@  1 *  staff  40862203 Mar 10 01:16 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31056950 Mar 10 01:17 SPARKLE.sol
-rw-r--r--@  1 *  staff     52810 Mar 10 01:17 kisaragi_chihaya.sol</p>
<div class="highlight"><pre><span></span><code><span class="nt">もう少し試行したら</span><span class="err">、</span><span class="nt">実装をまとめ始めてもいいかな</span><span class="err">。</span><span class="nt">3月中にα版がまとめられると良い</span><span class="err">。</span><span class="w"></span>

<span class="err">###</span><span class="w"> </span><span class="nt">2019</span><span class="p">.</span><span class="nc">3</span><span class="p">.</span><span class="nc">10</span><span class="w"></span>

<span class="nt">再度秋葉原製作所</span><span class="err">。</span><span class="nt">今日で圧縮率改善の試みに一旦ケリを付けておく</span><span class="err">。</span><span class="nt">並びに</span><span class="err">、</span><span class="nt">オンメモリ書き出し対応時に必要な変更点についてまとめていきたい</span><span class="err">。</span><span class="w"></span>

<span class="nt">日記を見返してみたが</span><span class="err">、</span><span class="nt">当初の圧縮率改善の試みはほぼ消化できているようだ</span><span class="err">。</span><span class="nt">LSPを試すという点が残っているが</span><span class="err">、</span><span class="nt">以下の点で見送る予定</span><span class="err">。</span><span class="w"></span>

<span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">フィルタ計算がPARCORに増して複雑</span><span class="w"></span>
<span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">LSPで保存してLPCで計算する方法は以下の難点がある</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">フィルタ計算時に変換時のLPC係数に応じて量子化が必要</span><span class="err">。</span><span class="nt">複雑になる</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">そうして得られたLPC係数は</span><span class="err">、</span><span class="nt">結局指定次数で得られたLPC係数と変わらないのでは</span><span class="err">（</span><span class="o">=</span><span class="nt">FLACと同程度にしかならない</span><span class="err">）</span><span class="w"></span>

<span class="nt">だから</span><span class="err">、</span><span class="nt">PARCOR係数の格子状フィルタで戦うのが正攻法だと考えている</span><span class="err">。</span><span class="w"></span>

<span class="nt">---</span><span class="w"></span>

<span class="err">####</span><span class="w"> </span><span class="nt">オンメモリ書き出しへの変更点要点</span><span class="w"></span>

<span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">ソースは独立して切る</span><span class="err">。</span><span class="nt">新規に書き起こす</span><span class="err">。</span><span class="nt">無駄な部分を消す</span><span class="err">。</span><span class="w"></span>
<span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">バージョンは5</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">再度バイナリフォーマットを考察</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">ブロックサンプル数等</span><span class="err">、</span><span class="nt">1部フィールドのサイズ見直し</span><span class="w"></span>
<span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">エンコードパラメータの整理</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">プリセットを作成</span><span class="err">。</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">低圧縮率でデコード早い</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nt">高圧縮率でデコード遅い</span><span class="w"></span>
<span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">シグネチャを</span><span class="err">`</span><span class="nt">SL</span><span class="o">*</span><span class="w"> </span><span class="err">`</span><span class="nt">に変える</span><span class="err">。</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">拡張子は</span><span class="err">`</span><span class="p">.</span><span class="nc">sla</span><span class="err">`。</span><span class="nt">Sound</span><span class="w"> </span><span class="nt">Lossless</span><span class="w"> </span><span class="nt">Audio</span><span class="err">（</span><span class="nt">良好なロスレスオーディオ</span><span class="err">）</span><span class="nt">の略</span><span class="err">。</span><span class="nt">あるいはSHINING</span><span class="w"> </span><span class="nt">LINE</span><span class="o">*</span><span class="err">。</span><span class="w"></span>
<span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">メモリ領域読み書きに変える</span><span class="err">。</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">オンメモリ対応のため</span><span class="err">。</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">高速化にもなるはず</span><span class="err">。</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">ひとまずBitStreamのメモリ版に変えるが</span><span class="err">、</span><span class="nt">将来的には高速なビット読み書きモジュールを使用する</span><span class="err">。</span><span class="w"></span>
<span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">エンコード</span><span class="err">・</span><span class="nt">デコードの関数化</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">ストリームエンコード</span><span class="err">・</span><span class="nt">デコードハンドル作成関数</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">エンコードサイズの計算関数</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">ストリームエンコード</span><span class="err">・</span><span class="nt">デコード関数</span><span class="w"></span>
<span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">ゴロム符号パラメータの更新式を再度検討</span><span class="w"></span>
<span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">高速化</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">格子型フィルターを1乗算型に変える</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">負荷測定</span><span class="w"></span>
<span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">性能検証</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">比較プログラムの作成</span><span class="err">。</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">様々なwavに対してエンコード</span><span class="err">・</span><span class="nt">デコードし性能</span><span class="err">（</span><span class="nt">圧縮率と速度</span><span class="err">）</span><span class="nt">比較</span><span class="w"></span>
<span class="w">   </span><span class="nt">-</span><span class="w"> </span><span class="nt">TAKと戦っておきたい</span><span class="err">。</span><span class="w"></span>

<span class="nt">---</span><span class="w"></span>

<span class="nt">ゴロム符号パラメータの更新式をwavpackに寄せる修正を忘れていた</span><span class="err">…。</span><span class="w"></span>

<span class="err">→</span><span class="nt">取り急ぎ試したが悪化</span><span class="err">。</span><span class="nt">しかし</span><span class="err">、</span><span class="nt">更新式で定数を足す際に固定小数化せずに足したら性能が良化したので取り込む</span><span class="err">。</span><span class="w"></span>

<span class="err">```</span><span class="nt">c</span><span class="p">:</span><span class="nd">パラメータ更新式の変更</span><span class="w"></span>
<span class="c">/* 修正前 */</span><span class="w"></span>
<span class="p">#</span><span class="nn">define</span><span class="w"> </span><span class="nt">SOLAGOLOMB_PARAMETER_UP</span><span class="o">(</span><span class="nt">param_array</span><span class="o">,</span><span class="w"> </span><span class="nt">order</span><span class="o">)</span><span class="w">  </span><span class="p">{</span><span class="err">\</span><span class="w"></span>
<span class="w">  </span><span class="err">((param_array)</span><span class="cp">[</span><span class="p">(</span><span class="k">order</span><span class="p">)</span><span class="cp">]</span><span class="err">)</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">((((param_array)</span><span class="cp">[</span><span class="p">(</span><span class="k">order</span><span class="p">)</span><span class="cp">]</span><span class="err">)</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">SOLAGOLOMB_FIXED_FLOAT_TO_UINT32(127))</span><span class="w"> </span><span class="err">&gt;&gt;</span><span class="w"> </span><span class="err">7)</span><span class="p">;</span><span class="w">  </span><span class="err">\</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c">/* 修正後 */</span><span class="w"></span>
<span class="p">#</span><span class="nn">define</span><span class="w"> </span><span class="nt">SOLAGOLOMB_PARAMETER_UP</span><span class="o">(</span><span class="nt">param_array</span><span class="o">,</span><span class="w"> </span><span class="nt">order</span><span class="o">)</span><span class="w">  </span><span class="p">{</span><span class="err">\</span><span class="w"></span>
<span class="w">  </span><span class="err">((param_array)</span><span class="cp">[</span><span class="p">(</span><span class="k">order</span><span class="p">)</span><span class="cp">]</span><span class="err">)</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">((((param_array)</span><span class="cp">[</span><span class="p">(</span><span class="k">order</span><span class="p">)</span><span class="cp">]</span><span class="err">)</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">127)</span><span class="w"> </span><span class="err">&gt;&gt;</span><span class="w"> </span><span class="err">7)</span><span class="p">;</span><span class="w">  </span><span class="err">\</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c">/* 修正後2 */</span><span class="w"></span>
<span class="p">#</span><span class="nn">define</span><span class="w"> </span><span class="nt">SOLAGOLOMB_PARAMETER_UP</span><span class="o">(</span><span class="nt">param_array</span><span class="o">,</span><span class="w"> </span><span class="nt">order</span><span class="o">)</span><span class="w">  </span><span class="p">{</span><span class="err">\</span><span class="w"></span>
<span class="w">  </span><span class="err">((param_array)</span><span class="cp">[</span><span class="p">(</span><span class="k">order</span><span class="p">)</span><span class="cp">]</span><span class="err">)</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">((((param_array)</span><span class="cp">[</span><span class="p">(</span><span class="k">order</span><span class="p">)</span><span class="cp">]</span><span class="err">)</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">SOLAGOLOMB_UINT32_TO_FIXED_FLOAT(127))</span><span class="w"> </span><span class="err">&gt;&gt;</span><span class="w"> </span><span class="err">7)</span><span class="p">;</span><span class="w">  </span><span class="err">\</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>何故良くなったのかは謎...と思ったら間違えてんじゃん。バグや。<code>SOLAGOLOMB_FIXED_FLOAT_TO_UINT32</code>だと固定小数として計算しちゃう。やりたいのは定数を固定小数にすること。そこで、修正後2に変えたら性能が悪化...。</p>
<p>更新式については、バグを疑いつつ検討したい…。重要な割にあまり考え抜いていないところだし…。</p>
<p>ロングタームの最後の試行。以下を試したい</p>
<ul>
<li>タップ数を増やす</li>
<li>3次の場合は連立方程式を解く必要あり。手が伸びてない。</li>
<li>減らした誤差に対して更にピッチ解析を行う</li>
<li>→繰り返せば繰り返すほど減ってる…。</li>
</ul>
<p>N次方程式を解くソースがどこかにあったはず。</p>
<p>→あった。関数内でmallocしているから、手直しして使おう。でもなんだか結果が合っていないように見える…。</p>
<h3>2018.3.12</h3>
<p>いっそPARCOR予測を多段適用すべきでは。フィルタの直列連結とどちらが良いか検証の価値はあり。</p>
<h3>2018.3.16</h3>
<p>平日あまり動けず。PARCORの多段適用を試している。まず、誤差に対してもう一度同一係数で予測をかけたらサイズが爆増した。とりやめ。</p>
<p>実際に誤差に対してPARCOR係数を再度求めてみた...係数を符号化しない状態で、長い音源で1MBクラスの減少が見られた。（以下の結果は次数10のPARCOR係数を2段入れている。）</p>
<p>```sh:注意：係数は符号化していない。参考値
-rw-r--r--@  1 *  staff  39845536 Mar 16 15:02 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  30154328 Mar 16 15:03 SPARKLE.sol
-rw-r--r--@  1 *  staff     52720 Mar 16 15:03 kisaragi_chihaya.sol</p>
<div class="highlight"><pre><span></span><code>素直にPARCOR係数を20次数にした方が結果が良かった。結果は以下：
</code></pre></div>

<p>-rw-r--r--@  1 *  staff  39767592 Mar 16 15:07 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  30135816 Mar 16 15:08 SPARKLE.sol
-rw-r--r--@  1 *  staff     52588 Mar 16 15:08 kisaragi_chihaya.sol</p>
<div class="highlight"><pre><span></span><code><span class="n">また</span><span class="err">、</span><span class="n">PARCOR係数を観察してみると</span><span class="err">、</span><span class="n">低次係数が小さくなっていた</span><span class="err">（</span><span class="n">普通に解析すると低次係数は1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">の近傍にある</span><span class="err">）。</span><span class="n">有効なフォルマント情報が抜き出せなかったものと想像している</span><span class="err">。</span><span class="w"></span>

<span class="n">PARCORを使うことで</span><span class="err">、</span><span class="n">次数を増やしても健全にサイズを減らせるようだ</span><span class="err">（</span><span class="n">FLACは次数を32まで選択できるが</span><span class="err">、</span><span class="n">最高圧縮時</span><span class="err">`</span><span class="o">-</span><span class="mi">8</span><span class="err">`</span><span class="n">でも次数を12としている</span><span class="err">。</span><span class="n">LPC係数の鋭敏性と</span><span class="err">、</span><span class="n">次数上昇による量子化が大変だからだと推察</span><span class="err">。）。</span><span class="n">だから</span><span class="err">、</span><span class="n">このコーデックではPARCORを大きめにとる</span><span class="err">。</span><span class="n">フィルター計算は1乗算型でしっかり高速化するつもり</span><span class="err">。</span><span class="w"></span>

<span class="n">次数によってどれくらいサイズが変わるのか知りたくない</span><span class="p">...</span><span class="err">？</span><span class="n">知りたいでしょ</span><span class="err">。</span><span class="n">じゃあ出してみるわ</span><span class="err">。</span><span class="n">ひとまず30まで</span><span class="err">。</span><span class="n">ロングタームはOFFにしとく</span><span class="err">。</span><span class="w"></span>

<span class="err">!</span><span class="o">[</span><span class="n">20190929123751p</span><span class="o">]</span><span class="p">(.</span><span class="o">/</span><span class="n">images</span><span class="o">/</span><span class="n">la_first_attempts</span><span class="o">/</span><span class="mf">20190929123751.</span><span class="n">png</span><span class="p">)</span><span class="w"></span>

<span class="mi">20</span><span class="n">前半辺りまでは単調に減るけど</span><span class="err">、</span><span class="n">それ以降はあまり減らず</span><span class="err">、</span><span class="n">増えたりする</span><span class="err">。</span><span class="w"></span>

<span class="n">あとはゴロム符号の更新式を考察したらまとめましょう</span><span class="err">。</span><span class="w"></span>

<span class="err">###</span><span class="w"> </span><span class="mf">2019.3.17</span><span class="w"></span>

<span class="n">秋葉原製作所5時間コース</span><span class="err">。</span><span class="n">ゴロム符号のパラメータ適用式を見直し</span><span class="err">。</span><span class="n">少なくとも自分にとって説明できるものにしたいし</span><span class="err">、</span><span class="n">まだ改善できる気がする</span><span class="err">。</span><span class="w"></span>

<span class="n">以下のp55にゴロム符号のパラメータ設定について記述あり</span><span class="err">。</span><span class="w"></span>

<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">[</span><span class="n">JPEG2000の解説</span><span class="o">]</span><span class="p">(</span><span class="nl">http</span><span class="p">:</span><span class="o">//</span><span class="k">last</span><span class="p">.</span><span class="n">hit</span><span class="p">.</span><span class="n">bme</span><span class="p">.</span><span class="n">hu</span><span class="o">/</span><span class="n">download</span><span class="o">/</span><span class="n">firtha</span><span class="o">/</span><span class="n">video</span><span class="o">/</span><span class="n">JPEG2000</span><span class="o">/</span><span class="n">David</span><span class="o">%</span><span class="mi">20</span><span class="n">S</span><span class="p">.</span><span class="o">%</span><span class="mi">20</span><span class="n">Taubman</span><span class="p">,</span><span class="o">%</span><span class="mi">20</span><span class="o">%</span><span class="mi">20</span><span class="n">Michael</span><span class="o">%</span><span class="mi">20</span><span class="n">W</span><span class="p">.</span><span class="o">%</span><span class="mi">20</span><span class="n">Marcellin</span><span class="o">%</span><span class="mi">20</span><span class="o">%</span><span class="mi">20</span><span class="p">(</span><span class="n">auth</span><span class="p">.)</span><span class="o">%</span><span class="mi">20</span><span class="n">JPEG2000</span><span class="o">%</span><span class="mi">20</span><span class="nc">Image</span><span class="o">%</span><span class="mi">20</span><span class="n">Compression</span><span class="o">%</span><span class="mi">20</span><span class="n">Fundamentals</span><span class="p">,</span><span class="o">%</span><span class="mi">20</span><span class="n">Standards</span><span class="o">%</span><span class="mi">20</span><span class="ow">and</span><span class="o">%</span><span class="mi">20</span><span class="n">Practice</span><span class="o">%</span><span class="mi">20</span><span class="o">%</span><span class="mf">202002.</span><span class="n">pdf</span><span class="p">)</span><span class="w"></span>

<span class="n">非常に簡単で</span><span class="err">、`</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ceil</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="n">平均</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="err">`</span><span class="n">としてパラメータ</span><span class="err">`</span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">k</span><span class="err">`</span><span class="n">とするもの</span><span class="err">。</span><span class="n">常にライス符号を使うことになる</span><span class="err">。</span><span class="w"></span>

<span class="n">試してみる</span><span class="err">。</span><span class="n">まずは</span><span class="err">、</span><span class="n">パラメータを変えないでやる場合と上式を使用する場合で比較する</span><span class="err">。</span><span class="w"></span>

<span class="n">結果</span><span class="err">：</span><span class="w"></span>

<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">パラメータ固定よりも上記の更新式のほうが性能が良い</span><span class="err">（←</span><span class="n">これは前から知ってた</span><span class="err">）</span><span class="w"></span>
<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">wavpackの更新式よりは良くなかった</span><span class="err">（←</span><span class="n">これも前見た気がする</span><span class="err">）</span><span class="w"></span>

<span class="n">で</span><span class="err">、</span><span class="n">パラメータの変化を見たところ</span><span class="err">、</span><span class="n">wavpackは値の変動に素早く追従しているが</span><span class="err">、</span><span class="n">平均値は追従が遅いように見える</span><span class="err">。</span><span class="w"></span>

<span class="n">色々あがいているが</span><span class="err">、</span><span class="n">平均を使うやり方では</span><span class="err">、</span><span class="n">どうもwavpackに勝てない</span><span class="err">。</span><span class="n">wavpackのパラメータ変化が理想として</span><span class="err">、</span><span class="n">それに近付くにはどうしたらいいか</span><span class="err">、</span><span class="n">で考えている</span><span class="err">。</span><span class="w"></span>

<span class="n">信念としては</span><span class="err">、</span><span class="n">wavpackの更新式が最適とは思えない</span><span class="err">。</span><span class="n">統計的な裏付けがほぼ無いし</span><span class="err">。</span><span class="w"></span>

<span class="n">指数平滑移動平均を使ったら</span><span class="err">、</span><span class="n">wavpackの更新式による結果を超えた</span><span class="err">。（</span><span class="n">しかもライス符号で</span><span class="err">！）</span><span class="w"></span>

<span class="err">```</span><span class="nl">sh</span><span class="p">:</span><span class="n">wavpack更新式</span><span class="w"></span>
<span class="o">-</span><span class="n">rw</span><span class="o">-</span><span class="n">r</span><span class="o">--</span><span class="n">r</span><span class="o">--</span><span class="err">@</span><span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w">  </span><span class="n">staff</span><span class="w">  </span><span class="mi">41129982</span><span class="w"> </span><span class="n">Mar</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="mi">18</span><span class="err">:</span><span class="mi">06</span><span class="w"> </span><span class="n">one_two_sweets_offvocal</span><span class="p">.</span><span class="n">sol</span><span class="w"></span>
<span class="o">-</span><span class="n">rw</span><span class="o">-</span><span class="n">r</span><span class="o">--</span><span class="n">r</span><span class="o">--</span><span class="err">@</span><span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w">  </span><span class="n">staff</span><span class="w">  </span><span class="mi">31271982</span><span class="w"> </span><span class="n">Mar</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="mi">18</span><span class="err">:</span><span class="mi">06</span><span class="w"> </span><span class="n">SPARKLE</span><span class="p">.</span><span class="n">sol</span><span class="w"></span>
<span class="o">-</span><span class="n">rw</span><span class="o">-</span><span class="n">r</span><span class="c1">--r--@  1 *  staff     52970 Mar 17 18:06 kisaragi_chihaya.sol</span>
</code></pre></div>

<p>```sh:指数平滑移動平均更新式
-rw-r--r--@  1 *  staff  41028253 Mar 17 18:08 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31110736 Mar 17 18:08 SPARKLE.sol
-rw-r--r--@  1 *  staff     52771 Mar 17 18:08 kisaragi_chihaya.sol</p>
<div class="highlight"><pre><span></span><code>このときの更新式は以下：

<span class="n">``</span>`<span class="n">c</span><span class="o">:</span>
<span class="o">/*</span> <span class="nf">meanはSOLAGOLOMB_UINT32_TO_FIXED_FLOAT</span><span class="p">(</span><span class="n">init_golomb_m</span><span class="p">)</span>で初期化 <span class="o">*/</span>
<span class="n">uint32_t</span> <span class="n">golomb_m2</span> <span class="o">=</span> <span class="nf">MAX</span><span class="p">(</span><span class="nf">SOLAGOLOMB_FIXED_FLOAT_TO_UINT32</span><span class="p">(</span><span class="n">mean</span><span class="p">),</span> <span class="m">1</span><span class="p">);</span>
<span class="nf">Golomb_PutCode</span><span class="p">(</span><span class="n">strm</span><span class="p">,</span> <span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="nf">CodingUtility_Log2ceil</span><span class="p">(</span><span class="n">golomb_m2</span> <span class="o">&gt;&gt;</span> <span class="m">1</span><span class="p">),</span> <span class="n">abs</span><span class="p">);</span> <span class="o">/*</span> 固定小数で<span class="o">/</span><span class="m">2</span>しているから、<span class="m">0.5</span>足したほうがいいかも <span class="o">*/</span>
<span class="n">mean</span> <span class="o">=</span> <span class="p">(</span><span class="m">15</span> <span class="o">*</span> <span class="n">mean</span> <span class="o">+</span> <span class="nf">SOLAGOLOMB_UINT32_TO_FIXED_FLOAT</span><span class="p">(</span><span class="n">abs</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="m">4</span><span class="p">;</span> <span class="o">/*</span> <span class="n">mean</span> <span class="o">&lt;-</span> <span class="m">15</span><span class="o">/</span><span class="m">16</span> <span class="o">*</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">abs</span> <span class="o">*/</span>
</code></pre></div>

<p><code>15/16 = 0.9375</code>がミソ。
他に良いパラメータをあさってみると、<code>119/128 = 0.9296875</code>、<code>238/256 = 0.9296875</code>で結果が良い。平滑化係数を<code>0.93</code>とするとよいのか？</p>
<p><a href="https://ci.nii.ac.jp/els/contentscinii_20190317165228.pdf?id=ART0008474240">平滑化係数はデータから推定できるようだ。</a>自己相関を使う（！）。簡単に試してみたけど、得られた平滑化係数が[0,1]からはみ出ることが多かった。（要請する制約に入らないこと多数）。</p>
<p>```c:平滑化係数計算
  {
    uint32_t  j;
    double    auto_corr[2];
    double    rho_1, alpha, b;</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* 1次までの自己相関計算 */</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">  </span><span class="n">auto_corr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="n">f</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_data</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="n">auto_corr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="k">double</span><span class="p">)</span><span class="k">data</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">j - i</span><span class="o">]</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="err">}</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>

<span class="n">rho_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">auto_corr</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">auto_corr</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">;</span><span class="w"></span>
<span class="n">rho_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">rho_1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0.5</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="vm">?</span><span class="w"> </span><span class="mf">0.5</span><span class="n">f</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="n">rho_1</span><span class="p">;</span><span class="w"></span>
<span class="n">rho_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">rho_1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="vm">?</span><span class="w"> </span><span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="n">rho_1</span><span class="p">;</span><span class="w"></span>
<span class="n">b</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nf">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">4.0</span><span class="n">f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rho_1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rho_1</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">2.0</span><span class="n">f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rho_1</span><span class="p">);</span><span class="w"></span>
<span class="n">b</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">0.0</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="vm">?</span><span class="w"> </span><span class="mf">0.0</span><span class="n">f</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="n">b</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="vm">?</span><span class="w"> </span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="w"> </span><span class="err">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">alpha</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mf">0.0</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="ss">&quot;%e \n&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="p">);</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>
</code></pre></div>

<p>}</p>
<div class="highlight"><pre><span></span><code><span class="mf">1</span><span class="n">パラメータに対して性能向上が見られたので</span><span class="err">、</span><span class="n">再帰ゴロム符号に適用していきたいが</span><span class="err">、</span><span class="n">やっつけでやったら事故った</span><span class="err">（</span><span class="n">ゼロ除算がどこかで起きている</span><span class="err">）。</span><span class="n">ちゃんとした形に整備して</span><span class="err">、</span><span class="n">性能が上がるか見ていく</span><span class="err">。</span><span class="w"></span>

<span class="n">家に帰って作った</span><span class="err">。</span><span class="n">結果は次</span><span class="err">：</span><span class="w"></span>
</code></pre></div>

<p>-rw-r--r--@  1 *  staff  40937961 Mar 17 23:56 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31060591 Mar 17 23:58 SPARKLE.sol
-rw-r--r--@  1 *  staff     52656 Mar 17 23:58 kisaragi_chihaya.sol</p>
<div class="highlight"><pre><span></span><code>観察した結果は次：


 - パラメータ数は2がベストだった。パラメータ更新は`119/128`を使った。
 - ライス符号が前提になるからか全体的に性能は悪化。
 - しかし振幅が小さい場合は減る方に動いた。大きいほど悪化。
   - 俺の声は減った
   - SPARKLEは少し悪化
   - ワン・ツー・スゥイーツは結構悪化

これは、最終的にライス（負荷）を使うのか、それともゴロム（圧縮率）を使うのかに分かれると思う。圧縮率を改善する取り組みに反するけど、ライス符号形式を推したい。なぜなら説明できるから。

デコーダ作って戻ることを確認したら、実装整理、すなわちバージョン5に入る。

### 2019.3.18

wavpackが符号bit+絶対値で分けていたのが依然として気になっている。-1が0に行くのは大きい。最後に試しておきたい。

→あんまり効果なし。1bit確定で消費するのがあまり望ましくないと考える。

デコーダも苦戦。パラメータの更新が難しくなっている。春分の日一杯でできるかどうかというところか…？

### 2019.3.19

デコーダデバッグ中。OK。戻ることを確認。テスト追加。

DreamGoesOnの圧縮率がどうもalsに比べて低くて、符号の頻度を見たら負方向に偏っていることが分かった。

どうも音源依存で偏りが発生しているようだ…。voice48aも正に偏っている。

SPARKLE, ワン・ツー・スゥイーツは偏っていない。一回ロッシー圧縮するとだめ？
→ワン・ツー・スゥイーツを一回mp3(96Kbps)にしてwavに戻して試してみたが、分布の偏り見られず。

```sh
ffmpeg -i one_two_sweets_offvocal.wav -ab 96k -f mp3 one_two_sweets_offvocal.mp3
ffmpeg -i one_two_sweets_offvocal.mp3 -f wav one_two_sweets_offvocal_frommp3.wav
</code></pre></div>

<p>エンコードパラメータが小さくなるフレームがあることに気づいた。それで、元波形の先頭（イントロ前）を見た所、微弱な信号が入っていることがわかった。（ワン・ツー・スゥイーツではしっかり0になっているが、DreamGoesOnは無音にならずわずかな信号が流れている。）</p>
<p><img alt="20190929123806p" src="./images/la_first_attempts/20190929123806.png" /></p>
<p>上がDream Goes On、下がワン・ツー・スゥイーツ。時間が示すように先頭部分。16bit PCMにして3程度の振動が入っている。</p>
<p>こういうフレームはランレングスでやってしまうべきかと思う。ランレングスの判定基準を甘くしよう。</p>
<h3>2019.3.20</h3>
<p>通勤中に思いついたこと:</p>
<ul>
<li>自己相関はピークをとらずに、単に最大値をとればよいのでは</li>
<li>実質今その実装。簡略化する。</li>
<li>各ブロックの立ち上がりでパラメータが大変動する。先頭は単純符号化でよいのでは</li>
<li>もしくは、先頭部分だけの平均を計算しておく。</li>
<li>30以上の高次係数は4bitとかで良さそう</li>
<li>→悪化傾向。16,20以降の係数を4bitにしたが悪化。</li>
<li>ライス符号化のパラメータはlog2(e)使うやつじゃなくて良かったか</li>
<li>m = log2((loge2)E(|e|)) という式</li>
<li>Wavpackが言及したDataCompressのp67周辺の記述。</li>
</ul>
<h3>2019.3.21</h3>
<p>3.20の夜は疲れて何もできず。寝不足か。</p>
<p>アニソンAnother stageの中止発表を受ける。急いでキャンセルしたい。</p>
<p>その他は今日はランレングスの調整から始める。</p>
<ul>
<li>閾値を上げるのは効果あり。</li>
<li>残差分布はほぼ対称になった。</li>
<li>パラメータをいっそ平均に変えるのも効果あり。</li>
<li>ランレングス中で適応的ライス符号を使うのは悪化。</li>
<li>ランレングスのときのゴロム符号パラメータは平均をそのまま使う。</li>
</ul>
<p>ゴロム符号の初期パラメータは先頭だけから求めることをする。
→16bitを越えてしまった。やっつけで16bit上限を設けたら性能が悪化。どうゆうことだ…。</p>
<p>モジュール簡略化のため、ゴロム符号パラメータはヘッダに含めないようにする。
→やった。</p>
<p>最後、DreamGoesOnがデコードアサーションしている（ゴロム符号パラメータが0になった）ので、修正してまとめていきたい。他のファイルはもとに戻る。ピッチ検出に失敗するのがトリガー？
→イチローの引退会見を横目にデバッグ。どうも4537回目のブロックデコードで20bitずれている。（20bitの空白ができていて、20bit空読みすると完全一致になる。）ランレングスを読みそこねている？</p>
<p>無音部分（ランレングス）の圧縮率が悪いかも。他コーデックを参考にすべきか...</p>
<ul>
<li>最大ランレングス長さ（を表現可能なビット長）を先読みで解析しておく…？</li>
<li>PARCOR係数を出す前に、エンコード対象のデータ列が本当の無音（0列）か否かを判定する。</li>
</ul>
<h3>2019.3.22</h3>
<p>バグ直し。
デバッグ中に気づいたけどランレングスのときにあまりランで出力できていない（ほとんど非ラン）…。閾値はもっと厳しくしていいのでは…。あと、まじの無音（0だけ）は特別な符号で表すだけでいいと思った。</p>
<p>バグ退治。エンコード時、ランレングスで最大長出力時に誤りがあった。</p>
<p>```c:誤
      /<em> 非ラン分出力 </em>/
      while (notrunlength &gt;= MAXLENGTH) {
        /<em> snip... </em>/</p>
<div class="highlight"><pre><span></span><code>`<span class="nv">MAXLENGTH</span> <span class="o">=</span> <span class="ss">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nv">length_bits</span><span class="ss">)</span> <span class="o">-</span> <span class="mi">1</span>`だから、ピッタリ`<span class="nv">notrunlength</span> <span class="o">==</span> <span class="nv">MAXLENGTH</span>`の時に、本当は何もしなくても出力できるのに、分割出力してしまう。正しくはこちら：

```<span class="nv">c</span>:正
      <span class="cm">/* 非ラン分出力 */</span>
      <span class="k">while</span> <span class="ss">(</span><span class="nv">notrunlength</span> <span class="o">&gt;</span> <span class="nv">MAXLENGTH</span><span class="ss">)</span> {
        <span class="cm">/* snip... */</span>
</code></pre></div>

<p>日記を見返していたら、最適なライス符号パラメータの式あるやん…平均に0.382(49/128)足すだけでいいじゃん。。。→簡単に適応的なやつに試したけど悪化。しかもゴロム化するのでやめとく。</p>
<h3>2019.3.23</h3>
<p>残りTODO:</p>
<ul>
<li>引き続きランレングスの吟味。</li>
<li>できれば完全無音のブロックをもっと少ないビットで符号化したい。<ul>
<li>やった。無音フレームか否かを識別するフラグを追加。やらしいのは、係数による結果だと誤りが出る所。入力が全て0かを判定して行う必要がある。</li>
<li>ワン・ツー・スゥイーツやSPARKLEなどの純正マスタリング音源に効果あり。（リアル無音なんか自然ではほぼ作れないから、当然ではある...。）</li>
</ul>
</li>
<li>ランレングスいらねえんじゃね…。<ul>
<li>ラン長が短すぎる。手元のDreamGoesOnやVoice48aでは最長12とか。</li>
<li>無音に近い場合は、パラメータを適用変化させないほうが良い？以下の表参照。→分散が小さく分布変動も小さいから、固定したほうが有利かも。</li>
<li>と思って固定パラメータ出力したら増えた…？なぜ？ほぼラン出力できてないのに増えるのはおかしいと思う。もうちょっと精査する必要あり。</li>
<li>→ returnし忘れていた。ただのしょうもないミス。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">音源</th>
<th align="center">ランレングスあり</th>
<th align="center">ランレングス無し</th>
<th align="center">ランレングス無し（固定ゴロム符号）</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">voice48a</td>
<td align="center">789104</td>
<td align="center">788643</td>
<td align="center">788617</td>
</tr>
<tr>
<td align="center">DreamGoesOn</td>
<td align="center">23927826</td>
<td align="center">23962467</td>
<td align="center">23922982</td>
</tr>
</tbody>
</table>
<ul>
<li>ロングタームをピークではなく単純最大に置き換える</li>
</ul>
<p>パラメータ固定小数を整数に戻すとき（右シフト時）、0.5を足して丸めるようにしたら性能改善。固定小数は丸めが大事だ…</p>
<h3>2019.3.25</h3>
<p>あーLMS（適応的アルゴリズム）を忘れていた…試したい…。
image_comp/LMS/lms_test.rb でテスト可能。</p>
<p>試してみる。すると、かなり減るように見えるぞ、おい。誤差の分散（と標準偏差）をプロットしてみたけど、増えることはなく、減っている。次数を増やすと減少が鈍るけれども、増えないだけでも有益に思える。次数を増やしても、振幅が小さめのボイスデータはかなりへる傾向が見られたので結構有益かも。</p>
<p>今は<code>double</code>で演算していたけど、固定小数に置き換えたときにどうなるか。それを含めてやはり試してみたい。</p>
<h3>2019.3.26</h3>
<p>LMSのモジュール化を試みる。APIは極めて簡単に作れる。</p>
<p>```c:API案
/<em> NLMS計算ハンドル </em>/
struct NLMSCalculator;</p>
<p>/<em> NLMS計算ハンドル </em>/
struct NLMSCalculator {
    LPCFixedFloat1_31   alpha;          /<em> ステップサイズ </em>/
    LPCFixedFloat1_31<em>  coef;           /</em> 係数 <em>/
    uint32_t            max_num_coef;   /</em> 最大の係数個数 */
};</p>
<p>/<em> 計算ハンドルの作成 </em>/
struct NLMSCalculator* NLMSCalculator_Create(LPCFixedFloat1_31 alpha, uint32_t max_num_coef);</p>
<p>/<em> 計算ハンドルの破棄 </em>/
void NLMSCalculator_Destroy(struct NLMSCalculator* nlms);</p>
<p>/<em> 予測 </em>/
LPCApiResult NLMSCalculator_PredictInt32(
    struct NLMSCalculator<em> nlms, uint32_t num_coef,
    const int32_t</em> data, uint32_t num_samples, int32_t* residual);</p>
<p>/<em> 合成 </em>/
LPCApiResult NLMSCalculator_SynthesizeInt32(
    struct NLMSCalculator<em> nlms, uint32_t num_coef,
    const int32_t</em> residual, uint32_t num_samples, int32_t* output);</p>
<div class="highlight"><pre><span></span><code><span class="n n-Quoted">`alpha`</span><span class="n">は</span><span class="n n-Quoted">`0.01f`</span><span class="p">(</span><span class="n">32bit固定小数で</span><span class="o">=</span><span class="n n-Quoted">`0x0147ae14`</span><span class="p">)</span><span class="n">あたりに固定したい。</span><span class="w"></span>

<span class="c1">### 2019.3.27</span><span class="w"></span>

<span class="n">上記のとおりに実装。LPCが膨れるので、そろそろ整理したい所。</span><span class="n n-Quoted">`predictor.c`</span><span class="n">にリネームしようかな。</span><span class="w"></span>

<span class="n">16bitの振動する信号に対しては予測が動いている。定数入力に対して係数が更新されない…（分散が0だから？）。24bitはダメダメ。これは溢れが起きているかも。どうも19bitまでは良くて、20bitからだめみたいです。</span><span class="w"></span>

<span class="n">TODO</span><span class="o">:</span><span class="n">LPC</span><span class="o">/</span><span class="n">PARCORの24bitテスト。</span><span class="w"></span>

<span class="c1">### 2019.3.28</span><span class="w"></span>

<span class="n">周りが焦らなくて焦る。木村監督は叩かれてる。</span><span class="w"></span>

<span class="n">24bitでだめなのは、やはり桁あふれだろうということで真面目に乗算の度にシフトしていた。すると、誤差がいつまでも残るようになった。それはいやなので、alpha抜き（alpha</span><span class="o">=</span><span class="n">1と同じ）で計算してみると収束が非常に良くなった。これで行こう。</span><span class="w"></span>

<span class="n">→更新式がまだ溢れている。結果は正しくなっているけど。。。</span><span class="w"></span>

<span class="c1">### 2019.3.29</span><span class="w"></span>

<span class="n">NLMSの更新式間違ってるわ。分散じゃなくて、単純に入力の2乗（パワー）で良かった。したら白色雑音意外は収束するようになった。よし、使える。</span><span class="w"></span>

<span class="n">PARCORの24bit版テストを追加。テストは通っている。</span><span class="w"></span>

<span class="c1">### 2019.3.30</span><span class="w"></span>

<span class="n">秋葉原製作所2時間。GWは小松に行こう。NLMSの更新式で整数除算を使うので、速度が気になっている。以下のサイトが有効かも。</span><span class="w"></span>

<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">[</span><span class="n">整数除算の高速化</span><span class="err">]</span><span class="p">(</span><span class="n">http</span><span class="o">://</span><span class="n">www</span><span class="p">.</span><span class="n">emit</span><span class="p">.</span><span class="n">jp</span><span class="o">/</span><span class="n">prog</span><span class="o">/</span><span class="n">prog_div</span><span class="p">.</span><span class="n">html</span><span class="p">)</span><span class="w"></span>

<span class="p">...</span><span class="n">適用は難しいことがわかった。32bit精度演算だと、最後の計算で右62bitシフトが必要になる。これはつまり128bit精度で途中結果を持たないと行けない…</span><span class="w"></span>

<span class="n">単純なビットシフトに置き換えてしまって良いように思える。ほか、うろついてたらlog2の切り捨ての計算方法があった。</span><span class="w"></span>

<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">[</span><span class="nf">floor</span><span class="p">(</span><span class="nf">log2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="n">の計算</span><span class="err">]</span><span class="p">(</span><span class="n">http</span><span class="o">://</span><span class="n">d</span><span class="p">.</span><span class="n">hatena</span><span class="p">.</span><span class="n">ne</span><span class="p">.</span><span class="n">jp</span><span class="o">/</span><span class="n">homeskill</span><span class="o">/</span><span class="mi">20110806</span><span class="o">/</span><span class="mi">1312626490</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">[</span><span class="n">Find</span><span class="w"> </span><span class="kt">integer</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="kt">integer</span><span class="n">（黒魔術）</span><span class="err">]</span><span class="p">(</span><span class="n">https</span><span class="o">://</span><span class="n">programmizm</span><span class="p">.</span><span class="n">sourceforge</span><span class="p">.</span><span class="k">io</span><span class="o">/</span><span class="n">blog</span><span class="o">/</span><span class="mi">2011</span><span class="o">/</span><span class="n">find</span><span class="o">-</span><span class="kt">integer</span><span class="o">-</span><span class="n">log</span><span class="o">-</span><span class="n">base</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="k">of</span><span class="o">-</span><span class="n">an</span><span class="o">-</span><span class="kt">integer</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">[</span><span class="kt">Integer</span><span class="w"> </span><span class="n">Log2</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="kt">binary</span><span class="w"> </span><span class="n">search</span><span class="err">]</span><span class="p">(</span><span class="n">https</span><span class="o">://</span><span class="n">codereview</span><span class="p">.</span><span class="n">stackexchange</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">questions</span><span class="o">/</span><span class="mi">151312</span><span class="o">/</span><span class="kt">integer</span><span class="o">-</span><span class="n">log2</span><span class="o">-</span><span class="n">implemented</span><span class="o">-</span><span class="k">using</span><span class="o">-</span><span class="kt">binary</span><span class="o">-</span><span class="n">search</span><span class="p">)</span><span class="w"></span>

<span class="n">シビアに高速化できそう。もしかしたらハッカーのたのしみに載ってそう。</span><span class="w"></span>

<span class="n">高速化はおいておいて、NLMSを取り込んでいく。→取り込んだ。次数はとりあえず10。全体的に減少が見られる：</span><span class="w"></span>
</code></pre></div>

<p>-rw-r--r--@  1 *  staff  40586832 Mar 30 14:32 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  30960017 Mar 30 14:30 SPARKLE.sol
-rw-r--r--@  1 *  staff     52560 Mar 30 14:33 kisaragi_chihaya.sol</p>
<div class="highlight"><pre><span></span><code>PARCOR係数の次数を増やすとNLMSによる恩恵が少なくなるが、それでも減る。以下の結果はPARCOR係数を20にしたときの結果：
</code></pre></div>

<p>-rw-r--r--@  1 *  staff  39715652 Mar 30 14:37 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  30101640 Mar 30 14:36 SPARKLE.sol
-rw-r--r--@  1 *  staff     52332 Mar 30 14:35 kisaragi_chihaya.sol</p>
<div class="highlight"><pre><span></span><code><span class="s s-Atom">以上で圧縮技術の駒は揃っただろう。</span><span class="nv">NLMSについて気になるのは</span><span class="s s-Atom">、次数と残差計算の順番。</span><span class="nv">PARCORによる残差は最初に出すとして</span><span class="s s-Atom">、</span><span class="nv">NLMSとロングタームはどちらを先に入れるのが良いか</span><span class="s s-Atom">。これらを検証したら切り上げる。</span>

<span class="s s-Atom">残差計算の順番は、なんと、順番に依存しない（変わらない）ことがわかった</span><span class="p">...</span><span class="s s-Atom">。サイズは厳密に一致。これはNLMSの短期予測の結果はロングタームの結果に何ら影響を及ぼさないことを意味しているのだろうか。。。</span>

<span class="s s-Atom">次数について見ていく。</span><span class="nv">PARCOR係数は10</span><span class="s s-Atom">、ロングタームありでの比較：</span>

<span class="p">|</span> <span class="nv">NLMS次数</span> <span class="p">|</span> <span class="s s-Atom">ワン・ツー・スウィーツ</span> <span class="p">|</span> <span class="nv">SPARKLE</span> <span class="p">|</span> <span class="s s-Atom">俺の声</span> <span class="p">|</span>
<span class="p">|:-</span><span class="s s-Atom">:</span><span class="p">|:-</span><span class="s s-Atom">:</span><span class="p">|:-</span><span class="s s-Atom">:</span><span class="p">|:-</span><span class="s s-Atom">:</span><span class="p">|</span>
<span class="p">|</span> <span class="s s-Atom">未適用</span> <span class="p">|</span> <span class="mi">40978249</span> <span class="p">|</span> <span class="mi">31055202</span> <span class="p">|</span> <span class="mi">52577</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">1</span> <span class="p">|</span> <span class="mi">41098033</span> <span class="p">|</span> <span class="mi">31274844</span> <span class="p">|</span> <span class="mi">52572</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">5</span> <span class="p">|</span> <span class="mi">40800621</span> <span class="p">|</span> <span class="mi">31090112</span> <span class="p">|</span> <span class="mi">52563</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">10</span> <span class="p">|</span> <span class="mi">40586832</span> <span class="p">|</span> <span class="mi">30960017</span> <span class="p">|</span> <span class="mi">52560</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">15</span> <span class="p">|</span> <span class="mi">40499597</span> <span class="p">|</span> <span class="mi">30931506</span> <span class="p">|</span> <span class="mi">52559</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">20</span> <span class="p">|</span> <span class="mi">40483976</span> <span class="p">|</span> <span class="mi">30921234</span> <span class="p">|</span> <span class="mi">52558</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">25</span> <span class="p">|</span> <span class="mi">40465348</span> <span class="p">|</span> <span class="mi">30915117</span> <span class="p">|</span> <span class="mi">52557</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">30</span> <span class="p">|</span> <span class="mi">40450833</span> <span class="p">|</span> <span class="mi">30910096</span> <span class="p">|</span> <span class="mi">52553</span> <span class="p">|</span> 
<span class="p">|</span> <span class="mi">50</span> <span class="p">|</span> <span class="mi">40397208</span> <span class="p">|</span> <span class="mi">30896233</span> <span class="p">|</span> <span class="mi">52535</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">100</span> <span class="p">|</span> <span class="mi">40326600</span> <span class="p">|</span> <span class="mi">30863911</span> <span class="p">|</span> <span class="mi">52532</span> <span class="p">|</span>

<span class="s s-Atom">計算負荷高い。サンプル毎に係数更新しているのが結構効いてるかも…（係数更新で除算使ってるし）。でも次数を増やしても悪化しないのは都合が良い。プリセットの設定がしやすい。</span>

<span class="o">-</span> <span class="p">[</span><span class="s s-Atom">固定小数点数の算術関数ライブラリ</span><span class="p">](</span><span class="nn">http</span><span class="p">:</span><span class="o">//</span><span class="s s-Atom">www</span><span class="p">.</span><span class="s s-Atom">geocities</span><span class="p">.</span><span class="s s-Atom">jp</span><span class="o">/</span><span class="s s-Atom">midarekazu</span><span class="o">/</span><span class="s s-Atom">math</span><span class="o">-</span><span class="s s-Atom">library</span><span class="p">.</span><span class="s s-Atom">html</span><span class="p">)</span>

<span class="s s-Atom">###</span> <span class="mf">2019.3.31</span>

<span class="s s-Atom">起床事故。</span><span class="mi">12</span><span class="s s-Atom">:</span><span class="mi">00</span><span class="s s-Atom">に起きる。マジカルミライの予約してたら14:</span><span class="mi">00</span><span class="s s-Atom">。その間に除算を減らした。</span><span class="nv">NLMSは処理を共通化できる</span><span class="s s-Atom">。やっておきたい。</span>

<span class="s s-Atom">あと、今日はversion</span><span class="mf">.5</span><span class="s s-Atom">に向けたモジュールソース分割を考えて、手をつけていきたい。秋葉原製作所16:</span><span class="mi">00</span><span class="o">-</span><span class="mi">21</span><span class="s s-Atom">:</span><span class="mi">00</span><span class="s s-Atom">の予定。</span>

<span class="mi">17</span><span class="s s-Atom">:</span><span class="mi">15</span> <span class="nv">NLMSの処理共通化完了</span><span class="s s-Atom">。</span>

<span class="s s-Atom">---</span>

<span class="s s-Atom">####</span> <span class="s s-Atom">オンメモリ書き出しへの変更点要点（改訂版）</span>

 <span class="o">-</span> <span class="s s-Atom">ソースは独立して切る。新規に書き起こす。無駄な部分を消す。</span>
 <span class="o">-</span> <span class="s s-Atom">シグネチャを</span><span class="err">`</span><span class="nv">SL</span><span class="o">*</span> <span class="err">`</span><span class="s s-Atom">に変える。</span>
   <span class="o">-</span> <span class="s s-Atom">拡張子は</span><span class="err">`</span><span class="p">.</span><span class="s s-Atom">sla</span><span class="err">`</span><span class="s s-Atom">。</span><span class="nv">Sound</span> <span class="nv">Lossless</span> <span class="nv">Audio</span><span class="s s-Atom">（良好なロスレスオーディオ）の略。あるいはSHINING</span> <span class="nv">LINE</span><span class="s s-Atom">*。</span>
 <span class="o">-</span> <span class="s s-Atom">バージョンは1</span>
   <span class="o">-</span> <span class="s s-Atom">再度バイナリフォーマットを考察</span>
   <span class="o">-</span> <span class="s s-Atom">ブロックサンプル数等、</span><span class="mi">1</span><span class="s s-Atom">部フィールドのサイズ見直し</span>
 <span class="o">-</span> <span class="s s-Atom">エンコードパラメータの整理</span>
   <span class="o">-</span> <span class="s s-Atom">プリセットを作成。</span>
   <span class="o">-</span> <span class="s s-Atom">低圧縮率でデコード早い</span> <span class="s s-Atom">?</span> <span class="s s-Atom">高圧縮率でデコード遅い</span>
 <span class="o">-</span> <span class="s s-Atom">メモリ領域読み書きに変える。</span>
   <span class="o">-</span> <span class="s s-Atom">オンメモリ対応のため。</span>
   <span class="o">-</span> <span class="s s-Atom">ひとまずBitStreamのメモリ版に変えるが、将来的には高速なビット読み書きモジュールを使用する。</span>
 <span class="o">-</span> <span class="s s-Atom">エンコード・デコードの関数化</span>
   <span class="o">-</span> <span class="s s-Atom">ストリームエンコード・デコードハンドル作成関数</span>
   <span class="o">-</span> <span class="s s-Atom">エンコードサイズの計算関数</span>
   <span class="o">-</span> <span class="s s-Atom">ストリームエンコード・デコード関数</span>
 <span class="o">-</span> <span class="s s-Atom">高速化</span>
   <span class="o">-</span> <span class="s s-Atom">格子型フィルターを1乗算型に変える</span>
   <span class="o">-</span> <span class="s s-Atom">負荷測定</span>
 <span class="o">-</span> <span class="s s-Atom">性能検証</span>
   <span class="o">-</span> <span class="s s-Atom">比較プログラムの作成。</span>
   <span class="o">-</span> <span class="s s-Atom">様々なwavに対してエンコード・デコードし性能（圧縮率と速度）比較</span>
   <span class="o">-</span> <span class="nv">TAKと戦っておきたい</span><span class="s s-Atom">。</span>

<span class="s s-Atom">---</span>

<span class="mi">18</span><span class="s s-Atom">:</span><span class="mi">46</span> <span class="s s-Atom">気になっていたバイトアラインを退治。サイズは1kほど増えたが、汎用性のためには全く問題なし。よし、</span><span class="mi">19</span><span class="s s-Atom">:</span><span class="mi">00</span><span class="s s-Atom">から思い切ってソース切るか。</span>

<span class="mi">20</span><span class="s s-Atom">:</span><span class="mi">48</span> <span class="s s-Atom">エンコーダ・デコーダ以外はソースを切った。エンコーダデコーダはAPIを検討する必要がある。</span>

<span class="s s-Atom">これは平日に投げよう。</span><span class="mi">21</span><span class="s s-Atom">:</span><span class="mi">00</span><span class="s s-Atom">になった。</span>

<span class="s s-Atom">###</span> <span class="mf">2019.4.2</span>

<span class="s s-Atom">有給とって作業。なんとしても、今日中に第一版を上げたい。仕様を紙に書いたので、まずはここに複写する。</span>

<span class="s s-Atom">####</span> <span class="nv">SLAヘッダ</span>

<span class="p">|</span> <span class="nf">サイズ</span><span class="p">(</span><span class="s s-Atom">bits</span><span class="p">)</span> <span class="p">|</span> <span class="s s-Atom">内容</span> <span class="p">|</span> <span class="s s-Atom">補足</span> <span class="p">|</span>
<span class="p">|</span><span class="s s-Atom">--:</span><span class="p">|:-</span><span class="s s-Atom">:</span><span class="p">|:-</span><span class="s s-Atom">:</span><span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="s s-Atom">シグネチャ</span> <span class="err">`</span><span class="s2">&quot;SL* &quot;</span><span class="err">`</span> <span class="p">|</span> <span class="nv">Sound</span> <span class="nv">Lossless</span> <span class="nv">Audio</span><span class="p">,</span> <span class="s s-Atom">あるいはSHINING</span> <span class="nv">LINE</span><span class="o">*</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="s s-Atom">一番最初のデータブロックまでのオフセット（自分除く）</span> <span class="p">|</span> <span class="nv">RIFF等の慣習に従って32bit</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">16</span> <span class="p">|</span> <span class="s s-Atom">これ以降のフィールドで、ヘッダ末尾までのCRC16</span> <span class="p">|</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="s s-Atom">フォーマットバージョン番号</span> <span class="p">|</span> <span class="mi">1</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">8</span>  <span class="p">|</span> <span class="s s-Atom">チャンネル数</span> <span class="p">|</span> <span class="s s-Atom">足りるでしょ…（怠慢）</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="s s-Atom">全サンプル数</span> <span class="p">|</span> <span class="s s-Atom">足りるでしょ…（怠慢）。ストリームエンコード時は未定義=</span><span class="err">`</span><span class="mh">0xFFFFFFFF</span><span class="err">`</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="s s-Atom">サンプリングレート</span> <span class="p">|</span> <span class="s s-Atom">足りるでしょ…（怠慢）</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">8</span>  <span class="p">|</span> <span class="mi">1</span><span class="s s-Atom">サンプルあたりのビット数</span> <span class="p">|</span> <span class="s s-Atom">wavへの復元で必要</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">8</span>  <span class="p">|</span> <span class="nv">PARCOR係数次数</span> <span class="p">|</span> <span class="s s-Atom">無音ブロック以外の全ブロックで同一</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">8</span>  <span class="p">|</span> <span class="s s-Atom">ロングタームタップ数</span> <span class="p">|</span> <span class="s s-Atom">ブロック毎に異なる</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">8</span>  <span class="p">|</span> <span class="nv">NLMS次数</span> <span class="p">|</span> <span class="s s-Atom">無音ブロック以外の全ブロックで同一</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">8</span>  <span class="p">|</span> <span class="s s-Atom">チャンネル毎の処理法</span> <span class="p">|</span> <span class="s s-Atom">無音ブロック以外の全ブロックで同一</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="nv">SLAブロック数</span> <span class="p">|</span> <span class="s s-Atom">ストリームエンコード時は未定義=</span><span class="err">`</span><span class="mh">0xFFFFFFFF</span><span class="err">`</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">16</span> <span class="p">|</span> <span class="nv">SLAブロックあたりの最大サンプル数</span> <span class="p">|</span>  <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="s s-Atom">最大ブロックサイズ</span><span class="p">[</span><span class="s s-Atom">byte</span><span class="p">]</span> <span class="p">|</span> <span class="s s-Atom">最低ビットレートの計算に必要。ストリームエンコード時は未定義=</span><span class="err">`</span><span class="mh">0xFFFFFFFF</span><span class="err">`</span> <span class="p">|</span>

<span class="s s-Atom">ヘッダサイズは38byte。</span>

<span class="s s-Atom">####</span> <span class="nv">SLAブロック</span>

<span class="p">|</span> <span class="nf">サイズ</span><span class="p">(</span><span class="s s-Atom">bits</span><span class="p">)</span> <span class="p">|</span> <span class="s s-Atom">内容</span> <span class="p">|</span> <span class="s s-Atom">補足</span> <span class="p">|</span>
<span class="p">|</span><span class="s s-Atom">--:</span><span class="p">|:-</span><span class="s s-Atom">:</span><span class="p">|:-</span><span class="s s-Atom">:</span><span class="p">|</span>
<span class="p">|</span> <span class="mi">16</span> <span class="p">|</span> <span class="s s-Atom">同期コード</span><span class="err">`</span><span class="mh">0xFFFF</span><span class="err">`</span> <span class="p">|</span> <span class="s s-Atom">アルファ符号は最大で15個までの連続した1を出すから。</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">32</span> <span class="p">|</span> <span class="s s-Atom">次のデータブロックまでのオフセット</span> <span class="p">|</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">16</span> <span class="p">|</span> <span class="s s-Atom">これ以降のフィールドで、次のブロック先頭までのCRC16値</span> <span class="p">|</span>  <span class="p">|</span>
<span class="p">|</span> <span class="mi">16</span> <span class="p">|</span> <span class="s s-Atom">このブロックのサンプル数</span> <span class="p">|</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">1</span> <span class="o">*</span> <span class="s s-Atom">チャンネル数</span> <span class="p">|</span> <span class="s s-Atom">無音ブロックか否か？</span> <span class="p">|</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">16</span> <span class="o">*</span> <span class="s s-Atom">チャンネル数</span> <span class="o">*</span> <span class="nv">MIN</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nv">PARCOR係数次数</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="s s-Atom">チャンネル数</span> <span class="o">*</span> <span class="nv">MAX</span><span class="p">(</span><span class="nv">PARCOR係数次数</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">|</span> <span class="nv">PARCOR係数</span> <span class="p">|</span> <span class="s s-Atom">最初の4次までは16bit</span><span class="p">,</span> <span class="s s-Atom">残りは8bitで符号化。非線形量子化は行っていない。</span> <span class="p">|</span>
<span class="p">|</span> <span class="mi">1</span> <span class="o">*</span> <span class="s s-Atom">チャンネル数</span> <span class="o">+</span> <span class="mi">26</span> <span class="o">*</span> <span class="s s-Atom">ロングターム有りch数</span> <span class="p">|</span> <span class="s s-Atom">ロングターム係数</span> <span class="p">|</span> <span class="s s-Atom">ロングタームを使用していないチャンネルは0が入る。</span><span class="mi">1</span><span class="s s-Atom">の場合、最初の10bitでピッチ周期、次の16bitで係数が符号化されている。</span> <span class="p">|</span>
<span class="p">|</span> <span class="s s-Atom">不定</span> <span class="p">|</span> <span class="s s-Atom">再帰的ライス符号化された残差</span> <span class="p">|</span> <span class="s s-Atom">チャンネルインターリーブではない。</span><span class="mi">1</span><span class="s s-Atom">ch目の符号化された信号列先頭</span><span class="p">,</span> <span class="p">...,</span> <span class="mi">1</span><span class="s s-Atom">ch目の符号化された信号列末尾</span><span class="p">,</span> <span class="mi">2</span><span class="s s-Atom">ch目の符号化された信号先頭</span><span class="p">,</span> <span class="p">...,</span> <span class="mi">2</span><span class="s s-Atom">ch目の符号化された信号末尾</span><span class="p">,...</span><span class="s s-Atom">という並び。</span> <span class="p">|</span>

<span class="mi">15</span><span class="s s-Atom">:</span><span class="mi">56</span> <span class="s s-Atom">ヘッダを書き下すところまではOK。現段階では壊れたところは見当たらない。実装を埋めていく。今日でとりあえずの第一版を上げて、レビューを受けたい。間に合ってくれ…！</span>

<span class="mi">19</span><span class="s s-Atom">:</span><span class="mi">34</span> <span class="s s-Atom">エンコーダのやっつけ版ができた。まだコンパイル・テストはしていない。コンパイルを頑張って通すようにして、デコーダに手を付ける。</span>

<span class="mi">25</span><span class="s s-Atom">:</span><span class="mi">00</span> <span class="s s-Atom">なんとかエンコード・デコードができるもの（alpha版1）を作成。</span>

<span class="s s-Atom">###</span> <span class="mf">2019.4.3</span>

<span class="s s-Atom">先輩に見て頂いているが、いろんな問題が見つかっている。</span>

 <span class="o">-</span> <span class="err">`</span><span class="nv">M_PI</span><span class="err">`</span><span class="s s-Atom">が未定義で怒られる</span>
 <span class="o">-</span> <span class="s s-Atom">プラットフォームによって圧縮率が異なる</span>
   <span class="o">-</span> <span class="s s-Atom">まず気になるのはfloatが一部混入している所。思い切ってdoubleにしよう。</span>
     <span class="o">-</span> <span class="nv">Rpiでは関係なかった</span><span class="s s-Atom">…原因を追っていたら、</span><span class="nv">C89では</span><span class="err">`</span><span class="s s-Atom">round</span><span class="err">`</span><span class="s s-Atom">が定義されていなくて、係数が全部0になっていた。。。</span><span class="err">`</span><span class="s s-Atom">std</span><span class="o">=</span><span class="s s-Atom">c99</span><span class="err">`</span><span class="s s-Atom">にしたらOKだったけども…。下の独自実装を使う。</span>
  <span class="o">-</span> <span class="s s-Atom">splintにかけたら負数の右シフトはやべえぞとあった。確かに。算術シフトとは限らないので静的アサートしよう</span>
  <span class="o">-</span> <span class="s s-Atom">ハッカーのたのしみを引用すると、算術右シフトをやるには以下の式：</span>

<span class="err">```</span><span class="s s-Atom">c</span>
<span class="cm">/* 算術右シフト(有効範囲:0 &lt;= rshift &lt;= 32) */</span>
<span class="s s-Atom">#define</span> <span class="nv">SHIFT_RIGHT_SIGNED</span><span class="p">(</span><span class="s s-Atom">sint</span><span class="p">,</span> <span class="s s-Atom">rshift</span><span class="p">)</span>    <span class="p">(</span><span class="s s-Atom">int32_t</span><span class="p">)((((</span><span class="s s-Atom">uint64_t</span><span class="p">)(</span><span class="s s-Atom">sint</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x80000000</span><span class="nv">UL</span><span class="p">)</span> <span class="s s-Atom">&gt;&gt;</span> <span class="p">(</span><span class="s s-Atom">rshift</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="mh">0x80000000</span><span class="nv">UL</span> <span class="s s-Atom">&gt;&gt;</span> <span class="p">(</span><span class="s s-Atom">rshift</span><span class="p">)))</span>
</code></pre></div>

<ul>
<li>デコードに失敗するケースがある</li>
<li>テスト追加（移植）</li>
<li>簡単に負荷を測ったところ、RecursiveRice_PutQuotPartの負荷が高かった。パラメータは絶対2の冪だから、決め打ち（ライス符号化）でいいのでは。</li>
</ul>
<p>```c:丸め関数の独自実装
double round(double number)
{
    return (number &gt;= 0) ? (double)((int)(number + 0.5f)) : (double)((int)(number - 0.5f));
}
double round(double f)
{
    return (f &gt;= 0.0) ? floor(f + 0.5f) : -floor(-f + 0.5);
}</p>
<div class="highlight"><pre><span></span><code><span class="n">もう少し警告をうるさくしたいので、オプション探索中。</span><span class="n n-Quoted">`splint`</span><span class="n">もかけたいし、</span><span class="n n-Quoted">`gcc -Wall -Wextra -Q --help=warnings`</span><span class="n">で有効になっている警告を表示できる。</span><span class="w"></span>

<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">[</span><span class="n">警告を要求</span><span class="o">/</span><span class="n">抑止するオプション</span><span class="err">]</span><span class="p">(</span><span class="n">http</span><span class="o">://</span><span class="n">www</span><span class="p">.</span><span class="n">cqpub</span><span class="p">.</span><span class="n">co</span><span class="p">.</span><span class="n">jp</span><span class="o">/</span><span class="n">interface</span><span class="o">/</span><span class="k">column</span><span class="o">/</span><span class="n">freesoft</span><span class="o">/</span><span class="mi">2003</span><span class="o">/</span><span class="mi">200308</span><span class="o">/</span><span class="mf">3.</span><span class="n">htm</span><span class="p">)</span><span class="w"></span>

<span class="n">コマンドラインパーサを作る時が来たかも。</span><span class="n n-Quoted">`getopt_long`</span><span class="n">（GNU拡張）</span><span class="w"> </span><span class="n">を自前で実装したもの</span><span class="w"></span>

<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">[</span><span class="n">コマンドライン引数の処理</span><span class="err">]</span><span class="p">(</span><span class="n">http</span><span class="o">://</span><span class="n">linuxc</span><span class="p">.</span><span class="n">info</span><span class="o">/</span><span class="n">stdinout</span><span class="o">/</span><span class="n">getopt</span><span class="o">/</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">[</span><span class="n">コマンドラインオプションの処理</span><span class="err">]</span><span class="p">(</span><span class="n">https</span><span class="o">://</span><span class="n">www</span><span class="p">.</span><span class="n">mm2d</span><span class="p">.</span><span class="n">net</span><span class="o">/</span><span class="n">main</span><span class="o">/</span><span class="n">prog</span><span class="o">/</span><span class="n">c</span><span class="o">/</span><span class="n">getopt</span><span class="o">-</span><span class="mf">03.</span><span class="n">html</span><span class="p">)</span><span class="w"></span>

<span class="n">性能計測してたら、nlz5の呼び出し回数が多いことが分かった。もしかしたら高速化した方がいいかも。ビットカウント問題に帰着する方法が一番速そう。</span><span class="w"></span>

<span class="c1">### 2019.4.5</span><span class="w"></span>

<span class="n">準備で4</span><span class="mf">.4</span><span class="n">は何もできず。思いついたのはceil</span><span class="p">(</span><span class="nf">log2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="n">は2のべき乗切り上げに変えられるということ。</span><span class="w"></span>

<span class="c1">### 2019.4.6</span><span class="w"></span>

<span class="mf">4.5</span><span class="n">は2時間半しか寝てないので今日は12時間寝た。週末はテスト追加と、上記の修正を入れていきたい。</span><span class="w"></span>

<span class="n">テスト追加はOK。はやめにrepo</span><span class="p">.</span><span class="n">作る。</span><span class="n n-Quoted">`-Wpedantic -Wformat=2 -Wconversion`</span><span class="n">をつけて警告を潰す。</span><span class="w"></span>

<span class="mi">14</span><span class="o">:</span><span class="mi">09</span><span class="w"> </span><span class="n">飯食いながら警告を潰した。15</span><span class="o">:</span><span class="n">00から2回目なのでここで切り上げる。</span><span class="w"></span>

<span class="n">macで性能計測する方法がわからなかったので調べた（</span><span class="n n-Quoted">`gprof`</span><span class="n">が使えなくて悲しい）。instrumentsを使う。</span><span class="w"></span>

<span class="n n-Quoted">`</span><span class="n n-Quoted n-Quoted-Escape">``</span><span class="n n-Quoted">sh</span>
<span class="n n-Quoted">$ instruments -t &quot;Time Profiler&quot; ./sla -c voice48a.wav voice48a.sla</span>
</code></pre></div>

<p>実行の結果できあがった<code>.trace</code>ファイルを開けばプロファイル結果が見られる。</p>
<p>最適化を気にし始める：</p>
<ul>
<li><a href="http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2">Bit Twiddling Hacks</a></li>
</ul>
<p>これ以上は、多分根本的に戦って行かないとだめかも。一旦最適化はおいて、CRC16等の機能追加に入ろう。と思ったらCRC16壊れてる。うーんやり直し。秋葉原製作所3時間タイムアップ。</p>
<p>家で作業。CRC16のリファレンスを入手するのにすげえ苦労した。pythonの<code>pycrc</code>を使う。</p>
<div class="highlight"><pre><span></span><code>python3 pycrc.py --model<span class="o">=</span>crc-16-ccitt --xor-in<span class="o">=</span>0xFFFF --check-file foo.txt
</code></pre></div>

<p>CRC16の組み込みOK。同時にブロックの次のオフセット記録もOK。未テストだからテスト突っ込みたい。</p>
<p>あとは、いよいよPARCORを1乗算型に変えるかな…</p>
<h3>2019.4.7</h3>
<p>コンパイラをmacの<code>clang</code>から<code>gcc-8</code>に変えたら警告がドバーッと出たので消していく。気になるのは論理定数を導入したほうが良さそう（列挙型で良い）。あと1乗算型変更が着手を今日のメインとしたい。できるか…？</p>
<p>CRC16は、CCITT-FALSEよりCCITTにしたほうが良いな。Linuxカーネルでよく使われるのはCCITTだし。<strong>と思ったらやめた。CCITT-FALSEでいく。Linux内部でも実装がブレブレ。初期値の与え方、結果の反転のやり方が使用箇所毎に違う。</strong></p>
<p>そして、今<code>assert</code>を消そうと思って<code>-DNDEBUG</code>を入れたら圧縮結果が変わった。これは最適化時に何かが起きている。</p>
<p>→原因が判明。<code>assert</code>マクロ自体<code>(void)0</code>に置き換えてしまうから、なにか副作用のある処理を<code>assert</code>していると、最適化により処理自体が消されてしまう。SLABitStreamを使うところでassertsしているところが多数あってassertを消すと挙動が変わっていた。</p>
<p><code>SLABitStream_GetBit</code> の負荷が高い。アルファ符号を取得するときに頻繁に呼ばれる。アルファ符号向けにランレングスを取得する関数を追加すべきか…？</p>
<p>NLZの高速な計算手法があった…もはや黒魔術。</p>
<ul>
<li><a href="http://d.hatena.ne.jp/Koonies/touch/20090708/nlz3">マジックナンバー0x03F566ED27179461の求め方とHD流のNLZ</a></li>
<li><a href="https://www.hackersdelight.org/hdcodetxt/nlz.c.txt">Hacker's Delightのソース</a></li>
</ul>
<p>分岐無しで自明に早いので取り込んでいる。</p>
<p>やりたいこと一つ出てきた。ヘッダのエンコードとデコードはハンドル無しでやるべき。（ハンドルがない状態で呼ばれるかもしれないから）。だから、バイト列の読み書きモジュールを新規に追加したい。おそらくヘッダ実装で間に合うはず。</p>
<p>うーん、CRC16の選択にまだ迷う。CCITT-FALSEはCCITTのミスみたいな記述があるし…。</p>
<ul>
<li><a href="https://crccalc.com/">計算リファレンス</a></li>
<li><a href="http://reveng.sourceforge.net/crc-catalogue/16.htm#crc.cat-bits.16">Catalogue of parametrised CRC algorithms with 16 bits</a></li>
<li><a href="http://www.ross.net/crc/download/crc_v3.txt">A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS</a></li>
</ul>
<p>やっぱり社内と統一をとるため、CRC-16/ARCにしようか。</p>
<p>あと、窓関数の変更対応ができてなくてサイン窓固定になってる…変えなきゃ…</p>
<h3>2019.4.9</h3>
<p>週末は完全に予定が入っているのでなんとか進めたい所。GWの予定も考えていかないと。</p>
<p>CRC16をIBM(ARC)に変えた。</p>
<p>特許調査始めないとダメかも…</p>
<ul>
<li>特開2013-120225(P2013-120225A)</li>
</ul>
<h3>2019.4.11</h3>
<p>特許を見始めているが、権利一体の原則の見地から見ると、おそらく抵触しないのではという感覚。油断せず継続調査。</p>
<p>ヘッダのエンコード・デコードをハンドル無しで行うように修正。
あと、入力が32bit整数ににスケールされている整数というのはなんとなく格好悪い。（例：16bitの65535が32bitのINT32_MAXになっている）</p>
<p>GWでは格子型フィルター演算の高速化・圧縮率改善の最後のあがきをすべきか。ロングタームが1tapしか使えないのがやだ。TAKのサイト見てたら前処理でフィルター入れているとのこと…やってみたい。</p>
<h3>2019.4.14</h3>
<p>4.14は夕方から秋葉原製作所3hコース。やるべきは、エンコード・デコードのテスト追加か。<code>Create</code>関数をワーク渡しにするのはまだ先としたい（メンバ追加はやりそうだから）。</p>
<h3>2019.4.17</h3>
<p>15,16はテストを少し追加していただけ。1乗算型PARCORの実装方法をついに見つけた。「音声のディジタル信号処理（上）」のp96だ。</p>
<h3>2019.4.18</h3>
<p>1乗算型にしようとしてみるがどうもならない。最初に実装した形がそもそも違うように見える…</p>
<h3>2019.4.19</h3>
<p>TAKの圧縮率にビビる。というか、これもうTAKの勝ちでは…。
TAKは線形予測の前に何かしらのフィルターを使用しているが、もしかしたら、NLMSかも？</p>
<p>下の結果は<code>-p4</code>（最大圧縮率）を使用。</p>
<div class="highlight"><pre><span></span><code>-rwxrwxrwx 1 kiriao kiriao 38580251 Apr 19 18:52 one_two_sweets_offvocal.tak
-rwxrwxrwx 1 kiriao kiriao 28597636 Apr 19 18:52 SPARKLE.tak
-rwxrwxrwx 1 kiriao kiriao    50358 Apr 19 18:52 kisaragi_chihaya.tak
-rwxrwxrwx 1 kiriao kiriao 21068517 Apr 19 18:54 Dream_goes_On.tak
-rwxrwxrwx 1 kiriao kiriao   753612 Apr 19 18:52 voice48a.tak
</code></pre></div>

<p>日に日に乗算結果を64bitで受けている現実が気になってきている。TAKは14bitだという。SSE化を見越した時に有利なのはどちらかは明らかだ。</p>
<p>TAKを越えない限り商品化は厳しいと思う。</p>
<h3>2019.4.20</h3>
<p>TAKに追いつきたい。まずは今のソースをgitに登録する。→やった。</p>
<ul>
<li>可変ブロックサイズ対応</li>
<li>PARCOR係数から残差電力を求められたはず。これで（もしくは符号長から）、最も残差電力が小さくなるブロックサイズを決める。</li>
<li>フィルタ処理の追加</li>
<li>TAKでは線形予測の前にフィルタを入れている。ローパス、ハイパス、NLMSを入れてみてどうなるか見る。</li>
<li>平均が小さい時にLZ符号化を試す</li>
<li>やってみたけど芳しくない。増える傾向。一方で適応的ハフマンを使ったら圧縮率がわずかに上がった。でも多分、幾何分布に従うことを考えて静的でも良いかもしれない。この結果は参考にしたい。</li>
</ul>
<p>まずは可変ブロックサイズ対応の前段階として、PARCOR係数による残差電力が実際の残差電力と一致するか観察する。
→そこそこ一致。傾向は合ってるかも。計算は<code>0次自己相関*Π(1-PARCOR^2)</code>でやった。誤差が出ているのはfloatじゃないのが問題かも。理論はおそらく正しい。</p>
<p>以下にその説明有り。</p>
<ul>
<li><a href="https://www.jstage.jst.go.jp/article/ast/34/2/34_E1250/_pdf/-char/ja">Low-complexity PARCOR coefficient quantization and prediction order estimation designed for entropy coding of prediction residuals</a></li>
</ul>
<p>得られたPARCOR係数から残差電力を計算する関数を追加しておく。しかし係数の当てはまりの良さを考えるなら、<code>Π(1-PARCOR^2)</code>（分散比。分散をどれだけ減らせたのかの比。）だけで良いはずなのでこれを計算する関数を追加した。エンコーダはこれを使って最小の残差を与えるブロックサイズを探す方針。</p>
<p>次は、というか今日のメインとして、線形予測前にフィルタを突っ込んで見る。あと30分しかないけど！</p>
<p>→NLMSを突っ込んだが悪化。FIRローパスは短い音声で大悪化、長い音声でほんの少し減少。他にできることがないか探してみる。</p>
<h3>2019.4.21</h3>
<p>可変ブロック対応に当たり、<a href="https://www.jstage.jst.go.jp/article/ast/34/2/34_E1250/_pdf/-char/ja">上の論文</a>を読んでいたら、ラプラス分布を仮定したときの符号長推定について書いてあった。これは大変に有益。これを使い、サンプルあたりの符号長としてブロックサイズを決めてみたい。</p>
<p>16bit整数として計算したときに、かなりの精度で予測できていることが分かった。計算量的にも大きくないから、取り入れていく。</p>
<p>なんだか実験がうまく行っていて、残り1時間あるからエイヤで組み込んでしまうか。</p>
<p>なんか組み込めた。そして減った。観察の結果は次:</p>
<ul>
<li>SPARKLEと俺の声は減った。しかし、ワン・ツー・スゥイーツでは増えている。</li>
<li>窓をかけてPARCOR係数を計算して推定を行うと、圧縮率が悪化する。</li>
<li>最大ブロックサイズを10240(232ms @44.1kHz)まで伸ばすべきかも。</li>
<li>無音時にどうなっているか怪しい。</li>
</ul>
<p>バグの調査が甘い（一応戻ることは確認している）が、速報値は以下：</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  40672844 Apr 21 20:45 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30850345 Apr 21 20:51 SPARKLE.sla
-rw-r--r--@  1 *  staff     51915 Apr 21 20:48 kisaragi_chihaya.sla
</code></pre></div>

<p>家帰って試行錯誤。まずはfloatの正規化が抜けていたので<code>pow(2,-31)</code>をかけた。また、最小ブロックサイズを小さくしすぎると(1024とか)ワン・ツー・スゥイーツの性能が悪くなった。逆に長くすると(4096とか)俺の声が悪化。</p>
<p>一つバグがあって（符号長のチャンネル平均が取れていなかった）潰したところ、性能改善。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  40245317 Apr 22 00:02 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30800189 Apr 22 00:03 SPARKLE.sla
-rw-r--r--@  1 *  staff     51776 Apr 22 00:03 kisaragi_chihaya.sla
</code></pre></div>

<p>最大ブロックサイズを16384までしたところ次の結果：</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  40148214 Apr 22 00:30 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30783283 Apr 22 00:32 SPARKLE.sla
-rw-r--r--@  1 *  staff     53486 Apr 22 00:31 kisaragi_chihaya.sla
</code></pre></div>

<p>たぶん最適割り当て問題になっている。今は、現在与えられたサンプル列を一番小さく符号化できそうなブロックサイズを使用している。これはグリーディな方法と言える。もしかしたら、エンコードすべきブロックの内容の先読みなり最適割り当てを行ったほうが性能がいいかも。当然良いはず。最大ブロック数分サンプルを見て、その中で最適な分割を探す問題とする。</p>
<p>非線形量子化、危ないけど導入すべきか…あと線形予測前のフィルターも気になる…。TTAを参考にすべきか。</p>
<h3>2019.4.22</h3>
<p>TTAのソースの可読性が著しく低い（愚痴）。filter関数ですべてをやり切ってるけど、何やってるかさっぱり。コメントもない。
へらへらしていたら、Levinson-Durbin法とは別にBurg法というものがあることを知った。周波数分解能が高い（他に問題もある）らしい。</p>
<ul>
<li><a href="http://www.emptyloop.com/technotes/A%20tutorial%20on%20Burg's%20method,%20algorithm%20and%20recursion.pdf">Burg’s Method, Algorithm and Recursion</a></li>
<li><a href="https://qiita.com/hirokisince1998/items/fd50c0515c7788458fce">Pythonで線形予測分析 (LPC) を学ぶ</a></li>
<li><a href="https://www.opus-codec.org/docs/vos_fastburg.pdf">A Fast Implementation of Burg’s Method</a></li>
<li><a href="https://pure.tue.nl/ws/portalfiles/portal/4337516/9214707.pdf">Algorithms for speech coding systems based on linear prediction</a></li>
<li><a href="https://jp.mathworks.com/help/dsp/ref/burgmethod.html">Burg Method(MATLAB, 自己相関等との比較)</a></li>
</ul>
<p>家帰って実装をしてみた。C++実装をもろ写経。予測してみたけどいい感じ（LPCより予測精度が高い）。
問題はPARCOR係数の解釈があっているかどうかというところ。</p>
<h3>2019.4.23</h3>
<p>Burg法実装がプロトタイプでできたので組み込んで様子を見る。三角関数の重ね合わせではLevinson法よりも予測精度が良かったけど、実wavに対しては良くならなかった。（窓を外しても、サイズを固定にしてもだめ）全体的にサイズ増加。何がいけないのかもよくわからない…。</p>
<p>改めて残りの減少ネタ。上から優先順位高い方：</p>
<ul>
<li>float → double</li>
<li>ブロックサイズ決定を最大ブロックサイズから初め、最大ブロックサイズの中の小分割の中で一番サイズが小さくなるものを採用する</li>
<li>エンコード高速化（最大ブロックサイズ毎で処理が独立になるので並列実行可能）にもなるので、こちらで行きたい。</li>
<li>ロングタームを3次以上に対応させる</li>
<li>平均（もしくは最大値が0xFF以下）が少ないときの符号化をハフマンに</li>
<li>分散が異なるラプラス分布（もしくは幾何分布か？）のハフマン符号テーブルを作っておく。</li>
<li>線形予測前のフィルター処理</li>
<li>TAKのページを改めて見ると、2つのフィルターを本チャンの線形予測フィルタの前に入れることができるとのこと。</li>
<li>一つは窓関数かもしれない。もう一つは一体何だ？プリエンファシスでは無いと思う。</li>
<li>平均除去とか？</li>
<li>ブロックサイズ推定を実測してみる</li>
<li>窓関数の再考</li>
<li>sin窓を今だに使い続けている</li>
<li><a href="http://www.maroon.dti.ne.jp/twist/4C616E637A6F73B4D8BFF4A4CBA4E8A4EBB2E8C1FCA4CEB3C8C2E7BDCCBEAE.html">Lanczos窓</a>とかどうだろうか</li>
</ul>
<h3>2019.4.25</h3>
<h4>小松観光計画</h4>
<p>基本はGAFの聖地を優先。しかし一日で回りきれそう。空いた時間は風呂にしたい。</p>
<ul>
<li><a href="https://busaboko.net/airforce/">GAFの聖地一覧</a></li>
<li>うつのみや小松城南店（本屋）</li>
<li>莵橋神社</li>
<li>8番ラーメン（城南末広店）</li>
<li>安宅の関（海沿い）</li>
<li>小松基地周辺</li>
<li>風呂</li>
</ul>
<table>
<thead>
<tr>
<th align="center">日付</th>
<th align="center">何するか</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">4/27</td>
<td align="center">- コーデック圧縮率向上施策考案 <br> - コーデック評価スクリプト作成 <br> - デコードテスト追加</td>
</tr>
<tr>
<td align="center">4/28</td>
<td align="center">- プリパラフレンドシップツアー <br> - 秋葉原で一泊</td>
</tr>
<tr>
<td align="center">4/29</td>
<td align="center">- 絵師百 <br> - 深夜バス乗車（渋谷）</td>
</tr>
<tr>
<td align="center">4/30</td>
<td align="center">- 小松駅着。ロッカーに荷物を入れて聖地巡礼開始。<br> - 本屋→神社→安宅→小松基地？ <br> - 昼は8番ラーメン <br> - 夜は海鮮丼。駅前に戻って松屋旅館へ。</td>
</tr>
<tr>
<td align="center">5/1</td>
<td align="center">- 温泉につかりながら作業 <br> - 加賀の宿　柴山温泉　ホテル翠湖で一泊。</td>
</tr>
<tr>
<td align="center">5/2</td>
<td align="center">- 温泉につかりながら作業 <br> - 金沢18:09発の新幹線で移動→19:59佐久平着。</td>
</tr>
</tbody>
</table>
<h3>2019.4.26</h3>
<p>ラプラス分布の最尤推定について。なんと、平均が0ならば単純な絶対値の標本平均が分散になる。</p>
<ul>
<li><a href="http://ikuro-kotaro.sakura.ne.jp/koramu/2732_s1.htm">観測データから確率密度関数を求める（その２）</a></li>
</ul>
<h3>2019.4.27</h3>
<p>コーデック評価スクリプトを昨晩にやっつけで仕立て上げた。ほしいのは以下の表。CSVで出せると良い。</p>
<h5>圧縮率</h5>
<table>
<thead>
<tr>
<th align="center">波形 / コマンド</th>
<th align="center">元波形[byte]</th>
<th align="center"><code>flac -8</code>[byte]</th>
<th align="center"><code>flac -8</code>[%]</th>
<th align="center"><code>wavpack -hh</code>[byte]</th>
<th align="center"><code>wavpack -hh</code>[%]</th>
<th align="center">...</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">いばらの女王</td>
<td align="center">20000000</td>
<td align="center">12000000</td>
<td align="center">50%</td>
<td align="center">...</td>
<td align="center">...</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ハローハロー</td>
<td align="center">22000000</td>
<td align="center">14000000</td>
<td align="center">63%</td>
<td align="center">...</td>
<td align="center">...</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">累計[%]</td>
<td align="center">42000000</td>
<td align="center">26000000</td>
<td align="center">62%</td>
<td align="center">...</td>
<td align="center">...</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<h5>デコード速度</h5>
<table>
<thead>
<tr>
<th align="center">波形 / コマンド</th>
<th align="center">元波形[ms]</th>
<th align="center"><code>flac -8</code>[ms]</th>
<th align="center"><code>flac -8</code>[x]</th>
<th align="center"><code>wavpack -hh</code>[ms]</th>
<th align="center"><code>wavpack -hh</code>[x]</th>
<th align="center">...</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">いばらの女王</td>
<td align="center">2000</td>
<td align="center">20</td>
<td align="center">100</td>
<td align="center">...</td>
<td align="center">...</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ハローハロー</td>
<td align="center">2200</td>
<td align="center">22</td>
<td align="center">100</td>
<td align="center">...</td>
<td align="center">...</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">累計[%]</td>
<td align="center">4200</td>
<td align="center">42</td>
<td align="center">100</td>
<td align="center">...</td>
<td align="center">...</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<p>秋葉原製作所5hコースで作業し、上記の表に該当する結果は得られた。軽く自分の声で試してみると、やはりまだ圧縮率が悪い。。。tta,wavpackよりも下。振幅が小さいデータに対する圧縮率が悪い傾向がある。</p>
<h3>2019.4.29</h3>
<p>今日は22:45渋谷発小松行きに乗るまでで作業する。やることはラプラス分布の最尤推定の当てはまりがどれくらい良いか確かめること。</p>
<p>見ているけどラプラス分布で当てはまりはあまり良くない…。正規分布はひどい（0近辺の当てはまりが絶望的）。幾何分布が一番当てはまりが良い印象（SPARKLEはよく当てはまるが、それ以外の音源で微妙…）。やるとしても幾何分布か…。</p>
<p>そもそも、符号化手法を考え直すべきか…。適応的に分布が小さくなっていたらランレングスに切り替える符号化有り。</p>
<ul>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/Malvar_DCC06.pdf">Adaptive Run-Length / Golomb-Rice Encoding of Quantized Generalized Gaussian Sources with Unknown Statistics</a></li>
</ul>
<p>wavpackの動作原理はわかっている（つもり）だから、TTAのソース読もうか…</p>
<p>```c:ttaのエンコードソースの一部
__forceinline void tta_encoder_put_value(TTA_adapt *rice, TTAint32 value) {
    TTAuint32 k, unary, outval;</p>
<div class="highlight"><pre><span></span><code><span class="n">outval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ENC</span><span class="p">(</span><span class="k">value</span><span class="p">);</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">encode</span><span class="w"> </span><span class="n">Rice</span><span class="w"> </span><span class="n">unsigned</span><span class="w"></span>
<span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">k0</span><span class="p">;</span><span class="w"></span>

<span class="n">rice</span><span class="o">-&gt;</span><span class="n">sum0</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">outval</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">sum0</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">k0</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">sum0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">shift_16</span><span class="o">[</span><span class="n">rice-&gt;k0</span><span class="o">]</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">k0</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">sum0</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">shift_16</span><span class="o">[</span><span class="n">rice-&gt;k0 + 1</span><span class="o">]</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">k0</span><span class="o">++</span><span class="p">;</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">outval</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">bit_shift</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="n">outval</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">bit_shift</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">k1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">sum1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">outval</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">sum1</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">k1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">sum1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">shift_16</span><span class="o">[</span><span class="n">rice-&gt;k1</span><span class="o">]</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">k1</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">sum1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">shift_16</span><span class="o">[</span><span class="n">rice-&gt;k1 + 1</span><span class="o">]</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">rice</span><span class="o">-&gt;</span><span class="n">k1</span><span class="o">++</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">unary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">outval</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="err">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">unary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">put</span><span class="w"> </span><span class="n">unary</span><span class="w"></span>
<span class="n">do</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">enc_fifo_bcount</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">        </span><span class="n">write_byte</span><span class="p">(</span><span class="n">enc_fifo_bcache</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">enc_fifo_bcache</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">enc_fifo_bcount</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="err">}</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unary</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">23</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">        </span><span class="n">enc_fifo_bcache</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">bit_mask</span><span class="o">[</span><span class="n">23</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">enc_fifo_bcount</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">enc_fifo_bcount</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">23</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">unary</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">23</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="err">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">        </span><span class="n">enc_fifo_bcache</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">bit_mask</span><span class="o">[</span><span class="n">unary</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">enc_fifo_bcount</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">enc_fifo_bcount</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">unary</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">unary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="err">}</span><span class="w"></span>
<span class="err">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">unary</span><span class="p">);</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="n">put</span><span class="w"> </span><span class="nc">binary</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">enc_fifo_bcount</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="n">write_byte</span><span class="p">(</span><span class="n">enc_fifo_bcache</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">enc_fifo_bcache</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">enc_fifo_bcount</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="n">enc_fifo_bcache</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="n">outval</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">bit_mask</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">enc_fifo_bcount</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">enc_fifo_bcount</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>
</code></pre></div>

<p>} // tta_encoder_put_value</p>
<div class="highlight"><pre><span></span><code><span class="nt">おそらく2つのライス符号パラメータで再帰ライス符号になっている</span><span class="err">。</span><span class="nt">値が小さいときの処理は特にしていないように見える</span><span class="err">（</span><span class="nt">固定フィルター</span><span class="o">(</span><span class="nt">31</span><span class="o">/</span><span class="nt">32</span><span class="o">)</span><span class="w"> </span><span class="o">*(</span><span class="nt">前サンプル</span><span class="o">)</span><span class="nt">のあとに謎の適応フィルタを入れている</span><span class="err">。</span><span class="w"> </span><span class="nt">__固定フィルターはプリエンファシスだ</span><span class="err">。</span><span class="nt">そういえば整数で試してなかった</span><span class="err">。</span><span class="nt">俺も試すべき__</span><span class="err">）。</span><span class="w"></span>

<span class="err">```</span><span class="nt">c</span><span class="p">:</span><span class="nd">固定フィルター処理</span><span class="w"></span>
<span class="p">#</span><span class="nn">define</span><span class="w"> </span><span class="nt">PREDICTOR1</span><span class="o">(</span><span class="nt">x</span><span class="o">,</span><span class="w"> </span><span class="nt">k</span><span class="o">)</span><span class="w"> </span><span class="o">((</span><span class="nt">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">((</span><span class="nt">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="nt">k</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">1</span><span class="o">))</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="nt">k</span><span class="o">)</span><span class="w"></span>

<span class="c">/* ...snip... */</span><span class="w"></span>

<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="nt">compress</span><span class="w"> </span><span class="nt">stage</span><span class="w"> </span><span class="nt">1</span><span class="o">:</span><span class="w"> </span><span class="nt">fixed</span><span class="w"> </span><span class="nt">order</span><span class="w"> </span><span class="nt">1</span><span class="w"> </span><span class="nt">prediction</span><span class="w"></span>
<span class="w">        </span><span class="nt">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">curr</span><span class="o">;</span><span class="w"></span>
<span class="w">        </span><span class="nt">curr</span><span class="w"> </span><span class="nt">-</span><span class="o">=</span><span class="w"> </span><span class="nt">PREDICTOR1</span><span class="o">(</span><span class="nt">enc-</span><span class="o">&gt;</span><span class="nt">prev</span><span class="o">,</span><span class="w"> </span><span class="nt">5</span><span class="o">);</span><span class="w"></span>
<span class="w">        </span><span class="nt">enc-</span><span class="o">&gt;</span><span class="nt">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">temp</span><span class="o">;</span><span class="w"></span>
</code></pre></div>

<p>FLACについても、値が小さいときの処置は特に無い。wavpackも多分無い（読んでみようと思うが…）。</p>
<h3>2019.4.30</h3>
<p>小松観光。ガーリー・エアフォースの聖地を一通りあさった。今日はあんまり何もできないだろうけど、明日明後日は場所を変えて作業するつもり。5/3からは実家にて作業予定。</p>
<p>上記のプリエンファシスを試してみる…と100KBクラスで減少した。効果あり。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  40129181 Apr 30 23:07 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30704135 Apr 30 23:06 SPARKLE.sla
-rw-r--r--@  1 *  staff     51787 Apr 30 23:07 kisaragi_chihaya.sla
</code></pre></div>

<p>実装を整理（関数化）して就寝。令和が始まった。
振幅が小さい音声の圧縮率がwavpack, ttaと比べて低いのが気になる。</p>
<h3>2019.5.1</h3>
<p>15:00ホテル翠湖にチェックイン。wi-fiが飛んでいないので、オフラインで作業する。</p>
<p>テーマを1つ決めて試してみたい。昨日今日でやろうと思ったのが、非線形量子化。以前試した時はむしろ悪化する事がわかっていた。そこで、今回は2次成分までを<code>arcsin</code>によって非線形量子化してみた。</p>
<p>結果は、微減（俺の声は1バイト減少、SPARKLEは数百バイト減少、ワン・ツー・スィーツは数十バイト減少）。16bitも割り当ててあれば線形量子化でも十分ということを示している結果だと思う。本を読んでいると、ビット割当数は4-12bitと低くなっている。如何に低いビット数で同一の結果が出せるか…というところに着目すると、非線形量子化は効いてくるらしい。もし、極限までサイズを減らすことを考えるならば、非線形量子化を適用して良いかもしれない。が、処理の単純化（サイズ削減が処理の複雑化に対して見合ってない）と、減らせるサイズが高々数KBで本質的にサイズ削減になっていないので、16bitで良いと思う。</p>
<p>非線形量子化があまり美味しい策では無いことが分かった。本日は、ブロックサイズ決定の処理を</p>
<ul>
<li>ブロックサイズ決定を最大ブロックサイズから初め、最大ブロックサイズの中の小分割の中で一番サイズが小さくなるものを採用する</li>
<li>エンコード高速化（最大ブロックサイズ毎で処理が独立になるので並列実行可能）にもなるので、こちらで行きたい。</li>
</ul>
<p>に変えてみる。これ、一見減らないように見えるけどどうだろうか。FLACはこれとほぼ同じやり方をしている。wavpackとTTAのブロックサイズ決定方式を見て、風呂に入る。</p>
<ul>
<li>TTAはサンプリングレート依存で決まる固定サイズっぽい。（かなり大きい。フィルターがLPCじゃないから、20ms程度にしなくてもOKなのかも）</li>
</ul>
<p>```c:libtta.h
typedef struct {
    TTAuint32 format;   // audio format
    TTAuint32 nch;  // number of channels
    TTAuint32 bps;  // bits per sample
    TTAuint32 sps;  // samplerate (sps)
    TTAuint32 samples;  // data length in samples
} TTA_ALIGNED(16) TTA_info;</p>
<div class="highlight"><pre><span></span><code><span class="err">```</span><span class="nt">c</span><span class="p">:</span><span class="nd">libtta</span><span class="p">.</span><span class="nc">c</span><span class="w"></span>
<span class="p">#</span><span class="nn">define</span><span class="w"> </span><span class="nt">MUL_FRAME_TIME</span><span class="o">(</span><span class="nt">x</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="nt">256</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">(</span><span class="nt">x</span><span class="o">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nt">245</span><span class="o">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">FRAME_TIME</span><span class="w"></span>

<span class="c">/* ...snip... */</span><span class="w"></span>
<span class="w">    </span><span class="nt">dec_flen_std</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">MUL_FRAME_TIME</span><span class="o">(</span><span class="nt">info-</span><span class="o">&gt;</span><span class="nt">sps</span><span class="o">);</span><span class="w"></span>
</code></pre></div>

<ul>
<li>wavpackはサンプリングレートとチャンネル数依存ぽい。けど謎ルール。。。コメントに妥協しているみたいなことが書いてある。計算の結果<code>wpc-&gt;block_size</code>にブロックサイズが入り、処理途中に変更することはない。</li>
</ul>
<p>```c:pack_utils.c
int WavpackPackInit (WavpackContext *wpc)
{
    if (wpc-&gt;metabytes &gt; 16384)             // 16384 bytes still leaves plenty of room for audio
        write_metadata_block (wpc);         //  in this block (otherwise write a special one)</p>
<div class="highlight"><pre><span></span><code><span class="c1">// The default block size is a compromise. Longer blocks provide better encoding efficiency,</span><span class="w"></span>
<span class="c1">// but longer blocks adversely affect memory requirements and seeking performance. For WavPack</span><span class="w"></span>
<span class="c1">// version 5.0, the default block sizes have been reduced by half from the previous version,</span><span class="w"></span>
<span class="c1">// but the difference in encoding efficiency will generally be less than 0.1 percent.</span><span class="w"></span>

<span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">dsd_multiplier</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">block_samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">sample_rate</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">48000</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">44100</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CONFIG_HIGH_FLAG</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">block_samples</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">num_channels</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">block_samples</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">while</span><span class="w"> </span><span class="p">(</span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">block_samples</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">12000</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">block_samples</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">num_channels</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">300000</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">block_samples</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">int</span><span class="w"> </span><span class="n">divisor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CONFIG_HIGH_FLAG</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">while</span><span class="w"> </span><span class="p">(</span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">sample_rate</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">divisor</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">divisor</span><span class="o">--</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">block_samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">sample_rate</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">divisor</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">while</span><span class="w"> </span><span class="p">(</span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">block_samples</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">12000</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">block_samples</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">num_channels</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">75000</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">block_samples</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">while</span><span class="w"> </span><span class="p">(</span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">block_samples</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">num_channels</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20000</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">wpc</span><span class="o">-&gt;</span><span class="n">block_samples</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">wavpackの予測はsign</span><span class="o">-</span><span class="n">sign</span><span class="w"> </span><span class="n">LMSに基づいているらしい。</span><span class="w"></span>

<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">[</span><span class="mf">9.10</span><span class="w">  </span><span class="n">THE</span><span class="w"> </span><span class="n">NORMALIZED</span><span class="w"> </span><span class="n">SIGN</span><span class="nv">?</span><span class="n">SIGN</span><span class="w"> </span><span class="n">LMS</span><span class="w"> </span><span class="k">ALGORITHM</span><span class="err">]</span><span class="p">(</span><span class="n">https</span><span class="o">://</span><span class="n">www</span><span class="p">.</span><span class="n">oreilly</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">library</span><span class="o">/</span><span class="k">view</span><span class="o">/</span><span class="n">adaptive</span><span class="o">-</span><span class="n">filtering</span><span class="o">/</span><span class="mi">9781482253351</span><span class="o">/</span><span class="n">xhtml</span><span class="o">/</span><span class="n">20_Chapter09a</span><span class="p">.</span><span class="n">xhtml</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">[</span><span class="n">Lecture</span><span class="w"> </span><span class="mi">8</span><span class="o">:</span><span class="w"> </span><span class="n">RX</span><span class="w"> </span><span class="n">FIR</span><span class="p">,</span><span class="w"> </span><span class="n">CTLE</span><span class="p">,</span><span class="w"> </span><span class="n">DFE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">Adaptive</span><span class="w"> </span><span class="n">Eq</span><span class="p">.</span><span class="err">]</span><span class="p">(</span><span class="n">http</span><span class="o">://</span><span class="n">www</span><span class="p">.</span><span class="n">ece</span><span class="p">.</span><span class="n">tamu</span><span class="p">.</span><span class="n">edu</span><span class="o">/~</span><span class="n">spalermo</span><span class="o">/</span><span class="n">ecen689</span><span class="o">/</span><span class="n">lecture8_ee720_rx_adaptive_eq</span><span class="p">.</span><span class="n">pdf</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">[</span><span class="n">Lecture</span><span class="w"> </span><span class="mi">5</span><span class="o">:</span><span class="w"> </span><span class="n">Variants</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">LMS</span><span class="w"> </span><span class="k">algorithm</span><span class="err">]</span><span class="p">(</span><span class="n">https</span><span class="o">://</span><span class="n">www</span><span class="p">.</span><span class="n">cs</span><span class="p">.</span><span class="n">tut</span><span class="p">.</span><span class="n">fi</span><span class="o">/~</span><span class="n">tabus</span><span class="o">/</span><span class="n">course</span><span class="o">/</span><span class="n">ASP</span><span class="o">/</span><span class="n">SGN2206LectureNew5</span><span class="p">.</span><span class="n">pdf</span><span class="p">)</span><span class="w"></span>

<span class="n">3番目の記事を読んでいたら、Signed</span><span class="w"> </span><span class="n">LMSは絶対値誤差の最小化に基づいているので、もしかしたらライス符号化に適しているかもしれない。実装は簡単なので早速試したところ、俺の声は1バイト減少したが、SPARKLEとワン・ツー・スィーツは悪化。これは、大振幅音源に弱いという、wavpackと同様の傾向を示している？</span><span class="w"></span>

<span class="n">ちょっと待て、sign</span><span class="o">-</span><span class="n">sign</span><span class="w"> </span><span class="n">LMS</span><span class="p">...</span><span class="n">性能高いのでは…？今までのNLMSの性能を超えている（タップを増やした時のサイズ減少が大きい）。ちょっと冷静になるために風呂に入る。確かめること：</span><span class="w"></span>

<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">係数の重み</span><span class="w"></span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="n">高次数にした時は重みを小さくしないと性能悪化に転じる。</span><span class="w"></span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="n">高次数で小さくなるような重み付けをすると性能改善が見られた。次数を増やすと性能悪化することもあった。次数に応じた重み付けを定式化できると良さそう。</span><span class="w"></span>
<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">カスケード接続は有効か？</span><span class="w"></span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="n">一部有効だった。（次数20を1回適用するより、次数5を4回適用したほうが減る。しかし、1つあたり次数を1</span><span class="p">,</span><span class="n">2等減らしすぎると悪化する。これはNLMS（正規化LMS）では見られなかったことだ。）</span><span class="w"></span>

<span class="n">冷静になってwavpackの実装を見ている。</span><span class="n n-Quoted">`decorr_tables.h`</span><span class="n">にテーブルが示されているが固定値のマジックナンバーにしか見えない…。</span><span class="w"></span>

<span class="n">sign</span><span class="o">-</span><span class="n">sign</span><span class="w"> </span><span class="n">LMSが有効で、NLMSよりも良い結果が出せることが明らかになったため、NLMSをsign</span><span class="o">-</span><span class="n">sign</span><span class="w"> </span><span class="n">LMSに切り替える。同時にカスケード数をパラメータ化する。</span><span class="w"></span>

<span class="n">軽く負荷を測ったらLMSの係数更新で結構食ってた。でも、係数更新は符号だけできまるから、テーブル引きに変えられるはず。→2019</span><span class="mf">.5.2</span><span class="n">の朝にやった。x400がx200になった。しかしまだ負荷が高い状態。</span><span class="w"></span>

<span class="c1">### 2019.5.2</span><span class="w"></span>

<span class="n">金沢に移動。特急券の時間を変えてもらって16</span><span class="o">:</span><span class="n">09発の新幹線に乗った。17</span><span class="o">:</span><span class="n">56佐久平着までに進められるだけ進める。やりたいのは、上記の高速化。</span><span class="w"></span>

<span class="n">『音声の線形予測』を読んでいると、1乗算型を実現するのは困難であることが分かる。1乗算型は通常の格子フィルタをKelly</span><span class="o">-</span><span class="n">Lochbaumモデルに変形してから導き出すが、それを行うと、追加でタップパラメータを計算する必要が出てくる。タップパラメータの計算精度を担保するのは難しい上に、（次数分の）追加の記憶容量が必要になるので到底許容できない。</span><span class="w"></span>

<span class="c1">### 2019.5.3</span><span class="w"></span>

<span class="n">実家にて作業。RGRいわきはしゃあない。圧縮をどうしても優先したかった（人生に関わることだから）。本日は以下の作業を行う予定：</span><span class="w"></span>

<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">→</span><span class="w"> </span><span class="kt">double</span><span class="w"></span>
<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ブロックサイズ決定を最大ブロックサイズから初め、最大ブロックサイズの中の小分割の中で一番サイズが小さくなるものを採用する</span><span class="w"></span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="n">エンコード高速化（最大ブロックサイズ毎で処理が独立になるので並列実行可能）にもなるので、こちらで行きたい。</span><span class="w"></span>

<span class="n n-Quoted">`float -&gt; double`</span><span class="n">はエイヤでやる。なまじ高速化を意識するから気持ちが悪いことになっているのだ。</span><span class="n n-Quoted">`double`</span><span class="n">でちゃんと動くものを作って（アルゴリズム的に高速化して）、後で実装レベルの高速化を行えば良い。</span><span class="w"></span>
<span class="n">→やった。</span><span class="w"></span>

<span class="n">ブロックサイズ決定の前に、今の圧縮結果をメモしておく。</span><span class="w"></span>
</code></pre></div>

<p>-rw-r--r--@  1 *  staff  39849911 May  3 12:37 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30014592 May  3 12:37 SPARKLE.sla
-rw-r--r--@  1 *  staff     51122 May  3 12:36 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff    777422 May  3 12:40 voice48a.sla
-rw-r--r--@  1 *  staff  23332503 May  3 12:39 Dream_goes_On.sla</p>
<div class="highlight"><pre><span></span><code><span class="n">当初の目標</span><span class="err">（</span><span class="n">ワン</span><span class="err">・</span><span class="n">ツー</span><span class="err">・</span><span class="n">スィーツで40MB切る</span><span class="err">）</span><span class="n">は既に達成済みではある</span><span class="err">。</span><span class="n">長尺の音声ではwavpack</span><span class="p">(</span><span class="o">-</span><span class="n">hhの最高圧縮</span><span class="p">),</span><span class="w"> </span><span class="n">ttaよりよい圧縮率を出している状況</span><span class="err">。</span><span class="n">しかし眼前にはTAKがいる</span><span class="err">。</span><span class="w"></span>

<span class="n">最大ブロックサイズの小分割の件</span><span class="err">、</span><span class="n">等分割による実装はできたが</span><span class="err">、</span><span class="n">圧縮率が悪化</span><span class="err">。</span><span class="n">当然な気がする</span><span class="err">。</span><span class="n">以前は現段階での最小推定値を常に使用していたのだから</span><span class="err">。</span><span class="n">最大ブロックサイズ内の分割についていい方法は無いか考えていたら</span><span class="err">、</span><span class="n">どうも最短経路問題に帰着できそうな気配</span><span class="err">。</span><span class="n">符号長さが辺の重みになる</span><span class="err">。</span><span class="n">ダイクストラ法が適用できる</span><span class="err">。</span><span class="w"></span>

<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">[</span><span class="n">ダイクストラ法(C言語)</span><span class="o">]</span><span class="p">(</span><span class="nl">http</span><span class="p">:</span><span class="o">//</span><span class="n">blue</span><span class="o">-</span><span class="mf">9.</span><span class="n">hatenadiary</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">entry</span><span class="o">/</span><span class="mi">2018</span><span class="o">/</span><span class="mi">01</span><span class="o">/</span><span class="mi">25</span><span class="o">/</span><span class="mi">190000</span><span class="p">)</span><span class="w"></span>
<span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">[</span><span class="n">ダイクストラ (Dijkstra) 法</span><span class="o">]</span><span class="p">(</span><span class="nl">http</span><span class="p">:</span><span class="o">//</span><span class="n">nw</span><span class="p">.</span><span class="n">tsuda</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">jp</span><span class="o">/</span><span class="n">lec</span><span class="o">/</span><span class="n">dijkstra</span><span class="o">/</span><span class="p">)</span><span class="w"></span>

<span class="mi">22</span><span class="err">:</span><span class="mi">45</span><span class="w"> </span><span class="n">ダイクストラ法のコア部分は多分できている</span><span class="err">（</span><span class="n">テスト中</span><span class="err">）。</span><span class="n">風呂入っている時に</span><span class="err">、</span><span class="n">アルファ符号取得の高速化は8bitパターンの結果を全てキャッシュしておけば良さそうだというのを思いつく</span><span class="err">。</span><span class="w"></span>

<span class="err">```</span><span class="nl">c</span><span class="p">:</span><span class="n">擬似コード</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">uint8_t</span><span class="w"> </span><span class="n">zero_runlength_table</span><span class="o">[</span><span class="n">0xFF</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 0 -&gt; 8 */</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="cm">/* 1 -&gt; 0 */</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="cm">/* 2 -&gt; 1 */</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="err">}</span><span class="p">;</span><span class="w"></span>
<span class="n">run</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zero_runlength_table</span><span class="o">[</span><span class="n">bitsbuf</span><span class="o">]</span><span class="p">;</span><span class="w"></span>
<span class="cm">/* もし8ならばまだ続いているので再度読み込む */</span><span class="w"></span>
</code></pre></div>

<p>25:30 やっつけでなんか動いているけど、結果はあまり良くない。等分割よりはすこし良くなった程度。しかし、一つ工夫を考えられた。探索範囲を広くとってその中で探索する。その時大事なのが最大ブロックサンプル数=探索範囲とせず、最大ブロックサンプル数&lt;探索範囲とすること。こうすることで、より広い範囲の探索で最適な割り当てを探れるようになるはず。</p>
<p>26:20 上記の修正を当てようとしてバグを踏んでる。エンコードコンフィグの最大ブロックサイズを探索範囲より小さくし、最大ブロックサンプル数&lt;探索範囲としたときにバッファオーバーランしておかしなことになってる。探索範囲もコンフィグから指定できると良い。</p>
<h3>2019.5.3</h3>
<p>デバッグ作業。無音に近い時に推定符号長が負値になってダイクストラ法がうまく動かないバグがあった。</p>
<p>とりあえず動いているようだけども結果は良くない。短い音声では良くなったが、長い音声で軒並み悪化。あがいてプリエンファシスをかけた音声に解析を行うけども結果は悪化。</p>
<p>振幅が大きい音声では、どうも長めにブロックサイズを割り当てた方がサイズが減るようだ。（最低ブロックサイズを増やしたところ比較的性能向上）LMSがいい味出していて、収束して圧縮が効いてくるまでに長いブロックサイズを必要としているように見える。</p>
<p>しっかし原理的にはその場で最短符号を探すよりも、広い範囲での最短符号を探したほうが絶対良いと思うのだが…実装ミスを疑う。</p>
<p>あとは、探索範囲を広げてみる。→傾向は上と同じ…最低ブロックサイズに引っ張られている。原理的に減るはずなのに、おかしい…。</p>
<p>推定コード長にブロックヘッダサイズを付加することで多少安定した。それでも傾向はほぼ同じ。もしかして原理的に減らないのかもしれない。グリーディな方法と選ばせるのが良いか？</p>
<p>→最大ブロックサイズを16384から12288に変えたら、比較的結果が安定した。16384では長すぎる？</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  39868406 May  4 18:54 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30161132 May  4 18:54 SPARKLE.sla
-rw-r--r--@  1 *  staff     50984 May  4 18:53 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff    772613 May  4 18:54 voice48a.sla
-rw-r--r--@  1 *  staff  23259269 May  4 18:55 Dream_goes_On.sla
</code></pre></div>

<p>短くかつ振幅が小さい音源の性能が改善したが、振幅の大きい音声（特にSPAKLE）は悪化。</p>
<p>いろいろあがいていたら20:30。終わりが見えてきている。ブロックヘッダサイズを大きくとったら全体的に性能が安定した。どうやら、パスを長くした時のペナルティを多くしたほうが性能が安定するようだ（実際、ブロックサイズを細かくしすぎると、ブロック先頭の残差増加や、LMSが収束しない等が発生してサイズが増加する）。ペナルティサイズを350byteにした時の結果は以下：</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  39761815 May  4 21:38 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30049221 May  4 21:38 SPARKLE.sla
-rw-r--r--@  1 *  staff     51077 May  4 21:39 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff    773953 May  4 21:39 voice48a.sla
-rw-r--r--@  1 *  staff  23297954 May  4 21:39 Dream_goes_On.sla
</code></pre></div>

<p>全部下がったわけではないが、性能は安定しているようだし、これで一旦Fixとしようか。（グリーディな方法と比較したところ、自分の声シリーズで0.2%改善、アイカツ楽曲で0.1%悪化。今の状態でバランスが取れたし、また並列エンコードへの道が見えたからこれでFixとする。）</p>
<p>→コードを整理してコミット。</p>
<p>時間がかかるようになっているので、ネックになっているところを調べたら自己相関が馬鹿になっていなかった。自己相関を簡単に高速化した。</p>
<p>```c:高速化前
  /<em> （標本）自己相関の計算 </em>/
  for (delay_time = 0; delay_time &lt; order; delay_time++) {
    auto_corr[delay_time] = 0.0f;
    /<em> 係数が0以上の時のみ和を取る </em>/
    for (i_sample = delay_time; i_sample &lt; num_sample; i_sample++) {
      auto_corr[delay_time] += data[i_sample] * data[i_sample - delay_time];
    }
  }</p>
<div class="highlight"><pre><span></span><code><span class="n">上記の計算だと積算で使用する項に重複が出る</span><span class="err">。</span><span class="n">重複を排除したのが以下の計算</span><span class="err">（『</span><span class="n">音声の線形予測</span><span class="err">』</span><span class="n">とFLACを参考にしている</span><span class="err">）。</span><span class="n">重複する項を</span><span class="err">`</span><span class="n">tmp</span><span class="err">`</span><span class="n">に受けて積和演算を行っている</span><span class="err">。</span><span class="w"></span>

<span class="err">```</span><span class="nl">c</span><span class="p">:</span><span class="n">高速化後</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* 係数初期化 */</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">lag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">lag</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">order</span><span class="p">;</span><span class="w"> </span><span class="n">lag</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="n">auto_corr</span><span class="o">[</span><span class="n">lag</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="n">f</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="err">}</span><span class="w"></span>

<span class="w">  </span><span class="cm">/* 次数の代わりにデータ側のラグに注目した自己相関係数計算 */</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">smpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">smpl</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">num_sample</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">order</span><span class="p">;</span><span class="w"> </span><span class="n">smpl</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">smpl</span><span class="o">]</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 同じラグを持ったデータ積和を取る */</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">lag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">lag</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">order</span><span class="p">;</span><span class="w"> </span><span class="n">lag</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">      </span><span class="n">auto_corr</span><span class="o">[</span><span class="n">lag</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">smpl + lag</span><span class="o">]</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="err">}</span><span class="w"></span>
<span class="w">  </span><span class="err">}</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">smpl</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sample</span><span class="p">;</span><span class="w"> </span><span class="n">smpl</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">smpl</span><span class="o">]</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">lag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">lag</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_sample</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">smpl</span><span class="p">;</span><span class="w"> </span><span class="n">lag</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">      </span><span class="n">auto_corr</span><span class="o">[</span><span class="n">lag</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">smpl + lag</span><span class="o">]</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="err">}</span><span class="w"></span>
<span class="w">  </span><span class="err">}</span><span class="w"></span>
</code></pre></div>

<p>根本的にはFFTを使うべき…。</p>
<h3>2019.5.4</h3>
<p>明日の帰りが早いこともあるので今日は大きな実装変更はしない予定。エンコード負荷が気になるので計測と可能ならば手直しを入れる。</p>
<p>ロングタームの3,5,...対応はまだ後回し。</p>
<p>負荷結果をざっと見ると、負荷が大きいのは自己相関計算に尽きる。</p>
<ul>
<li>最適分割探索の際の係数計算における自己相関</li>
<li>ロングターム係数計算時のFFTによる自己相関</li>
</ul>
<p>SIMD, OpenMPで頑張るのはまだ先の話。（俺がやるべきでも無いと思う）</p>
<p>LMSの更新量の重みを上げた（右シフト9から右シフト7に変えた）ところ性能が上がった…。（右シフト6では悪化に転じた。）</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  39571790 May  5 16:31 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29824752 May  5 16:30 SPARKLE.sla
-rw-r--r--@  1 *  staff     50937 May  5 16:30 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff    770970 May  5 16:32 voice48a.sla
-rw-r--r--@  1 *  staff  23047704 May  5 16:34 Dream_goes_On.sla
</code></pre></div>

<p>まだSign-Sign LMSには謎が多い。一回腰を据えて適応フィルタの理論を読むべきか。→日本語版が法外に高いので英語版を購入。</p>
<ul>
<li><a href="http://users.ics.forth.gr/tsakalid/UVEG09/Book/Haykin-AFT(3rd.Ed.)_Introduction.pdf">Adaptive Filter Theory 3rd（イントロのみ）</a></li>
</ul>
<p>Sign-Sign LMSの計算途中で、係数が32bitの範囲でオーバーフローしていることが分かった。係数を32bitにしたら圧縮性能が堕ちたので判明。FIRフィルターだから係数の範囲は予測できない…。どっかで制限をかける等できれば…。</p>
<h3>2019.5.5</h3>
<p>昨日の自己相関の計算が遅い件について、もう少し早いアルゴリズムが『音声のディジタル信号処理（上）』の172pあたりに書いてあったので実装中。</p>
<p>→実装したが速度に納得できず、しかも複雑になっている。本に書いてある計算式は変形自己相関で、データのインデックスが飛び出ることを許す式になっている。（平均を常にNで割って行える式）なので自前で簡潔な実装にしようとしたところ、案の定ハマる。</p>
<p>RL見なければいけないので一旦置く。。。</p>
<h3>2019.5.7</h3>
<p>5.6は実家から返りながら上の自己相関計算の高速化をやっていた。変形自己相関ではない方法で計算する実装は2019.5.7にできた。テストもOKで、2倍とは行かないまでもSPARKLEで自己相関計算負荷が44%が39.8%になっているのは確認した。有意に早くなっている。</p>
<h3>2019.5.13</h3>
<p>いよいよ手詰まりとなる。（ロングターム係数を増やすのはまだだが）</p>
<p>TAKのデコーダ実装がffmpegに含まれていた：</p>
<ul>
<li><a href="https://github.com/FFmpeg/FFmpeg/blob/a0ac49e38ee1d1011c394d7be67d0f08b2281526/libavcodec/takdec.c">libavcodec/takdec.c</a></li>
</ul>
<p>といっても新しいバージョンではデコードできないとのこと。。。（パッチも当てられていない…）。読んでいるが、謎のテーブルを使用しているのが目につく。（TAKの公式ページではハフマンとライスを組み合わせたものと言っていた。だから、ライス符号パラメータをインデックスにした静的ハフマン符号ではないかと予測する。）</p>
<p>ロングターム係数の次数を増やして、効果を見て区切りかな。
他に気付いている点は、格子型フィルタの前向き誤差は実はメモリに持たなくても実装できる点くらいだろうか…</p>
<h3>2019.5.18</h3>
<p>平日は時間あまり取れず。やっつけでLU分解のソースを移植したくらい。LU分解では処理中にワーク領域を必要としていたので、ハンドルをもたせた。また、計算時のユーティリティだから、SLAUtilityに置く。</p>
<p>→15:20 LU分解によるソルバー追加完了。あとは解いて様子見。</p>
<p>思いつきでPARCOR音声合成の僅かな高速化。実は合成時は前向き誤差を保存する必要はない。</p>
<p>```c:変更前
    /<em> 誤差入力 </em>/
    forward_residual[order] = (int64_t)residual[samp];
    for (ord = order; ord &gt;= 1; ord--) {
      /<em> 前向き誤差計算 </em>/
      mul_temp = SLAUTILITY_SHIFT_RIGHT_ARITHMETIC(parcor_coef[ord] * backward_residual[ord - 1] + half, 31);
      forward_residual[ord - 1] = forward_residual[ord] + mul_temp;
      /<em> 後ろ向き誤差計算 </em>/
      mul_temp = SLAUTILITY_SHIFT_RIGHT_ARITHMETIC(parcor_coef[ord] * forward_residual[ord - 1] + half, 31);
      backward_residual[ord] = backward_residual[ord - 1] - mul_temp;
    }
    /<em> 合成信号 </em>/
    assert((forward_residual[0] &lt;= INT32_MAX) &amp;&amp; (forward_residual[0] &gt;= INT32_MIN));
    output[samp] = (int32_t)(forward_residual[0]);
    /<em> 後ろ向き誤差計算部にデータ入力 </em>/
    backward_residual[0] = forward_residual[0];</p>
<div class="highlight"><pre><span></span><code><span class="err">```</span><span class="nl">c</span><span class="p">:</span><span class="n">変更後</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 誤差入力 */</span><span class="w"></span>
<span class="w">    </span><span class="n">int64_t</span><span class="w"> </span><span class="n">forward_res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">residual</span><span class="o">[</span><span class="n">samp</span><span class="o">]</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">ord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">order</span><span class="p">;</span><span class="w"> </span><span class="n">ord</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">ord</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">      </span><span class="cm">/* 前向き誤差計算 */</span><span class="w"></span>
<span class="w">      </span><span class="n">mul_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SLAUTILITY_SHIFT_RIGHT_ARITHMETIC</span><span class="p">(</span><span class="n">parcor_coef</span><span class="o">[</span><span class="n">ord</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">backward_residual</span><span class="o">[</span><span class="n">ord - 1</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="mi">31</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">forward_res</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">mul_temp</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="cm">/* 後ろ向き誤差計算 */</span><span class="w"></span>
<span class="w">      </span><span class="n">mul_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SLAUTILITY_SHIFT_RIGHT_ARITHMETIC</span><span class="p">(</span><span class="n">parcor_coef</span><span class="o">[</span><span class="n">ord</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">forward_res</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="mi">31</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">backward_residual</span><span class="o">[</span><span class="n">ord</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">backward_residual</span><span class="o">[</span><span class="n">ord - 1</span><span class="o">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mul_temp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="err">}</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 合成信号 */</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">((</span><span class="n">forward_res</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">INT32_MAX</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">forward_res</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">INT32_MIN</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="o">[</span><span class="n">samp</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">int32_t</span><span class="p">)(</span><span class="n">forward_res</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* 後ろ向き誤差計算部にデータ入力 */</span><span class="w"></span>
<span class="w">    </span><span class="n">backward_residual</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">forward_res</span><span class="p">;</span><span class="w"></span>
</code></pre></div>

<p>前向き誤差がキャッシュされるので当然早くなる。SPARKLEで100ms（全体で15.8%→10.7%）程の改善。遊んでないで、ロングタームに戻ろう。</p>
<p>ロングターム実装OK。早速、タップ数を上げて試してみる。</p>
<p>```sh:タップ数3
-rw-r--r--@  1 *  staff  39556836 May 18 16:57 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29836474 May 18 16:56 SPARKLE.sla
-rw-r--r--@  1 *  staff     50923 May 18 16:58 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff    770757 May 18 16:55 voice48a.sla
-rw-r--r--@  1 *  staff  23064285 May 18 16:58 Dream_goes_On.sla</p>
<div class="highlight"><pre><span></span><code>```sh:タップ数5
-rw-r--r--@  1 *  staff  39568754 May 18 17:02 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29847311 May 18 17:03 SPARKLE.sla
-rw-r--r--@  1 *  staff     50930 May 18 17:01 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff    771036 May 18 17:01 voice48a.sla
-rw-r--r--@  1 *  staff  23064514 May 18 17:03 Dream_goes_On.sla
</code></pre></div>

<p>上げたら悪化（効果はあまり大きくない）。これはもしかしたらロングターム係数失敗回数が多くなっているのかもしれない。簡単に調べたところその通りで、SPARKLEでは、タップ数3で406回、タップ数5で742回失敗していた。係数が安定するまでタップ数を落とすのがいいかも。（とりあえず今は、係数が発散していたらタップ数を強制的に1にしている。）また、ロングタームを複数回適用するのも有りかも。（効果は薄そう…一番のピッチをロングタームで潰しても少ししか効果がなかったし…）</p>
<p>実装をまとめた。これにてベータ版としたい。もう1MB減らすアイデアがあればTAKを倒せるが…。</p>
<h3>2019.5.19</h3>
<p>以下の論文を読んでいた：</p>
<ul>
<li><a href="https://pdfs.semanticscholar.org/ad7c/dc0865ff40fcac9bae02ccc77a24105a4e26.pdf">THE LOG?LOG LMS ALGORITHM</a></li>
</ul>
<p>要は、LMSの計算の係数更新で、最も近い2の冪数に変えて演算するように変えたもの。今はSign-Sign LMSだが、筆者は論文の中で、それは非常に荒く量子化した状態と同じと言及していた（理論的には、絶対値誤差を最小にしているのだが…）</p>
<p>そこで、Sign-Signをナイーブにやるのではなく、負荷は上がるけど誤差項のみlog2を取るように変えてみた（注：上の論文とは違う。論文では最も近い2の冪数にしていたが、こっちは単純にlogをとっている）ら、ほとんどの音源で性能が向上。</p>
<div class="highlight"><pre><span></span><code>-rw-r--r--@  1 *  staff  39555825 May 19 18:45 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29780060 May 19 19:04 SPARKLE.sla
-rw-r--r--@  1 *  staff     50879 May 19 19:02 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  23082381 May 19 18:47 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    770037 May 19 18:53 voice48a.sla
</code></pre></div>

<p>（Dream goes onで性能悪化している。それ以外は向上。）</p>
<p>どうするか。これ取り込んでFixとする？→取り込み、更新をテーブル引きにした。これで一旦beta版としよう。</p>
<h3>2019.5.21</h3>
<p>LMSの係数更新って毎サンプル行う必要はあるのだろうか。更新間隔を間引いてもいいのかも？</p>
<p>VSで負荷計ったら、復号処理でアルファ符号を取得するところが遅いことが分かった。やはりバイトパターンテーブルからランレングスを取るのがいいかも。やってみる。</p>
<p>他にも自己相関の加算対象はオート変数が良いかも。</p>
<ul>
<li><a href="https://wandbox.org/permlink/Fqtn0WIBvyGaPWYg">wandboxdで試作したラン長取得マスク</a></li>
</ul>
<h3>2019.5.23</h3>
<p>コマンドラインパーサを作りたい。業務が終わらんくてあんまり作業できてない。</p>
<p>なんとかアルファ符号取得時にテーブルを使用するように変えて、速度向上。もう一度負荷計測したら、GetBitsとそのLog2Ceilで負荷がかかっていた：</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="cm">/* ライス符号の剰余部分取得 */</span><span class="w"></span>
<span class="w">  </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SLABitStream_GetBits</span><span class="p">(</span><span class="n">strm</span><span class="p">,</span><span class="w"> </span><span class="n">SLAUtility_Log2Ceil</span><span class="p">(</span><span class="n">m</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rest</span><span class="p">);</span><span class="w"></span>
</code></pre></div>

<p>この引数で渡しているmは2の冪数だから、高速にlog2できないか？</p>
<h3>2019.5.25</h3>
<p>みなとみらい（ランドマークプラザ）のコメダ。
今日はlog2ceilの高速化をまずやってコマンドラインパーサの仕様を考える。log2ceilの高速化まあOK。要はテーブル引き。効果はわずかだが、確かに早くはなっている。</p>
<p>コマンドラインパーサの仕様を考える。まず汎用に使いたいので名前は<code>command_parser.[ch]</code>とする。ヘッダは、</p>
<p>```c:command_parser.h</p>
<h1>include <stdint.h></h1>
<p>/<em> 最大の文字列バッファサイズ </em>/</p>
<h1>define COMMAND_PARSER_MAX_STRING_BUFFER_SIZE   256</h1>
<p>/<em> 取得結果 </em>/
typedef enum CommandPaeserResultTag {
    COMMAND_PARSER_RESULT_OK,                             /<em> 正常終了 </em>/
    COMMAND_PARSER_RESULT_INSUFFICIENT_FILE_BUFFER_SIZE,  /<em> ファイルバッファサイズが足らない </em>/
    COMMAND_PARSER_RESULT_NOT_SPECIFY_OPTION_TO_ARGUMENT, /<em> 引数の指定が必須のオプションが指定されていない </em>/
    COMMAND_PARSER_RESULT_NOT_SPECIFY_MANDATORY_OPTION,   /<em> 指定が必須のオプションが指定されていない </em>/
    COMMAND_PARSER_RESULT_UNKOWN_OPTION,                  /<em> 定義にないオプションが指定された </em>/
} CommandPaeserResult;</p>
<p>/<em> 論理定数 </em>/
typedef enum CommandParserBoolTag {
    COMMAND_PARSER_FALSE = 0,   /<em> 偽 </em>/
    COMMAND_PARSER_TRUE,        /<em> 真 </em>/
} CommandParserBool;</p>
<p>/<em> コマンドラインパーサ仕様 </em>/
struct CommandParserSpecification {
    char                short_option;       /<em> [in] 短いオプション文字列 </em>/
    const char<em>         long_option;        /</em> [in] 長いオプション文字列 <em>/
    CommandParserBool   need_argument;      /</em> [in] オプションに引数は必要か？ <em>/
    CommandParserBool   mandatory;          /</em> [in] 引数の指定は必須か？ <em>/
    const char</em>         description;        /<em> [in] 引数の説明 </em>/
    char                argument_string[COMMAND_PARSER_MAX_STRING_BUFFER_SIZE]; /<em> [out] 得られた文字列 </em>/
    CommandParserBool   is_acquired;        /<em> [out] オプションが指定されたか？ </em>/
};</p>
<p>/<em> 引数説明の印字 </em>/
void CommandParser_PrintDescription(const CommandParserSpecification* cps);</p>
<p>/<em> 引数のパース </em>/
CommandPaeserResult CommandPaser_ParseArguments(
    int32_t argc, const char<strong> argv,
    struct CommandParserSpecification* cps,
    char</strong> filename_list, uint32_t filename_list_size);</p>
<div class="highlight"><pre><span></span><code><span class="err">```</span><span class="nt">c</span><span class="p">:</span><span class="nd">コマンドラインパーサ仕様の定義例</span><span class="w"></span>
<span class="nt">struct</span><span class="w"> </span><span class="nt">CommandParserSpecification</span><span class="w"> </span><span class="nt">arguments</span><span class="cp">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c">/* 入力ファイル: ショートオプション&#39;i&#39;, ロングオプション&quot;input&quot;, 引数必須, 指定必須 */</span><span class="w"></span>
<span class="w">    </span><span class="err">{</span><span class="w"> </span><span class="err">&#39;i&#39;,</span><span class="w"> </span><span class="err">&quot;input&quot;,</span><span class="w"> </span><span class="err">COMMAND_PARSER_TRUE,</span><span class="w"> </span><span class="err">COMMAND_PARSER_TRUE,</span><span class="w"> </span><span class="err">&quot;input</span><span class="w"> </span><span class="err">file&quot;,</span><span class="w"> </span><span class="err">&quot;&quot;</span><span class="w"> </span><span class="p">}</span><span class="o">,</span><span class="w"></span>
<span class="w">    </span><span class="c">/* 出力ファイル: ショートオプション&#39;o&#39;, ロングオプション&quot;output&quot;, 引数必須 */</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="err">&#39;o&#39;,</span><span class="w"> </span><span class="err">&quot;output&quot;,</span><span class="w"> </span><span class="err">COMMAND_PARSER_TRUE,</span><span class="w"> </span><span class="err">COMMAND_PARSER_FALSE,</span><span class="w"> </span><span class="err">&quot;output</span><span class="w"> </span><span class="err">file&quot;,</span><span class="w"> </span><span class="err">&quot;&quot;</span><span class="w"> </span><span class="p">}</span><span class="o">,</span><span class="w"></span>
<span class="w">    </span><span class="c">/* 最適化オプション: ショートオプション&#39;p&#39;, ロングオプションなし, 引数必須 */</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="err">&#39;p&#39;,</span><span class="w"> </span><span class="err">NULL,</span><span class="w"> </span><span class="err">COMMAND_PARSER_TRUE,</span><span class="w"> </span><span class="err">COMMAND_PARSER_FALSE,</span><span class="w"> </span><span class="err">&quot;optimization</span><span class="w"> </span><span class="err">level&quot;,</span><span class="w"> </span><span class="err">&quot;&quot;</span><span class="w"> </span><span class="p">}</span><span class="o">,</span><span class="w"></span>
<span class="w">    </span><span class="c">/* 情報表示: ショートオプション&#39;v&#39;, ロングオプション&quot;verpose&quot; */</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="err">&#39;v&#39;,</span><span class="w"> </span><span class="err">&quot;verpose&quot;,</span><span class="w"> </span><span class="err">COMMAND_PARSER_FALSE,</span><span class="w"> </span><span class="err">COMMAND_PARSER_FALSE,</span><span class="w"> </span><span class="err">&quot;verpose</span><span class="w"> </span><span class="err">information&quot;,</span><span class="w"> </span><span class="err">&quot;&quot;</span><span class="w"> </span><span class="p">}</span><span class="o">,</span><span class="w"></span>
<span class="w">    </span><span class="c">/* サイレントモード: ショートオプション&#39;s&#39;, ロングオプション&quot;silent&quot; */</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="err">&#39;s&#39;,</span><span class="w"> </span><span class="err">&quot;silent&quot;,</span><span class="w"> </span><span class="err">COMMAND_PARSER_FALSE,</span><span class="w"> </span><span class="err">COMMAND_PARSER_FALSE,</span><span class="w"> </span><span class="err">&quot;silent</span><span class="w"> </span><span class="err">mode&quot;,</span><span class="w"> </span><span class="err">&quot;&quot;</span><span class="w"> </span><span class="p">}</span><span class="o">,</span><span class="w"></span>
<span class="w">    </span><span class="nt">NULL</span><span class="w">    </span><span class="c">/* 最後はNULLターミネート */</span><span class="w"></span>
<span class="err">}</span><span class="o">;</span><span class="w"></span>
</code></pre></div>

<p>Log2Ceilの負荷が高い。LMSでLog2Ceilをサンプルごとに読んでいるがこれが大きな負荷になっている…（SPARKLEでは2.7秒の処理時間の内150ms使っている）。負荷を取るか、圧縮率を取るか…。</p>
<p>2の冪に対するlog2呼び出しは明らかに一箇所からしか呼ばれないので、Utilityにある必要はないように見える。インライン関数展開されることを期待する意味も込めて、Coder側に移動して良いかも。→やったら最早負荷リストに乗らなくなった。</p>
<h3>2019.5.26</h3>
<p>コマンドラインパーサを作成する。</p>
<p>一応仕様は見えたけど、いきなり大きく作ると混乱しそうだから、まずはショートオプション対応版をつくる。</p>
<p>16:57 ロングオプション対応含めだいたいできた。エラー発生時にエラー出力するかどうかが迷いどころ。もう少し整理したらmain.cに取り込んでいく。</p>
<h3>2019.5.28</h3>
<p>コマンドラインパーサを追加。テストも追加。mandatoryは邪魔（<code>-o</code>を必須にしていたが、それだと<code>-h</code>だけでもエラーになってしまう。また、必須の判定はユーザがやればいい。）だし、-i, -o は指定必須だからオプションじゃなくていいかな。</p>
<h3>2019.5.29</h3>
<p>bonkなるフォーマットはPARCORを使っているようだ。ソースも短いので見てみる。→レビンソン-ダービン法をめちゃくちゃ改善しているようだった。読み解けない…</p>
<h3>2019.6.1</h3>
<p>6月は32bit演算対応を模索したい。最終的にSIMD化するときに、原理上ワード長で速度に差が出ると感じている。あと適応フィルタの本を読んで、LMSにさらなる改良を加えたい。</p>
<p>bit幅の変動を観察していたら、まずPARCOR予測の入力がすでにbit幅が17bitになっていることが分かった。原因を見ていたらMS処理のところでsideが引き算になっていて、これによりbit幅が増加していた。（例えば、Lchが30000、Rchが-30000のとき、side = L - R = 30000 - (-30000) = 60000。60000は符号付き16bitで表現できない。）</p>
<p>いろいろとbit幅増加要因がありそうなので、データ加工フローを見直してみる。以下の結果は符号ビットを含めている。</p>
<ol>
<li>入力データ：16bit</li>
<li>MS処理のsideの引き算処理：17bit</li>
<li>プレエンファシスフィルタの最大予測誤差を加味：18bit<ul>
<li>プリエンファシスにより大体の音声で絶対値は小さくなる、が、例外あり。 </li>
</ul>
</li>
<li>PARCOR</li>
<li>ロングターム</li>
<li>LMS</li>
<li>エンコード</li>
</ol>
<p>予測フィルタに入る前までに幅が18bitになっている。
予測は最大16bit幅で行うから、18bitで入ってきた場合は、2bitの切り捨てを入れないといけない。無条件に2bitの切り捨てを行うと、誤差は増える方向にしかいかない。</p>
<p>おそらく必須になるのが、入力データをもれなく表現できる最小ビット幅の計測関数。やることはデータのABSの最大値を探してそのlog2ceilをとって+1する。（最後の+1は負値対応）</p>
<ol>
<li>入力データ：16bit</li>
<li>MS処理のsideの引き算処理：17bit</li>
<li>プレエンファシスフィルタの最大予測誤差を加味：18bit</li>
<li>PARCOR：積和演算を<strong>15bit</strong>幅で行い、予測時に元のデータのビット幅に合わせる：19bit？<ul>
<li>元のデータのビット幅をXbitとしたら、X&gt;15ならばフィルタ入力時に(X-15)ビット算術右シフトする</li>
<li>予測として得られた15bitデータを(X-15)ビット左シフトする。（(X-15)が負ならば(15-X)算術右シフト）</li>
</ul>
</li>
<li>ロングターム：積和演算を<strong>15bit</strong>幅で行い、予測時に元のデータのビット幅に合わせる：20bit？</li>
<li>LMS：積和演算を<strong>15bit</strong>幅で行い、予測時に元のデータのビット幅に合わせる：21bit？</li>
<li>エンコード</li>
</ol>
<p>別件で一点。ライス符号のパラメータが変化するところはあまりないのに、今はサンプル毎の更新処理を入れている。だから、パラメータが変化するところだけをマークして、パラメータが2倍になるのか1/2になるのかがわかれば原理的に早くなる。</p>
<h3>2019.6.2</h3>
<p>秋葉原製作所5hコース。今日は引き続き、積和演算の32bit化を検討する。</p>
<p>重要なのは積の瞬間に32bitの表現範囲を超えてしまうこと。だから積の瞬間だけ後ろ向き・前向き誤差を16bitに丸めれば良い。</p>
<p>問題は右シフト量をどうやってデコーダ側に渡すかという点。予測／合成関数の引数に右シフト量を追加するか？予測／合成を呼び出す側でシフト量を確定させてやれば良いのかも。</p>
<p>エンコーダ側で、なんとなく32bit積算ができた（無論サイズ悪化）ので、まずはテストに合格することを目標にする。テストにビット幅計測を追加する必要がある。</p>
<p>単体テストに追加してOKの様子。ミソは、入出力データには一切手を入れずに、乗算の精度だけを落とすということ。入出力データを右シフトすると復元できなくなる。ついでにUtilityにデータのビット幅計測関数を追加。</p>
<p>データのビット幅が16bitを超えていたら、PARCOR係数側を右シフトするようにした。これにより、演算時の後ろ向き・前向き誤差の右シフトが不要になった。（ここで、PARCOR係数の非線形量子化が活きてくるんだなあ…と直感。）</p>
<p>一旦小休止して、テストから本チャンへの移行を試みる。テストが通っているから、演算にはセーフなはずで、大事なのはエンコーダ・デコーダにビット幅を示すフィールドが追加されること。</p>
<p>PARCOR係数さえ正しくシフトしていれば良いことが分かったので、もはや予測ルーチンでは右シフトを行う必要が無いのでは。エンコーダ側でビット幅を計測、係数を右シフトして関数実行する形にしてみる。改めてテストが通ったら本チャン組み込み。</p>
<p>本チャン組み込みをした。テストは通っているし、手元の音源で元に戻るので一旦安心してしまって取り込む。なお、係数右シフト量を新規にブロックヘッダに追加している。そのため係数の精度悪化も合わせてサイズは増加している。</p>
<h3>2019.6.3</h3>
<p>暑さのせいか体力が持たない。LMSの32bit演算化を試みている。</p>
<ul>
<li>24bit Wavを食わせたら落ちたので原因を見ていたらサイズオーバーしていた…。また、俺の声24bitでも圧縮率が非常に悪い（ちょっと調べたらmonkey's audioも悪かった。FLAC以下の性能）。最小値ぶん右シフトするなりの対処はいるかも。</li>
<li>もしかしてと思って白色雑音を入れたら16bitでも例外発生。これは対処しないとだめだね。</li>
</ul>
<h3>2019.6.4</h3>
<p>歯医者。力尽きて寝ていてあまり作業できず。</p>
<p>サイズオーバー対策は、やはり確保するメモリを増やすしかない。また、EncodeBlock内でエラーチェックを強化する。</p>
<p>白色雑音は、EncodeBlock内でPARCOR係数計算後、分散比を見て予測するか否かをチェックする。分散比が閾値以下になっていなかったら、圧縮不可能として、生データを書き出す。</p>
<p>24bit対策は、まず原因調査しないと。そもそもあまり減っていないのがきになる。</p>
<p>また、コマンドラインパーサで文字列デフォルト値は書き変わってしまうためやめよう。全てdescriptionで説明しよう。</p>
<h3>2019.6.8</h3>
<p>平日ろくに動けず。以下の作業をやっていく：</p>
<ul>
<li>LMSはまず動いているか？16bitでオーバーフローなしで動くことを要確認。</li>
<li>LMSのカスケードは廃止。</li>
<li>mainの修正：文字列デフォルトを使わない。</li>
</ul>
<p>32bitに対応すると、LMSはやはり16bit整数以上で乗算時にオーバーフローする。</p>
<ul>
<li>係数：無制限に上がる／下がってしまう</li>
<li>入力信号：入力が16bitでない可能性がある。</li>
</ul>
<p>PARCORでは入力のビット幅に合わせて係数を右シフトしてしまうことで問題なかったが、LMSではそうもいかない。係数はいくらでも増減する。また、右シフト量はLMSの事前に計算して、記録しておかないとだめ。係数の値を見て右シフトするのは負荷が高い。積和演算の途中で32bit範囲を超える可能性がある。</p>
<p>上記の困難点が見えたので、LMSの32bit化は一旦断念する。</p>
<p>コマンドラインパーサを整理。デフォルトを廃止。同時に、APIを呼ぶときにいちいちスペックとスペック数を渡しているのがめちゃくちゃ冗長。ハンドル化するか、スペック数をなくして仕様リストをNULLターミネートする形に持っていきたい。→OK。NULLターミネートに変えた。</p>
<p>LMSのカスケードを廃止する…けど温情でもう少し観察してだめなことが分かったら廃止する。</p>
<p>```sh:次数10/カスケード1
-rw-r--r--@  1 *  staff  39558053 Jun  8 20:13 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29781967 Jun  8 20:14 SPARKLE.sla
-rw-r--r--@  1 *  staff     50878 Jun  8 20:14 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  23078354 Jun  8 20:12 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    770097 Jun  8 20:14 voice48a.sla</p>
<div class="highlight"><pre><span></span><code>```sh:次数5/カスケード2
-rw-r--r--@  1 *  staff  40076780 Jun  8 20:17 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30057429 Jun  8 20:16 SPARKLE.sla
-rw-r--r--@  1 *  staff     50889 Jun  8 20:15 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  22957174 Jun  8 20:18 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    770666 Jun  8 20:16 voice48a.sla
</code></pre></div>

<p>```sh:次数20/カスケード1
-rw-r--r--@  1 *  staff  39573905 Jun  8 20:21 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29785000 Jun  8 20:20 SPARKLE.sla
-rw-r--r--@  1 *  staff     50780 Jun  8 20:22 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  22879755 Jun  8 20:22 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    768107 Jun  8 20:22 voice48a.sla</p>
<div class="highlight"><pre><span></span><code>```sh:次数10/カスケード2
-rw-r--r--@  1 *  staff  39174228 Jun  8 20:09 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29607357 Jun  8 20:08 SPARKLE.sla
-rw-r--r--@  1 *  staff     50827 Jun  8 20:07 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  22656860 Jun  8 20:10 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    768789 Jun  8 20:10 voice48a.sla
</code></pre></div>

<p>```sh:次数5/カスケード4
-rw-r--r--@  1 *  staff  40024904 Jun  8 20:26 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30040884 Jun  8 20:25 SPARKLE.sla
-rw-r--r--@  1 *  staff     51036 Jun  8 20:27 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  34086796 Jun  3 00:42 DiamondSmile.sla
-rw-r--r--@  1 *  staff    772863 Jun  8 20:27 voice48a.sla</p>
<div class="highlight"><pre><span></span><code>```sh:次数40/カスケード1
-rw-r--r--@  1 *  staff  39280231 Jun  8 20:30 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29776691 Jun  8 20:31 SPARKLE.sla
-rw-r--r--@  1 *  staff     51114 Jun  8 20:32 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  22631773 Jun  8 20:31 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    773745 Jun  8 20:32 voice48a.sla
</code></pre></div>

<p>```sh:次数20/カスケード2
-rw-r--r--@  1 *  staff  39356907 Jun  8 20:35 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29691217 Jun  8 20:34 SPARKLE.sla
-rw-r--r--@  1 *  staff     50837 Jun  8 20:33 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  22479866 Jun  8 20:36 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    768416 Jun  8 20:33 voice48a.sla</p>
<div class="highlight"><pre><span></span><code>```sh:次数10/カスケード4
-rw-r--r--@  1 *  staff  39280231 Jun  8 20:41 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29776691 Jun  8 20:42 SPARKLE.sla
-rw-r--r--@  1 *  staff     51114 Jun  8 20:43 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  22631773 Jun  8 20:38 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    773745 Jun  8 20:42 voice48a.sla
</code></pre></div>

<p>ん？次数10/カスケード2が良い？ごめんやっぱ廃止できない。プリセットを修正。</p>
<h3>2019.6.9</h3>
<p>日曜日のTODOは、</p>
<ul>
<li>白色雑音対策</li>
<li>分散比を観察（実際に白色雑音で高くなっているか？）</li>
<li>圧縮しないモードを追加</li>
<li>24bit対策</li>
<li>最小値の算出機能追加</li>
<li>一般の24bitデータ対策</li>
</ul>
<p>もしかしたら24bit対応で絶望して結局PARCORも64bitになるかもしれない。</p>
<p>14:00に秋葉原製作所in。まずは白色雑音対策を打つ。6.8の夜の観察により、白色雑音では推定圧縮率（(1サンプルあたり推定符号長)/(元データのサンプルあたりビット数)）が0.98位になることを確認：</p>
<p>```sh:1秒間の白色雑音をエンコードした際の推定圧縮率
0.980077
0.980992
0.980059
0.980983</p>
<div class="highlight"><pre><span></span><code>他のデータでは0.90を超えることは稀であることを確認している。

![20190929123826p](./images/la_first_attempts/20190929123826.png)

雑に見積もって0.95以上ならば圧縮不可能と判定していいと考える。

→対策を行った。推定圧縮率が閾値以上ならば生データを書き出すように修正。これに伴ってブロックデータタイプを新しく導入。今の所、圧縮済みデータか、無音か、生データの3種類が存在する。

さて、いよいよ24bit対策に入る。

24bitデータを食わせると、以下のアサートを吐いて死んでしまう（少し気になって8bitも試したけど大丈夫だった。FLACよりよい結果が出ている。）：

```sh
Assertion failed: (init_param &lt; (1UL &lt;&lt; 16)), function SLACoder_PutDataArray, file SLACoder.c, line 462.
</code></pre></div>

<p>→これは初期パラメータのサイズ不足。24bitデータならば24bitレンジで初期値が出る。元データのビット幅を引数として渡し、そのビット数で符号化するように修正すれば良さそう。ひとまず24bit符号化して回避。</p>
<div class="highlight"><pre><span></span><code>Assertion failed: <span class="o">(</span>encoder-&gt;parcor_rshift<span class="o">[</span>ch<span class="o">]</span> &lt; <span class="o">(</span>1UL &lt;&lt; <span class="m">3</span><span class="o">))</span>, <span class="k">function</span> SLAEncoder_EncodeBlock, file SLAEncoder.c, line <span class="m">610</span>.
</code></pre></div>

<p>→ビット幅が24のときに、右シフト量が24-16=8になる。8は3ビットで保存できない。と思ったらビット幅が25とか出てきた。これは明らかなバグ。ワン・ツー・スイーツでも17が出ている。→バグじゃなかった。プリエンファシスで16bit幅を超えてる！</p>
<p>16bitwavを左シフトして作ったダイヤモンドスマイルの結果がかなり悪い。右シフト量が大きくて、PARCOR係数の精度がひどいことになっている。<strong>データ側のシフトに切り替えてみたが、状況はあまり変わらず悪化。</strong>（係数を右シフトするよりは圧縮率はよかった。ただし実装が複雑化。関数引数に変化あり。速度は自明に低下。つらい。）</p>
<p>FLAC, wavpackはおそらく最小値を見ていて、その分右シフト処理をしている。Monkey's Audio, ttaはそのまま圧縮しにいって減らせている（謎）。</p>
<p>64bit演算にしてみて様子を見る。。。様子は変わらず。</p>
<p><strong>バグだった！</strong>ライス符号パラメータがオーバーフローしていた！8bitの固定小数を使っていて、かつ119を掛ける時があって、24bitdデータを突っ込むと、確かに32bitだとオーバーフローする！直したら（パラメータを64bitにしたら）一気に減るようになった。</p>
<p>しかしまだ最小値の対処が抜けている。これを対処することでFLAC, wavpackを倒せる予定。</p>
<p>また、24bitエンコード時は高次係数も16bitを振った方が良さそうな印象。（また、右シフト量に応じた係数記録をすべき）</p>
<h3>2019.6.11</h3>
<p>最小値の対処を入れる。→やった。まだテスト実装だから、ビット幅計算関数を別途作成すべき。</p>
<p>ダイヤモンドスマイルの圧縮率、wavpackにおいて負けとる。</p>
<p>いろんな短い波形のエンコードデコードテストがやりたい…</p>
<h3>2019.6.12</h3>
<p>最小値対処を入れる。設計にはだいぶ迷った。</p>
<ul>
<li>各ブロックで解析を行って、ブロックヘッダに書いておくのを考えていたが、それは明らかにもったいない気がした。</li>
<li>なぜなら左シフトされて入っているデータはレアケースだと思うから。</li>
<li>なのでヘッダに入れることにした。最初に全体を解析して、左シフト量を計測しておく。また、概念的に近いと考えてWaveFormatに左シフト量のメンバを追加。</li>
<li>EncodeWhole時にしかヘッダに情報を入れない。</li>
<li>EncodeBlockを個別に呼び出したときは効果なし。</li>
<li>ユーザは左シフト量メンバをいじれない。</li>
</ul>
<p>TODO:</p>
<ul>
<li>24bitエンコード時は高次係数も16bitを振る。</li>
<li>右シフト量に応じた係数記録をする</li>
<li>係数量子化、最初にpow(2, 16)すべきでは？精度が落ちてる。この機会に整理。</li>
<li>いろんなwavのエンコードデコードテストを追加</li>
<li>とにかく一致確認を行う。ユニットテストとは分ける。</li>
<li>無音、サイン波、雑音、定数、ナイキスト振幅などなど…</li>
<li>8, 16, 24bit, 8bit&lt;&lt;16, 16bit&lt;&lt;8</li>
</ul>
<h3>2019.6.13</h3>
<p>何もできず。FLACのexe（実行可能形式）はGPLだけど、リンクしない限りは公開義務は発生しない。つまり、使うだけならOK。</p>
<h3>2019.6.14</h3>
<p>Adaptive filter theoryをパラパラ見ているけどSign Sign LMSの記述がどこにもない。やはりwebを見る。</p>
<ul>
<li><a href="https://archive.org/details/bstj45-2-255/page/n1">Techniques for Adaptive Equalization of Digital Communication Systems</a></li>
<li><a href="https://pdfs.semanticscholar.org/b26c/eda431a8b71e78298982ced440232266eb7b.pdf">LMS Adaptive Filters for Noise Cancellation: A Review</a></li>
</ul>
<p>あまりいい情報はない。</p>
<p>高速化で気になっていたのは、係数更新時のバッファアクセス。毎回andは取りたくない…直線アクセスできんのかと思っていたら、あった</p>
<ul>
<li><a href="http://exp1gw.ec.t.kanazawa-u.ac.jp/DSP/Processor/delay.html">ディレイラインの実装</a></li>
</ul>
<h3>2019.6.15</h3>
<p>ついでに久々に海ベローチェに来た。今日はここで作業して大井町寄って帰る。</p>
<p>ビックサイト行く途中で、IIRも適応的にできたことをAdaptive filter theoryの本に思い出させてもらった。そういえば適応ノッチフィルタの応用例があった。</p>
<p>適応IIRが先か、フィルタ処理高速化が先か…。圧縮率改善を先に頑張ったほうが良さそうだから、適応IIRを試してみよう。</p>
<p>やっつけで実装してみた（更新式はsign-sign）けど、なかなか性能が良い。（バグあるかも）</p>
<p>```sh:FIRのみ
-rw-r--r--@  1 *  staff  39558053 Jun  8 20:13 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29781967 Jun  8 20:14 SPARKLE.sla
-rw-r--r--@  1 *  staff     50878 Jun  8 20:14 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  23078354 Jun  8 20:12 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    770097 Jun  8 20:14 voice48a.sla</p>
<div class="highlight"><pre><span></span><code>```sh:FIR+IIR（予測出力をIIRフィルタの入力とする）
-rw-r--r--@   1 *  staff   39417404 Jun 15 17:12 one_two_sweets_offvocal.sla
-rw-r--r--@   1 *  staff   29704724 Jun 15 17:13 SPARKLE.sla
-rw-r--r--@   1 *  staff      50819 Jun 15 17:13 kisaragi_chihaya.sla
-rw-r--r--@   1 *  staff   22925409 Jun 15 17:13 Dream_goes_On.sla
-rw-r--r--@   1 *  staff     769208 Jun 15 17:14 voice48a.sla
</code></pre></div>

<p>```sh:FIR+IIR（残差をIIRフィルタの入力とする）
-rw-r--r--@   1 *  staff   39339579 Jun 15 17:29 one_two_sweets_offvocal.sla
-rw-r--r--@   1 *  staff   29652750 Jun 15 17:28 SPARKLE.sla
-rw-r--r--@   1 *  staff      50818 Jun 15 17:30 kisaragi_chihaya.sla
-rw-r--r--@   1 *  staff   22852870 Jun 15 17:29 Dream_goes_On.sl
-rw-r--r--@   1 *  staff     769343 Jun 15 17:30 voice48a.sla</p>
<div class="highlight"><pre><span></span><code>予測出力を入力するか、残差を入力とするかで実装が少し変わる。理論的なところでは、予測出力をIIRの入力とするものは出力誤差法（Output Error Method）と呼ばれるらしく（不安定、かつ局所最適に陥るそうだ。）、また、残差をIIRフィルタの入力とするものは該当する手法がない。何をしてるんだろう。。。

不安定さはステップサイズを小さくすることで防ぐしかないらしい（本によると）。

局所最適は等誤差法（Equation Error Method）で防げる。これは、希望出力をIIRの入力とするもの。この場合希望出力は無音になるな…

係数を64bitにしたら、残差IIR入力時に発散している（32bit整数を超える）ことがわかった。見たところ、定数予測のところで残差がいきなり発散していた。不安定なモードに入ったらしい…。発散するのは一般的によろしくないので、残差入力は取りやめる。

IIR対応により負荷が増えた。次数分のIIR計算を行うから2倍と言ってもいい。同等の計算負荷の次数を5にしてもFIR10より結果が悪い。昨日見たバッファアクセス高速化でどれだけ良くなるか…。後、log2演算の負荷がたかい。

ちょっと思ったこと：エンコードパラメータの再度精査。

### 2019.6.16

昨日バッファアクセス最適化を実装したけどバグがあるので、まずそれを直す。その後にエンコードデコードテストを行う。

6/8の結果に戻らずに苦戦していたが、6/8から6/16の間にフォーマット変更が入っているからもとに戻すのはだいぶ厳しそうなのでやめた。負荷の増減を見る。

OKで、インデックス参照は確かに早くなったが誤差レベル。
LMSの負荷が高すぎる…SPARKLE.wavのデコードで3秒のうち1秒がLMS...

LMSの高速化がどう考えてもキモだ。log2を諦めるか？

16:16 2時間半経った。高速化は一旦置いてテスト作成に入る。

19:13 ぐえー疲れた。テストはなんとか作った。しかし、左シフト量のオフセット計測の実装が怪しい感じ。

### 2019.6.17

テストを作り上げていく上でバグが2つ潰せた。

 1. 左シフト量の計算ミス
 2. 負の最大値(8bitでの-128)を符号なし化すると256になって8bitで符号化できない

### 2019.6.19

さらにバグつぶし。もっとテストケース増やそう。

 1. ステレオ白色雑音のデコードに失敗する
    - MS処理が働き、Mはガウス分布に近づくので圧縮、SはL-Rによりビット幅が増えて圧縮できず生データが入っていた。
    - 生データを係数領域に出力してしまい、デコード時にMチャンネルが残差と思ってデコードしてしまった。

### 2019.6.20

バグつぶし。チャープ信号追加で以下のバグがわかった。

 1. PARCOR係数がroundの結果正の最大値+1（=-1）になる場合がある。
    - クリップにより対処
 2. 推定符号長が負になる
    - パワーが極端に小さいときに起こる。1bit/1sampleで符号化できるとした。

### 2019.6.21

修正をまとめた。また、SLAUtility.cに機種依存文字が入っていたので消した。

### 2019.6.22

技術書典むけプロット：
</code></pre></div>

<p>あらすじver.0.1.1</p>
<ol>
<li>まえがき
ロスレス音声コーデックを作ってみませんか。
ロスレス音声コーデックと言えば、FLACがまず思い浮かべられると思いますが、実はFLACは
他のロスレス音声コーデックに比べて圧縮率が悪いという欠点があります。（展開速度は速いですが！）
本稿では "FLACを超える圧縮率を持つロスレス音声コーデック" の作成を目標として、
その基礎理論と実装を説明していきます。</li>
</ol>
<p>0-1. そもそもロスレス音声コーデックとは？</p>
<ol>
<li>基礎理論編
ロスレス音声コーデックは大体以下の構成を持ちます。</li>
</ol>
<p>+----------+       +---------+       +----------------------+       +----------------+
|          |       |         |       |                      |       |                |
|①入力wav +---+--&gt;+ ②予測  +---+--&gt;+ ③エントロピー符号化 +---+--&gt;+ ④出力バイナリ |
|          |   |   |         |   |   |                      |   |   |                |
+----------+   |   +---------+   |   +----------------------+   |   +----------------+
               |                 |                              |
               |                 |                              |
               +                 +                              +
            pcmデータ         残差信号                       ビット列</p>
<p>①入力のwavを取得する。
　音声信号データはPCMで符号化されている
②入力の音声データパターンを解析して、音声の予測を行う。
　予測信号と元の信号の差を残差という。予測が正確ならば、残差は小さくなり、
　③のエントロピー符号化でより小さく圧縮することができる。
③残差信号をビット列に符号化（エンコード）する。
　"エントロピー符号化"は、入力データの"確率分布"に基づいて、出力ビット列が
　短くなるように符号化を行います。
④出力バイナリデータが得られます。</p>
<p>復号（デコード）時は④→③→②→①の手順で処理を行い、元の入力wavを得ます。</p>
<p>②、③の性能が個別に高ければ高いほど、より良い圧縮率を達成することができます。
本章では、②、③の基礎理論である予測とエントロピー符号化を紹介していきます。</p>
<p>1-1. 予測
  1-1-1 予測とはどういうことか
  1-1-2 線形予測の理論と実装
　　　　（1サンプル間の予測から線形予測まで。頻度分布を見せる。）</p>
<p>1-2. エントロピー符号化
  1-2-1 符号化とはどういうことか
  1-2-2 情報量とエントロピー
　　　　（エントロピー計測プログラムを載せる）
  1-2-3 エントロピー符号化の例
       - α、γ、σ符号とその確率分布
       - Golomb-Rice符号</p>
<ol>
<li>実装編 -FLACを超える圧縮率を持つコーデックを作ってみる-
2-1. 固定小数演算PARCOR予測フィルタ
2-2. 残差符号化
  2-2-1 残差の確率分布分析
  2-2-2 ビットライタ、ビットリーダの実装
  2-2-3 負値の扱い
  2-2-4 ライス符号化パラメータの調整
2-3. wavファイルの読み込み</li>
</ol>
<p>Appendix. 失敗編
A-1. 他の予測手法
 A-1-1. Burg（共分散）法
 A-1-2. 1乗算型PARCOR格子フィルタ
A-2. 他のエントロピー符号
 A-2-1. ランレングス符号化
 A-2-2. ハフマン、適応的ハフマン
 A-2-3. LZ系
A-3. その他
 A-3-1. PARCOR係数の非線形量子化</p>
<div class="highlight"><pre><span></span><code><span class="s s-Atom">texの環境を整えてガリガリ書いていく。</span>

<span class="s s-Atom">ボイスデータをevaluateしていたらエンコードエラーがじゃんじゃん出てくる。その対策中。</span><span class="nv">LPC係数計算中に</span><span class="err">`</span><span class="nf">fabs</span><span class="p">(</span><span class="s s-Atom">gamma</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="s s-Atom">f</span><span class="err">`</span><span class="s s-Atom">になるケースがある</span><span class="p">...</span><span class="s s-Atom">確認したケースではサンプル数が少ない&amp;パワーが小さいのが原因。</span>

 <span class="mf">1.</span> <span class="s s-Atom">wavのfmtチャンクが拡張されている（サイズが16より大きい）ときにエラーを出していたが、スキップするようにした。（おそらく有効なデータは入っていない）</span>

 <span class="mf">2.</span> <span class="s s-Atom">入力サンプルがPARCOR係数次数よりも少ないときは無音として扱うようにした。</span>
    <span class="o">-</span> <span class="s s-Atom">入力サンプルが次数よりも大きく、自己相関が小さい場合は未対応。まだエンコードに失敗しうる。</span>

<span class="s s-Atom">上記2点の修正を入れたところ、使用している評価データに対してはエンコードできるようになった。</span>

<span class="nv">TTAは読み込めないwavがある</span><span class="s s-Atom">（おそらくfmtの拡張に対応していない）し、</span><span class="nv">Monkey</span><span class="err">&#39;</span><span class="s s-Atom">s</span> <span class="nv">Audioはクラッシュするwavがある</span><span class="s s-Atom">…。</span>

<span class="s s-Atom">今夜、</span><span class="nv">FLAC</span> <span class="s s-Atom">vs</span> <span class="nv">WavPack</span> <span class="s s-Atom">vs</span> <span class="nv">SLA</span> <span class="s s-Atom">予定。</span>

<span class="s s-Atom">手元の音源4091曲で圧縮率を比較：</span>

<span class="p">|</span> <span class="s s-Atom">手法</span> <span class="p">|</span> <span class="s s-Atom">圧縮率（圧縮後/圧縮前</span> <span class="o">*</span> <span class="mi">100</span><span class="s s-Atom">）</span><span class="p">[</span><span class="c1">%] | CPU負荷 [%] |</span>
<span class="p">|:-</span><span class="s s-Atom">:</span><span class="p">|:-</span><span class="s s-Atom">:</span><span class="p">|:-</span><span class="s s-Atom">:</span><span class="p">|</span>
<span class="p">|</span> <span class="nv">FLAC</span> <span class="o">-</span><span class="mi">8</span> <span class="p">|</span> <span class="mf">53.40</span> <span class="p">|</span> <span class="mf">0.720</span> <span class="p">|</span> 
<span class="p">|</span> <span class="nv">WavPack</span> <span class="o">-</span><span class="s s-Atom">hh</span> <span class="p">|</span> <span class="mf">48.00</span> <span class="p">|</span> <span class="mf">0.976</span> <span class="p">|</span>
<span class="p">|</span> <span class="s s-Atom">sla</span> <span class="p">|</span> <span class="mf">45.86</span> <span class="p">|</span> <span class="mf">1.24</span> <span class="p">|</span>

<span class="s s-Atom">###</span> <span class="mf">2019.6.23</span>

<span class="s s-Atom">久々に何も進めない休日。直近のTODOがない。執筆に励むべきかも。</span>

<span class="s s-Atom">###</span> <span class="mf">2019.6.25</span>

<span class="o">-</span> <span class="p">[</span><span class="s s-Atom">de</span> <span class="nv">Bruijn</span> <span class="s s-Atom">multiplication</span><span class="p">](</span><span class="nn">http</span><span class="p">:</span><span class="o">//</span><span class="s s-Atom">supertech</span><span class="p">.</span><span class="s s-Atom">csail</span><span class="p">.</span><span class="s s-Atom">mit</span><span class="p">.</span><span class="s s-Atom">edu</span><span class="o">/</span><span class="s s-Atom">papers</span><span class="o">/</span><span class="s s-Atom">debruijn</span><span class="p">.</span><span class="s s-Atom">pdf</span><span class="p">)</span>

<span class="s s-Atom">###</span> <span class="mf">2019.6.27</span>

<span class="err">`</span><span class="s s-Atom">uint32_t</span> <span class="nv">SLAUtility_Log2CeilFor2PoweredValue</span><span class="p">(</span><span class="s s-Atom">uint32_t</span> <span class="s s-Atom">val</span><span class="p">);</span><span class="err">`</span><span class="s s-Atom">が定義されていない。宣言だけあるので宣言を消す。→消した。</span>

<span class="err">`</span><span class="s s-Atom">wine</span><span class="err">`</span><span class="s s-Atom">を使って、</span><span class="nv">TAKとMP4ALSを評価に追加した</span><span class="s s-Atom">。圧縮率はTAKが一番。しかし人間の声ではSLAが何故か一番良かった。無音区間をうまく捉えられている？また、</span><span class="nv">MP4ALSと比べたところ</span><span class="s s-Atom">、僅かにSLAが上回っている。</span>

<span class="s s-Atom">小粒な修正。</span>

 <span class="o">-</span> <span class="nv">VSでビルドが通るように修正</span><span class="s s-Atom">。</span><span class="p">(</span><span class="err">`</span><span class="s s-Atom">。*/</span><span class="err">`</span><span class="s s-Atom">がエンコードでアウトだった。半角空けて</span><span class="err">`</span><span class="s s-Atom">。</span> <span class="s s-Atom">*/</span><span class="err">`</span><span class="s s-Atom">として対処。</span><span class="p">)</span>
 <span class="o">-</span> <span class="s s-Atom">バージョン文字列を文字列に変更。（フォーマットバージョンは整数。）</span>
 <span class="o">-</span> <span class="s s-Atom">シグネチャを</span><span class="err">`</span><span class="nv">SL</span><span class="o">*</span> <span class="err">`</span><span class="s s-Atom">から</span><span class="err">`</span><span class="nv">SL</span><span class="s s-Atom">*\</span><span class="mi">0</span><span class="err">`</span><span class="s s-Atom">に変更。（テキストファイルとして開いた時の事故を防ぐ目的）</span>

<span class="s s-Atom">プリセットを変更した。負荷として、</span><span class="nv">LMSよりPARCORは負荷増加しにくいので</span><span class="s s-Atom">、</span><span class="nv">PARCORにより多くを割り振るように変更</span><span class="s s-Atom">。</span>

<span class="s s-Atom">###</span> <span class="mf">2019.6.29</span>

<span class="s s-Atom">アプリに組み込んだときに、負荷変動がやばい。</span><span class="err">`</span><span class="nv">SLADecoder_DecodeBlock</span><span class="err">`</span><span class="s s-Atom">はブロックサイズ単位でデコードするが、それが例えば16384サンプル単位だと、</span><span class="mi">16384</span><span class="s s-Atom">サンプル周期でスパイクが発生する。これでは実用に耐えないので、より小さなブロックサイズ、例えば512サンプル単位でデコードできるようにしたい。</span>

<span class="s s-Atom">対応策を考えている。今有力なのは、</span><span class="err">`</span><span class="nv">SLADecoder_DecodeSubBlock</span><span class="err">`</span><span class="s s-Atom">という関数を新規に追加すること。</span><span class="err">`</span><span class="nv">SLADecoder_DecodeSubBlock</span><span class="err">`</span><span class="s s-Atom">の仕様は次の通り：</span>

 <span class="o">-</span> <span class="s s-Atom">ブロック先頭のときは、パラメータを読み取って指定サンプル分デコード。</span>
 <span class="o">-</span> <span class="s s-Atom">ブロック途中のときは、継続して指定サンプル分デコード。その際に次のブロックに入ったら、改めてパラメータを読み取って指定サンプル分に達するまでデコード。</span>
 <span class="o">-</span> <span class="s s-Atom">今読み取っているブロックのサンプル数をカウントすればやれそう。</span>

<span class="s s-Atom">負荷が変動するのは、ヘッダのパラメータの読み取り分（微小）と無音/生データデコード時（それなり）</span>

<span class="s s-Atom">おそらくこの関数はシークを実現するときも必要になるはず。</span><span class="err">`</span><span class="nv">SLADecoder_DecodeSubBlock</span><span class="err">`</span><span class="s s-Atom">の名前はあんまり良くなさそう。任意位置から任意サンプル分だけデコードできるので、もっと別の名前が良い。</span>

<span class="s s-Atom">同時に、ブロック途中で再度デコードを行っても問題なくデコードできるように下地を作る。</span>

 <span class="mf">1.</span> <span class="s s-Atom">ライス符号の初期パラメータをブロックヘッダに持たせる</span>
    <span class="o">-</span> <span class="s s-Atom">再帰的ライス符号のパラメータをコーディングモジュールの外から渡すように変える。</span>
    <span class="o">-</span> <span class="s s-Atom">パラメータの初期化をPutDataArray</span><span class="p">,</span> <span class="nv">GetDataArrayで行わない</span><span class="s s-Atom">。</span>
    <span class="o">-</span> <span class="s s-Atom">→やった。ここで気付いたけど、**コーディングモジュールをハンドル化したほうがよい。**</span>
 <span class="mf">2.</span> <span class="s s-Atom">予測モジュールのリセット関数を用意する。</span>
    <span class="o">-</span> <span class="s s-Atom">各予測モジュールと、エンコーダ・デコーダに追加</span>
    <span class="o">-</span> <span class="s s-Atom">予測/合成時に、リセットを行わないようにする</span>
    <span class="o">-</span> <span class="s s-Atom">ブロックヘッダ先頭だけでリセットを行う</span>
      <span class="o">-</span> <span class="s s-Atom">→試そうとしてきつい。予測/合成が始まるデータのインデックスに初回と2回目以降で差異がある。リセット関数でフラグを立てるか。</span>
    <span class="o">-</span> <span class="s s-Atom">プリエンファシス・デエンファシスも状態を持たねばなるまい。モジュール化するし、</span><span class="nv">Predictorに移動する</span><span class="s s-Atom">。</span>
    <span class="o">-</span> <span class="s s-Atom">合成予測ハンドルをチャンネル数分だけ持つように変える。</span>
    <span class="o">-</span> <span class="nv">LMSカスケードを廃止</span><span class="s s-Atom">。ハンドルが増えるし、何より圧縮に寄与しないから。</span>
      <span class="o">-</span> <span class="s s-Atom">→やった。</span>

<span class="s s-Atom">###</span> <span class="mf">2019.6.30</span>

<span class="s s-Atom">湿度のせいか、集中力が保たない。しかし大事なところなので頑張る。</span>

 <span class="mf">1.</span> <span class="s s-Atom">ブロックヘッダのエンコード・デコードを行う内部関数を新規追加</span>
    <span class="o">-</span> <span class="s s-Atom">エンコード側は難しいことがわかったのでデコード側のみ実装。（ブロックサイズ</span><span class="p">,</span> <span class="nv">CRC16がブロックエンコードが終わらない限り確定しないため</span><span class="s s-Atom">）</span>
 <span class="mf">2.</span> <span class="s s-Atom">先輩社員提案仕様を形にし始める</span>

<span class="mf">2.</span><span class="s s-Atom">に取り掛かっているが、残差デコードで一点問題が。**残差はチャンネルインターリーブでエンコード／デコードしないとブロックの途中でデコードを中断できない。**→やった。</span>

<span class="s s-Atom">予測ハンドルリセット時、フラグでなく入力サンプル数カウントを0にした方が素直かも。</span>

<span class="s s-Atom">###</span> <span class="mf">2019.7.1</span>

<span class="s s-Atom">実装整理。とにかく、ストリーミングデコードが完成しない限りはだめだ。</span>

<span class="s s-Atom">###</span> <span class="mf">2019.7.2</span>

<span class="s s-Atom">『ディジタル音声処理（古井貞）』に1乗算型の構成が書いてあった。。。。再度試してみたけど一致せず。うーん。諦めか？</span>

<span class="s s-Atom">戻ってストリーミングデコードへ向けて頑張る。</span>

<span class="s s-Atom">###</span> <span class="mf">2019.7.3</span>

<span class="s s-Atom">データ追加・回収系のテストを追加。同時にLMSに関する良いリンクを見つける。</span>

 <span class="o">-</span> <span class="p">[</span><span class="s s-Atom">再考・適応的アルゴリズム</span><span class="p">](</span><span class="nn">https</span><span class="p">:</span><span class="o">//</span><span class="s s-Atom">www</span><span class="p">.</span><span class="s s-Atom">jstage</span><span class="p">.</span><span class="s s-Atom">jst</span><span class="p">.</span><span class="s s-Atom">go</span><span class="p">.</span><span class="s s-Atom">jp</span><span class="o">/</span><span class="s s-Atom">article</span><span class="o">/</span><span class="s s-Atom">essfr</span><span class="o">/</span><span class="mi">8</span><span class="o">/</span><span class="mi">4</span><span class="o">/</span><span class="mi">8</span><span class="k">_</span><span class="mi">292</span><span class="s s-Atom">/</span><span class="k">_</span><span class="s s-Atom">pdf/-char</span><span class="o">/</span><span class="s s-Atom">ja</span><span class="p">)</span>

 <span class="o">-</span> <span class="p">[</span><span class="nv">Computer</span> <span class="s s-Atom">exercise</span> <span class="mi">6</span><span class="s s-Atom">:</span> <span class="nv">Fixed</span><span class="o">-</span><span class="s s-Atom">point</span> <span class="s s-Atom">implementation</span> <span class="s s-Atom">of</span> <span class="s s-Atom">the</span> <span class="nv">LMS</span> <span class="s s-Atom">algorithm</span><span class="p">](</span><span class="nn">https</span><span class="p">:</span><span class="o">//</span><span class="s s-Atom">www</span><span class="p">.</span><span class="s s-Atom">eit</span><span class="p">.</span><span class="s s-Atom">lth</span><span class="p">.</span><span class="s s-Atom">se</span><span class="o">/</span><span class="s s-Atom">fileadmin</span><span class="o">/</span><span class="s s-Atom">eit</span><span class="o">/</span><span class="s s-Atom">courses</span><span class="o">/</span><span class="s s-Atom">ett042</span><span class="o">/</span><span class="nv">CE</span><span class="o">/</span><span class="nv">CE6e</span><span class="p">.</span><span class="s s-Atom">pdf</span><span class="p">)</span>

<span class="nv">Sign</span><span class="o">-</span><span class="nv">Signはやりすぎ</span><span class="s s-Atom">…？入力信号のsignを取って、残差との乗算で更新してみる。→劇的にだめだった。とりやめ。</span>

<span class="s s-Atom">あと、ループアンローリング時は、和の変数も分けた方が良さそう。和の依存関係がなくなるからよい。</span>

<span class="err">```</span><span class="nn">c</span><span class="p">:</span><span class="s s-Atom">こんな感じ。</span>
<span class="s s-Atom">int</span> <span class="s s-Atom">sum1</span><span class="p">,</span> <span class="s s-Atom">sum2</span><span class="p">,</span> <span class="s s-Atom">sum3</span><span class="p">,</span> <span class="s s-Atom">sum4</span><span class="p">;</span>

<span class="nf">for</span> <span class="p">(</span><span class="s s-Atom">int</span> <span class="s s-Atom">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="s s-Atom">i</span> <span class="o">&lt;</span> <span class="s s-Atom">nsmpl</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span> <span class="s s-Atom">i++</span><span class="p">)</span> <span class="p">{</span>
 <span class="s s-Atom">sum1</span> <span class="s s-Atom">+=</span> <span class="s s-Atom">i</span><span class="p">;</span>
 <span class="s s-Atom">sum2</span> <span class="s s-Atom">+=</span> <span class="s s-Atom">i</span><span class="p">;</span>
 <span class="s s-Atom">sum3</span> <span class="s s-Atom">+=</span> <span class="s s-Atom">i</span><span class="p">;</span>
 <span class="s s-Atom">sum4</span> <span class="s s-Atom">+=</span> <span class="s s-Atom">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="s s-Atom">int</span> <span class="s s-Atom">ans</span> <span class="o">=</span> <span class="s s-Atom">sum1</span> <span class="o">+</span> <span class="s s-Atom">sum2</span> <span class="o">+</span> <span class="s s-Atom">sum3</span> <span class="o">+</span> <span class="s s-Atom">sum4</span><span class="p">;</span>
</code></pre></div>

<p>シフト演算も劇的に速いわけではない。注意。Log2Ceilも割と重いと思う。</p>
<ul>
<li><a href="http://www001.upp.so-net.ne.jp/y_yutaka/labo/math_algo/calcbench.html">簡単な演算負荷比較</a></li>
</ul>
<h3>2019.7.6</h3>
<p>ストリーミングデコードのテスト追加して細々としたバグつぶし中。</p>
<h3>2019.7.7</h3>
<p>まだバグあり。波形依存でもとに戻らない。2時間がかかったが、ロングタームが悪さしていることがわかった。更に追いかける。</p>
<ul>
<li>
<p>ロングタームとLMSが最初のバッファリング中のところでデコードが途切れるとバッファが不正になっていた</p>
</li>
<li>
<p>必要バイトの最小値を最小ブロックヘッダ値に設定</p>
</li>
</ul>
<p>だいたいバグは潰したけど、まだ構造的に未完成。データの受け渡しキューを綺麗にしたい。</p>
<h3>2019.7.9</h3>
<p>やはりデータコピー（<code>memmove</code>）負荷が大きい。データパケットキュー構造を作っている。</p>
<h3>2019.7.10</h3>
<p>技術書典参加確定。
パケットキューを作った。<code>SLAUtility</code>に追加。それに合わせてAPIを見直し。</p>
<h3>2019.7.11</h3>
<p>パケットキュー差し替え時のバグとり。とりあえず動いているようだが、ダブルバッファリングに変えたい。</p>
<ul>
<li>シグネチャを<code>SLA*\0</code>から<code>SLA*\1</code>に変える。<code>\1</code>はSOH(Start of Header)。<code>\0</code>だとSL*の繋がるイメージに反するから。→やった。</li>
</ul>
<h3>2019.7.13</h3>
<p>とどめの3連休としよう。</p>
<ul>
<li>最悪ビットレート値をヘッダに記録する→やった。</li>
<li>Par （タイポ）→ Per→やった。</li>
<li>連続バッファをダブルバッファリングに変える</li>
<li>実は難しいことがわかっている。ブロックデコード終了直後にデータ追加が入ると、ブロックサイズが前のブロックのママになってしまう。</li>
<li>制御が複雑になるので一旦ペンディングとする。</li>
</ul>
<h3>2019.7.14</h3>
<p>13:30起床。体が動かん。TODOなるべく早めにこなして、原稿執筆にはいる。</p>
<p>TODO: </p>
<ul>
<li>ストリーミングデコーダ作成直後にブロックサイズが不定になっている。</li>
<li>フォーマット設定したかどうかのフラグをもたせる。</li>
<li>フォーマット設定する前はサイズを最悪値で見積もっておく。</li>
<li>→やった。が、デコード開始直後は最大ブロックサイズ分突っ込んでおかないと失敗するケースあり。データ不足が発生していると想像。</li>
<li>異様に圧縮率がよい高崎データが元に戻っているのか精査</li>
<li>→わかった。wavファイルの末尾に<code>bext</code>チャンクが入っていた。そのチャンク情報を<code>sla</code>は捨てていたため、小さくなっていた。他のコーデックは律儀に保存していた。</li>
<li><a href="https://ja.wikipedia.org/wiki/Broadcast_Wave_Format">Broadcast Wave Format</a></li>
<li>捨てた分のチャンクサイズを足すと、やはりTakを下回る。</li>
<li><a href="http://tausoft.org/wiki/True_Audio_Codec_Algorithms">TTAの原理</a></li>
<li>残差でsignを取るのは負荷が高いから試していない。</li>
<li>→うーん。微妙。減ったり増えたり。安定しないの取り下げ。TTAで気になるのはステップサイズを可変にしている記述があった。論文はロシア語で読めないのでソースを見てみる。</li>
<li>全体的なコードリファクタ、テスト追加</li>
</ul>
<p>これはTODOではなくちら見でOK</p>
<ul>
<li><a href="https://www.hpl.hp.com/techreports/1999/HPL-1999-144.pdf">Lossless Compression of Digital Audio</a></li>
<li>今更なのに王道論文...いや、線形回帰ベースで古いな。</li>
</ul>
<p>永遠に上っ面の知識の吸収を続けるのか、それとも研究をしっかりやって将来的な発展に結びつけたいのか。かけた時間が時間なので、引くに引けない状況になってしまった。</p>
<p>TTAのソース（フィルタ処理）を読んでいる。</p>
<p>```c:TTAのfilter.hにコメントを入れてみる
static __inline void hybrid_filter_enc(TTA_fltst <em>fs, TTAint32 </em>in) {
    register TTAint32 <em>pA = fs-&gt;dl;     /</em> pA: 入力バッファ <em>/
    register TTAint32 </em>pB = fs-&gt;qm;     /<em> pB: 乗算係数     </em>/
    register TTAint32 <em>pM = fs-&gt;dx;     /</em> pM: 係数更新量   <em>/
    register TTAint32 sum = fs-&gt;round;  /</em> 丸め定数で初期化 */</p>
<div class="highlight"><pre><span></span><code><span class="c">/* 係数更新: 残差fs-&gt;errorの符号で変える */</span><span class="w"></span>
<span class="nt">if</span><span class="w"> </span><span class="o">(</span><span class="nt">fs-</span><span class="o">&gt;</span><span class="nt">error</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nt">0</span><span class="o">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="err">pB</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="w"> </span><span class="err">-=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">pB</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="w"> </span><span class="err">-=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">pB</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="w"> </span><span class="err">-=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">pB</span><span class="cp">[</span><span class="mi">3</span><span class="cp">]</span><span class="w"> </span><span class="err">-=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">3</span><span class="cp">]</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="err">pB</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="w"> </span><span class="err">-=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">pB</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="w"> </span><span class="err">-=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">pB</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="w"> </span><span class="err">-=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">pB</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="w"> </span><span class="err">-=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="nt">else</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="o">(</span><span class="nt">fs-</span><span class="o">&gt;</span><span class="nt">error</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nt">0</span><span class="o">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="err">pB</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">pB</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">pB</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">pB</span><span class="cp">[</span><span class="mi">3</span><span class="cp">]</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">3</span><span class="cp">]</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="err">pB</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">pB</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">pB</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="err">pB</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="w"> </span><span class="err">+=</span><span class="w"> </span><span class="err">pM</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c">/* フィルタ出力計算 */</span><span class="w"></span>
<span class="nt">sum</span><span class="w"> </span><span class="o">+=</span><span class="w">  </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">pB</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">pB</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">pB</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">3</span><span class="cp">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">pB</span><span class="cp">[</span><span class="mi">3</span><span class="cp">]</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">    </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">pB</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">pB</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">pB</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">pB</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="o">;</span><span class="w"></span>

<span class="c">/* 入力バッファ</span><span class="cp">[</span><span class="mi">0</span><span class="nx">..3</span><span class="cp">]</span><span class="c">の更新 0が最も古いデータとなる */</span><span class="w"></span>
<span class="nt">pM</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">pM</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="o">;</span><span class="w"> </span><span class="nt">pM</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">pM</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="o">;</span><span class="w"> </span><span class="nt">pM</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">pM</span><span class="cp">[</span><span class="mi">3</span><span class="cp">]</span><span class="o">;</span><span class="w"> </span><span class="nt">pM</span><span class="cp">[</span><span class="mi">3</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">pM</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="o">;</span><span class="w"></span>
<span class="nt">pA</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="o">;</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="o">;</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">2</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">3</span><span class="cp">]</span><span class="o">;</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">3</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="o">;</span><span class="w"></span>

<span class="c">/* 新しめの係数更新量</span><span class="cp">[</span><span class="mi">4</span><span class="nx">..7</span><span class="cp">]</span><span class="c">の更新 */</span><span class="w"></span>
<span class="nt">pM</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">((</span><span class="nt">pA</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="nt">30</span><span class="o">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nt">1</span><span class="o">);</span><span class="w">        </span><span class="c">/* sign(pA</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="c">)（0のときは1）     */</span><span class="w"></span>
<span class="nt">pM</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">((</span><span class="nt">pA</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="nt">30</span><span class="o">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nt">2</span><span class="o">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="nt">1</span><span class="o">;</span><span class="w">   </span><span class="c">/* 2 * sign(pA</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="c">)（0のときは2） */</span><span class="w"></span>
<span class="nt">pM</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">((</span><span class="nt">pA</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="nt">30</span><span class="o">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nt">2</span><span class="o">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="nt">1</span><span class="o">;</span><span class="w">   </span><span class="c">/* 2 * sign(pA</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="c">)（0のときは2） */</span><span class="w"></span>
<span class="nt">pM</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">((</span><span class="nt">pA</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="nt">30</span><span class="o">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nt">4</span><span class="o">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="nt">3</span><span class="o">;</span><span class="w">   </span><span class="c">/* 4 * sign(pA</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="c">)（0のときは4） */</span><span class="w"></span>

<span class="c">/* 元のソース</span>
<span class="c">pA</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="c"> = -pA</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="c">; pA</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="c"> = -pA</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="c">;</span>
<span class="c">pA</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="c"> = *in - pA</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="c">; pA</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="c"> = *in;</span>
<span class="c">pA</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="c"> += pA</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="c">; pA</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="c"> += pA</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="c">;</span>
<span class="c">*/</span><span class="w"></span>
<span class="nt">pA</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">-pA</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="o">;</span><span class="w">         </span><span class="c">/* pA</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="c"> = -直前の3階の差分 */</span><span class="w"></span>
<span class="nt">pA</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">-pA</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="o">;</span><span class="w">         </span><span class="c">/* pA</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="c"> = -直前の2階の差分 */</span><span class="w"></span>
<span class="nt">pA</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="nt">in</span><span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="o">;</span><span class="w">    </span><span class="c">/* pA</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="c"> = 入力 - 直前の入力（1階の差分） */</span><span class="w"></span>
<span class="nt">pA</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="nt">in</span><span class="o">;</span><span class="w">            </span><span class="c">/* pA</span><span class="cp">[</span><span class="mi">7</span><span class="cp">]</span><span class="c"> = 入力データ */</span><span class="w"></span>
<span class="nt">pA</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">6</span><span class="cp">]</span><span class="o">;</span><span class="w">         </span><span class="c">/* pA</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="c"> = 1階の差分 - 直前の2階の差分（2階の差分） */</span><span class="w"></span>
<span class="nt">pA</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nt">pA</span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span><span class="o">;</span><span class="w">         </span><span class="c">/* pA</span><span class="cp">[</span><span class="mi">4</span><span class="cp">]</span><span class="c"> = 2階の差分 - 直前の3階の差分（3階の差分） */</span><span class="w"></span>

<span class="c">/* 入力をインプレースで残差に差し替える */</span><span class="w"></span>
<span class="o">*</span><span class="nt">in</span><span class="w"> </span><span class="nt">-</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="nt">sum</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="nt">fs-</span><span class="o">&gt;</span><span class="nt">shift</span><span class="o">);</span><span class="w"></span>
<span class="nt">fs-</span><span class="o">&gt;</span><span class="nt">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="nt">in</span><span class="o">;</span><span class="w"></span>
</code></pre></div>

<p>} // hybrid_filter_enc
```</p>
<p>いろんな工夫が見られる。</p>
<ul>
<li>入力信号バッファの先頭4つには<strong>差分値</strong>が入っている</li>
<li><code>pA[7]</code>: 生の入力信号</li>
<li><code>pA[6]</code>: 1階の差分（現在の入力 - 直前の入力）</li>
<li><code>pA[5]</code>: 2階の差分（1階の差分 - 直前の1階の差分）</li>
<li><code>pA[4]</code>: 3階の差分（2階の差分 - 直前の2階の差分）</li>
<li><code>pA[3]</code>: 直前の<code>pA[4]</code></li>
<li><code>pA[2]</code>: 直前の<code>pA[3]</code></li>
<li><code>pA[1]</code>: 直前の<code>pA[2]</code></li>
<li><code>pA[0]</code>: 直前の<code>pA[1]</code></li>
<li>各係数の更新量<code>pM</code>は次のように決まる。（ただし、<code>sign</code>は符号関数。<code>sign(0) = 1</code>）:</li>
<li><code>pM[7]</code>: <code>4 * sign(pA[7]) = ((pA[7] &gt;&gt; 30) | 4) &amp; ~3</code> </li>
<li><code>pM[6]</code>: <code>2 * sign(pA[6]) = ((pA[6] &gt;&gt; 30) | 2) &amp; ~1</code></li>
<li><code>pM[5]</code>: <code>2 * sign(pA[5]) = ((pA[5] &gt;&gt; 30) | 2) &amp; ~1</code> </li>
<li><code>pM[4]</code>: <code>sign(pA[4])  = ((pA[4] &gt;&gt; 30) | 1)</code> </li>
<li><code>pM[3]</code>: 直前の<code>pM[4]</code></li>
<li><code>pM[2]</code>: 直前の<code>pM[3]</code></li>
<li><code>pM[1]</code>: 直前の<code>pM[2]</code></li>
<li><code>pM[0]</code>: 直前の<code>pM[1]</code></li>
</ul>
<p>今更ながら示唆がある。</p>
<ul>
<li>フィルタ係数と言うよりは、<strong>微係数</strong>を適応的に変化させている</li>
<li>予測も微係数を用いて行う。これは…何らかの補間手法では？</li>
<li>入力は過去に行くほど影響度が小さくなっている</li>
<li>係数更新量も過去に行くほど小さくなっている</li>
<li>更新量は小さいように見えるが、TTAは1秒分のデータをブロックエンコードするので、十分に収束するものと想像</li>
<li>係数更新が一番最初にきている</li>
</ul>
<p>ここまで読めたのだから、取り込んでみた。が、性能が悪い。シフト量が鬼門で、どの値に設定すれば良いのかさっぱり。長尺データはそれなりの結果を出している（既存よりは低い）。<strong>係数更新が一番最初に行われるのもだいぶミソだ。予測後に更新したら性能が落ちた。</strong></p>
<p>取り下げるけど、示唆が3点。</p>
<ol>
<li>係数更新のタイミングを予測前にする<ul>
<li>やったら爆裂に悪化。定義からはずれたと思う。やめ。</li>
</ul>
</li>
<li>古いバッファデータの更新量を小さくする</li>
<li>係数シフトを乗算右シフトに含める<ul>
<li>これを参考にして、LMSの乗算時右シフトを10bitにしたら32bit整数で計算が完結した。</li>
<li>圧縮率を犠牲に、32bit演算化の道が開けた感がある。</li>
<li>しかし、24bit WAVを使用したとき、加算対象の変数を64bitにしたときと32bitnにしたときで差が出る…原因を追う。</li>
</ul>
</li>
</ol>
<h3>2019.7.15</h3>
<p>秋葉原製作所8時間取った。ほぼ最後の追い込み。最後の課題はLMSの32bit化。</p>
<p>変更前（64bit演算、重みシフト10bit）の結果をメモしておく：</p>
<table>
<thead>
<tr>
<th align="center">音源</th>
<th align="center">圧縮後サイズ</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">A112b.wav</td>
<td align="center">156819</td>
</tr>
<tr>
<td align="center">ワン・ツー・スゥイーツ</td>
<td align="center">39496924</td>
</tr>
<tr>
<td align="center">SPARKLE</td>
<td align="center">29499550</td>
</tr>
<tr>
<td align="center">俺の声</td>
<td align="center">50884</td>
</tr>
</tbody>
</table>
<ul>
<li>乗算時にオーバーフローは発生していない（テスト確認済み）</li>
</ul>
<p>32bitだとどうにも性能が悪い問題があった。これは、固定小数の精度が悪いのが原因（オーバーフロー以外で悪化する原因はこれしか考えられない）。64bit時は30bitも割り当てているから当然。</p>
<p>係数の更新量テーブルを見直して、更新量を一律1bit右シフトしたら性能がそれなりに良化した。乗算時にオーバーフローしていないかチェックして、問題なければ...と思ったら、24bit音源で2%程の大幅悪化が見られた。</p>
<p>どうするか…24bit対策するか…</p>
<p>ひとまず今の更新量テーブル見直しの結果は以下：</p>
<table>
<thead>
<tr>
<th align="center">音源</th>
<th align="center">圧縮後サイズ</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">A112b.wav</td>
<td align="center">156667</td>
</tr>
<tr>
<td align="center">ワン・ツー・スゥイーツ</td>
<td align="center">39441828</td>
</tr>
<tr>
<td align="center">SPARKLE</td>
<td align="center">29468749</td>
</tr>
<tr>
<td align="center">俺の声</td>
<td align="center">50985</td>
</tr>
</tbody>
</table>
<p>アイカツ音源で0.3%の悪化。うーん。手元のデータに都合が良すぎるのか？</p>
<p>設計上のジャッジを下さねばなるまい。...やはり、圧縮率は落ちるが、速度向上、より広い移植性を目指して32bitでやるべきでは？→やった。</p>
<p><code>splint</code>を全体的に行ってコード整理を行う。</p>
<p>このタイミングでMP4ALSのソースを見つけてしまった…。一応追加。しかし、Hydrogen Audioでの扱いを信じることにする。</p>
<p>帰った後でソースを見直していたらロングタームの予測変数が32bitになっていてオーバーフローで圧縮率を悪化させていた…。64bitに直したら、圧縮率を犠牲にしないで32bit化することができた。</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
                </main>
            </div>
            <!-- /.entry-content -->
<section class="well" id="related-posts">
    <h4>Related Posts:</h4>
    <ul>
        <li><a href="/ya-suo-lu-gai-shan-jian-tao-11.html">圧縮率改善検討(11)</a></li>
        <li><a href="/ya-suo-lu-gai-shan-jian-tao-10.html">圧縮率改善検討(10)</a></li>
        <li><a href="/ya-suo-lu-gai-shan-jian-tao-9.html">圧縮率改善検討(9)</a></li>
        <li><a href="/ya-suo-lu-gai-shan-jian-tao-8.html">圧縮率改善検討(8)</a></li>
        <li><a href="/ya-suo-lu-gai-shan-jian-tao-7.html">圧縮率改善検討(7)</a></li>
    </ul>
</section>
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>
<!-- Sidebar -->
<section class="well well-sm">
  <ul class="list-group list-group-flush">

<!-- Sidebar/Social -->
<li class="list-group-item">
  <h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
  <ul class="list-group" id="social">
    <li class="list-group-item"><a href="https://github.com/aikiriao/"><i class="fa fa-github-square fa-lg"></i> GitHub</a></li>
  </ul>
</li>
<!-- End Sidebar/Social -->

<!-- Sidebar/Tag Cloud -->
<li class="list-group-item">
  <a href="/"><h4><i class="fa fa-tags fa-lg"></i><span class="icon-label">Tags</span></h4></a>
  <ul class="list-group " id="tags">
    <li class="list-group-item tag-1">
      <a href="/tag/natural-gradient.html">Natural Gradient</a>
    </li>
    <li class="list-group-item tag-1">
      <a href="/tag/resnet.html">ResNet</a>
    </li>
    <li class="list-group-item tag-1">
      <a href="/tag/wavelet.html">Wavelet</a>
    </li>
    <li class="list-group-item tag-1">
      <a href="/tag/lossless-audio-codec.html">Lossless Audio Codec</a>
    </li>
    <li class="list-group-item tag-1">
      <a href="/tag/auto-correlation.html">Auto Correlation</a>
    </li>
    <li class="list-group-item tag-1">
      <a href="/tag/lpc.html">LPC</a>
    </li>
    <li class="list-group-item tag-1">
      <a href="/tag/golomb-rice.html">Golomb-Rice</a>
    </li>
    <li class="list-group-item tag-1">
      <a href="/tag/sign-algorithm.html">Sign Algorithm</a>
    </li>
    <li class="list-group-item tag-1">
      <a href="/tag/lms.html">LMS</a>
    </li>
    <li class="list-group-item tag-1">
      <a href="/tag/lifting.html">Lifting</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="/tag/adpcm.html">ADPCM</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="/tag/lossless-audio.html">Lossless Audio</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="/tag/auto-regressive.html">Auto Regressive</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="/tag/signed-lms.html">Signed LMS</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="/tag/regularization.html">Regularization</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="/tag/auxiliary-function.html">Auxiliary Function</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="/tag/lad.html">LAD</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="/tag/signedlms.html">SignedLMS</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="/tag/rls.html">RLS</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="/tag/inverse-auto-correlation.html">Inverse Auto Correlation</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="/tag/empirical-fisher.html">Empirical Fisher</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/ji-jie-xue-xi.html">機械学習</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/hessian.html">Hessian</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/l1norumu.html">L1ノルム</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/irls.html">IRLS</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/information-geometry.html">Information Geometry</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/manifold.html">Manifold</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/bp.html">BP</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/xin-hao-chu-li.html">信号処理</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/wavpack.html">WavPack</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/rosuresuyin-sheng.html">ロスレス音声</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/tak.html">TAK</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/sla.html">SLA</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/ig.html">IG</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="/tag/cnn.html">CNN</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/de-dian-ji-suan.html">得点計算</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/ma-que.html">麻雀</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/ji-chu.html">基礎</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/test.html">test</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/qing-bao-ji-he.html">情報幾何</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/dft.html">DFT</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/ribabu.html">リバーブ</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/sse.html">SSE</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/chuang-guan-shu-fa.html">窓関数法</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/fuzzy-clustering.html">Fuzzy Clustering</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/poemu.html">ポエム</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/glasso.html">GLASSO</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/lms-algorithm.html">LMS Algorithm</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/xiang-ting-shu.html">向聴数</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/tong-ji.html">統計</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/risanpura.html">リサンプラー</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/jupyter.html">Jupyter</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/supasufu-hao-hua.html">スパース符号化</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/ehuekuta.html">エフェクター</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/c89.html">C89</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/monkeys-audio.html">Monkey's Audio</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/circulant-matrix.html">Circulant Matrix</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/xun-hui-xing-lie.html">巡回行列</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/githubio.html">githubio</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/gu-shi-ji.html">古事記</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/fisher-information-matrix.html">Fisher Information Matrix</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="/tag/pelican.html">pelican</a>
    </li>
  </ul>
</li>
<!-- End Sidebar/Tag Cloud -->

<!-- Sidebar/Links -->
<li class="list-group-item">
  <h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
  <ul class="list-group" id="links">
    <li class="list-group-item">
      <a href="http://getpelican.com/" target="_blank">Pelican</a>
    </li>
    <li class="list-group-item">
      <a href="http://python.org/" target="_blank">Python.org</a>
    </li>
    <li class="list-group-item">
      <a href="http://jinja.pocoo.org/" target="_blank">Jinja2</a>
    </li>
    <li class="list-group-item">
      <a href="https://policies.google.com/technologies/partner-sites" target="_blank">Google Analytics</a>
    </li>
  </ul>
</li>
<!-- End Sidebar/Links -->
  </ul>
</section>
<!-- End Sidebar -->            </aside>
        </div>
    </div>
</div>
<!-- End Content Container -->

<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2022 aiki
            &middot; Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>              <p><small>Unless otherwise stated, all articles are published under the <a href="http://www.wtfpl.net/about/">WTFPL</a> license. ブログ記述は誤りを含むのでご注意ください。</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="/theme/js/respond.min.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-169927697-1']);
        _gaq.push(['_trackPageview']);

        (function () {
            var ga = document.createElement('script');
            ga.type = 'text/javascript';
            ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(ga, s);
        })();
    </script>
    <!-- End Google Analytics Code -->

<script type="text/javascript">
jQuery(document).ready(function($) {
    $("div.collapseheader").click(function () {
    $header = $(this).children("span").first();
    $codearea = $(this).children(".input_area");
    console.log($(this).children());
    $codearea.slideToggle(500, function () {
        $header.text(function () {
            return $codearea.is(":visible") ? "Collapse Code" : "Expand Code";
        });
    });
});
});
</script>
</body>
</html>