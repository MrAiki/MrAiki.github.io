<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Aiki's Blog - 雑記</title><link href="/" rel="alternate"></link><link href="/feeds/za-ji.atom.xml" rel="self"></link><id>/</id><updated>2021-07-04T10:00:00+09:00</updated><entry><title>戦略会議中2021(9)</title><link href="/zhan-lue-hui-yi-zhong-20219.html" rel="alternate"></link><published>2021-07-04T10:00:00+09:00</published><updated>2021-07-04T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-04:/zhan-lue-hui-yi-zhong-20219.html</id><summary type="html">&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/558477"&gt;Wavelet Transform Domain Adaptive FIR Filtering&lt;/a&gt; 「ウェーブレット変換とその応用」で触れられていたもう一つの論文。&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;ウェーブレット変換域でLMS/Newtonを使う。うまいことコレスキー分解して、スパース推定を使って計算効率化を図る。&lt;/li&gt;
&lt;li&gt;当然単純な変換域でのLMSよりは性能が良い。&lt;/li&gt;
&lt;li&gt;変換域で自己相関行列を見ており、しかもその逆はスパースであると言っている。&lt;/li&gt;
&lt;li&gt;自分の発想を突っ込めそうに思える。が、変換域でAR過程になるのだろうか？&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/258086"&gt;Low Bit Rate Transparent Audio Compression using Adapted Wavelets&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;最大消失モーメントを持つウェーブレットはタップ数に応じて有限個しか無い（ドベシィ。例えばタップ数40なら最大で20次までのモーメントを消せるが、そのウェーブレットの組み合わせは1024通りしか無いとのこと。10bitで送れる。）より、その中から適切なウェーブレットを適応的に選ぶ&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;この事実は気になる。ウェーブレット10講に書いてあるかな。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;選択尺度は等誤差面の議論から割と自然に出てくる。しかしその選択は総当りっぽい。デコード負荷は低いから許されるか…&lt;/li&gt;
&lt;li&gt;ほかにも、LPCは人間の声道管モデルベースだから音楽などでの無声音（ピッチがない音）は厳しいという指摘があった。確かに。&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;a class="reference external" href="http://www.seas.ucla.edu/spapl/codecs/G722tut.pdf"&gt;G.722: a new CCITT coding …&lt;/a&gt;&lt;/dt&gt;&lt;/dl&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/558477"&gt;Wavelet Transform Domain Adaptive FIR Filtering&lt;/a&gt; 「ウェーブレット変換とその応用」で触れられていたもう一つの論文。&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;ウェーブレット変換域でLMS/Newtonを使う。うまいことコレスキー分解して、スパース推定を使って計算効率化を図る。&lt;/li&gt;
&lt;li&gt;当然単純な変換域でのLMSよりは性能が良い。&lt;/li&gt;
&lt;li&gt;変換域で自己相関行列を見ており、しかもその逆はスパースであると言っている。&lt;/li&gt;
&lt;li&gt;自分の発想を突っ込めそうに思える。が、変換域でAR過程になるのだろうか？&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/258086"&gt;Low Bit Rate Transparent Audio Compression using Adapted Wavelets&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;最大消失モーメントを持つウェーブレットはタップ数に応じて有限個しか無い（ドベシィ。例えばタップ数40なら最大で20次までのモーメントを消せるが、そのウェーブレットの組み合わせは1024通りしか無いとのこと。10bitで送れる。）より、その中から適切なウェーブレットを適応的に選ぶ&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;この事実は気になる。ウェーブレット10講に書いてあるかな。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;選択尺度は等誤差面の議論から割と自然に出てくる。しかしその選択は総当りっぽい。デコード負荷は低いから許されるか…&lt;/li&gt;
&lt;li&gt;ほかにも、LPCは人間の声道管モデルベースだから音楽などでの無声音（ピッチがない音）は厳しいという指摘があった。確かに。&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;a class="reference external" href="http://www.seas.ucla.edu/spapl/codecs/G722tut.pdf"&gt;G.722: a new CCITT coding standard for digital transmission of wideband audio signals&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;QMF(20タップ)で高域と低域に分け、それぞれの帯域でG.711のADPCMを使う。高域は低いビットを割り当てる。&lt;/li&gt;
&lt;li&gt;音質がよくなったことを報告しとる。そうだよなあという感じ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;予め用意してあるウェーブレットから選ぶというのはどうなんだろう…個人的には適応的リフィティングを検討してみたい。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category></entry><entry><title>戦略会議中2021(8)</title><link href="/zhan-lue-hui-yi-zhong-20218.html" rel="alternate"></link><published>2021-07-03T10:00:00+09:00</published><updated>2021-07-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-03:/zhan-lue-hui-yi-zhong-20218.html</id><content type="html">&lt;p&gt;昨日見た下記3論文を読んで、展望を考えたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/558477"&gt;Wavelet Transform Domain Adaptive FIR Filtering&lt;/a&gt; 「ウェーブレット変換とその応用」で触れられていたもう一つの論文。&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;かるく見たけど、…ん？まじで変換域で適応フィルタしてるだけ？自己相関の逆かけて白色化するのはたしかに大事だけど、これでいいのか？&lt;/li&gt;
&lt;li&gt;不思議なのは、自己回帰過程を考えていてその自己相関行列も計算しているが、逆の計算を考えていない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/258086"&gt;Low Bit Rate Transparent Audio Compression using Adapted Wavelets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.seas.ucla.edu/spapl/codecs/G722tut.pdf"&gt;G.722: a new CCITT coding standard for digital transmission of wideband audio signals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category></entry><entry><title>戦略会議中2021(7)</title><link href="/zhan-lue-hui-yi-zhong-20217.html" rel="alternate"></link><published>2021-07-02T10:00:00+09:00</published><updated>2021-07-02T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-02:/zhan-lue-hui-yi-zhong-20217.html</id><summary type="html">&lt;p&gt;改めて音声符号化にウェーブレットを使うことの是非を見る意図で、「ウェーブレットとサブバンド符号化」をつまんでいる。
概要を述べているだけなので厳しい。見つかった文献を漁る。高音質と中音質に分けていたので分類に従って列挙。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;高音質&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.aes.org/e-lib/online/browse.cfm?elib=6768"&gt;High-Quality, Low-Rate Audio Transform Coding for Transmission and Multimedia Applications&lt;/a&gt; AES会員でないと読めないっぽい。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/151054"&gt;A MUSICAM source codec for digital audio broadcasting and storage&lt;/a&gt; MPEG-Iの基礎になっている考え方。フィルタバンクを使用。知覚符号化そのものか？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/225993"&gt;Sum-difference stereo transform coding&lt;/a&gt; これもフィルタバンク+量子化の流れ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/258086"&gt;Low Bit Rate Transparent Audio Compression using Adapted Wavelets&lt;/a&gt; 適応的（辞書的）にウェーブレットを選んで冗長性を減らす。ウェーブレットパケットの構成も動的に決めている …&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;改めて音声符号化にウェーブレットを使うことの是非を見る意図で、「ウェーブレットとサブバンド符号化」をつまんでいる。
概要を述べているだけなので厳しい。見つかった文献を漁る。高音質と中音質に分けていたので分類に従って列挙。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;高音質&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.aes.org/e-lib/online/browse.cfm?elib=6768"&gt;High-Quality, Low-Rate Audio Transform Coding for Transmission and Multimedia Applications&lt;/a&gt; AES会員でないと読めないっぽい。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/151054"&gt;A MUSICAM source codec for digital audio broadcasting and storage&lt;/a&gt; MPEG-Iの基礎になっている考え方。フィルタバンクを使用。知覚符号化そのものか？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/225993"&gt;Sum-difference stereo transform coding&lt;/a&gt; これもフィルタバンク+量子化の流れ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/258086"&gt;Low Bit Rate Transparent Audio Compression using Adapted Wavelets&lt;/a&gt; 適応的（辞書的）にウェーブレットを選んで冗長性を減らす。ウェーブレットパケットの構成も動的に決めている？これってICASSPのやつと同等に見える。腰を入れて読むべきかも。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/117212"&gt;High quality audio bit-rate reduction system family for different applications&lt;/a&gt; MUSICAMの解説論文。より概要に寄った感じ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.mp3-tech.org/programmer/docs/ac3-flex.pdf"&gt;AC-3: Flexible Perceptual Coding for Audio Transmission and Storage&lt;/a&gt; ドルビーが提案しているっぽいコーデック。フィルタバンク+知覚符号化。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/publication/234825071_Acoustic_Signal_Compression_with_Wavelet_Packets"&gt;Acoustic Signal Compression with Wavelet Packets&lt;/a&gt; コスト関数の最適化に基づいてウェーブレット基底を選択する手法。ちゃんと読めず。そういえばリフィティング使ってないけど、リフィティングが現れる前の話？&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;中音質&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/6769805"&gt;Digital Coding of Speech in Sub-bands&lt;/a&gt; ノキアベルラボの人。だいぶクラシカルだけど、基本が詰まっている。小さめのサブバンドに分割して符号化。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/1170341"&gt;Application of quadrature mirror filters to split band voice coding schemes&lt;/a&gt; これもフィルタバンク(QMF)で分割して、フィルタ出力を量子化して送るというもの。単純極まるけど基本的でわかりやすい。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=1170894"&gt;16kbps Real time QMF sub-band coding implementation&lt;/a&gt; これもQMF+線形量子化。自分も試してみるか？問題点はQMFの設計だけに思える。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.seas.ucla.edu/spapl/codecs/G722tut.pdf"&gt;G.722: a new CCITT coding standard for digital transmission of wideband audio signals&lt;/a&gt; QMF出力に対して、低域と高域でそれぞれADPCM。これは素晴らしい。ピンときたし、ウェーブレット変換領域での適応フィルタに一致していると思う。これも読みたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category></entry><entry><title>戦略会議中2021(6)</title><link href="/zhan-lue-hui-yi-zhong-20216.html" rel="alternate"></link><published>2021-06-28T10:00:00+09:00</published><updated>2021-06-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-06-28:/zhan-lue-hui-yi-zhong-20216.html</id><content type="html">&lt;p&gt;4月からここまでだいたい論文執筆やら発表準備、ゼミ輪講で潰れていた。
GWはウェーブレット理解のために合宿。高速ウェーブレット変換まではOKということで資料公開。
論文発表の準備がようやく落ち着いてきた。7月からは調査に再度着手したい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/558477"&gt;Wavelet Transform Domain Adaptive FIR Filtering&lt;/a&gt; 「ウェーブレット変換とその応用」で触れられていたもう一つの論文。&lt;ul&gt;
&lt;li&gt;これから再度スタートする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://yukara-13.hatenablog.com/entry/2013/12/01/222742"&gt;【Python】 Constant-Q 変換 (対数周波数スペクトログラム)&lt;/a&gt; 定Q変換について。周波数に応じて窓幅を変えて解析する。それってウェーブレットの問題意識と全く同じ。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category></entry><entry><title>戦略会議中2021(5)</title><link href="/zhan-lue-hui-yi-zhong-20215.html" rel="alternate"></link><published>2021-04-15T10:00:00+09:00</published><updated>2021-04-15T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-04-15:/zhan-lue-hui-yi-zhong-20215.html</id><content type="html">&lt;p&gt;紹介を進め、ウェーブレットの適用について考え始めている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/558477"&gt;Wavelet Transform Domain Adaptive FIR Filtering&lt;/a&gt; 「ウェーブレット変換とその応用」で触れられていたもう一つの論文。&lt;ul&gt;
&lt;li&gt;こっちも古いので、もっと新しい論文を見て考えたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category></entry><entry><title>戦略会議中2021(4)</title><link href="/zhan-lue-hui-yi-zhong-20214.html" rel="alternate"></link><published>2021-04-14T10:00:00+09:00</published><updated>2021-04-14T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-04-14:/zhan-lue-hui-yi-zhong-20214.html</id><content type="html">&lt;p&gt;紹介を進め、ウェーブレットの適用について考え始めている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/abstract/document/536674?casa_token=fIVBeh0AOcIAAAAA:Q_3gyG3siw1wY-Eqm9y7B1IVmAQEG8EJ0sExiLhSlmGR2iA4260KPX-BApaRWjfyyXNrgDzN39w"&gt;Wavelet Transform Based Adaptive Filters: Analvsis and New Results&lt;/a&gt; 「ウェーブレット変換とその応用」で触れられていたウェーブレット変換してから適用フィルタをかませる論文。&lt;ul&gt;
&lt;li&gt;ざっと読んでみた。入力信号とウェーブレット関数の内積でウェーブレット領域に飛ばして、その領域での係数を適応学習するというもの。定常的な信号ではDFT領域に飛ばして適応するアルゴリズムには敵わなかったが、インパルーシブな信号に対しては、（ドベシィウェーブレットで）速い収束性能を示していた。また、理論的に条件数が向上することが示され、普通のLMSよりも収束が速いことが分かっている。紙に印刷したい。&lt;/li&gt;
&lt;li&gt;ウェーブレット関数の自己相関行列のようなものが出てきている。すげえ気になる。&lt;/li&gt;
&lt;li&gt;SAのように、ラプラス分布仮定を入れるとどうなるか試してみたい。&lt;/li&gt;
&lt;li&gt;他のウェーブレットはどうか？も気になる。&lt;/li&gt;
&lt;li&gt;古いので、もっと新しい論文を見て考えたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category></entry><entry><title>戦略会議中2021(3)</title><link href="/zhan-lue-hui-yi-zhong-20213.html" rel="alternate"></link><published>2021-04-11T10:00:00+09:00</published><updated>2021-04-11T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-04-11:/zhan-lue-hui-yi-zhong-20213.html</id><content type="html">&lt;p&gt;紹介をほぼ進めた。背景理論をどこまで書くか考える。
また、NARUの警告つぶしをした。ほぼこれで固まるかな。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www5d.biglobe.ne.jp/~noocyte/Programming/CMacros.html"&gt;C/C++ 関数・マクロ集 ((ほぼ？) 処理系・OS 非依存)&lt;/a&gt; Cマクロ集（いつか使える）&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://cppemb.blog17.fc2.com/blog-entry-21.html"&gt;境界調整（アラインメント）を調べる&lt;/a&gt; alignofの可搬性のある実装。どこかで刺さるはず。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://git.sr.ht/~rabbits/uxn/tree/master/item/src/uxn.c"&gt;~rabbits/uxn&lt;/a&gt; 200行以内の8bit(16bitもっぽい)スタックマシン実装。本質が全て詰まっている。解説本あったら買う。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ethw.org/History_of_Lossless_Data_Compression_Algorithms"&gt;History of Lossless Data Compression Algorithms&lt;/a&gt; ロスレスデータ圧縮アルゴリズムの歴史と特許批判&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://android.googlesource.com/platform/external/libldac/"&gt;libldac&lt;/a&gt; ソニーの高音質ロッシーコーデックLDACのソース。オープンソース化している。DCTベースのようだが詳細不明。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>戦略会議中2021(2)</title><link href="/zhan-lue-hui-yi-zhong-20212.html" rel="alternate"></link><published>2021-04-08T10:00:00+09:00</published><updated>2021-04-08T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-04-08:/zhan-lue-hui-yi-zhong-20212.html</id><content type="html">&lt;p&gt;研究紹介を進めながら、今年一年をどうするか考えつつある。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://elvera.nue.tu-berlin.de/files/0843Purat1997.pdf"&gt;Lossless Transform Coding of Audio Signals&lt;/a&gt; LTACの理論解説論文&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>戦略会議中2021(1)</title><link href="/zhan-lue-hui-yi-zhong-20211.html" rel="alternate"></link><published>2021-04-07T10:00:00+09:00</published><updated>2021-04-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-04-07:/zhan-lue-hui-yi-zhong-20211.html</id><content type="html">&lt;p&gt;今年一年をどう過ごすか決めつつある。今年はウェーブレットを攻める。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.oreilly.co.jp/BOOK/osp/OpenSource_Web_Version/Web_version000106.html"&gt;オープンソースソフトウェア 彼らはいかにしてビジネススタンダードになったのか&lt;/a&gt; OSSの偉人たちのコメントがただで見れる。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(32)</title><link href="/kodetsukuzuo-ri2021chun-32.html" rel="alternate"></link><published>2021-04-01T10:00:00+09:00</published><updated>2021-04-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-04-01:/kodetsukuzuo-ri2021chun-32.html</id><content type="html">&lt;p&gt;.editorconfigのチェックを追加。github actionsに追加。便利で宜しい。&lt;/p&gt;
&lt;p&gt;つかの間の休息。今日はmsbuild対応と、playerビルド時にpulseaudioを導入したい（sudo apt-getでいいらしい）。また、gtestをWindowsで動かすには…？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://zenn.dev/shimat/articles/d9ed0345c9866e"&gt;GitHub ActionsでMSBuildによるビルドを行う&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ライブラリの整理もしたい。。。ライブラリを細く切りすぎてる感じがある。→オブジェクトファイルのみを取るやり方があった。全てを1つのライブラリにまとめられた。勝利。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(31)</title><link href="/kodetsukuzuo-ri2021chun-31.html" rel="alternate"></link><published>2021-03-31T10:00:00+09:00</published><updated>2021-03-31T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-31:/kodetsukuzuo-ri2021chun-31.html</id><content type="html">&lt;p&gt;editorconfigに怒られてるが、インデント調整を手でやるのがめんどい。vimでうまくやれないか（プラグイン無しで）調べていたら、tabstop=4として、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vim -c &lt;span class="s1"&gt;&amp;#39;normal! gg=G&amp;#39;&lt;/span&gt; -c &lt;span class="s1"&gt;&amp;#39;:wq&amp;#39;&lt;/span&gt; CMakeLists.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;で行けることが分かった。-cはvim起動時にコマンドを実行するコマンド。'normal'はノーマルコマンドをぶち込む。gg=Gでファイル全体をインデント。':wq'で保存して終了。&lt;/p&gt;
&lt;p&gt;vimのインデントの挙動もすこし辛かったのでいじった。 &lt;a class="reference external" href="https://vim-jp.org/vimdoc-ja/indent.html#cino-E"&gt;ここ&lt;/a&gt; 参照。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(30)</title><link href="/kodetsukuzuo-ri2021chun-30.html" rel="alternate"></link><published>2021-03-30T10:00:00+09:00</published><updated>2021-03-30T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-30:/kodetsukuzuo-ri2021chun-30.html</id><content type="html">&lt;p&gt;このスキにプロセッサをワーク領域対応させるか。やった。作業なので特に工夫はない。ワークサイズがどこかで重要になるかも。&lt;/p&gt;
&lt;p&gt;整理として &lt;cite&gt;.editorconfig&lt;/cite&gt; 設定して &lt;cite&gt;editorconfig-checker&lt;/cite&gt; かけたらボロボロであることが分かった。修正しなきゃ。でも論文返ってきた。直す。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.gfd-dennou.org/arch/hiroki/homepage-old/main027.html"&gt;科学英語論文における時制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;のんびりしてたらBNN(Binarised Newral Network)を予測モデルに使うのが良さそうというのが去来した。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(29)</title><link href="/kodetsukuzuo-ri2021chun-29.html" rel="alternate"></link><published>2021-03-29T10:00:00+09:00</published><updated>2021-03-29T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-29:/kodetsukuzuo-ri2021chun-29.html</id><summary type="html">&lt;p&gt;プレーヤー作成中、ブロックデコード関数を公開したけど、仕様の厳しさを感じている。末端でブロックサンプル数が少なくなったときの処理が難しい。&lt;/p&gt;
&lt;p&gt;ブロックヘッダにサンプル数を記録すべきでは無いかと考えている。そしてヘッダのブロックあたりサンプル数は最大ブロックサンプル数に変更。そうしないと現在のブロックをデコードするときに何サンプルデコードすべきかわからなくなる。末端までサンプル数固定にするのもありだけど、無音が挿入されるのが汚い。&lt;/p&gt;
&lt;p&gt;論文についての返事がないので実装を進めた。ブロックヘッダにサンプル数を入れた。&lt;/p&gt;
&lt;p&gt;単純再生サンプル作った。この春できるのはここらへんまでかな。参考にしたリンクは以下。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gist.github.com/andormade/1360885/6b239efc7bc59a7dd038b9543b98bdd6afd40559"&gt;Audio Queue example&lt;/a&gt; CoreAudio出力の参考に。&lt;/li&gt;
&lt;li&gt;WASAPIが一番大変だった&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gist.github.com/kevinmoran/3d05e190fb4e7f27c1043a3ba321cede"&gt;WASAPI Play .wav File.cpp&lt;/a&gt; わかりやすかったがWAVEFORMATEXを0クリアしてなくてCbsizeが未初期化クラッシュ。ドハマリ&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://charatsoft.sakura.ne.jp/develop/toaru2/index.php?did=7"&gt;WASAPIをプログラムしてみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ameblo.jp/shuz096/entry-10916035039.html"&gt;WASAPIによる音声再生&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://achurch.org/SIL/current/src/sysdep/windows/sound-wasapi.c"&gt;System Interface Library for games&lt;/a&gt; ピュアCでやろうとするとGUIDが取れない。自力でGUIDを定義しているのがこれ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://0pointer.de/lennart/projects/pulseaudio/doxygen/pacat-simple_8c-example.html"&gt;pacat-simple.c&lt;/a&gt; pulseaudio出力の参考に。pa_simpleで十分だった。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;データフォーマット&lt;/h2&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;ヘッダフォーマット&lt;/h3&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;bit幅&lt;/th&gt;
&lt;th class="head"&gt;内容&lt;/th&gt;
&lt;th class="head"&gt;補足&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;&lt;cite&gt;'N', 'A', 'R', 'U'&lt;/cite&gt;&lt;/td&gt;
&lt;td&gt;NARUファイルであることを示すシグネチャ …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;プレーヤー作成中、ブロックデコード関数を公開したけど、仕様の厳しさを感じている。末端でブロックサンプル数が少なくなったときの処理が難しい。&lt;/p&gt;
&lt;p&gt;ブロックヘッダにサンプル数を記録すべきでは無いかと考えている。そしてヘッダのブロックあたりサンプル数は最大ブロックサンプル数に変更。そうしないと現在のブロックをデコードするときに何サンプルデコードすべきかわからなくなる。末端までサンプル数固定にするのもありだけど、無音が挿入されるのが汚い。&lt;/p&gt;
&lt;p&gt;論文についての返事がないので実装を進めた。ブロックヘッダにサンプル数を入れた。&lt;/p&gt;
&lt;p&gt;単純再生サンプル作った。この春できるのはここらへんまでかな。参考にしたリンクは以下。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gist.github.com/andormade/1360885/6b239efc7bc59a7dd038b9543b98bdd6afd40559"&gt;Audio Queue example&lt;/a&gt; CoreAudio出力の参考に。&lt;/li&gt;
&lt;li&gt;WASAPIが一番大変だった&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gist.github.com/kevinmoran/3d05e190fb4e7f27c1043a3ba321cede"&gt;WASAPI Play .wav File.cpp&lt;/a&gt; わかりやすかったがWAVEFORMATEXを0クリアしてなくてCbsizeが未初期化クラッシュ。ドハマリ&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://charatsoft.sakura.ne.jp/develop/toaru2/index.php?did=7"&gt;WASAPIをプログラムしてみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ameblo.jp/shuz096/entry-10916035039.html"&gt;WASAPIによる音声再生&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://achurch.org/SIL/current/src/sysdep/windows/sound-wasapi.c"&gt;System Interface Library for games&lt;/a&gt; ピュアCでやろうとするとGUIDが取れない。自力でGUIDを定義しているのがこれ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://0pointer.de/lennart/projects/pulseaudio/doxygen/pacat-simple_8c-example.html"&gt;pacat-simple.c&lt;/a&gt; pulseaudio出力の参考に。pa_simpleで十分だった。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;データフォーマット&lt;/h2&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;ヘッダフォーマット&lt;/h3&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;bit幅&lt;/th&gt;
&lt;th class="head"&gt;内容&lt;/th&gt;
&lt;th class="head"&gt;補足&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;&lt;cite&gt;'N', 'A', 'R', 'U'&lt;/cite&gt;&lt;/td&gt;
&lt;td&gt;NARUファイルであることを示すシグネチャ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;フォーマットバージョン番号&lt;/td&gt;
&lt;td&gt;エンコードしたときのフォーマットバージョン&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;エンコーダバージョン番号&lt;/td&gt;
&lt;td&gt;エンコードしたときのエンコーダバージョン&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;チャンネル数&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;サンプル数&lt;/td&gt;
&lt;td&gt;1チャンネルあたりの全サンプル数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;サンプリングレート&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;サンプルあたりビット数&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;ブロックあたりサンプル数&lt;/td&gt;
&lt;td&gt;現状固定の想定。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;フィルタ次数N&lt;/td&gt;
&lt;td&gt;2の冪定数に限定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;AR(p) モデルの次数p&lt;/td&gt;
&lt;td&gt;N &amp;gt; 2*p を満たさなければならない&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;チャンネル毎の処理法&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;ブロックフォーマット&lt;/h3&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;bit幅&lt;/th&gt;
&lt;th class="head"&gt;内容&lt;/th&gt;
&lt;th class="head"&gt;補足&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;&lt;cite&gt;'0xFFFF'&lt;/cite&gt;&lt;/td&gt;
&lt;td&gt;ブロック先頭を示す同期コード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;ブロックサイズ&lt;/td&gt;
&lt;td&gt;この領域以降のブロックのサイズ[byte]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;CRC16&lt;/td&gt;
&lt;td&gt;この領域以降のブロックのCRC16値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;ブロックデータタイプ&lt;/td&gt;
&lt;td&gt;0:残差、1:無音（ランレングス符号化）、2:生データ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;チャンネルあたりサンプル数&lt;/td&gt;
&lt;td&gt;このブロックに含まれる1チャンネルあたりのサンプル数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;不定&lt;/td&gt;
&lt;td&gt;データ&lt;/td&gt;
&lt;td&gt;圧縮済みデータ or 生データ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="todo"&gt;
&lt;h3&gt;TODOリスト&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;リングバッファアクセス高速化: 済&lt;/li&gt;
&lt;li&gt;ハンドルのワーク配置化: 済&lt;ul&gt;
&lt;li&gt;将来的にフィルタもワーク配置したい。自己割当なしで実装すれば良さそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CRC16対応: 済&lt;/li&gt;
&lt;li&gt;コマンドライン整理: 済&lt;/li&gt;
&lt;li&gt;プリセット選定: 済&lt;ul&gt;
&lt;li&gt;いまのところ、(NGSA次数, SA次数, ブロックサイズ) と書くとしたとき&lt;ul&gt;
&lt;li&gt;高速（低圧縮モード）は(4, 4, 8192)&lt;/li&gt;
&lt;li&gt;通常（デフォルト）は(8, 8, 8192)&lt;/li&gt;
&lt;li&gt;低速（高圧縮モード）は(16, 8, 16384)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;でいこうと思ってたけど、フィルタ次数を増やしても負荷インパクトが大きくならない+圧縮率が向上し続けるのを見て、次数は4, 8, 16, 32, 64まで選べるようにした。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MSVC環境で &lt;cite&gt;_BitScanReverse&lt;/cite&gt; を使う: 済&lt;/li&gt;
&lt;li&gt;MSVC環境で &lt;cite&gt;gtest&lt;/cite&gt; できるようにする: 手が空いたらでよい。&lt;/li&gt;
&lt;li&gt;評価開始（評価スクリプトを作る。Rubyでいい。）&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(28)</title><link href="/kodetsukuzuo-ri2021chun-28.html" rel="alternate"></link><published>2021-03-27T10:00:00+09:00</published><updated>2021-03-27T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-27:/kodetsukuzuo-ri2021chun-28.html</id><content type="html">&lt;p&gt;論文化が入ってしまったので作業が止まった。。。ギリギリ形にはなってる。&lt;/p&gt;
&lt;p&gt;Monkey's AudioがCNN使ってるのを改めて見る。Binarised NNとか使えないか妄想する。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;コーダーのパラメーター数は定数でいい。引数いらん。&lt;ul&gt;
&lt;li&gt;と思ってやってみたけど、さして負荷変わるわけでもなし、実装が単純になったかというとそうでもないのでやめる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プレーヤー作りたい。サウンドドライバのインターフェイスは最小限に。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(27)</title><link href="/kodetsukuzuo-ri2021chun-27.html" rel="alternate"></link><published>2021-03-22T10:00:00+09:00</published><updated>2021-03-22T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-22:/kodetsukuzuo-ri2021chun-27.html</id><summary type="html">&lt;p&gt;再度確かめてwavpack(-hh)を0.1%リードしているのを再確認。実装を修正、テストを固めた。アサートはデコードが不完全なことに起因していた。&lt;/p&gt;
&lt;p&gt;お話作りにはいる（が、23日になってしまった…）&lt;/p&gt;
&lt;p&gt;wavpackのsign algorithmの係数更新がかっこよすぎる...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#if 1   &lt;/span&gt;&lt;span class="c1"&gt;// PERFCOND&lt;/span&gt;
&lt;span class="cp"&gt;#define update_weight(weight, delta, source, result) \&lt;/span&gt;
&lt;span class="cp"&gt;    if (source &amp;amp;&amp;amp; result) { int32_t s = (int32_t) (source ^ result) &amp;gt;&amp;gt; 31; weight = (delta ^ s) + (weight - s); }&lt;/span&gt;
&lt;span class="cp"&gt;#elif 1&lt;/span&gt;
&lt;span class="cp"&gt;#define update_weight(weight, delta, source, result) \&lt;/span&gt;
&lt;span class="cp"&gt;    if (source &amp;amp;&amp;amp; result) weight += (((source ^ result …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;再度確かめてwavpack(-hh)を0.1%リードしているのを再確認。実装を修正、テストを固めた。アサートはデコードが不完全なことに起因していた。&lt;/p&gt;
&lt;p&gt;お話作りにはいる（が、23日になってしまった…）&lt;/p&gt;
&lt;p&gt;wavpackのsign algorithmの係数更新がかっこよすぎる...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#if 1   &lt;/span&gt;&lt;span class="c1"&gt;// PERFCOND&lt;/span&gt;
&lt;span class="cp"&gt;#define update_weight(weight, delta, source, result) \&lt;/span&gt;
&lt;span class="cp"&gt;    if (source &amp;amp;&amp;amp; result) { int32_t s = (int32_t) (source ^ result) &amp;gt;&amp;gt; 31; weight = (delta ^ s) + (weight - s); }&lt;/span&gt;
&lt;span class="cp"&gt;#elif 1&lt;/span&gt;
&lt;span class="cp"&gt;#define update_weight(weight, delta, source, result) \&lt;/span&gt;
&lt;span class="cp"&gt;    if (source &amp;amp;&amp;amp; result) weight += (((source ^ result) &amp;gt;&amp;gt; 30) | 1) * delta;&lt;/span&gt;
&lt;span class="cp"&gt;#else&lt;/span&gt;
&lt;span class="cp"&gt;#define update_weight(weight, delta, source, result) \&lt;/span&gt;
&lt;span class="cp"&gt;    if (source &amp;amp;&amp;amp; result) (source ^ result) &amp;lt; 0 ? (weight -= delta) : (weight += delta);&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;cite&gt;(source ^ result) &amp;gt;&amp;gt; 31&lt;/cite&gt; で予測と信号の符号が合っているかどうかがわかる。合ってたら0, 合ってなかったら~0=-1。係数更新も &lt;cite&gt;weight = (delta ^ s) + (weight - s)&lt;/cite&gt; で確かに成立している( &lt;cite&gt;s=0,~0=-1&lt;/cite&gt; で考えよ）。難点は、source == resultのときに+=で更新してしまうところか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(26)</title><link href="/kodetsukuzuo-ri2021chun-26.html" rel="alternate"></link><published>2021-03-21T10:00:00+09:00</published><updated>2021-03-21T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-21:/kodetsukuzuo-ri2021chun-26.html</id><content type="html">&lt;p&gt;圧縮率向上の工夫として、やはり、振幅に応じてステップサイズ乗じるのが効くはず。（固定でシフト量をいじるとかなり圧縮率が変わってくるので）&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;やってみたが、計測した振幅（分散）をどうステップサイズに反映させるかがうまく行かないのでやめる。単純に分散逆数を乗じるとステップサイズが大きくなりすぎて劣化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他にも、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;プリエンファシスのシフト量を5から4に変えたら若干の改善が見られたので採用。とおもったけどもう一度検証したら悪化してた。5のままにする。&lt;/li&gt;
&lt;li&gt;SAのフィルタ次数を16にした時、そのままでは性能が悪いが、係数更新時にlog2(次数)だけ右シフトすると具合がいい（これは次数で割っていることに相当する）。高振幅な音源では改善したけど、問題のデータでは悪化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さらにあがいていると、SAは右シフト量0で更新すると、低振幅音源で安定してよい圧縮率を出してくれる事がわかった（当然高振幅音源は悪化するけど、それほどひどくない）。特にクラシック音源に限ればwavpack(-hh)を0.5%リードしている。ワン・ツー・スゥイーツでもリードしているし、話の作り方としても良いかもしれないので、これで検証掛けてみる。就寝。&lt;/p&gt;
&lt;p&gt;3:30くらいになんか勝手に起きた。結果を見たら0.1%リードしてるのを確認した。念の為テストを実行したら圧縮できずにアサートしている…まだ怪しい。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(25)</title><link href="/kodetsukuzuo-ri2021chun-25.html" rel="alternate"></link><published>2021-03-20T10:00:00+09:00</published><updated>2021-03-20T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-20:/kodetsukuzuo-ri2021chun-25.html</id><content type="html">&lt;p&gt;金曜日に試した項目を整理。やはり低振幅信号ではGolomb符号が重要なので突っ込んだ。移動が多くて夕方過ぎは失神した。&lt;/p&gt;
&lt;p&gt;ほぼ最終手段だけど、エンコードを複数回実行する手段を突っ込んだ。とうぜん圧縮率は上がる。当然エンコード負荷もあがる。これから評価。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(24)</title><link href="/kodetsukuzuo-ri2021chun-24.html" rel="alternate"></link><published>2021-03-19T10:00:00+09:00</published><updated>2021-03-19T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-19:/kodetsukuzuo-ri2021chun-24.html</id><content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;ゴロムは減るけど、最終手段としよう。気になってるのはステップサイズのとり方かな。&lt;/li&gt;
&lt;li&gt;ブロックヘッダのデータのビット幅は8でもよかったしサイズ削減に貢献したので8に戻した。&lt;/li&gt;
&lt;li&gt;いろいろあがく。低振幅音源で効くのでゴロム符号は採用。SAの残差をsignからlogに置き換えたら低振幅音源で改善傾向。wavpack+0.4%くらい(-m4だと+0.1%)&lt;/li&gt;
&lt;li&gt;うーん、Golomb符号ありなら、signもlogもあんまり変わらない感じ。Golombの影響力が大きい。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(23)</title><link href="/kodetsukuzuo-ri2021chun-23.html" rel="alternate"></link><published>2021-03-18T10:00:00+09:00</published><updated>2021-03-18T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-18:/kodetsukuzuo-ri2021chun-23.html</id><summary type="html">&lt;p&gt;評価スクリプトをSLAから持ってきて試してみると、平均圧縮率が悪い。
なぜだ。手元の音源ではよかったのに。&lt;/p&gt;
&lt;p&gt;結果を見ると、音量が控えめな音源でかなり性能が悪くなっている事がわかった。（完全な無音ではない）&lt;/p&gt;
&lt;p&gt;フィルタ次数を減らしたほうが結果が良い状態。どうする。観察。&lt;/p&gt;
&lt;p&gt;フィルタ係数を見ると、次数16では大きくなりすぎている印象。。そこで、フィルタ係数のビット幅を小さくしたら改善に向かったが、flacには及ばない。また、SLAと同じようにライスパラメータが小さいときは固定のゴロム符号を行うようにしたらわずかに改善した。ゴロム符号の対処は最終手段とする。&lt;/p&gt;
&lt;p&gt;もっとフィルタ係数の変化を観察すべきかと思う。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;AR係数が小さいときはほぼ白色雑音だから係数をリセットする→すこしは良くなったけどだめだった。&lt;/li&gt;
&lt;li&gt;フィルタ係数（ブロックヘッダ）の記録にとるビット幅を8から12に増やしたら改善傾向。しかしまだ断然悪い。（追記：NGSAの計算精度向上後は8の方が良かった）&lt;/li&gt;
&lt;li&gt;以前フィルタ末尾の重みが大きかったのを見ていた。（末尾が原因で係数右シフトが起きてた）末尾係数を見てみる。&lt;ul&gt;
&lt;li&gt;係数の動きが不自然（先頭と末尾の動きが同期してる等）なので自然勾配の更新がおかしいと思って、勾配における積和演算で丸めをやめたら、低振幅音源で圧縮率が大幅に改善した（全体的に良くなったので採用）。。。。固定小数演算よくわからん・・・なんで良くなった…。多分、丸めの方向が正方向にしかできてなかったのが災いしていたかも。引くときは丸めのための加算がいらないはず。&lt;/li&gt;
&lt;li&gt;ステップサイズを大きくとると、低振幅音源で改善、大振幅音源で悪化。当然だけど、これから、ステップサイズは分散に合わせて変えるべきであることがわかる。&lt;/li&gt;
&lt;li&gt;これでWavpack(-hh)と比べて …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;評価スクリプトをSLAから持ってきて試してみると、平均圧縮率が悪い。
なぜだ。手元の音源ではよかったのに。&lt;/p&gt;
&lt;p&gt;結果を見ると、音量が控えめな音源でかなり性能が悪くなっている事がわかった。（完全な無音ではない）&lt;/p&gt;
&lt;p&gt;フィルタ次数を減らしたほうが結果が良い状態。どうする。観察。&lt;/p&gt;
&lt;p&gt;フィルタ係数を見ると、次数16では大きくなりすぎている印象。。そこで、フィルタ係数のビット幅を小さくしたら改善に向かったが、flacには及ばない。また、SLAと同じようにライスパラメータが小さいときは固定のゴロム符号を行うようにしたらわずかに改善した。ゴロム符号の対処は最終手段とする。&lt;/p&gt;
&lt;p&gt;もっとフィルタ係数の変化を観察すべきかと思う。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;AR係数が小さいときはほぼ白色雑音だから係数をリセットする→すこしは良くなったけどだめだった。&lt;/li&gt;
&lt;li&gt;フィルタ係数（ブロックヘッダ）の記録にとるビット幅を8から12に増やしたら改善傾向。しかしまだ断然悪い。（追記：NGSAの計算精度向上後は8の方が良かった）&lt;/li&gt;
&lt;li&gt;以前フィルタ末尾の重みが大きかったのを見ていた。（末尾が原因で係数右シフトが起きてた）末尾係数を見てみる。&lt;ul&gt;
&lt;li&gt;係数の動きが不自然（先頭と末尾の動きが同期してる等）なので自然勾配の更新がおかしいと思って、勾配における積和演算で丸めをやめたら、低振幅音源で圧縮率が大幅に改善した（全体的に良くなったので採用）。。。。固定小数演算よくわからん・・・なんで良くなった…。多分、丸めの方向が正方向にしかできてなかったのが災いしていたかも。引くときは丸めのための加算がいらないはず。&lt;/li&gt;
&lt;li&gt;ステップサイズを大きくとると、低振幅音源で改善、大振幅音源で悪化。当然だけど、これから、ステップサイズは分散に合わせて変えるべきであることがわかる。&lt;/li&gt;
&lt;li&gt;これでWavpack(-hh)と比べて+0.5%くらい。ゴロムを加えるのもあり。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(22)</title><link href="/kodetsukuzuo-ri2021chun-22.html" rel="alternate"></link><published>2021-03-17T10:00:00+09:00</published><updated>2021-03-17T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-17:/kodetsukuzuo-ri2021chun-22.html</id><content type="html">&lt;p&gt;CRC16対応をした。あとはコマンドライン整理とプリセット精査なんだけど、処理負荷でどこが重くなってんのか見ておきたい。&lt;/p&gt;
&lt;p&gt;負荷測定については、instrumentsがdeparchedなので、 &lt;cite&gt;xcrun xctrace&lt;/cite&gt; を使う。&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
xcrun xctrace record --template 'Time Profiler' --launch -- ./naru -e a.wav a.nar
&lt;/pre&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(21)</title><link href="/kodetsukuzuo-ri2021chun-21.html" rel="alternate"></link><published>2021-03-16T10:00:00+09:00</published><updated>2021-03-16T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-16:/kodetsukuzuo-ri2021chun-21.html</id><content type="html">&lt;p&gt;ワーク配置をする。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LPC計算ハンドル: 済&lt;/li&gt;
&lt;li&gt;コーダー: 済（まよったけど、今後別用途ありうる）&lt;/li&gt;
&lt;li&gt;プロセッサ: やめる。内部モジュールであって構造体公開してるし。&lt;/li&gt;
&lt;li&gt;エンコーダ: 済&lt;/li&gt;
&lt;li&gt;デコーダ: 済&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の順に。かるくデコーダのワークサイズみた。8ch, 最大32次とすると9kくらい。プロセッサがほとんどを占めてる。まだメモリを削る要望はないけど、やるとしたらここかな。コンフィグの最大次数に合わせて動的確保する実装に変えるべき。&lt;/p&gt;
&lt;p&gt;Windowsで軽く動かしてたら、NLZは &lt;cite&gt;_BitScanReverse&lt;/cite&gt; を使えば早くできそうな印象で、やっつけたらたしかに早くなった。630ms-&amp;gt;550msとか。全部NLZ(CLZ)使ってんのもよくなくて、CTZも使ったほうがいいんじゃないか。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://blog.jiubao.org/2015/01/gcc-bitscanforward-bitscanreverse-msvc.html"&gt;gcc で _BitScanForward &amp;amp; _BitScanReverse 互換関数、MSVC で __builtin_clz &amp;amp; __builtin_ctz 互換関数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(20)</title><link href="/kodetsukuzuo-ri2021chun-20.html" rel="alternate"></link><published>2021-03-15T10:00:00+09:00</published><updated>2021-03-15T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-15:/kodetsukuzuo-ri2021chun-20.html</id><content type="html">&lt;p&gt;3/13はイベント、3/14はリングバッファ高速化（やった）。今日3/15は事務用で一日潰れる。&lt;/p&gt;
&lt;p&gt;作業開始は22:30となる。また、論文にまとめないといけなそうな雰囲気。しかし焦りたくない。&lt;/p&gt;
&lt;p&gt;今日はフィルタモジュール整理から初めて、できれば&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LPC計算ハンドル&lt;/li&gt;
&lt;li&gt;コーダー&lt;/li&gt;
&lt;li&gt;プロセッサ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;をワーク配置形式に作っていきたい。フィルタモジュール整理してたら24時回りそう。。。。&lt;/p&gt;
&lt;p&gt;AR次数が2以上の場合に対処していたら1:00回ったので切り上げる。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(19)</title><link href="/kodetsukuzuo-ri2021chun-19.html" rel="alternate"></link><published>2021-03-12T10:00:00+09:00</published><updated>2021-03-12T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-12:/kodetsukuzuo-ri2021chun-19.html</id><content type="html">&lt;p&gt;Riceパラメータはlog2で記録するようにした。
残差が大きく(=圧縮率が悪化)なったら対策を考える。問題後回し。&lt;/p&gt;
&lt;p&gt;そして、固定小数幅を14bitにするのを試行する。→やってみたら実音声で大幅悪化。やめやめ。&lt;/p&gt;
&lt;p&gt;残りで大きいところは&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;リングバッファアクセス高速化&lt;/li&gt;
&lt;li&gt;ハンドルのワーク配置化&lt;/li&gt;
&lt;li&gt;コマンドライン整理&lt;/li&gt;
&lt;li&gt;プリセット選定&lt;ul&gt;
&lt;li&gt;いまのところ、(NGSA次数, SA次数, ブロックサイズ) と書くとしたとき&lt;ul&gt;
&lt;li&gt;高速（低圧縮モード）は(4, 4, 8192)&lt;/li&gt;
&lt;li&gt;通常（デフォルト）は(8, 8, 8192)&lt;/li&gt;
&lt;li&gt;低速（高圧縮モード）は(16, 8, 16384)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上が残件になるが、致命的なところは除いたつもりなので、今の内容で公開する。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(18)</title><link href="/kodetsukuzuo-ri2021chun-18.html" rel="alternate"></link><published>2021-03-11T10:00:00+09:00</published><updated>2021-03-11T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-11:/kodetsukuzuo-ri2021chun-18.html</id><content type="html">&lt;p&gt;1サンプル単位で振動する信号への対処を考慮中。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;64bit化してオーバーフロー原因かしらべる-&amp;gt;コンパイルエラー多発。そして解決してない。オーバーフローせずに吹っ飛んでるっぽい。&lt;/li&gt;
&lt;li&gt;プリエンファシスをLPCで計算した1次フィルタに置き換える: 前提がほぼ崩れるので最終手段に近い。&lt;/li&gt;
&lt;li&gt;アサートしているのは（残差増大に伴って）Rice符号の初期パラメータが大きくなりすぎているからなので、パラメータ保存領域を大きくする&lt;ul&gt;
&lt;li&gt;うまく行かなかった。発散してるっぽいし、この対処だと本質的な問題（発散）を隠してる気がする。&lt;/li&gt;
&lt;li&gt;Riceパラメータのlog2ceilをとって記録することで5bitに確実に収まり、アサートは発生しなくなる…が、やっぱ残差が大きくなっている事実は変わらないわけで、どうするか考えるべき。テストケースは18とか出てるので大きいとおもふ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ブロックサンプル数を8192より大きくすると収束する&lt;ul&gt;
&lt;li&gt;何故？AR係数がうまく求まるから？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;固定小数のビット数を14にしたら性能向上したけど、後の検証に回す。（12,13だと性能悪化）&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(17)</title><link href="/kodetsukuzuo-ri2021chun-17.html" rel="alternate"></link><published>2021-03-10T10:00:00+09:00</published><updated>2021-03-10T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-10:/kodetsukuzuo-ri2021chun-17.html</id><content type="html">&lt;p&gt;テストケース追加中。実装も並行して修正かけてる。&lt;/p&gt;
&lt;p&gt;ノイズ（エントロピー大）エンコード時に残差が大きくなってライスパラメータが記録できずクラッシュしていた。このため、生データブロックを追加。&lt;/p&gt;
&lt;p&gt;同時にブロックヘッダのフォーマットを整理。ビットストリームなしでもブロックヘッダはエンコード/デコードできるようにする。そのためブロックデータタイプを1byteにした。&lt;/p&gt;
&lt;p&gt;1サンプル周期の振動に対して残差が発散している。。。
デバッグ中。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;NGSAの勾配がすぐに止まってしまうのを見ている。（定常的だから当然かも知れない）。&lt;/li&gt;
&lt;li&gt;プリエンファシスが逆効果（振幅増大）している...。オーバーフロー多発。&lt;/li&gt;
&lt;li&gt;勾配の更新タイミングを履歴更新後にしたら若干改善したが、それでも発散している。（以前圧縮率悪化を確認していたが、あまり悪化しなかった。何故？）&lt;/li&gt;
&lt;li&gt;係数初期値をLPCで求めるのもありか？&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(16)</title><link href="/kodetsukuzuo-ri2021chun-16.html" rel="alternate"></link><published>2021-03-09T10:00:00+09:00</published><updated>2021-03-09T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-09:/kodetsukuzuo-ri2021chun-16.html</id><content type="html">&lt;p&gt;テストケース追加中。&lt;/p&gt;
&lt;p&gt;動かしていて、ブロックにサイズに準じるデータが無いことに気づく。
AADでは固定ビットレートだからブロックサイズが固定されていたのでいらなかったが、こっち可変ビットレートだから必須のはず。&lt;/p&gt;
&lt;p&gt;もう少し考えるとサイズのbit幅をいくつにしようか悩む。16bitでは小さい。SLAに倣うか→見たら32bitだった。まあそうか。
ついでにCRC検査向けに16bit入れとくか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(15)</title><link href="/kodetsukuzuo-ri2021chun-15.html" rel="alternate"></link><published>2021-03-08T10:00:00+09:00</published><updated>2021-03-08T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-08:/kodetsukuzuo-ri2021chun-15.html</id><content type="html">&lt;p&gt;引き続き発散現象調査。&lt;/p&gt;
&lt;p&gt;対策として、フィルタ係数のクリップ処理を入れてしまうのはどうかと考えている。&lt;/p&gt;
&lt;p&gt;なるべく、というか厳密にフィルタの出力を変えないように係数をクリップしたいのだが、どうすればいいのか。その議論ってあんまりされてないように見えるんやがな。（FIRフィルタ係数の同値類ってなんだ？）&lt;/p&gt;
&lt;p&gt;色々見ると、（あんまり記述無いけど）&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.csee.umbc.edu/~tinoosh/cmpe691/slides/Handout.fir.scaling.pdf"&gt;FIR FILTER SCALING&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;にあるように、全係数を定数で割ると案の定ゲインが定数倍だけ小さくなる。しかし周波数特性はそのまま。&lt;/p&gt;
&lt;p&gt;周波数特性は保たれるからええか、というノリで定数倍の方策を取る。幅は18bit（[-4,4]の範囲）とした。16, 17bitだと顕著に性能が悪い。しっかしオーバーフローが怖いかも。&lt;/p&gt;
&lt;p&gt;テスト追加に入る。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(14)</title><link href="/kodetsukuzuo-ri2021chun-14.html" rel="alternate"></link><published>2021-03-07T10:00:00+09:00</published><updated>2021-03-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-07:/kodetsukuzuo-ri2021chun-14.html</id><content type="html">&lt;p&gt;「重ねる努力」での発散現象を観察している。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;SAのフィルタ係数が正の値に徐々に吹っ飛んでいる&lt;/li&gt;
&lt;li&gt;ブロックの切り替わりが原因ぽい&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ブロックの切り替わりで怪しい処理はなにかと見ていたら、NGSAの残差初期値がただのデータ履歴で更新されていて、勾配が不連続になっていて怪しいことが見えた。リファレンス通りに、取得した履歴を元に自然勾配の初期値を計算してみる。&lt;/p&gt;
&lt;p&gt;すると、問題を確認したケースにおいては発散しなくなった。しかし、デバッグのためにブロックサイズを小さくして切り替わりが多く出るようにしたら再度発散。原因を追う。&lt;/p&gt;
&lt;p&gt;調査したところ、ブロックサイズを1024サンプルにしたとき、「重ねる努力」の1041000サンプル付近で「シャーン」というエントロピーの高い振幅大音源をきっかけにフィルタ係数が発散していた。もっと見たところAR係数が0.3等の低い数値をとっていた（確認したらそれまでは0.9以上をとっていたのに、急落していた。）&lt;/p&gt;
&lt;p&gt;対策をどうしようか。0.4未満ならリセットするとかやれば、1024では発散しないけど、ブロックサイズを512, 256にしたら発散する。。。（しかも、発散時にAR係数は0.9以上だった。）アドホックなのでやりたくないし、AR係数が本質的な原因では無いと考えている。&lt;/p&gt;
&lt;p&gt;バグを疑って調査を続ける。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(13)</title><link href="/kodetsukuzuo-ri2021chun-13.html" rel="alternate"></link><published>2021-03-06T10:00:00+09:00</published><updated>2021-03-06T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-06:/kodetsukuzuo-ri2021chun-13.html</id><content type="html">&lt;p&gt;デコーダを作った。といっても枠は作ってあってプロセッサ部を埋めるだけ。
動かしたところSAの係数を記録してなかった。追加。&lt;/p&gt;
&lt;p&gt;処理順序を整理して、たぶんロスレスに戻っていることを確認。&lt;/p&gt;
&lt;p&gt;テストに入っていく。大規模なテストをやる前に手元のファイルをいくつか試していると、「重ねる努力」でアサート。こいつのバグを潰したら、テスト追加に入ろう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(12)</title><link href="/kodetsukuzuo-ri2021chun-12.html" rel="alternate"></link><published>2021-03-05T10:00:00+09:00</published><updated>2021-03-05T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-05:/kodetsukuzuo-ri2021chun-12.html</id><content type="html">&lt;p&gt;ちょっとCmake整理した。&lt;/p&gt;
&lt;p&gt;で、昨日の続きといく。発散している現象はフィルタ係数をダンプしてみたけど、不連続的じゃなくてゆっくりと値が大きくなっていたので、厄介かもしれない。&lt;/p&gt;
&lt;p&gt;発散対策としてステップサイズをいじる。NGSAの係数右シフト量を4から6にしたら安定する+圧縮率上がる。設定次第でwavpack(-hh)を超える状況になる。&lt;/p&gt;
&lt;p&gt;ステップサイズをいじってコード整理。デコーダの制作に入ろうと思う。（SAのシフト前に0.5加えたら圧縮率向上した。こういうのがこわい。なお、プリエンファシスは0.5加算は不要。定数乗算だから。）
デコーダができてビットパーフェクトに戻るまではぬか喜びなので、気合い入れる。&lt;/p&gt;
&lt;p&gt;デコード側だけでもin-placeな復号ができるといいなあ・・・&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(11)</title><link href="/kodetsukuzuo-ri2021chun-11.html" rel="alternate"></link><published>2021-03-04T10:00:00+09:00</published><updated>2021-03-04T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-04:/kodetsukuzuo-ri2021chun-11.html</id><content type="html">&lt;p&gt;起床ミスって日中の作業時間が、、&lt;/p&gt;
&lt;p&gt;8bit音声に対して圧縮率が悪いのは、8bit音声を非常に低振幅(-128 - 127)のデータとして扱っているからと思われる。対策としては16bit固定小数に合わせて処理する。後でいいと思う。&lt;/p&gt;
&lt;p&gt;振幅が高い、ボーカル付きデータとしてカレンダーガールを導入したらMS処理で16bit範囲を超えてしまった…プリエンファシス処理のバッファもシフトしないとだめ。&lt;/p&gt;
&lt;p&gt;うーん、データ/フィルタ記録が馬鹿になってない。TTAを見習ってすべて8bit範囲に収まるように記録するのが吉か？（シフト量も記録しておく。）
8bitはやりすぎな気もするから、12bitも検討したい。シフト量は4bitでいいだろう。→でも、SLAでみたように、量子化幅はあんまりドラスティックに効かないとおもう。一応いじれるようにして、調節はあと。と思ったら8bitで保存しても圧縮性能に影響が大きく出ないので、8bitにしてみる。&lt;/p&gt;
&lt;p&gt;ちょっとした思いつきでSAをさらにもう一段重ねたけど不安定（圧縮率・係数発散）なのでやめておく。&lt;/p&gt;
&lt;p&gt;実装整理。in-placeにしてみた。でもコーダーが1サンプル単位で動いとらんからバッファがいる状況。早いうちになんとかしたいかも。&lt;/p&gt;
&lt;p&gt;2段目のフィルタをいじって遊んでたら、発散するパターンを見つけた。現在デバッグ中。落ち着いたらデコーダ作り始めたいところ。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(10)</title><link href="/kodetsukuzuo-ri2021chun-10.html" rel="alternate"></link><published>2021-03-03T10:00:00+09:00</published><updated>2021-03-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-03:/kodetsukuzuo-ri2021chun-10.html</id><summary type="html">&lt;p&gt;NNGSAとのRMS比較をやる。NNGSAが低いのなら後段でSAかませたい。
残差の振幅分布を見ると、やっぱNGSAの方が良い。0付近へよくデータが集まる。
RMSEもNGSAのほうが良かった。。。&lt;/p&gt;
&lt;p&gt;うーん、変だ。確かにSLAのときも全く同様の現象を見たんだけど。
実験ではNGSAとても悪かったはずなんだがなあ。。。&lt;/p&gt;
&lt;p&gt;グダグダしてのんびりとしている。根本的な改善策がないか、過去のブログを見直してみる。&lt;/p&gt;
&lt;p&gt;気になったのはTTAのエンコード部分。再帰的ライスを使っているのは知っていたが、さらに、指数移動平均によって平均を更新していることが分かった。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// aiki: 1つの残差出力&lt;/span&gt;
&lt;span class="kr"&gt;__forceinline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;tta_encoder_put_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TTA_adapt&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TTAint32&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;TTAuint32&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// aiki: 符号付き整数を符号なし整数に変換(非負数は奇, 負数は偶)&lt;/span&gt;
      &lt;span class="n"&gt;outval&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ENC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

      &lt;span class="c1"&gt;// encode Rice unsigned&lt;/span&gt;
      &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// aiki: 指数移動平均式で平均を更新: sum0 &amp;lt;- (15/16) * sum0 + outval …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;NNGSAとのRMS比較をやる。NNGSAが低いのなら後段でSAかませたい。
残差の振幅分布を見ると、やっぱNGSAの方が良い。0付近へよくデータが集まる。
RMSEもNGSAのほうが良かった。。。&lt;/p&gt;
&lt;p&gt;うーん、変だ。確かにSLAのときも全く同様の現象を見たんだけど。
実験ではNGSAとても悪かったはずなんだがなあ。。。&lt;/p&gt;
&lt;p&gt;グダグダしてのんびりとしている。根本的な改善策がないか、過去のブログを見直してみる。&lt;/p&gt;
&lt;p&gt;気になったのはTTAのエンコード部分。再帰的ライスを使っているのは知っていたが、さらに、指数移動平均によって平均を更新していることが分かった。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// aiki: 1つの残差出力&lt;/span&gt;
&lt;span class="kr"&gt;__forceinline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;tta_encoder_put_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TTA_adapt&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TTAint32&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;TTAuint32&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// aiki: 符号付き整数を符号なし整数に変換(非負数は奇, 負数は偶)&lt;/span&gt;
      &lt;span class="n"&gt;outval&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ENC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

      &lt;span class="c1"&gt;// encode Rice unsigned&lt;/span&gt;
      &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// aiki: 指数移動平均式で平均を更新: sum0 &amp;lt;- (15/16) * sum0 + outval&lt;/span&gt;
      &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;outval&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;// aiki: shift_16[x] は 2^(4 + x) = 16 * 2^(x) を計算するテーブル.&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: k0 &amp;gt; 0 &amp;amp;&amp;amp; sum0 &amp;lt; 16 * 2^(k0) ならば k0 が大きいので減らす&lt;/span&gt;
              &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: sum0 &amp;gt; 32 * 2^(k0) ならば k0 が小さいので増やす&lt;/span&gt;
              &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;bit_shift&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: 出力値が 2^(k0) 以上ならば&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: 出力値を引く: outval -= 2^(k0)&lt;/span&gt;
              &lt;span class="n"&gt;outval&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;bit_shift&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
              &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// aiki: 指数移動平均式で平均を更新: sum1 &amp;lt;- (15/16) * sum1 + outval&lt;/span&gt;
              &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;outval&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
              &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="c1"&gt;// aiki: k1 &amp;gt; 0 &amp;amp;&amp;amp; sum1 &amp;lt; 16 * 2^(k1) ならば k1 が大きいので減らす&lt;/span&gt;
                      &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="c1"&gt;// aiki: sum0 &amp;gt; 32 * 2^(k1) ならば k1 が小さいので増やす&lt;/span&gt;
                      &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// aiki: unaryの計算&lt;/span&gt;
              &lt;span class="n"&gt;unary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// aiki: elseをブロックで囲った&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: 出力値が 2^(k0) より小さければ、unaryは0&lt;/span&gt;
    &lt;span class="n"&gt;unary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// aiki: static変数の補足&lt;/span&gt;
  &lt;span class="c1"&gt;// aiki: enc_fifo_bcount: static変数。キャッシュ内のビットカウント。&lt;/span&gt;
  &lt;span class="c1"&gt;// aiki: enc_fifo_bcache: static変数。キャッシュ内のビット。&lt;/span&gt;

      &lt;span class="c1"&gt;// put unary&lt;/span&gt;
  &lt;span class="c1"&gt;// aiki: unaryの連続した1を出力する&lt;/span&gt;
      &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: キャッシュ内に1バイト以上データがあるなら1バイト未満になるまで出力&lt;/span&gt;
              &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                      &lt;span class="n"&gt;write_byte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                      &lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                      &lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="p"&gt;}&lt;/span&gt;

              &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// aiki: bit_mask[x]は下位x[bit]に1が立ったマスク&lt;/span&gt;
      &lt;span class="c1"&gt;// aiki: unaryが24以上ならば, 23bit分をマスクで一気に書き出す&lt;/span&gt;
      &lt;span class="c1"&gt;// aiki: 24が特別になっているのは, これに7bit以上のデータがあるとオーバーランするから&lt;/span&gt;
                      &lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                      &lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                      &lt;span class="n"&gt;unary&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// aiki: マスクを使って一気に書き出す&lt;/span&gt;
                      &lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                      &lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;unary&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                      &lt;span class="n"&gt;unary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

      &lt;span class="c1"&gt;// put binary&lt;/span&gt;
  &lt;span class="c1"&gt;// aiki: キャッシュ内に1バイト以上データがあるなら1バイト未満になるまで出力&lt;/span&gt;
      &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
              &lt;span class="n"&gt;write_byte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
              &lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: Rice符号の剰余部出力: k(k0 or k1)が1以上であれば、outvalの下位k[bit]を出力&lt;/span&gt;
              &lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// tta_encoder_put_value&lt;/span&gt;

&lt;span class="c1"&gt;// aiki: 1つの残差を復号&lt;/span&gt;
&lt;span class="kr"&gt;__forceinline&lt;/span&gt; &lt;span class="n"&gt;TTAint32&lt;/span&gt; &lt;span class="nf"&gt;tta_decoder_get_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TTA_adapt&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;TTAuint32&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;TTAint32&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="c1"&gt;// decode Rice unsigned&lt;/span&gt;
  &lt;span class="c1"&gt;// aiki: unary部を復号し連続した1の数をvalueに&lt;/span&gt;
  &lt;span class="c1"&gt;// aiki: バイト単位の読み出し&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
              &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;read_byte&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
              &lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0xff&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                      &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                      &lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;read_byte&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
              &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// aiki: 残ったビット分のカウント&lt;/span&gt;
      &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
              &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// aiki: valueが0ならlevelは0でk0, それ以上ならlevelは1でk1をつかう&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
              &lt;span class="n"&gt;level&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
              &lt;span class="n"&gt;level&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// aiki: Rice符号の剰余部取得: k(k0 or k1)が1以上であれば、outvalの下位k[bit]を出力&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: キャッシュがk[bit]以上になるまでバイト単位で読み込み&lt;/span&gt;
              &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                      &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;read_byte&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
                      &lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                      &lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: Rice符号の取得値の確定。右辺のvalueはunaryと同等。&lt;/span&gt;
              &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: k[bit]読み込み後のキャッシュ更新&lt;/span&gt;
              &lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: 指数移動平均式で平均を更新: sum1 &amp;lt;- (15/16) * sum1 + outval&lt;/span&gt;
              &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
              &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="c1"&gt;// aiki: k1 &amp;gt; 0 &amp;amp;&amp;amp; sum1 &amp;lt; 16 * 2^(k1) ならば k1 が大きいので減らす&lt;/span&gt;
                      &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
              &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
      &lt;span class="c1"&gt;// aiki: k1 &amp;gt; 0 &amp;amp;&amp;amp; sum1 &amp;lt; 16 * 2^(k1) ならば k1 が大きいので減らす&lt;/span&gt;
                      &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: 出力値を足す: outval += 2^(k0)&lt;/span&gt;
              &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;bit_shift&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// aiki: 指数移動平均式で平均を更新: sum0 &amp;lt;- (15/16) * sum0 + outval&lt;/span&gt;
      &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: k0 &amp;gt; 0 &amp;amp;&amp;amp; sum0 &amp;lt; 16 * 2^(k0) ならば k0 が大きいので減らす&lt;/span&gt;
              &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="c1"&gt;// aiki: sum0 &amp;gt; 32 * 2^(k0) ならば k0 が小さいので増やす&lt;/span&gt;
      &lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// aiki: 符号なし整数を符号付き整数に変換&lt;/span&gt;
      &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// tta_decoder_get_value&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ビット出力がよく洗練されている... static変数にしているのはむしろ扱いやすくしているのかもしれない。やっぱ俺はまだまだだ...&lt;/p&gt;
&lt;p&gt;単独のフィルタでは伸び悩みを感じてきたので、奥の手たるカスケードを召喚した。組み合わせとしてはNGSA-&amp;gt;SA, SA-&amp;gt;NGSA, NGSA-&amp;gt;NGSA, SA-&amp;gt;SAがあったが、NGSA-&amp;gt;SAが最もよく、フィルタ次数とブロックサイズ設定よってはwavpack(-hh)を超える結果を出したので、採用する。&lt;/p&gt;
&lt;p&gt;良くなる理由は、カスケード接続が一般によい手段であることが指摘されている他、NGSAで相関除去が強く動くからではないかと想像している。&lt;/p&gt;
&lt;p&gt;コード整理。NNGSAを廃止。1サンプル単位で予測できるように実装する。 &lt;cite&gt;static&lt;/cite&gt; 関数とするのでインライン展開が効くはず。整理していたらすべてin-placeでやりきれそうに見えた。やってしまっていいか、寝てからやってしまおう。&lt;/p&gt;
&lt;p&gt;AR係数次数0にするとSAになるわけだが、性能が良かったりする。。。。。もう少し検証必須。
また、SAは次数小さくしたほうが良い結果が出る。4とか、NGSAの半分とか。&lt;/p&gt;
&lt;p&gt;係数の観察もしたい。丸めの影響も見たいところ。&lt;/p&gt;
&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;全部in-placeにしてバッファ1つでやりきるように整理&lt;/li&gt;
&lt;li&gt;SAのフィルタ次数策定&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(9)</title><link href="/kodetsukuzuo-ri2021chun-9.html" rel="alternate"></link><published>2021-03-02T10:00:00+09:00</published><updated>2021-03-02T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-02:/kodetsukuzuo-ri2021chun-9.html</id><content type="html">&lt;p&gt;NNGSAは一旦置く。NGSAで勝負をしかけていく。&lt;/p&gt;
&lt;p&gt;ステップサイズの調節を入れてみたが、上がったり下がったり。もっとよく見る必要がある。→ステップサイズに掛ける固定小数の精度を11bitにしたら、総じて良くなったので採用の方向で検討。&lt;/p&gt;
&lt;p&gt;残差を見たら-2.0, 2.0に近い値をとっており危ないことに気づく。観察した所入力信号に不連続点が入っていた。おそらく、プリエンファシスのときにブロック先頭で毎回0入れてしまっているのが原因。→そのとおりだった。修正の結果範囲は-0.5-0.5以内に収まっている。圧縮率も向上。&lt;/p&gt;
&lt;p&gt;flacは倒せて、ttaはブロックサイズとフィルタ次数の設定次第で上回る結果。（総じて、ブロックサイズとフィルタ次数を大きく取ると良い。）
しかしwavpack(-hh)が強い。もう一段フィルタぶち込むか…まだ時期尚早か？&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(8)</title><link href="/kodetsukuzuo-ri2021chun-8.html" rel="alternate"></link><published>2021-03-01T10:00:00+09:00</published><updated>2021-03-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-01:/kodetsukuzuo-ri2021chun-8.html</id><summary type="html">&lt;p&gt;NNGSAをうまく動かしたい。キモは整数除算。&lt;/p&gt;
&lt;p&gt;と思っていたら正規化定数が負になっているのを見て、異常だと思った。アルゴリズムのミスからPython実装まで疑ったが問題なかった。&lt;/p&gt;
&lt;p&gt;そこでC言語実装版を見たら誤差が蓄積していた。固定小数演算による誤差蓄積。&lt;/p&gt;
&lt;p&gt;対策としては、ブロック計算開始時に真の値にセットし直すこと。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.sage-p.com/compone/toda/fixdec.htm"&gt;固定小数&lt;/a&gt; いつもお世話になってる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://midarekazu.g2.xrea.com/math-library.html"&gt;固定小数点数の算術関数ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://hp200lx.cocolog-nifty.com/blog/2014/11/memo-a1c8.html"&gt;■固定小数点数の除算&lt;/a&gt; 補正によって32bitのまま精度を良くする方法が載っている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.emit.jp/prog/prog_div.html"&gt;整数除算の高速化&lt;/a&gt; これ、どこかで効いてくるはず。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、除算の誤差もなんとか収まって発散は収まったように見える、が、圧縮率が悪い。&lt;/p&gt;
&lt;p&gt;短めの音声で見てみると、先頭10000サンプルぐらいの残差が大きいことが見えてきていた。正規化定数の最小値を大きく取りすぎていたので小さくするなどの対処で若干改善したが、まだLMS(AR(1))に及ばず。&lt;/p&gt;
&lt;p&gt;超えないことを真面目に追うべきなのだが、その後色々と弄っていた。すると、（やはりというか…）NGSA（正規化なしの残差の符号を取るだけ）にしたら圧縮性能が向上。。。。しかも、プリエンファシスと組み合わせてさらに圧縮性能向上。。。FLAC(-8)を超えた。SLAでやった残差のlog2を取るのは良くなかった。&lt;/p&gt;
&lt;p&gt;フィルタを2段重ねることでttaも超えた。が、wavpack(-hh)は超えない。でも2段重ねは最終手段にしたい。ギリギリまでフィルタ次数8で戦い続ける。（8にするのはAR(2 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;NNGSAをうまく動かしたい。キモは整数除算。&lt;/p&gt;
&lt;p&gt;と思っていたら正規化定数が負になっているのを見て、異常だと思った。アルゴリズムのミスからPython実装まで疑ったが問題なかった。&lt;/p&gt;
&lt;p&gt;そこでC言語実装版を見たら誤差が蓄積していた。固定小数演算による誤差蓄積。&lt;/p&gt;
&lt;p&gt;対策としては、ブロック計算開始時に真の値にセットし直すこと。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.sage-p.com/compone/toda/fixdec.htm"&gt;固定小数&lt;/a&gt; いつもお世話になってる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://midarekazu.g2.xrea.com/math-library.html"&gt;固定小数点数の算術関数ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://hp200lx.cocolog-nifty.com/blog/2014/11/memo-a1c8.html"&gt;■固定小数点数の除算&lt;/a&gt; 補正によって32bitのまま精度を良くする方法が載っている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.emit.jp/prog/prog_div.html"&gt;整数除算の高速化&lt;/a&gt; これ、どこかで効いてくるはず。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、除算の誤差もなんとか収まって発散は収まったように見える、が、圧縮率が悪い。&lt;/p&gt;
&lt;p&gt;短めの音声で見てみると、先頭10000サンプルぐらいの残差が大きいことが見えてきていた。正規化定数の最小値を大きく取りすぎていたので小さくするなどの対処で若干改善したが、まだLMS(AR(1))に及ばず。&lt;/p&gt;
&lt;p&gt;超えないことを真面目に追うべきなのだが、その後色々と弄っていた。すると、（やはりというか…）NGSA（正規化なしの残差の符号を取るだけ）にしたら圧縮性能が向上。。。。しかも、プリエンファシスと組み合わせてさらに圧縮性能向上。。。FLAC(-8)を超えた。SLAでやった残差のlog2を取るのは良くなかった。&lt;/p&gt;
&lt;p&gt;フィルタを2段重ねることでttaも超えた。が、wavpack(-hh)は超えない。でも2段重ねは最終手段にしたい。ギリギリまでフィルタ次数8で戦い続ける。（8にするのはAR(2)まで試すことができるから。4は高速モード、16は高圧縮モードにしたい。）&lt;/p&gt;
&lt;p&gt;NGSAで行くとして考えたいのはステップサイズ。分散（とAR係数から決まる係数）を掛けたほうがよいはず。自然勾配法の定義から、AR(1)の場合は &lt;span class="math"&gt;\(1/(1 - \psi_{1}^{2})\)&lt;/span&gt; を掛けてやれば良いことが見えている。
また、デコーダを作る前準備として、ブロックヘッダの仕様を策定したい。&lt;/p&gt;
&lt;p&gt;（一瞬怖くなって普通のsignアルゴリズムにしてみたら、NGSAのほうが良いのが確認できた。でも圧縮率の差は1%未満。。。）&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(6)</title><link href="/kodetsukuzuo-ri2021chun-6.html" rel="alternate"></link><published>2021-02-28T10:00:00+09:00</published><updated>2021-02-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-28:/kodetsukuzuo-ri2021chun-6.html</id><content type="html">&lt;p&gt;ナイーブな全体エンコード・デコードはできている。
また、LMS/Newton AR(1)もまあできたかなというところ。flac, wavpackと同程度に見える。ステップサイズ依存で結構性能が揺らぐ。&lt;/p&gt;
&lt;p&gt;AR(2)ではステップサイズを小さく取らないと厳しい。
また、プリエンファシスをかけると結構性能が落ちているように見える。もう少し詳しく見ていく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;AR(1)でプリエンファシスをかけると性能悪化。勾配でプリエンファシスみたいなことしてるからそりゃそうか？&lt;/li&gt;
&lt;li&gt;AR(2)は良くなった。（けどAR(1)と同じくらいの性能。）直流を削ることで解析精度が良くなっている？&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(7)</title><link href="/kodetsukuzuo-ri2021chun-7.html" rel="alternate"></link><published>2021-02-28T10:00:00+09:00</published><updated>2021-02-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-28:/kodetsukuzuo-ri2021chun-7.html</id><content type="html">&lt;p&gt;プリエンファシスを掛けるとよくない。
これは確かにAR(1)のアルゴリズム的にもうなずける。&lt;/p&gt;
&lt;p&gt;今日はNNGSAをためしてみる。が、良くない。
除算時の左シフトを入れるととても悪い。むしろ乗算と同じ、15bit右シフトを入れるとそれなりに安定してくる…&lt;/p&gt;
&lt;p&gt;いま一番良いのがLMS/Newton AR(1)でステップサイズ設定無しの組み合わせ。
しかしflacにすら及んでいない…&lt;/p&gt;
&lt;p&gt;NNGSAがうまくいかん、というところで終わりそう。除算が鬼門で、すぐにオーバーフローしてしまう。。。
オーバーフローの他に、正規化定数が小さくなりすぎて係数値が吹っ飛ぶ現象も確認。
整数除算についてデバッグと調査を続ける。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(5)</title><link href="/kodetsukuzuo-ri2021chun-5.html" rel="alternate"></link><published>2021-02-25T10:00:00+09:00</published><updated>2021-02-25T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-25:/kodetsukuzuo-ri2021chun-5.html</id><content type="html">&lt;p&gt;今日は少なくともヘッダエンコード・デコード、ハンドル作成までいっておきたい。
その先は一括エンコード、デコード関数を追加して動作確認フェイズに入りたい。そこでテストを固めてしまうと動きが鈍くなりそうなので、一括エンコード、一括デコード追加中はテスト追加一旦停止で。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(4)</title><link href="/kodetsukuzuo-ri2021chun-4.html" rel="alternate"></link><published>2021-02-24T10:00:00+09:00</published><updated>2021-02-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-24:/kodetsukuzuo-ri2021chun-4.html</id><content type="html">&lt;p&gt;ディレクトリ構成を固めてみた。
内部依存がある場合がどうなるかわからん。今日コーダーモジュールを持ってくるので、そこで何かわかるはず。&lt;/p&gt;
&lt;p&gt;→構成をかえたり、ファイル命名規則を統一したりしていたら1日ほぼ終わった。一応コーディングモジュールは持ってきた。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(3)</title><link href="/kodetsukuzuo-ri2021chun-3.html" rel="alternate"></link><published>2021-02-23T10:00:00+09:00</published><updated>2021-02-23T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-23:/kodetsukuzuo-ri2021chun-3.html</id><content type="html">&lt;p&gt;cmake+gtestのディレクトリ構成を迷っている。。。&lt;/p&gt;
&lt;p&gt;現在各モジュールごとにtestを作っているが、もしかしたら細かくやりすぎ？
SLAのときでもsrc以下にすべてを入れていたので、それでいいはず。そちらにしよう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;トップレベルにCMakeLists.txtを置く。そこでテストの分岐をこなす。&lt;/li&gt;
&lt;li&gt;src以下に全ソース&lt;/li&gt;
&lt;li&gt;include以下に公開ヘッダ&lt;/li&gt;
&lt;li&gt;test以下にテストソース&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/januswel/ctest-gtest"&gt;サンプル&lt;/a&gt; をよく見ましょう。。。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(2)</title><link href="/kodetsukuzuo-ri2021chun-2.html" rel="alternate"></link><published>2021-02-22T10:00:00+09:00</published><updated>2021-02-22T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-22:/kodetsukuzuo-ri2021chun-2.html</id><content type="html">&lt;p&gt;テスト環境整備中。&lt;/p&gt;
&lt;p&gt;gtestはC++用のフレームワークのようで、Cコンパイラでビルドするとエラーが出る（ &lt;cite&gt;&amp;lt;limits&amp;gt;&lt;/cite&gt; なんて無い、と言われた）。
でも無理やりビルドするためにcmakeの CXX で新しくプロジェクトを作った。
かなり強引にやった。型を中心に色々警告でてるし、C89との差異で苦しむかもしれない。&lt;/p&gt;
&lt;p&gt;さて、フォーマットを決めよう。フォーマットが決まればあとはそのとおり実装していくだけのはずだ。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;基本設計方針&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;AR(p) Natural Gradientの実装。&lt;/li&gt;
&lt;li&gt;符号はSLAの再帰的ライスを使用する。SLAの実装はそのままでシンボルを変えてポーティングする。&lt;/li&gt;
&lt;li&gt;目標はTTA, Wavpackの圧縮率を超えること。（超えたら対外発表可能とする）&lt;/li&gt;
&lt;li&gt;圧縮性能を試すだけなので、SIMDやアセンブリレベルの過度な高速化はしない。&lt;/li&gt;
&lt;li&gt;無音時のランレングス符号化はあり。&lt;ul&gt;
&lt;li&gt;ひとまずは残差のみで実装していく。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;データの正常性検査はほとんど入れない。（ブロックのシグネチャはあり。CRCはやらない。）&lt;/li&gt;
&lt;li&gt;ひとまずは16bitwavの対応で良い。&lt;ul&gt;
&lt;li&gt;やろうと思えばできるが、複雑化のコストが大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(1)</title><link href="/kodetsukuzuo-ri2021chun-1.html" rel="alternate"></link><published>2021-02-19T10:00:00+09:00</published><updated>2021-02-19T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-19:/kodetsukuzuo-ri2021chun-1.html</id><content type="html">&lt;p&gt;さて、コーデックづくりに入ろう。今回は、CMake/C89で作る。
テストもctestを使おうと思っており、その導入検討を行う。&lt;/p&gt;
&lt;p&gt;まず、ctestのほかにgoogleが出しているgtestというのがある。これもcmakeとの親和性が良いらしい。
今回はctestで試してみる...と思ったらgtestがいいかも。できないことはないはずなのでやってみよう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gitlab.kitware.com/cmake/community/-/wikis/doc/ctest/Testing-With-CTest"&gt;Testing With CTest&lt;/a&gt; ピンと来ないのでKitware公式情報を見る。&lt;ul&gt;
&lt;li&gt;うーん？どうもCtestは &lt;cite&gt;enable_testing()&lt;/cite&gt; によってテスト用のディレクトリを生成するのを有効化しているだけ？&lt;/li&gt;
&lt;li&gt;&lt;cite&gt;add_test&lt;/cite&gt; でテスト追加。 &lt;cite&gt;make test&lt;/cite&gt; でテスト実行。&lt;/li&gt;
&lt;li&gt;多分、プログラム実行時の返り値だけをみているっぽい。アサーションマクロとかはサポートしていない？？&lt;/li&gt;
&lt;li&gt;それだと gtest が良いということになる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/janus_wel/items/4e6c12f9104f501104c7"&gt;C++ のユニットテストをいい感じにする&lt;/a&gt; がいいかも...と思ったらgtest使ってる。うーん。&lt;ul&gt;
&lt;li&gt;&lt;cite&gt;ExternalProject&lt;/cite&gt; でCMakeの機能でgtestを導入することができる。これで可搬性が担保できそう。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/januswel/ctest-gtest"&gt;GitHubはこちら&lt;/a&gt; 構成はmain除きこれに前ならえでよいはずだ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>\(\mathrm{AR}(p)\) へ一般化(6)</title><link href="/mathrmarp-heyi-ban-hua-6.html" rel="alternate"></link><published>2021-02-12T10:00:00+09:00</published><updated>2021-02-12T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-12:/mathrmarp-heyi-ban-hua-6.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;論文出したけど、自己共分散と自己相関でまだ混乱してる。
実装時には嘘つけないので整理しないといけない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bookdown.org/gary_a_napier/time_series_lecture_notes/ChapterThree.html"&gt;Chapter 3 Autoregressive processes&lt;/a&gt; 一般のAR(p)モデルの分散の求め方が載ってる。そしてその分散を掛けたものを我々は自己相関と言っている気がする。&lt;ul&gt;
&lt;li&gt;AR(1)なら &lt;span class="math"&gt;\(\sigma_{x}^{2} = \frac{\sigma_{z}^{2}}{1 - \rho^{2}}\)&lt;/span&gt; が分散になる。以下、システムノイズを標準正規分布 &lt;span class="math"&gt;\(N(0,1)\)&lt;/span&gt; とする …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;論文出したけど、自己共分散と自己相関でまだ混乱してる。
実装時には嘘つけないので整理しないといけない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bookdown.org/gary_a_napier/time_series_lecture_notes/ChapterThree.html"&gt;Chapter 3 Autoregressive processes&lt;/a&gt; 一般のAR(p)モデルの分散の求め方が載ってる。そしてその分散を掛けたものを我々は自己相関と言っている気がする。&lt;ul&gt;
&lt;li&gt;AR(1)なら &lt;span class="math"&gt;\(\sigma_{x}^{2} = \frac{\sigma_{z}^{2}}{1 - \rho^{2}}\)&lt;/span&gt; が分散になる。以下、システムノイズを標準正規分布 &lt;span class="math"&gt;\(N(0,1)\)&lt;/span&gt; とする。すると &lt;span class="math"&gt;\(\sigma_{z}^{2} = 1\)&lt;/span&gt; だから &lt;span class="math"&gt;\(\sigma_{x}^{2} = \frac{1}{1 - \rho^{2}}\)&lt;/span&gt; となる。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\((\ve{K})_{ij} = \rho^{|i-j|}\)&lt;/span&gt; とすると、自己相関行列は &lt;span class="math"&gt;\(\ve{R} = \sigma_{x}^{2}\ve{K} = \frac{1}{1 - \rho^{2}}\ve{K}\)&lt;/span&gt; と書ける。ここで、自己相関行列と自己共分散行列は全く同じものを指しているので注意。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\ve{R}^{-1} = \left(\frac{1}{1 - \rho^{2}}\right)^{-1} \ve{K}^{-1} = \frac{1 - \rho^{2}}{1 - \rho^{2}} \ve{A}^{-1} = \ve{A}^{-1}\)&lt;/span&gt; ここで &lt;span class="math"&gt;\(\ve{A}^{-1}\)&lt;/span&gt; は &lt;a class="reference external" href="https://projecteuclid.org/download/pdf_1/euclid.aoms/1177706636"&gt;共分散の逆を求める論文&lt;/a&gt; で求めたもの。だから、スカラーはキャンセルされて、結局 &lt;span class="math"&gt;\(\ve{A}^{-1}\)&lt;/span&gt; で良かったことになる。おそらく一般の &lt;span class="math"&gt;\(\mathrm{AR}(p)\)&lt;/span&gt; でスカラーがキャンセルされるはず。&lt;/li&gt;
&lt;li&gt;overleafに書いてる &lt;span class="math"&gt;\(\sigma^{2}\)&lt;/span&gt; は &lt;span class="math"&gt;\(\sigma_{x}^{2}\)&lt;/span&gt; と考えればよい…はず。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\ve{R}_{1}^{-1}\)&lt;/span&gt; の替わりに &lt;span class="math"&gt;\(\ve{K}_{1}^{-1}\)&lt;/span&gt; を使ってLMS/Newtonアルゴリズムを実装すると、収束範囲はどうなるか。 &lt;span class="math"&gt;\(\ve{R}_{1} = \frac{1}{1 - \rho^{2}}\ve{K}_{1}\)&lt;/span&gt; だから、 &lt;span class="math"&gt;\(\ve{R}_{1}\)&lt;/span&gt; の固有値 &lt;span class="math"&gt;\(\lambda_{k}\)&lt;/span&gt; に対し &lt;span class="math"&gt;\(\ve{K}_{1}\)&lt;/span&gt; の固有値 &lt;span class="math"&gt;\(\mu_{k}\)&lt;/span&gt; の範囲は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{\sigma_{x}^{2} (1 - \rho^{2})}{1 + 2 \rho + \rho^{2}} &amp;lt; \lambda_{k} &amp;lt; \frac{\sigma_{x}^{2} (1 - \rho^{2})}{1 - 2 \rho + \rho^{2}} \\
\iff \frac{\sigma_{x}^{2}}{1 + 2 \rho + \rho^{2}} &amp;lt; \mu_{k} &amp;lt; \frac{\sigma_{x}^{2}}{1 - 2 \rho + \rho^{2}} \\
\iff \frac{\sigma_{x}^{2}}{(1 + \rho)^{2}} &amp;lt; \mu_{k} &amp;lt; \frac{\sigma_{x}^{2}}{(1 - \rho)^{2}}
\end{align*}
&lt;/div&gt;
&lt;p&gt;これより、一般化固有値問題 &lt;span class="math"&gt;\(\ve{R}\ve{x} = \eta\ve{K}_{1}\ve{x}\)&lt;/span&gt; の最大固有値 &lt;span class="math"&gt;\(\eta_{\max}\)&lt;/span&gt; は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\eta_{\max} &amp;amp;= \max_{\ve{x} \neq \ve{0}} \frac{\ve{x}^{\mathsf{T}}\ve{R}\ve{x}}{\ve{x}^{\mathsf{T}}\ve{K}_{1}\ve{x}} = \max_{\ve{x} \neq \ve{0}} \frac{\ve{x}^{\mathsf{T}}\ve{R}\ve{x}}{\ve{x}^{\mathsf{T}}\ve{x}} \frac{\ve{x}^{\mathsf{T}}\ve{x}}{\ve{x}^{\mathsf{T}}\ve{K}_{1}\ve{x}} \\
&amp;amp;\leq \left( \max_{\ve{x} \neq \ve{0}} \frac{\ve{x}^{\mathsf{T}}\ve{R}\ve{x}}{\ve{x}^{\mathsf{T}}\ve{x}} \right) \left( \min_{\ve{x} \neq \ve{0}} \frac{\ve{x}^{\mathsf{T}}\ve{K}_{1}\ve{x}}{\ve{x}^{\mathsf{T}}\ve{x}} \right)^{-1} \\
&amp;amp;&amp;lt; N\sigma_{x}^{2} \left\{ \frac{\sigma_{x}^{2}}{(1 + \rho)^{2}} \right\}^{-1} = N (1 + \rho)^{2} \\
&amp;amp;&amp;lt; 2N
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。しかし、ここまでやっておいてあれだけど、逆行列は &lt;span class="math"&gt;\(\ve{R}^{-1} = \ve{A}^{-1}\)&lt;/span&gt; で間違いない（わざわざ &lt;span class="math"&gt;\(\ve{K}_{1}^{-1}\)&lt;/span&gt; を計算するのが大変で不自然）ので問題なことが分かった。むしろ問題は標準正規分布と書いてないことだろうか。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Auto Regressive"></category><category term="Inverse Auto Correlation"></category></entry><entry><title>\(\mathrm{AR}(p)\) へ一般化(5)</title><link href="/mathrmarp-heyi-ban-hua-5.html" rel="alternate"></link><published>2021-02-05T10:00:00+09:00</published><updated>2021-02-05T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-05:/mathrmarp-heyi-ban-hua-5.html</id><summary type="html">&lt;p&gt;査読が返るまでの間既存手法の調査をやろう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;cite&gt;Simplified Newton-Type Adaptive Estimation Algorithms &amp;lt;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.882.2918&amp;amp;rep=rep1&amp;amp;type=pdf&amp;gt;&lt;/cite&gt; 最初に気になってた所。バシッと言ってくれてない。FNTF(fast Newton transversal filters)というのが源流かもしれない。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ssp.ece.upatras.gr/moustakides/downloads/journals/ada1991.pdf"&gt;Fast Newton transversal filters--A new class of adaptive estimation algorithms&lt;/a&gt; &lt;a class="reference external" href="https://www.researchgate.net/publication/3314234_Fast_Newton_transversal_filters--A_new_class_of_adaptive_estimation_algorithms"&gt;ここ&lt;/a&gt; からでもいける。とても近いように見えるんだが、、、AR仮定しているし計算量も同等なんだが、、、、適応的に共分散行列の逆を求めているように見受けられる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/d142/4e76ba905ce822bc26d59a97e6c3aa18d412.pdf?_ga=2.17625393.981950394.1612533179-1720100206.1612533179"&gt;Fast LMS/Newton Algorithms …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;査読が返るまでの間既存手法の調査をやろう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;cite&gt;Simplified Newton-Type Adaptive Estimation Algorithms &amp;lt;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.882.2918&amp;amp;rep=rep1&amp;amp;type=pdf&amp;gt;&lt;/cite&gt; 最初に気になってた所。バシッと言ってくれてない。FNTF(fast Newton transversal filters)というのが源流かもしれない。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ssp.ece.upatras.gr/moustakides/downloads/journals/ada1991.pdf"&gt;Fast Newton transversal filters--A new class of adaptive estimation algorithms&lt;/a&gt; &lt;a class="reference external" href="https://www.researchgate.net/publication/3314234_Fast_Newton_transversal_filters--A_new_class_of_adaptive_estimation_algorithms"&gt;ここ&lt;/a&gt; からでもいける。とても近いように見えるんだが、、、AR仮定しているし計算量も同等なんだが、、、、適応的に共分散行列の逆を求めているように見受けられる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/d142/4e76ba905ce822bc26d59a97e6c3aa18d412.pdf?_ga=2.17625393.981950394.1612533179-1720100206.1612533179"&gt;Fast LMS/Newton Algorithms Based on Autoregressive Modeling and Their Application to Acoustic Echo Cancellation&lt;/a&gt; これもちょっと前に読んでいる。確かに近いが、コレスキー分解した行列の積を計算しているので遅いのでは…。LPCで求めた係数がコレスキー分解の三角行列に入ってきているのは参考になる。&lt;ul&gt;
&lt;li&gt;上の論文のAlgorithm 2が非常に近いかも。勾配(u)を1時刻ずらして、格子フィルタ通して、その出力結果を最新の勾配にしている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/profile/Behrouz_Farhang-Boroujeny/publication/224400239_Fast_LMSNewton_Algorithms_for_Stereophonic_Acoustic_Echo_Cancelation/links/00b495329e1f99d45c000000/Fast-LMS-Newton-Algorithms-for-Stereophonic-Acoustic-Echo-Cancelation.pdf"&gt;Fast LMS/Newton Algorithms for Stereophonic Acoustic Echo Cancelation&lt;/a&gt; 上の論文の弟子？が書いたステレオチャンネル拡張論文。原理はほぼおなじに見える。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.720.7573&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Analysis of the Stereophonic LMS/Newton Algorithm and Impact of Signal Nonlinearity on Its Convergence Behavior&lt;/a&gt; これも著者ほぼ同じ感じ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.448.3364&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Tracking of Time-Varying Mobile Radio Channels—Part I: The Wiener LMS Algorithm&lt;/a&gt; 一瞬だけ触れている。効率的だと言っている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/publication/3321287_Efficient_least_squares_adaptive_algorithms_for_FIR_transversal_filtering"&gt;Efficient least squares adaptive algorithms for FIR transversal filtering&lt;/a&gt; 前も挙げたと思うけど、包括的な内容。詳しく見てみよう。→パット見、ない。上のFast LMS/Newton...も引用してない。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/profile/Kazushi_Ikeda2/publication/3318680_A_numerically_stable_fast_Newton-type_adaptive_filter_based_on_order_recursive_least_squares_algorithm/links/02e7e53b4b2c3efe52000000/A-numerically-stable-fast-Newton-type-adaptive-filter-based-on-order-recursive-least-squares-algorithm.pdf"&gt;A Numerically Stable Fast Newton-Type Adaptive Filter Based on Order Recursive Least Squares Algorithm&lt;/a&gt; 近いようで、近くない…うーん、はっきりと共分散行列が(2p+1)-重対角行列だと言い切って欲しい…。どうやら、予測係数を更新しながらの手法のようだ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://core.ac.uk/download/pdf/37884714.pdf"&gt;A WAVELET BASED PARTIAL UPDATE FAST LMS/NEWTON ALGORITHM&lt;/a&gt; ウェーブレット係数を適応学習。発想はとても良くて、将来的に使うことになるかも。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Auto Regressive"></category><category term="Inverse Auto Correlation"></category></entry><entry><title>\(\mathrm{AR}(p)\) へ一般化(4)</title><link href="/mathrmarp-heyi-ban-hua-4.html" rel="alternate"></link><published>2021-01-31T10:00:00+09:00</published><updated>2021-01-31T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-01-31:/mathrmarp-heyi-ban-hua-4.html</id><content type="html">&lt;p&gt;rejectはショックやなあ…コメント悪くなかっただけに…。&lt;/p&gt;
&lt;p&gt;一般化については記述した。残りは調査だと思う。しかし次の論文書きの期限が迫る。&lt;/p&gt;
</content><category term="雑記"></category><category term="Auto Regressive"></category><category term="Inverse Auto Correlation"></category></entry><entry><title>\(\mathrm{AR}(p)\) へ一般化(3)</title><link href="/mathrmarp-heyi-ban-hua-3.html" rel="alternate"></link><published>2021-01-25T10:00:00+09:00</published><updated>2021-01-25T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-01-25:/mathrmarp-heyi-ban-hua-3.html</id><content type="html">&lt;p&gt;論文読みを通し、紙に書いた。一般的な逆行列の構造が見えた。かなり美しいし、もうやってるだろという直感がある。。。
しかし、査読結果が返るまでに勾配更新の一般化までやっておこう。&lt;/p&gt;
&lt;p&gt;どこかで徹底的な調査が必要と考える。&lt;/p&gt;
</content><category term="雑記"></category><category term="Auto Regressive"></category><category term="Inverse Auto Correlation"></category></entry><entry><title>\(\mathrm{AR}(p)\) へ一般化(2)</title><link href="/mathrmarp-heyi-ban-hua-2.html" rel="alternate"></link><published>2021-01-24T10:00:00+09:00</published><updated>2021-01-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-01-24:/mathrmarp-heyi-ban-hua-2.html</id><summary type="html">&lt;p&gt;午前中に &lt;span class="math"&gt;\(p=2\)&lt;/span&gt; のケースをまとめた。やっぱ成り立っている。しかも2次形式はどうも &lt;span class="math"&gt;\(\mathcal{O}(1)\)&lt;/span&gt; で更新できるっぽい。&lt;/p&gt;
&lt;p&gt;午後、一般化のために論文を読み始めた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://projecteuclid.org/download/pdf_1/euclid.aoms/1177706636"&gt;On the Inversion of the Sample Covariance Matrix in a Stationary Autoregressive Process&lt;/a&gt; これ。読めないものでもない。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/648856/how-to-prove-that-the-inverse-of-a-persymmetric-matrix-is-also-persymmetric"&gt;How to prove that the inverse of a persymmetric matrix is also persymmetric?&lt;/a&gt; persymmetricの逆はまたpersymmetricであることの証明。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em …&lt;/script&gt;</summary><content type="html">&lt;p&gt;午前中に &lt;span class="math"&gt;\(p=2\)&lt;/span&gt; のケースをまとめた。やっぱ成り立っている。しかも2次形式はどうも &lt;span class="math"&gt;\(\mathcal{O}(1)\)&lt;/span&gt; で更新できるっぽい。&lt;/p&gt;
&lt;p&gt;午後、一般化のために論文を読み始めた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://projecteuclid.org/download/pdf_1/euclid.aoms/1177706636"&gt;On the Inversion of the Sample Covariance Matrix in a Stationary Autoregressive Process&lt;/a&gt; これ。読めないものでもない。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/648856/how-to-prove-that-the-inverse-of-a-persymmetric-matrix-is-also-persymmetric"&gt;How to prove that the inverse of a persymmetric matrix is also persymmetric?&lt;/a&gt; persymmetricの逆はまたpersymmetricであることの証明。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Auto Regressive"></category><category term="Inverse Auto Correlation"></category></entry><entry><title>\(\mathrm{AR}(p)\) へ一般化(1)</title><link href="/mathrmarp-heyi-ban-hua-1.html" rel="alternate"></link><published>2021-01-23T10:00:00+09:00</published><updated>2021-01-23T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-01-23:/mathrmarp-heyi-ban-hua-1.html</id><summary type="html">&lt;p&gt;手始めに &lt;span class="math"&gt;\(p=2\)&lt;/span&gt; で効率的に計算できることを示すべきだろう。
また、 &lt;span class="math"&gt;\(p=2\)&lt;/span&gt; の場合の自己相関行列がどうなっているかももう少し見たい。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text …&lt;/script&gt;</summary><content type="html">&lt;p&gt;手始めに &lt;span class="math"&gt;\(p=2\)&lt;/span&gt; で効率的に計算できることを示すべきだろう。
また、 &lt;span class="math"&gt;\(p=2\)&lt;/span&gt; の場合の自己相関行列がどうなっているかももう少し見たい。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Auto Regressive"></category><category term="Inverse Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(34) (完)</title><link href="/r-1-noji-suan-34-wan.html" rel="alternate"></link><published>2021-01-22T10:00:00+09:00</published><updated>2021-01-22T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-01-22:/r-1-noji-suan-34-wan.html</id><summary type="html">&lt;p&gt;だいぶ更新が滞ってしまった。しかし何もしてなかったわけではない。&lt;/p&gt;
&lt;p&gt;まずOverleafに結果をまとめていた（実験含め）。AR(1)の自己相関行列の固有値はやっぱり陽に求まらない。存在範囲が示されているだけ。&lt;/p&gt;
&lt;p&gt;1/9にはOverleafの内容を先生に公開した（がまだ見てもらってない・・・）&lt;/p&gt;
&lt;p&gt;1/13に論文のRebuttalがきて、1/15までその対応に追われていた。その次の1/18に進捗発表あるのを失念していて、麻雀CUIをガリガリ書いてた。1/20に進捗発表。「Acoustic Speech &amp;amp; Signal Processing」もしくは「Access」に出すのが良いのではないかという啓示を受ける。&lt;/p&gt;
&lt;p&gt;残った仕事は&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;上記論文誌はどうか見てみる&lt;/li&gt;
&lt;li&gt;既存の手法と被ってないか: これは継続してやる。&lt;/li&gt;
&lt;li&gt;一般の &lt;span class="math"&gt;\(AR(p)\)&lt;/span&gt; について議論する&lt;ul&gt;
&lt;li&gt;逆行列が一般化して書けるか、とても不安&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定常誤差のバウンドを求めたい。&lt;ul&gt;
&lt;li&gt;SAの評価だと上界しかわからない。Widrow本に書いてないか？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ロスレス音声に突っ込む&lt;ul&gt;
&lt;li&gt;これは春やる。長期休みで1つコーデックを作ろう。ウェーブレットを使うアイデアも残っている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;卒論とか落ち着いたら突っ込む事を忘れずに。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; にフォーカスして頑張るのは終わったと思う。連載はここで切り上げて、AR …&lt;/p&gt;</summary><content type="html">&lt;p&gt;だいぶ更新が滞ってしまった。しかし何もしてなかったわけではない。&lt;/p&gt;
&lt;p&gt;まずOverleafに結果をまとめていた（実験含め）。AR(1)の自己相関行列の固有値はやっぱり陽に求まらない。存在範囲が示されているだけ。&lt;/p&gt;
&lt;p&gt;1/9にはOverleafの内容を先生に公開した（がまだ見てもらってない・・・）&lt;/p&gt;
&lt;p&gt;1/13に論文のRebuttalがきて、1/15までその対応に追われていた。その次の1/18に進捗発表あるのを失念していて、麻雀CUIをガリガリ書いてた。1/20に進捗発表。「Acoustic Speech &amp;amp; Signal Processing」もしくは「Access」に出すのが良いのではないかという啓示を受ける。&lt;/p&gt;
&lt;p&gt;残った仕事は&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;上記論文誌はどうか見てみる&lt;/li&gt;
&lt;li&gt;既存の手法と被ってないか: これは継続してやる。&lt;/li&gt;
&lt;li&gt;一般の &lt;span class="math"&gt;\(AR(p)\)&lt;/span&gt; について議論する&lt;ul&gt;
&lt;li&gt;逆行列が一般化して書けるか、とても不安&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定常誤差のバウンドを求めたい。&lt;ul&gt;
&lt;li&gt;SAの評価だと上界しかわからない。Widrow本に書いてないか？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ロスレス音声に突っ込む&lt;ul&gt;
&lt;li&gt;これは春やる。長期休みで1つコーデックを作ろう。ウェーブレットを使うアイデアも残っている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;卒論とか落ち着いたら突っ込む事を忘れずに。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; にフォーカスして頑張るのは終わったと思う。連載はここで切り上げて、AR(p)のまとめに全力を入れていく。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(33)</title><link href="/r-1-noji-suan-33.html" rel="alternate"></link><published>2021-01-03T10:00:00+09:00</published><updated>2021-01-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-01-03:/r-1-noji-suan-33.html</id><summary type="html">&lt;p&gt;Overleafにまとめようと思ってガリガリ書いてたら、AR(1)の自己相関行列の逆って一様三項行列になっていないことに気づく。
簡単な式変形で行けないかなと思ったけどうまく行かずハマっていた。
（一様三項行列も差分方程式が出てくるのでかなり手強い。。。）&lt;/p&gt;
&lt;p&gt;5時間くらい苦悶した後にネットの海を泳いで探していた所、AR(1)の逆行列を議論しているところがあった
（AR(1)の自己相関行列はKac--Murdock--Szego (KMS) matrixというらしい）&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://reader.elsevier.com/reader/sd/pii/S0024379599000804?token=77D3B38ACFC349B36FFAE83B2E5AD1E466D8E0D91C45D8A8FBF49228DFBF347B41379B44D26B8E4F99DD26A3856F8E7F"&gt;Asymptotic distribution of the spectra of aclass of generalized Kac--Murdock--Szego matrices&lt;/a&gt; 周辺文献も書いていて有益。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://babel.hathitrust.org/cgi/pt?id=uc1.31822012438206&amp;amp;view=1up&amp;amp;seq=86"&gt;Toeplitz forms and their applications&lt;/a&gt; 上の文献が参照していた。導出が書いてあるかなり広範な文献。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/publication/238877783_Numerical_Solution_of_the_Eigenvalue_Problem_for_Symmetric_Rationally_Generated_Toeplitz_matrices"&gt;Numerical Solution of the Eigenvalue Problem for Symmetric Rationally Generated Toeplitz matrices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/publication/241615223_Properties_of_Some_Generalizations_of_Kac-Murdock-Szego_Matrices"&gt;Properties of Some Generalizations …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Overleafにまとめようと思ってガリガリ書いてたら、AR(1)の自己相関行列の逆って一様三項行列になっていないことに気づく。
簡単な式変形で行けないかなと思ったけどうまく行かずハマっていた。
（一様三項行列も差分方程式が出てくるのでかなり手強い。。。）&lt;/p&gt;
&lt;p&gt;5時間くらい苦悶した後にネットの海を泳いで探していた所、AR(1)の逆行列を議論しているところがあった
（AR(1)の自己相関行列はKac--Murdock--Szego (KMS) matrixというらしい）&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://reader.elsevier.com/reader/sd/pii/S0024379599000804?token=77D3B38ACFC349B36FFAE83B2E5AD1E466D8E0D91C45D8A8FBF49228DFBF347B41379B44D26B8E4F99DD26A3856F8E7F"&gt;Asymptotic distribution of the spectra of aclass of generalized Kac--Murdock--Szego matrices&lt;/a&gt; 周辺文献も書いていて有益。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://babel.hathitrust.org/cgi/pt?id=uc1.31822012438206&amp;amp;view=1up&amp;amp;seq=86"&gt;Toeplitz forms and their applications&lt;/a&gt; 上の文献が参照していた。導出が書いてあるかなり広範な文献。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/publication/238877783_Numerical_Solution_of_the_Eigenvalue_Problem_for_Symmetric_Rationally_Generated_Toeplitz_matrices"&gt;Numerical Solution of the Eigenvalue Problem for Symmetric Rationally Generated Toeplitz matrices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/publication/241615223_Properties_of_Some_Generalizations_of_Kac-Murdock-Szego_Matrices"&gt;Properties of Some Generalizations of Kac-Murdock-Szeg ̈o Matrices&lt;/a&gt; いろいろなKMS行列に対して固有値を計算している。どこかで刺さるかも。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;問題は、バシッとした固有値が書かれていないところか。固有値の満たす範囲を示している。そして導出ちゃんと見てない。明日見よう。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\lambda_{k} &amp;amp;= \frac{1 - \rho^{2}}{1 + \rho^{2} - 2\rho\cos \theta_{k}} \\
&amp;amp; \frac{(k-1)\pi}{n+1} &amp;lt; \theta_{k} &amp;lt; \frac{k\pi}{n+1} \quad k = 1, ..., n
\end{align*}
&lt;/div&gt;
&lt;p&gt;一方、一様三項行列の固有値は &lt;span class="math"&gt;\(\lambda_{k} = \frac{1 - \rho^{2}}{1 + \rho^{2} - 2\rho\cos\left( \frac{k\pi}{n+1} \right)}\)&lt;/span&gt; となっている。つまり、KMSの方は僅かに角度が小さくて、それ以外は全く同じということになる。また &lt;span class="math"&gt;\(n\)&lt;/span&gt; を大きくしていけばその差はどんどん狭まる。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(32)</title><link href="/r-1-noji-suan-32.html" rel="alternate"></link><published>2020-12-29T10:00:00+09:00</published><updated>2020-12-29T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-29:/r-1-noji-suan-32.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;追加調査。今日まで見てみてなさそうであれば追加実験に入る。実信号のパフォーマンスが気になっている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.stanford.edu/class/stats253/lectures/lect6.pdf"&gt;Autoregressive Processes in Time&lt;/a&gt; 前にもみたけどもう一度挙げる。本質的な指摘はここでされている。論文があってもおかしくない。&lt;ul&gt;
&lt;li&gt;自己共分散行列の逆の解釈もされているから、目を通すべきか。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.882.2918&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Simplified Newton-Type Adaptive Estimation Algorithms&lt;/a&gt; これもほぼ同じことを言ってる。少なくとも入力データをAR(p)と見做すという仮定は全く同一。精読がいる。通しで軽く読んでみた。うーん、再帰的に &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; に該当する行列を求めているようで、効率が良さそう。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ssp.ece.upatras.gr/moustakides/downloads/journals/ada1991.pdf"&gt;Fast Newton …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;追加調査。今日まで見てみてなさそうであれば追加実験に入る。実信号のパフォーマンスが気になっている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.stanford.edu/class/stats253/lectures/lect6.pdf"&gt;Autoregressive Processes in Time&lt;/a&gt; 前にもみたけどもう一度挙げる。本質的な指摘はここでされている。論文があってもおかしくない。&lt;ul&gt;
&lt;li&gt;自己共分散行列の逆の解釈もされているから、目を通すべきか。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.882.2918&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Simplified Newton-Type Adaptive Estimation Algorithms&lt;/a&gt; これもほぼ同じことを言ってる。少なくとも入力データをAR(p)と見做すという仮定は全く同一。精読がいる。通しで軽く読んでみた。うーん、再帰的に &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; に該当する行列を求めているようで、効率が良さそう。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ssp.ece.upatras.gr/moustakides/downloads/journals/ada1991.pdf"&gt;Fast Newton transversal filters-A new class of adaptive estimation algorithms&lt;/a&gt; その筆者がFNTFとして提案した論文。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/d142/4e76ba905ce822bc26d59a97e6c3aa18d412.pdf?_ga=2.31362239.1402051301.1609139051-1178548257.1609139051"&gt;Fast LMS/Newton Algorithms Based on Autoregressive Modeling and Their Application to Acoustic Echo Cancellation&lt;/a&gt; 昨日挙げた論文。&lt;ul&gt;
&lt;li&gt;やっぱり陽に逆行列を求めてはいないように見える。（むしろ、 &lt;span class="math"&gt;\(R^{-1}x\)&lt;/span&gt; を直接推定することに重きがある）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;格子フィルタで再帰的に行列要素を求めているのは大変参考になる。&lt;/strong&gt; 定数倍除きあってればいいので、いまやろうとしていることに組み込めないか？&lt;/li&gt;
&lt;li&gt;実験でFNTFを叩いてる。収束が極端に遅くなるケースがある、とのこと。特に特性が急に変わるケース。多分 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; が適応できてないんだと思ふ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まとめ。近いこと言ってると思うんだけど、どの論文もなぜか &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; がn重対角行列であることを指摘していない。もう、結果まとめて上に回そう。&lt;/p&gt;
&lt;p&gt;追加実験:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;分散は入力データ全体を見て計算し、更新しない。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;i.i.d.のときの性能はLMSと一致するか&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;一致を確認。ついでに &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; が単位行列に近くなっていることも確認。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;相関を変えたときの性能はどうか&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LMSより優位に収束が早くなる。&lt;/li&gt;
&lt;li&gt;定常誤差が少し持ち上がる。←相関を上げると顕著。行列要素が大きくなり、勾配もでかくなっていると想像。&lt;/li&gt;
&lt;li&gt;LMSより安定した学習曲線になっているように見える←要観察。前サンプルを使っているのが功奏している？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;相関付き雑音でフィルタ次数を変えたときはどうか&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2は当然早い（降下時SAより早いのが気になった。また、NLMSは暴れ気味）&lt;/li&gt;
&lt;li&gt;大きくしていくと定常誤差が大きくなっていく。同時に、NLMSの収束が遅くなっている&lt;/li&gt;
&lt;li&gt;50で完全にNLMSより収束が早い。&lt;/li&gt;
&lt;li&gt;100でLMSは発散、AR(1)はNLMSより早く収束。ただし定常誤差は悪目。&lt;/li&gt;
&lt;li&gt;500ではLMSもろとも発散した。学習係数設定が悪そう。→0.01から0.001にしたらちゃんと収束する方向に進んだ。ちゃんと固有値解析すれば収束条件が得られるはず。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;実データでLMSより良くなるか&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;ステップサイズを大きく取ると発散する。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;小さく取ればNGSAに近い性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;実データでの &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; も対角優位になってるかチェックしとく。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;なっていなそう。&lt;/strong&gt; 行列の中心が最大で、それから端っこに行くに従って小さくなる。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="聖者の行進の5000-10000サンプルにおける自己相関行列(左から真値, AR(1), 絶対値誤差)" src="./images/realdata_inv_cutocorr_gt_and_ar1.png" style="width: 400px;" /&gt;
&lt;/div&gt;
&lt;div class="figure"&gt;
&lt;img alt="聖者の行進の5000-10000サンプルにおける自己相関行列(左から真値, glasso, 絶対値誤差)" src="./images/realdata_inv_cutocorr_gt_and_gl.png" style="width: 400px;" /&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;これはどう説明できるだろうか。AR(p)のpを増やせばいくらか中心を大きく持っていけるが、MA要素もあるとしか。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;glassoと近いのはポジれる。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;glassoと近く、スパースな &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; で計算できているのは理想的であると考える。&lt;/p&gt;
&lt;p&gt;明日以降、学習曲線の追加実験を行っていく。
また、以前計算を投げてしまった事項が気になっている。AR(1)の &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; は単位行列+対称行列の形に表せる。これとベクトルの積はどういった意味があるのか。幾何学的意味も含めて少し考えてみたい。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(31)</title><link href="/r-1-noji-suan-31.html" rel="alternate"></link><published>2020-12-27T10:00:00+09:00</published><updated>2020-12-27T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-27:/r-1-noji-suan-31.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.cmu.edu/~andrewgw/andrewgwthesis.pdf"&gt;Covariance Kernels for Fast Automatic Pattern Discovery and Extrapolation with Gaussian Processes&lt;/a&gt; これの61p.あたり。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mloss.org/revision/view/1639/"&gt;Toeblitz Toolkit for Fast Toeplitz Matrix Operations 1.03&lt;/a&gt; Toeplitz行列をFFTで解くやつのライブラリ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ミソは、 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; そのものではなく、 &lt;span class="math"&gt;\(R^{-1}x …&lt;/span&gt;&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.cmu.edu/~andrewgw/andrewgwthesis.pdf"&gt;Covariance Kernels for Fast Automatic Pattern Discovery and Extrapolation with Gaussian Processes&lt;/a&gt; これの61p.あたり。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mloss.org/revision/view/1639/"&gt;Toeblitz Toolkit for Fast Toeplitz Matrix Operations 1.03&lt;/a&gt; Toeplitz行列をFFTで解くやつのライブラリ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ミソは、 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; そのものではなく、 &lt;span class="math"&gt;\(R^{-1}x\)&lt;/span&gt; をFFTを使って求めるということにあると思ふ。&lt;/p&gt;
&lt;p&gt;で、再開して手元でメモをとっているが、AR(p)が俄然悪い。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;背景雑音が悪さしてないか。背景雑音を-200dB（ほぼ0）に。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;傾向変わらず。ゆらぎが小さくなった程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;そういえば、なぜ AR(p) のオフセットが乗っているのか。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;SAのステップサイズを高めた状態に対応するものかと思っていたが、違うようだ。SAと同じ定常誤差になるようにステップサイズを設定しても収束が遅い。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;条件数悪化が原因ではないかと考えているので、S-MとAR(1)で求まった &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; の固有値をJupyterで観察してみた。すると、&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="S-Mの固有値変化" src="./images/NGSA_eigvals.png" style="width: 400px;" /&gt;
&lt;/div&gt;
&lt;div class="figure"&gt;
&lt;img alt="AR(1)の固有値変化" src="./images/NGSAAR1_eigvals.png" style="width: 400px;" /&gt;
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;条件数はS-MとAR(1)でほぼ同じ（30付近をフラフラ。N=5, 相関0.8）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;S-Mの固有値が指数的な減少をしている&lt;/strong&gt; 。一方のAR(1)の方はほぼ一定の固有値。&lt;/li&gt;
&lt;li&gt;そういえば、S-Mの &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; と真の &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; を比較するときはノルムを1に揃えていた。要素の大きさは加味していなかった。&lt;/li&gt;
&lt;li&gt;条件数が変わらないで固有値が減っているということは、&lt;strong&gt;S-Mは行列要素が小さくなっており、そしてそれが本質的に収束を早めることに寄与している。&lt;/strong&gt; AdaGradの如く、最初は勾配を大きくとり、徐々に勾配を小さくすることが有効になっているっぽい。&lt;ul&gt;
&lt;li&gt;AR(1)の &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; を1ノルム化したら定常誤差がNGSAと同等になった（ただし、収束は悪化）&lt;/li&gt;
&lt;li&gt;NGSAの &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; を1ノルム化にしたら性能悪化した（定常誤差大）&lt;/li&gt;
&lt;li&gt;AR(1)の &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; は真値ともよく一致しているので、足りないのはこの点だと思う。 &lt;strong&gt;学習が進むにつれて行列要素を小さくする必要がある。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;観察から、 &lt;strong&gt;誤差に応じて行列要素の大きさを変えるべき&lt;/strong&gt; であることが分かった。つまり、誤差の符号だけではなく、誤差の絶対値を使うべきである。そしてそれはNewton/LMSと同一。&lt;/p&gt;
&lt;p&gt;Newton/LMSの &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; を &lt;span class="math"&gt;\(\mathcal{O}(pN)\)&lt;/span&gt; で計算できるのは旨味がある。既存研究があるはず。調査してみる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/d142/4e76ba905ce822bc26d59a97e6c3aa18d412.pdf?_ga=2.31362239.1402051301.1609139051-1178548257.1609139051"&gt;Fast LMS/Newton Algorithms Based on Autoregressive Modeling and Their Application to Acoustic Echo Cancellation&lt;/a&gt; 発想としてはもうほぼ同一なんだけど、なぜか、本当に何故か &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; をn-重対角行列としてない。これ、明日腰を据えて読んでみよう。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://my.ece.utah.edu/~hrao/Journal09.pdf"&gt;Fast LMS/Newton Algorithms for Stereophonic Acoustic Echo Cancelation&lt;/a&gt; ちゃんと読んでない。ほぼ同じはず。行列や固有値の観察もあるのに、これも同様に何故かn重対角行列にしてない。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://home.eng.iastate.edu/~julied/classes/ee524/articles/firlmsfilters.pdf"&gt;Efficient least squares adaptive algorithms for FIR transversal filtering&lt;/a&gt; 古いけど、上記含め俯瞰的に触れている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.mdpi.com/1999-4893/12/1/4/htm"&gt;On Fast Converging Data-Selective Adaptive Filtering&lt;/a&gt; NNGSAと全く同じ手法が提案されておる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://sc.enseeiht.fr/doc/Seminar_Bermudez.pdf"&gt;Adaptive Filtering - Theory and Applications&lt;/a&gt; 適応フィルタの包括的まとめ。京大林先生並みにまとめてある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;祈るような感じで探している…。今の所なさそうに見えるが…。&lt;/p&gt;
&lt;p&gt;もう一回調べて、無ければ、追加実験の後にoverleaf執筆に入ろうかな。
一旦寝て、再度調査してみてからにしよう。落ち着いてからのほうがよい。実データで悪いかもしれないし。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(30)</title><link href="/r-1-noji-suan-30.html" rel="alternate"></link><published>2020-12-24T10:00:00+09:00</published><updated>2020-12-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-24:/r-1-noji-suan-30.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;まずはCGについての質問を投げておく。
KWBT先生にメール出す前にCGの状況を要約してみよう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;a class="reference external" href="http://www.cs.cmu.edu/~pradeepr/convexopt/Lecture_Slides/conjugate_direction_methods.pdf"&gt;Conjugate Gradient Descent&lt;/a&gt; 後ろの方で 、普通の共役勾配方でもモーメンタムがかかっていることを言っている。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;a class="reference external" href="https://users.ece.cmu.edu/~xinli/classes/cmu_18660/Lec23.pdf"&gt;18-660: Numerical Methods for Engineering Design and Optimization&lt;/a&gt; pre-conditioning（前処理）で共役勾配の性能を維持する方法を紹介。前処理はコレスキー分解に基づいている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://stanford.edu/class/ee364b/lectures/conj_grad_slides.pdf"&gt;Conjugate Gradient Method&lt;/a&gt; こっちは理論的にもかなり有益そう。もうちょっと見よう。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.slis.tsukuba.ac.jp/~fujisawa.makoto.fu/cgi-bin/wiki/index.php?%CF%A2%CE%A91%BC%A1%CA%FD%C4%F8%BC%B0%A1%A7%B6%A6%CC%F2%B8%FB%C7%DB%CB%A1#da9ac0ee"&gt;連立1次方程式：共役勾配法&lt;/a&gt; 日本語で言ったもの。一般に条件数が悪いと収束特性は悪化する。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.uio.no/studier/emner/matnat/ifi/nedlagte-emner/INF-MAT4350/h08/undervisningsmateriale/chap15slides.pdf"&gt;The Conjugate Gradient …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;まずはCGについての質問を投げておく。
KWBT先生にメール出す前にCGの状況を要約してみよう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;a class="reference external" href="http://www.cs.cmu.edu/~pradeepr/convexopt/Lecture_Slides/conjugate_direction_methods.pdf"&gt;Conjugate Gradient Descent&lt;/a&gt; 後ろの方で 、普通の共役勾配方でもモーメンタムがかかっていることを言っている。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;a class="reference external" href="https://users.ece.cmu.edu/~xinli/classes/cmu_18660/Lec23.pdf"&gt;18-660: Numerical Methods for Engineering Design and Optimization&lt;/a&gt; pre-conditioning（前処理）で共役勾配の性能を維持する方法を紹介。前処理はコレスキー分解に基づいている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://stanford.edu/class/ee364b/lectures/conj_grad_slides.pdf"&gt;Conjugate Gradient Method&lt;/a&gt; こっちは理論的にもかなり有益そう。もうちょっと見よう。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.slis.tsukuba.ac.jp/~fujisawa.makoto.fu/cgi-bin/wiki/index.php?%CF%A2%CE%A91%BC%A1%CA%FD%C4%F8%BC%B0%A1%A7%B6%A6%CC%F2%B8%FB%C7%DB%CB%A1#da9ac0ee"&gt;連立1次方程式：共役勾配法&lt;/a&gt; 日本語で言ったもの。一般に条件数が悪いと収束特性は悪化する。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.uio.no/studier/emner/matnat/ifi/nedlagte-emner/INF-MAT4350/h08/undervisningsmateriale/chap15slides.pdf"&gt;The Conjugate Gradient Method&lt;/a&gt; 条件数と収束特性の式が書いてある。 &lt;span class="math"&gt;\(\ve{Ax} = \ve{b}\)&lt;/span&gt; を解くことを考えたときに、 &lt;span class="math"&gt;\(\kappa = \frac{\lambda_{\mathrm{max}}}{\lambda_{\mathrm{min}}}\)&lt;/span&gt; を &lt;span class="math"&gt;\(\ve{A}\)&lt;/span&gt; の条件数とすると、&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{|| \ve{x} - \ve{x}_{k} ||_{\ve{A}}}{|| \ve{x} - \ve{x}_{0} ||_{\ve{A}}} \leq 2\left( \frac{\sqrt{\kappa} - 1}{\sqrt{\kappa} + 1} \right)^{k}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;条件数が大きくなると右辺は1に近づき、左辺のノルム比が減りづらくなって収束が遅くなることを示唆している。条件数が1より少し大きいときがベストの挙動か。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なぜ共役勾配が相関付きで悪いのかが分かった。一般に共役勾配法は条件数が悪いと収束特性が悪くなる。そして、次数を上げると条件数は悪化する…ということだと思う。条件数を見てみましょう。&lt;/p&gt;
&lt;p&gt;実験の結果、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;相関付きノイズで自己相関行列の条件数が増大すること&lt;/li&gt;
&lt;li&gt;同一の相関付きノイズで次数を高めると自己相関行列の条件数が増大すること&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が分かった。共役勾配法の限界にぶつかってしまったらしい。&lt;/p&gt;
&lt;p&gt;しかし得たものものある。共役勾配法はモーメンタムがかかっているということだ。
AR(p)の逆行列を組み込んでやればええのではないか。&lt;/p&gt;
&lt;p&gt;やってみた。がそもそも収束しない。暴れまくる。
&lt;span class="math"&gt;\(\ve{Hm} = \delta f\)&lt;/span&gt; だから脳死で &lt;span class="math"&gt;\(\ve{H} \ve{m}[n] = \delta f[n] \Rightarrow \ve{m}[n] = \ve{H}^{-1} \delta f[n]\)&lt;/span&gt; 成り立つだろとか思っていたけど、成り立っていなさそう（実験的に確かめた）。なぜなら &lt;span class="math"&gt;\(\ve{m}\)&lt;/span&gt; は逐次的に更新しているから。&lt;/p&gt;
&lt;p&gt;あと、共役勾配法の自己相関行列の更新は &lt;span class="math"&gt;\(\ve{R} \leftarrow \lambda \ve{R} + (1 - \lambda) \ve{x} \ve{x}^{\mathsf{T}}\)&lt;/span&gt; では性能が非常に悪く、 &lt;span class="math"&gt;\(\ve{R} \leftarrow \lambda \ve{R} + \ve{x} \ve{x}^{\mathsf{T}}\)&lt;/span&gt; でないとだめ。これは確かに指数移動平均の極限で見たな。確かに前者が正しい。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(29)</title><link href="/r-1-noji-suan-29.html" rel="alternate"></link><published>2020-12-23T10:00:00+09:00</published><updated>2020-12-23T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-23:/r-1-noji-suan-29.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;うーん、一週間抜けてしまった。木は講義+事務、金土日はマジミラ、月は講義+事務、火はゼミ+レポ、水曜日はレポ。
こう書くと言い訳がましい。年末は研究にしたい。。実家にも帰れないし。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left …&lt;/script&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;うーん、一週間抜けてしまった。木は講義+事務、金土日はマジミラ、月は講義+事務、火はゼミ+レポ、水曜日はレポ。
こう書くと言い訳がましい。年末は研究にしたい。。実家にも帰れないし。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(28)</title><link href="/r-1-noji-suan-28.html" rel="alternate"></link><published>2020-12-16T10:00:00+09:00</published><updated>2020-12-16T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-16:/r-1-noji-suan-28.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;貰ったコメント&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;CGがうまく行かないのはKWBT先生に相談すべき。&lt;ul&gt;
&lt;li&gt;なるはや。状況をまとめてメールを送る。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AR(p)がうまく行かないのは、AR以上のダイナミクスがデータにあるからでは？（AR(p)では表現できてない）&lt;ul&gt;
&lt;li&gt;AR(p)は &lt;span class="math"&gt;\(\varepsilon[n]\)&lt;/span&gt; がi.i.d.として定式化されるが、そうなってない。&lt;/li&gt;
&lt;li&gt;ARモデルに合った（AR過程に従って生成した）データに対して実験すべきでは？&lt;ul&gt;
&lt;li&gt;都合の良いデータに対して実験してよし。モデルは都合よくていい。そこから話を作っていい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;モデルの方をリッチにする。ARMAとか、雑音に相関がある場合を組み込んでしまう。&lt;/li&gt;
&lt;li&gt;そもそも …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;貰ったコメント&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;CGがうまく行かないのはKWBT先生に相談すべき。&lt;ul&gt;
&lt;li&gt;なるはや。状況をまとめてメールを送る。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AR(p)がうまく行かないのは、AR以上のダイナミクスがデータにあるからでは？（AR(p)では表現できてない）&lt;ul&gt;
&lt;li&gt;AR(p)は &lt;span class="math"&gt;\(\varepsilon[n]\)&lt;/span&gt; がi.i.d.として定式化されるが、そうなってない。&lt;/li&gt;
&lt;li&gt;ARモデルに合った（AR過程に従って生成した）データに対して実験すべきでは？&lt;ul&gt;
&lt;li&gt;都合の良いデータに対して実験してよし。モデルは都合よくていい。そこから話を作っていい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;モデルの方をリッチにする。ARMAとか、雑音に相関がある場合を組み込んでしまう。&lt;/li&gt;
&lt;li&gt;そもそも、実信号データに対してARモデルはどこまで誤差を減らせるのか？&lt;ul&gt;
&lt;li&gt;Wiener-Hopf解のときの誤差と比較せよ、と理解した。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2021年4月まではなんとか粘れる。粘るのだ。方針としては悪くないように見える。
しっかしロスレスを絶対忘れたくない。ということで、TODOを入れておく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;春はDWTを使ったロッシーなコーデックを作ろう。&lt;/li&gt;
&lt;li&gt;論文著者に対する連絡を忘れずに出す。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(27)</title><link href="/r-1-noji-suan-27.html" rel="alternate"></link><published>2020-12-12T10:00:00+09:00</published><updated>2020-12-12T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-12:/r-1-noji-suan-27.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;AR(1), AR(2), 共役勾配は「低次ならうまくいく」という主張が本当か確かめたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;全く逆の結果が出てきている。AR(p), 高次にしたときに強いように見える。&lt;ul&gt;
&lt;li&gt;128, 256, 512にすると収束速度がNGSAを上回る。。。。（定常誤差は悪い。注意。）&lt;ul&gt;
&lt;li&gt;512にすると計算量がはんぱない。。その場合AR(p)はSAよりも僅かに良い程度。&lt;/li&gt;
&lt;li&gt;256以上の高次環境下では、NGSA(Sharman-Morrison)はSAよりも収束特性が悪くなっている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;スパース制約（相関は低次までしかないという仮定）が効いている？&lt;/li&gt;
&lt;li&gt;高次でも、i.i.d …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;AR(1), AR(2), 共役勾配は「低次ならうまくいく」という主張が本当か確かめたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;全く逆の結果が出てきている。AR(p), 高次にしたときに強いように見える。&lt;ul&gt;
&lt;li&gt;128, 256, 512にすると収束速度がNGSAを上回る。。。。（定常誤差は悪い。注意。）&lt;ul&gt;
&lt;li&gt;512にすると計算量がはんぱない。。その場合AR(p)はSAよりも僅かに良い程度。&lt;/li&gt;
&lt;li&gt;256以上の高次環境下では、NGSA(Sharman-Morrison)はSAよりも収束特性が悪くなっている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;スパース制約（相関は低次までしかないという仮定）が効いている？&lt;/li&gt;
&lt;li&gt;高次でも、i.i.d.雑音はやはりSAと同等になる。&lt;ul&gt;
&lt;li&gt;高次の場合、Sharman-Morrison式は悪化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定常誤差は気になる。相関付き雑音だと最終的な定常誤差はSA, NGSA(Sharman-Morrison)より悪い。&lt;ul&gt;
&lt;li&gt;これが致命的かもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;初期の残差が気になるから、リファレンス係数のノルムを1にしたらSAが一番強くなった。&lt;ul&gt;
&lt;li&gt;これは問題を過度に優しくしている恐れがある。回答を単位超球上に制限している。&lt;/li&gt;
&lt;li&gt;全次元[-1,1]から一様乱数で選んだほうが遥かに難しい。ノルムを1にするというのは次元の呪いから開放されて議論しているので、おそらく正しくない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;実際のデータ突っ込んだときにどうなるか？&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;悪い。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;AR(1), AR(2)仮定は激烈に悪い。SAより悪い。定常性がないから入力全体で平均取るのをやめて指数移動平均に任せてみたけど、やっぱり悪い。&lt;/li&gt;
&lt;li&gt;CGベース手法も割と悪い。SAと同程度。定常じゃないからと思って忘却係数を小さくとっても同じ。&lt;/li&gt;
&lt;li&gt;実データもまた自己相関行列を観察するところから始めなければならないので、深追いするのはやめる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実データにたいして良くないことが分かった所でタイムアップ。京都に向かう。&lt;/p&gt;
&lt;p&gt;また、共役勾配の処理順序を変えたらなぜうまく行ったのか、金谷本と何が違うのかを見たい…がこれは厳しいか。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jnns/20/2/20_62/_pdf"&gt;正準相関分析&lt;/a&gt; ちょっと気になった。良い解説。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(26)</title><link href="/r-1-noji-suan-26.html" rel="alternate"></link><published>2020-12-11T10:00:00+09:00</published><updated>2020-12-11T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-11:/r-1-noji-suan-26.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;木曜日が潰れているのあんまり良くない。平日あまり進捗が出ていないのは健全とは言えない。総受けでやりすぎている可能性を疑い、タスクを減らすべきかと感じている。&lt;/p&gt;
&lt;p&gt;今日は共役勾配法ベース手法の性能観察を行う。
土曜日までに各手法の状態をまとめて、来週月・火は報告内容をまとめていくことに集中する。&lt;/p&gt;
&lt;p&gt;基本的なところでは12/8に書いた内容と同じ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;i.i.d.でSharman-Morrison式とほぼ同等の性能（少し悪い）&lt;/li&gt;
&lt;li&gt;相関付き雑音でi.i.dと同じステップサイズ・忘却係数に設定していると爆裂に性能が悪くなる。（1000サンプル以内で全く定常状態に入らない）&lt;ul&gt;
&lt;li&gt;ステップサイズを大きくとってもあまり良くならない。大きくとると開始直後悪化。&lt;/li&gt;
&lt;li&gt;忘却係数を小さく取ると収束はするが定常誤差大。&lt;/li&gt;
&lt;li&gt;eta（共役勾配法の線形結合係数に乗じるパラメータ）を1.0未満にすると収束性能悪化。&lt;/li&gt;
&lt;li&gt;共役勾配法の他手法も試してみるか。&lt;ul&gt;
&lt;li&gt;Polak-Ribi`ere(PR …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;木曜日が潰れているのあんまり良くない。平日あまり進捗が出ていないのは健全とは言えない。総受けでやりすぎている可能性を疑い、タスクを減らすべきかと感じている。&lt;/p&gt;
&lt;p&gt;今日は共役勾配法ベース手法の性能観察を行う。
土曜日までに各手法の状態をまとめて、来週月・火は報告内容をまとめていくことに集中する。&lt;/p&gt;
&lt;p&gt;基本的なところでは12/8に書いた内容と同じ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;i.i.d.でSharman-Morrison式とほぼ同等の性能（少し悪い）&lt;/li&gt;
&lt;li&gt;相関付き雑音でi.i.dと同じステップサイズ・忘却係数に設定していると爆裂に性能が悪くなる。（1000サンプル以内で全く定常状態に入らない）&lt;ul&gt;
&lt;li&gt;ステップサイズを大きくとってもあまり良くならない。大きくとると開始直後悪化。&lt;/li&gt;
&lt;li&gt;忘却係数を小さく取ると収束はするが定常誤差大。&lt;/li&gt;
&lt;li&gt;eta（共役勾配法の線形結合係数に乗じるパラメータ）を1.0未満にすると収束性能悪化。&lt;/li&gt;
&lt;li&gt;共役勾配法の他手法も試してみるか。&lt;ul&gt;
&lt;li&gt;Polak-Ribi`ere(PR)を使うと少しは相関に強そうな挙動を見せる。&lt;ul&gt;
&lt;li&gt;しかし、定常誤差が大きくなるような傾向。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Fletcher-Reeves(FR)は共役勾配が発散する。&lt;/li&gt;
&lt;li&gt;Hestenes-Stiefel(HS)は収束が遅い。&lt;ul&gt;
&lt;li&gt;ステップサイズを高くしても遅い。&lt;/li&gt;
&lt;li&gt;etaを変えても悪化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dai-Yuan(DY)もHSと同じく収束が遅い。&lt;ul&gt;
&lt;li&gt;ステップサイズを高くしても遅い。&lt;/li&gt;
&lt;li&gt;etaを変えても悪化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;うーん。良くない。そもそもなんで悪くなったかを考えるべきでは？&lt;ul&gt;
&lt;li&gt;悪条件だから、というのがあるはず。相関係数を変えてみてみる。&lt;ul&gt;
&lt;li&gt;0.1-0.2ではデフォルトとあまり変わらない。&lt;/li&gt;
&lt;li&gt;0.3あたりからプラトーというか収束が遅くなるような挙動を見せ始める。ただしSharman-Morrison式と同等の定常誤差に落ち着く&lt;/li&gt;
&lt;li&gt;0.5では完全に収束曲線が &amp;quot;膨らむ&amp;quot;。尾根に引っかかっていると思う。&lt;/li&gt;
&lt;li&gt;0.8では1000サンプル以内で収束しない。しかし、10000サンプルまで伸ばしてみてみると、定常誤差がSharman-Morrison式よりも小さくなる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;係数次数を大きく取ると傾向が顕著。逆に小さければ、相関が大きくても性能悪化が目立ちにくくなる。&lt;ul&gt;
&lt;li&gt;低次（とくに2）だと、共役勾配の二次の定式化が効いているのかもしれない。&lt;/li&gt;
&lt;li&gt;次数が上がるに従って勾配の広がり（残差勾配）が高次化してしまい、却って性能悪化に転じてしまう？&lt;/li&gt;
&lt;li&gt;AR(1), AR(2)も含めたまとめ方としては、「低次ならうまくいく」かもしれない。。。後ろ向きやなあ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(25)</title><link href="/r-1-noji-suan-25.html" rel="alternate"></link><published>2020-12-08T10:00:00+09:00</published><updated>2020-12-08T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-08:/r-1-noji-suan-25.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;共役勾配法を動くようにした。。。修正内容は、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;係数更新が先、共役勾配の更新を後&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;論文の順序に合わせた結果。しかしなぜうまく行ったのか分かっていない。&lt;/li&gt;
&lt;li&gt;金谷先生の本では係数更新が後、これではうまく行かない（発散する）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sharman-Morrison式で &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; を更新&lt;ul&gt;
&lt;li&gt;これは観察からこっちが正しいことが見えている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能としては、i.i.d.でSharman-Morrison式とほぼ同等、相関付き雑音でSAと性能が近くなっているように見える。要観察。&lt;/p&gt;
&lt;p&gt;AR(1), AR(2)モデル仮定での &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を使う手法は、結局あんまりよくないという所で落ち着きそう …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;共役勾配法を動くようにした。。。修正内容は、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;係数更新が先、共役勾配の更新を後&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;論文の順序に合わせた結果。しかしなぜうまく行ったのか分かっていない。&lt;/li&gt;
&lt;li&gt;金谷先生の本では係数更新が後、これではうまく行かない（発散する）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sharman-Morrison式で &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; を更新&lt;ul&gt;
&lt;li&gt;これは観察からこっちが正しいことが見えている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能としては、i.i.d.でSharman-Morrison式とほぼ同等、相関付き雑音でSAと性能が近くなっているように見える。要観察。&lt;/p&gt;
&lt;p&gt;AR(1), AR(2)モデル仮定での &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を使う手法は、結局あんまりよくないという所で落ち着きそう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;i.i.d.雑音の場合はSAと同程度（ &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; は単位行列になる）&lt;ul&gt;
&lt;li&gt;理論的にも問題ないけど、性能が良くならないのはつらい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相関付き雑音の場合は、収束は早くなるが定常誤差が悪化。&lt;ul&gt;
&lt;li&gt;定常誤差を良くするためにステップサイズを小さくしていくとSAと一致してしまう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(24)</title><link href="/r-1-noji-suan-24.html" rel="alternate"></link><published>2020-12-07T10:00:00+09:00</published><updated>2020-12-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-07:/r-1-noji-suan-24.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;(23)の所でずっと詰まっていた。イベントを通り抜ける。その最中、そういえば共分散行列を忘却係数付きで更新し、その逆行列を求めたときどうなるかを確かめていないことを思い出した。&lt;/p&gt;
&lt;p&gt;すると、共分散行列の更新則の違いで差が出ていることが分かった。忘却係数を &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; とすると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{R}[n+1] &amp;amp;\leftarrow \lambda \ve{R}[n] + (1 - \lambda) \ve{x}[n] \ve{x}[n]^{\mathsf …&lt;/div&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;(23)の所でずっと詰まっていた。イベントを通り抜ける。その最中、そういえば共分散行列を忘却係数付きで更新し、その逆行列を求めたときどうなるかを確かめていないことを思い出した。&lt;/p&gt;
&lt;p&gt;すると、共分散行列の更新則の違いで差が出ていることが分かった。忘却係数を &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; とすると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{R}[n+1] &amp;amp;\leftarrow \lambda \ve{R}[n] + (1 - \lambda) \ve{x}[n] \ve{x}[n]^{\mathsf{T}} \tag{1} \\
\ve{R}[n+1] &amp;amp;\leftarrow \lambda \ve{R}[n] + \ve{x}[n] \ve{x}[n]^{\mathsf{T}} \tag{2}
\end{align*}
&lt;/div&gt;
&lt;p&gt;の2つの更新則が考えられる。(1)は普通の指数移動平均、(2)はRLSとかの更新則。そして、(1), (2)の性能を比べると、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;(1)は詰まっていた所の性能と同じ性能。&lt;ul&gt;
&lt;li&gt;i.i.d.の場合はSAと同等&lt;/li&gt;
&lt;li&gt;相関付きの場合は一旦SAより早めに残差が落ちるが、その後残差悪化に転じて定常誤差が大きい状態になってしまう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2)はSherman-Morrison式NGSAと同等の性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あれ？(2)が正しいんだっけ？
おかしいと思ってもう一度適応フィルタ本（Heykin）を見たら、やはり(2)が正しい。(2)の更新則によってRLSが成り立っている。また、(2)で &lt;span class="math"&gt;\(\ve{R}[1] = \ve{I}\)&lt;/span&gt; とするのはL2正則化に該当する。&lt;/p&gt;
&lt;p&gt;すると(2)の方式を採用しつつ、逆行列のAR(1)近似が取れればよいということになるが、標本分散を(2)の方式で更新してみても全く性能が良くない。&lt;/p&gt;
&lt;p&gt;あがいてレバガチャしてしまう前に、(2)で求められている &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; の観察を開始。（もしかして共役勾配法も(2)でやればうまくいくのか…？）&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(23)</title><link href="/r-1-noji-suan-23.html" rel="alternate"></link><published>2020-12-03T10:00:00+09:00</published><updated>2020-12-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-03:/r-1-noji-suan-23.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;glassoが自己相関行列を指数移動平均で更新したら、NGSAとほぼ同等の性能を出していたので、その観察から、
モーメンタムを込めながらAR(1)仮定の高速計算ができないか、で今考え中。&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;摂動展開&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;詰まってる。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\lambda \ve{R} + \ve{M})^{-1} \approx \lambda^{-1}\ve{R}^{-1} - \lambda^{-2} \ve{R}^{-1}\ve{M}\ve …&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;glassoが自己相関行列を指数移動平均で更新したら、NGSAとほぼ同等の性能を出していたので、その観察から、
モーメンタムを込めながらAR(1)仮定の高速計算ができないか、で今考え中。&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;摂動展開&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;詰まってる。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\lambda \ve{R} + \ve{M})^{-1} \approx \lambda^{-1}\ve{R}^{-1} - \lambda^{-2} \ve{R}^{-1}\ve{M}\ve{R}^{-1}
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;となるけど、それをどうする？右辺第二項の計算で &lt;span class="math"&gt;\(\mathcal{O}(N^{2})\)&lt;/span&gt; なのがうーんという感じ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;AR(1)仮定での &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; の構造に着目する&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{R}^{-1} = \ve{I}
- \rho \left[ \begin{array}{cccc}
  0 &amp;amp; 1      &amp;amp;        &amp;amp;   \\
  1 &amp;amp; 0      &amp;amp; \ddots &amp;amp;   \\
    &amp;amp; \ddots &amp;amp; \ddots &amp;amp; 1 \\
    &amp;amp;        &amp;amp; 1      &amp;amp; 0 \\
  \end{array} \right]
+ \rho^{2} \left[ \begin{array}{ccccc}
  0 &amp;amp;   &amp;amp;        &amp;amp;   &amp;amp;   \\
    &amp;amp; 1 &amp;amp;        &amp;amp;   &amp;amp;   \\
    &amp;amp;   &amp;amp; \ddots &amp;amp;   &amp;amp;   \\
    &amp;amp;   &amp;amp;        &amp;amp; 1 &amp;amp;   \\
    &amp;amp;   &amp;amp;        &amp;amp;   &amp;amp; 0 \\
  \end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;というふうに分解できるから、 &lt;span class="math"&gt;\(\rho\)&lt;/span&gt; に摂動を加えるなりしたら何か起こらないかなあと思ってるんだけど、良さげな更新則は出てこない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;AR(2)仮定を探る&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;真の &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を見ていると、5重対角行列成分も無視できないくらいある。陽に求まるはず。&lt;ul&gt;
&lt;li&gt;でも、モーメンタムから目をそらすことになってしまいそう。i.i.d.のときの性能は変わらないはず。&lt;/li&gt;
&lt;li&gt;それでも試すだけ試してみるか&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ARMAまで手を伸ばしたらあった。もう少し探る。 &lt;a class="reference external" href="https://library.wolfram.com/infocenter/MathSource/5723/#downloads"&gt;Inverse of the Covariance Matrix of ARMA(p,q) Time Series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ism.ac.jp/editsec/aism/pdf/062_5_0967.pdf"&gt;Statistical inference for functions of the covariance matrix in the stationary Gaussian time-orthogonal principal components model&lt;/a&gt; これのpp.979が答えでは？うん、答えだわ。使ってみようぜ。&lt;/li&gt;
&lt;li&gt;&lt;cite&gt;On the inversion of the sample covariance matrix in a stationary autoregressive process &amp;lt;https://projecteuclid.org/download/pdf_1/euclid.aoms/1177706636&amp;gt;__&lt;/cite&gt; 引用している論文。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=&amp;amp;ved=2ahUKEwj3wfbw7bTtAhVNJaYKHeE5BeQQFjABegQIAxAC&amp;amp;url=https%3A%2F%2Fwww.sid.ir%2FFileServer%2FJE%2F10012004A204&amp;amp;usg=AOvVaw2O9EqdHNmqDdro32aAFB7V"&gt;THE INVERSE OF COVARIANCE MATRICES FOR THE ARMA (p, q) CLASS OF PROCESSES*&lt;/a&gt; 昨日に引き続き。これは包括的に結果のみを述べてる。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://watermark.silverchair.com/60-1-193.pdf?token=AQECAHi208BE49Ooan9kkhW_Ercy7Dm3ZL_9Cf3qfKAc485ysgAAAqgwggKkBgkqhkiG9w0BBwagggKVMIICkQIBADCCAooGCSqGSIb3DQEHATAeBglghkgBZQMEAS4wEQQMCZNl7JbYxA_CjO0KAgEQgIICW85GXJBCY8NesN8BBLt6LmnsJxhYFHRTCUjzCd9LiHZkm6ztS4fBeyXN8_umUkHYiUW08GdJ7gV4paSnBsylGuSzdSVx3hfRdOKWMQ0_SNRAfYgfNC4OwZAm1lMMGCe543EtFABcGDbPWtK5NMW0J9-svryZAHDSAtRlZbMXB_vMftrYeTB2VpVwrYhuRlx8YfvXG7OXttk_UplS8T6kC9v_qEXW2Pa9dqB6tYB1Dhm0t9-1vMKr8LedPAt7NccTlfCLFbViEXpDrwuKkQcctgab8tstd86L_CkNqijOxSdmA6ZbH2AdOmNLztGXJdL7_zVtP1xa9SVU7VOO3ORZX2Q8XHhO8bk6vCjDnbOdWasI8z040Xb1aiI65VbANSEu9IEAPZSYdc-06WQaihgH3TmMyc9GC93Ue9nWAk--jbdtrYJqSeukMXfa_aIM4dmIS0OHWfvTcc0dXtlAWST5HaRh_LNNtlBl_iQ0A4rENRbrtHSZvLo2jdeGlgAPMNT0QwTare-B3rrPcM7icppYuxdteFbxBp6PaTGdEG22eE-eeCS34zR6XFgHia3AGESzvsSvAs6WjVZtT8BhQSQX2olWlrHRPPmW8AP4lBeR3ceXgaXae7dn2bEjzSjh5iEWteJSXMfLR9jataZnKWoRd0q-8athStWQIV3yPBlawOU_hw-G6DB1ZIHI60uaYUVN1QndwAIkyS8vFUEwOngip4lWQrrb62byC2FFHAQtC2M_gJXg1T08_0L9JKIXM69zMkH4B4hj-7J16C65mcFsagB15zf_9J6MUUW8AQ"&gt;On the inverse of the covariance matrix for an autoregressive-moving average process&lt;/a&gt; 上で参照している論文。これも答えが出とる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;どん詰まりよ。AR(1)仮定は相関付きであっても微妙。i.i.d.の場合はSAと同程度。うーん。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(22)</title><link href="/r-1-noji-suan-22.html" rel="alternate"></link><published>2020-12-02T10:00:00+09:00</published><updated>2020-12-02T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-02:/r-1-noji-suan-22.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;前日見ていた &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; のAR(1)仮定による近似を実験しているが、渋いな〜渋い。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;真の（共分散行列を計算してから逆行列を計算した） &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; とはかなり類似。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;当然3重対角成分以外は0にしているので誤差がある。しかし真の &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; も小さい値を取るので全体的な誤差は小さい。&lt;/li&gt;
&lt;li&gt;真値とのRMSを見たら減少してることを確認。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;i.i.d.雑音ではSAとほぼ変わらんくらいの性能。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;頷ける。 &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; が単位行列の定数倍に近くなるから …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;前日見ていた &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; のAR(1)仮定による近似を実験しているが、渋いな〜渋い。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;真の（共分散行列を計算してから逆行列を計算した） &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; とはかなり類似。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;当然3重対角成分以外は0にしているので誤差がある。しかし真の &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; も小さい値を取るので全体的な誤差は小さい。&lt;/li&gt;
&lt;li&gt;真値とのRMSを見たら減少してることを確認。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;i.i.d.雑音ではSAとほぼ変わらんくらいの性能。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;頷ける。 &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; が単位行列の定数倍に近くなるから。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;相関付き雑音ならちょっと改善。NGSAとSAの中間くらいか？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;以下の条件下ではSharman-Morrison式NGSAの性能と近い。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;入力雑音のパワー（分散）を大きくする（0dBとか）&lt;/li&gt;
&lt;li&gt;フィルタ係数の次元を落とす（2とか）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;NGSAで求まってる &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; は何なの…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;実験で見たとき、Sharman-Morrisonによる &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; もほぼ多重対角行列だったのを見ている&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;i.i.d.雑音でSharman-Morrison式NGSAがよくなる現象、一体何なんだ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;スケールを揃えて見てみた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;10サンプル後, 対角優位ではあるが、対角要素以外がおおきい。&lt;/li&gt;
&lt;li&gt;1000サンプル, 2000サンプル後もほぼ同様。対角要素以外は小さくなるものの小さくなりきっていない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;なんかモーメンタムみたいになってる？慣性が残って加速しているのか？まさか…&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;曲率以外の概念が無いと、この収束加速は説明できない。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;モーメンタムありえる。&lt;/strong&gt; 更新式の横から勾配 &lt;span class="math"&gt;\(\ve{v}\)&lt;/span&gt; を乗じると、&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{R}^{-1}[n+1] &amp;amp;= \frac{1}{\lambda} \left[ \ve{R}^{-1}[n] - \frac{\ve{R}^{-1}[n]\ve{x}[n]\left\{\ve{R}^{-1}\ve{x}[n]\right\}^{\mathsf{T}}}{\lambda + \ve{x}[n]^{\mathsf{T}} \ve{R}^{-1}[n] \ve{x}[n]} \right] \\
\implies \ve{R}^{-1}[n+1]\ve{v} &amp;amp;= \frac{1}{\lambda} \left[ \ve{R}^{-1}[n]\ve{v} - \frac{\ve{R}^{-1}[n]\ve{x}[n]\left\{\ve{R}^{-1}\ve{x}[n]\right\}^{\mathsf{T}}}{\lambda + \ve{x}[n]^{\mathsf{T}} \ve{R}^{-1}[n] \ve{x}[n]} \ve{v} \right]
\end{align*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;だから、直前ステップの自然勾配 &lt;span class="math"&gt;\(\ve{R}^{-1}[n]\ve{v}\)&lt;/span&gt; に対して修正を掛けながら更新している事がわかる。&lt;/li&gt;
&lt;li&gt;前に進捗報告でglasso版がほぼ同じような結果を出していたのは、共分散行列を &lt;span class="math"&gt;\(\ve{R}[n+1] \leftarrow \lambda \ve{R}[n] + \ve{x}[n] \ve{x}[n]^{\mathsf{T}}\)&lt;/span&gt; と指数移動平均的に更新したからと思われる。両辺の逆を取ると、（1次）近似的には &lt;span class="math"&gt;\(\ve{R}^{-1}[n]\)&lt;/span&gt; の成分と &lt;span class="math"&gt;\((\ve{x}[n]\ve{x}[n]^{\mathsf{T}})^{-1}\)&lt;/span&gt; (擬似逆行列) の和に分けることができて、右から勾配を乗じると直前ステップの勾配成分が発生し、モーメンタムになる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;やはりモーメンタムの線が濃い。事前にSherman-Morrisonで &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を求めて固定して自然勾配学習を行うと、NGSAの収束性能が悪化した。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;しかし、固定した &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を使ってモーメンタムを使っても性能が良くない。SAと同程度。何が違うんだ…？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;アイデアとしては、行列を指数移動平均的に更新するやり方を採用することだろうか。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(21)</title><link href="/r-1-noji-suan-21.html" rel="alternate"></link><published>2020-12-01T10:00:00+09:00</published><updated>2020-12-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-01:/r-1-noji-suan-21.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;昨日あたりから三重対角行列の性質を使ってうまくやれないか...でずっと悩んでいた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;（PCAより）共分散行列（今考えてる信号では自己相関行列としてよい、平均0だから）の固有値は各軸の分散になる&lt;/li&gt;
&lt;li&gt;自己相関行列の逆はほぼ三重対角行列とみなせる。その行列の要素と固有値には陽な関係がある&lt;/li&gt;
&lt;li&gt;ある行列の固有値は、その逆行列の固有値の逆数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という3点から攻めればいけるかな、と思ったけど、観測により得られる要素がほとんどなくて、&amp;quot;各軸の分散&amp;quot;も直交変換しないとわからない。という所で詰まっていた。&lt;/p&gt;
&lt;p&gt;しばらく悶絶していたら、今考えてるのは直前時刻との相関、つまりAR(1)だから、そいつ共分散の逆行列ならよく知られてるんじゃないと思って探したらすぐに陽な答えが見つかった:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/975069/the-inverse-of-ar-structure-correlation-matrix-kac-murdock-szeg-̈o-matrix"&gt;The inverse of AR structure correlation matrix / Kac-Murdock-Szeg …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;昨日あたりから三重対角行列の性質を使ってうまくやれないか...でずっと悩んでいた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;（PCAより）共分散行列（今考えてる信号では自己相関行列としてよい、平均0だから）の固有値は各軸の分散になる&lt;/li&gt;
&lt;li&gt;自己相関行列の逆はほぼ三重対角行列とみなせる。その行列の要素と固有値には陽な関係がある&lt;/li&gt;
&lt;li&gt;ある行列の固有値は、その逆行列の固有値の逆数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という3点から攻めればいけるかな、と思ったけど、観測により得られる要素がほとんどなくて、&amp;quot;各軸の分散&amp;quot;も直交変換しないとわからない。という所で詰まっていた。&lt;/p&gt;
&lt;p&gt;しばらく悶絶していたら、今考えてるのは直前時刻との相関、つまりAR(1)だから、そいつ共分散の逆行列ならよく知られてるんじゃないと思って探したらすぐに陽な答えが見つかった:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/975069/the-inverse-of-ar-structure-correlation-matrix-kac-murdock-szeg-̈o-matrix"&gt;The inverse of AR structure correlation matrix / Kac-Murdock-Szeg ̈o matrix&lt;/a&gt; これにピンときた。前に &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を計算したときの結果ともかなり合ってる。&lt;ul&gt;
&lt;li&gt;手元で計算結果を確認した。コレスキー（Cholesky）分解を使っておる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mathoverflow.net/questions/65795/inverse-of-an-ar1-or-laplacian-or-kac-murdock-szegö-matrix"&gt;Inverse of an AR(1) or Laplacian (?) or Kac-Murdock-Szegö matrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.stanford.edu/class/stats253/lectures/lect6.pdf"&gt;Lecture 6 Autoregressive Processes in Time&lt;/a&gt; AR(2)も逆行列がシンボリックに求まるっぽい&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=&amp;amp;ved=2ahUKEwjF9dyVlK3tAhVPPHAKHcOYDNMQFjABegQIAhAC&amp;amp;url=https%3A%2F%2Fwww.sid.ir%2FFileServer%2FJE%2F10012004A204&amp;amp;usg=AOvVaw2O9EqdHNmqDdro32aAFB7V"&gt;THE INVERSE OF COVARIANCE MATRICES FOR THE ARMA (p, q) CLASS OF PROCESSES&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;かなり上手い結果が出ている。AR(1)だと仮定してやれば、1つシフトさせたときの相関を求めてしまえば自己相関行列の逆が求まってしまう。&lt;/p&gt;
&lt;p&gt;主張としては、1サンプルギャップでの相関が &lt;span class="math"&gt;\(0 &amp;lt; \rho &amp;lt; 1\)&lt;/span&gt; のとき、 &lt;span class="math"&gt;\(N \times N\)&lt;/span&gt; の相関行列&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{R} = \left[ \begin{array}{ccccc}
1          &amp;amp; \rho       &amp;amp; \rho^{2} &amp;amp; ... &amp;amp; \rho^{N-1} \\
\rho       &amp;amp; 1          &amp;amp; \rho     &amp;amp;     &amp;amp; \rho^{N-2} \\
\vdots     &amp;amp;            &amp;amp; \ddots   &amp;amp;     &amp;amp; \vdots     \\
\rho^{N-1} &amp;amp; \rho^{N-2} &amp;amp; ...      &amp;amp;     &amp;amp; 1          \\
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;の逆行列 &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{R}^{-1} = \frac{1}{1 - \rho^{2}} \left[ \begin{array}{ccccc}
1      &amp;amp; -\rho        &amp;amp; 0         &amp;amp; ...          &amp;amp; 0      \\
-\rho  &amp;amp; 1 + \rho^{2} &amp;amp; -\rho     &amp;amp; \ddots       &amp;amp; \vdots \\
0      &amp;amp; -\rho        &amp;amp; \ddots    &amp;amp; \ddots       &amp;amp; 0      \\
\vdots &amp;amp; \ddots       &amp;amp; \ddots    &amp;amp; 1 + \rho^{2} &amp;amp; -\rho  \\
0      &amp;amp; ...          &amp;amp; 0         &amp;amp; -\rho        &amp;amp; 1      \\
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる。特に、&lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; に信号の分散 &lt;span class="math"&gt;\(\sigma^{2}\)&lt;/span&gt; を乗じると自己相関行列 &lt;span class="math"&gt;\(\ve{K}\)&lt;/span&gt; に一致するから&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{K} &amp;amp;= \sigma^{2} \ve{R} \\
\ve{K}^{-1} &amp;amp;= \sigma^{-2} \ve{R}^{-1}
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。&lt;/p&gt;
&lt;p&gt;証明） &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; はコレスキー（Cholesky）分解によって&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{R} = \ve{L}\  \mathrm{diag}(1, 1 - \rho^{2}, ..., 1 - \rho^{2})\  \ve{L}^{\mathsf{T}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と分解できる。ここで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{L} = \left[ \begin{array}{ccccc}
1          &amp;amp; 0           &amp;amp; 0         &amp;amp; ...    &amp;amp; 0      \\
\rho       &amp;amp; 1           &amp;amp; 0         &amp;amp; \ddots &amp;amp;        \\
\vdots     &amp;amp; \rho        &amp;amp; 1         &amp;amp; \ddots &amp;amp; 0      \\
\rho^{N-2} &amp;amp; \ddots      &amp;amp; \ddots    &amp;amp; \ddots &amp;amp; 0      \\
\rho^{N-1} &amp;amp; \rho^{N-2}  &amp;amp; ...       &amp;amp; \rho   &amp;amp; 1      \\
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;確認すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
&amp;amp; \ve{L}\  \mathrm{diag}(1, 1 - \rho^{2}, ..., 1 - \rho^{2})\  \ve{L}^{\mathsf{T}} \\
&amp;amp;= \left[ \begin{array}{ccccc}
1          &amp;amp; 0           &amp;amp; 0         &amp;amp; ...    &amp;amp; 0   \\
\rho       &amp;amp; 1           &amp;amp; 0         &amp;amp; \ddots &amp;amp;     \\
\vdots     &amp;amp; \rho        &amp;amp; 1         &amp;amp; \ddots &amp;amp; 0   \\
\rho^{N-2} &amp;amp; \ddots      &amp;amp; \ddots    &amp;amp; \ddots &amp;amp; 0   \\
\rho^{N-1} &amp;amp; \rho^{N-2}  &amp;amp; ...       &amp;amp; \rho   &amp;amp; 1   \\
\end{array} \right]
\left[ \begin{array}{cccc}
1 &amp;amp;              &amp;amp;        &amp;amp;             \\
  &amp;amp; 1 - \rho^{2} &amp;amp;        &amp;amp;             \\
  &amp;amp;              &amp;amp; \ddots &amp;amp;             \\
  &amp;amp;              &amp;amp;        &amp;amp; 1- \rho^{2} \\
\end{array} \right]
\left[ \begin{array}{ccccc}
1      &amp;amp; \rho   &amp;amp; ...    &amp;amp; \rho^{N-2} &amp;amp; \rho^{N-1}  \\
0      &amp;amp; 1      &amp;amp; \rho   &amp;amp; \ddots     &amp;amp; \rho^{N-2}  \\
\vdots &amp;amp; 0      &amp;amp; 1      &amp;amp; \ddots     &amp;amp; 0           \\
0      &amp;amp; \ddots &amp;amp; \ddots &amp;amp; \ddots     &amp;amp; \rho        \\
0      &amp;amp; 0      &amp;amp; ...    &amp;amp; 0          &amp;amp; 1           \\
\end{array} \right] \\
&amp;amp;= \left[ \begin{array}{ccccc}
1          &amp;amp; 0                        &amp;amp; 0            &amp;amp; ...                &amp;amp; 0             \\
\rho       &amp;amp; 1 - \rho^{2}             &amp;amp; 0            &amp;amp; \ddots             &amp;amp; \vdots        \\
\rho^{2}   &amp;amp; \rho(1 - \rho^{2})       &amp;amp; 1 - \rho^{2} &amp;amp; \ddots             &amp;amp; 0             \\
\vdots     &amp;amp; \vdots                   &amp;amp; \ddots       &amp;amp; \ddots             &amp;amp; 0             \\
\rho^{N-1} &amp;amp; \rho^{N-2}(1 - \rho^{2}) &amp;amp; ...          &amp;amp; \rho(1 - \rho^{2}) &amp;amp; 1 - \rho^{2}  \\
\end{array} \right]
\left[ \begin{array}{ccccc}
1      &amp;amp; \rho   &amp;amp; ...    &amp;amp; \rho^{N-2} &amp;amp; \rho^{N-1}  \\
0      &amp;amp; 1      &amp;amp; \rho   &amp;amp; \ddots     &amp;amp; \rho^{N-2}  \\
\vdots &amp;amp; 0      &amp;amp; 1      &amp;amp; \ddots     &amp;amp; 0           \\
0      &amp;amp; \ddots &amp;amp; \ddots &amp;amp; \ddots     &amp;amp; \rho        \\
0      &amp;amp; 0      &amp;amp; ...    &amp;amp; 0          &amp;amp; 1           \\
\end{array} \right] \\
&amp;amp;= \left[ \begin{array}{ccccc}
1          &amp;amp; \rho       &amp;amp; \rho^{2} &amp;amp; ... &amp;amp; \rho^{N-1} \\
\rho       &amp;amp; 1          &amp;amp; \rho     &amp;amp;     &amp;amp; \rho^{N-2} \\
\vdots     &amp;amp;            &amp;amp; \ddots   &amp;amp;     &amp;amp; \vdots     \\
\rho^{N-1} &amp;amp; \rho^{N-2} &amp;amp; ...      &amp;amp;     &amp;amp; 1          \\
\end{array} \right] = \ve{R}
\end{align*}
&lt;/div&gt;
&lt;p&gt;OKであることが分かる。では、 &lt;span class="math"&gt;\(\ve{L}^{-1}\)&lt;/span&gt; を求めることを考えるが、これは拡張行列に対して行基本変形（ガウスの消去法）を使って求めてみる。
つまり、 &lt;span class="math"&gt;\(\left[ \ve{L}\  \ve{I} \right] \rightarrow \left[ \ve{I}\  \ve{L}^{-1} \right]\)&lt;/span&gt; として求める。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\left[ \ve{L}\  \ve{I} \right]
&amp;amp;= \left[ \begin{array}{cccccccccc}
1          &amp;amp; 0          &amp;amp; 0      &amp;amp; ...    &amp;amp; 0  &amp;amp; 1 &amp;amp;   &amp;amp;        &amp;amp;   &amp;amp;   \\
\rho       &amp;amp; 1          &amp;amp; 0      &amp;amp; \ddots &amp;amp;    &amp;amp;   &amp;amp; 1 &amp;amp;        &amp;amp;   &amp;amp;   \\
\vdots     &amp;amp; \rho       &amp;amp; 1      &amp;amp; \ddots &amp;amp; 0  &amp;amp;   &amp;amp;   &amp;amp; \ddots &amp;amp;   &amp;amp;   \\
\rho^{N-2} &amp;amp; \ddots     &amp;amp; \ddots &amp;amp; \ddots &amp;amp; 0  &amp;amp;   &amp;amp;   &amp;amp;        &amp;amp; 1 &amp;amp;   \\
\rho^{N-1} &amp;amp; \rho^{N-2} &amp;amp; ...    &amp;amp; \rho   &amp;amp; 1  &amp;amp;   &amp;amp;   &amp;amp;        &amp;amp;   &amp;amp; 1 \\
\end{array} \right] \\
&amp;amp; \rightarrow \left[ \begin{array}{cccccccccc}
1      &amp;amp; 0          &amp;amp; 0      &amp;amp; ...    &amp;amp; 0  &amp;amp; 1           &amp;amp;   &amp;amp;        &amp;amp;   &amp;amp;   \\
0      &amp;amp; 1          &amp;amp; 0      &amp;amp; \ddots &amp;amp;    &amp;amp; -\rho       &amp;amp; 1 &amp;amp;        &amp;amp;   &amp;amp;   \\
0      &amp;amp; \rho       &amp;amp; 1      &amp;amp; \ddots &amp;amp; 0  &amp;amp; -\rho^{2}   &amp;amp;   &amp;amp; \ddots &amp;amp;   &amp;amp;   \\
\vdots &amp;amp; \ddots     &amp;amp; \ddots &amp;amp; \ddots &amp;amp; 0  &amp;amp; \vdots      &amp;amp;   &amp;amp;        &amp;amp; 1 &amp;amp;   \\
0      &amp;amp; \rho^{N-2} &amp;amp; ...    &amp;amp; \rho   &amp;amp; 1  &amp;amp; -\rho^{N-1} &amp;amp;   &amp;amp;        &amp;amp;   &amp;amp; 1 \\
\end{array} \right] \\
&amp;amp; \rightarrow \left[ \begin{array}{cccccccccc}
1      &amp;amp; 0      &amp;amp; 0      &amp;amp; ...    &amp;amp; 0  &amp;amp; 1      &amp;amp;             &amp;amp;        &amp;amp;   &amp;amp;   \\
0      &amp;amp; 1      &amp;amp; 0      &amp;amp; \ddots &amp;amp;    &amp;amp; -\rho  &amp;amp; 1           &amp;amp;        &amp;amp;   &amp;amp;   \\
0      &amp;amp; 0      &amp;amp; 1      &amp;amp; \ddots &amp;amp; 0  &amp;amp; 0      &amp;amp; -\rho       &amp;amp; \ddots &amp;amp;   &amp;amp;   \\
\vdots &amp;amp; \ddots &amp;amp; \ddots &amp;amp; \ddots &amp;amp; 0  &amp;amp; \vdots &amp;amp; \vdots      &amp;amp;        &amp;amp; 1 &amp;amp;   \\
0      &amp;amp; 0      &amp;amp; ...    &amp;amp; \rho   &amp;amp; 1  &amp;amp; 0      &amp;amp; -\rho^{N-2} &amp;amp;        &amp;amp;   &amp;amp; 1 \\
\end{array} \right] \\
\rightarrow ... &amp;amp;\rightarrow \left[ \begin{array}{cccccccccc}
1      &amp;amp; 0      &amp;amp; 0      &amp;amp; ...    &amp;amp; 0  &amp;amp; 1      &amp;amp;             &amp;amp;        &amp;amp;       &amp;amp;   \\
0      &amp;amp; 1      &amp;amp; 0      &amp;amp; \ddots &amp;amp;    &amp;amp; -\rho  &amp;amp; 1           &amp;amp;        &amp;amp;       &amp;amp;   \\
0      &amp;amp; 0      &amp;amp; 1      &amp;amp; \ddots &amp;amp; 0  &amp;amp; 0      &amp;amp; -\rho       &amp;amp; \ddots &amp;amp;       &amp;amp;   \\
\vdots &amp;amp; \ddots &amp;amp; \ddots &amp;amp; \ddots &amp;amp; 0  &amp;amp; \vdots &amp;amp; \ddots      &amp;amp; \ddots &amp;amp; 1     &amp;amp;   \\
0      &amp;amp; 0      &amp;amp; ...    &amp;amp; 0      &amp;amp; 1  &amp;amp; 0      &amp;amp; ...         &amp;amp; 0      &amp;amp; -\rho &amp;amp; 1 \\
\end{array} \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{L}^{-1} =
\left[ \begin{array}{cccc}
1     &amp;amp;        &amp;amp;        &amp;amp;   \\
-\rho &amp;amp; 1      &amp;amp;        &amp;amp;   \\
      &amp;amp; \ddots &amp;amp; \ddots &amp;amp;   \\
      &amp;amp;        &amp;amp; -\rho  &amp;amp; 1 \\
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（下三角行列だからなんかえもい結果でないかな）この結果から、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{R}^{-1} &amp;amp;= (\ve{L}^{\mathsf{T}})^{-1} \  \mathrm{diag}(1, 1 - \rho^{2}, ..., 1 - \rho^{2})^{-1}\  \ve{L}^{-1} \\
&amp;amp;= (\ve{L}^{-1})^{\mathsf{T}} \  \mathrm{diag}(1, \frac{1}{1 - \rho^{2}}, ..., \frac{1}{1 - \rho^{2}})\  \ve{L}^{-1} \\
&amp;amp;= \frac{1}{1 - \rho^{2}}
\left[ \begin{array}{cccc}
1 &amp;amp; -\rho  &amp;amp;        &amp;amp;       \\
  &amp;amp; 1      &amp;amp; \ddots &amp;amp;       \\
  &amp;amp;        &amp;amp; \ddots &amp;amp; -\rho \\
  &amp;amp;        &amp;amp;        &amp;amp; 1     \\
\end{array} \right]
\left[ \begin{array}{cccc}
1 - \rho^{2} &amp;amp;   &amp;amp;        &amp;amp;   \\
             &amp;amp; 1 &amp;amp;        &amp;amp;   \\
             &amp;amp;   &amp;amp; \ddots &amp;amp;   \\
             &amp;amp;   &amp;amp;        &amp;amp; 1 \\
\end{array} \right]
\left[ \begin{array}{cccc}
1     &amp;amp;        &amp;amp;        &amp;amp;   \\
-\rho &amp;amp; 1      &amp;amp;        &amp;amp;   \\
      &amp;amp; \ddots &amp;amp; \ddots &amp;amp;   \\
      &amp;amp;        &amp;amp; -\rho  &amp;amp; 1 \\
\end{array} \right] \\
&amp;amp;= \frac{1}{1 - \rho^{2}}
\left[ \begin{array}{cccc}
1 - \rho^{2} &amp;amp; -\rho  &amp;amp;        &amp;amp;       \\
             &amp;amp; 1      &amp;amp; \ddots &amp;amp;       \\
             &amp;amp;        &amp;amp; \ddots &amp;amp; -\rho \\
             &amp;amp;        &amp;amp;        &amp;amp; 1     \\
\end{array} \right]
\left[ \begin{array}{cccc}
1     &amp;amp;        &amp;amp;        &amp;amp;   \\
-\rho &amp;amp; 1      &amp;amp;        &amp;amp;   \\
      &amp;amp; \ddots &amp;amp; \ddots &amp;amp;   \\
      &amp;amp;        &amp;amp; -\rho  &amp;amp; 1 \\
\end{array} \right] \\
&amp;amp;= \frac{1}{1 - \rho^{2}}
\left[ \begin{array}{ccccc}
1      &amp;amp; -\rho        &amp;amp; 0         &amp;amp; ...          &amp;amp; 0      \\
-\rho  &amp;amp; 1 + \rho^{2} &amp;amp; -\rho     &amp;amp; \ddots       &amp;amp; \vdots \\
0      &amp;amp; -\rho        &amp;amp; \ddots    &amp;amp; \ddots       &amp;amp; 0      \\
\vdots &amp;amp; \ddots       &amp;amp; \ddots    &amp;amp; 1 + \rho^{2} &amp;amp; -\rho  \\
0      &amp;amp; ...          &amp;amp; 0         &amp;amp; -\rho        &amp;amp; 1      \\
\end{array} \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;となって結果が確かめられた。&lt;/p&gt;
&lt;p&gt;もう一度考えると、i.i.d.雑音のときは有効な情報は分散（の逆数）ということになる。（入力がi.i.d.雑音のとき &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; は対角行列であることは見た）
それだけでも収束性能が上がるということは、分散で正規化するだけでも意味がある、というかNLMSとほぼ同じ発想になっている。
このことからもNLMSと同等かそれ以下の性能しか出せないのは頷ける。NGSAでは残差の大きさ入れてないから。&lt;/p&gt;
&lt;p&gt;現実の信号は直前サンプルに強い相関を持つのは妥当な仮定。だから良くなるはずというのが自分の印象。
自分、実験いいすか？&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(20)</title><link href="/r-1-noji-suan-20.html" rel="alternate"></link><published>2020-11-30T10:00:00+09:00</published><updated>2020-11-30T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-30:/r-1-noji-suan-20.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;色々方針がグッチャになってるのが良くない。現状をまとめる&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LARSを試す&lt;ul&gt;
&lt;li&gt;とにかく遅い。CDよりも遅い …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;色々方針がグッチャになってるのが良くない。現状をまとめる&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LARSを試す&lt;ul&gt;
&lt;li&gt;とにかく遅い。CDよりも遅い。&lt;/li&gt;
&lt;li&gt;原因を知りたいが、実装だけでは理解不能。&lt;/li&gt;
&lt;li&gt;最小角の原理から抑えていかないとだめか。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;巡回行列化してFFT:&lt;ul&gt;
&lt;li&gt;基礎は抑えた。&lt;/li&gt;
&lt;li&gt;実装するにしても &lt;span class="math"&gt;\(n\)&lt;/span&gt; が小さいから &lt;span class="math"&gt;\(\mathcal{O}(n \log n)\)&lt;/span&gt; との差が出なそうな印象。&lt;/li&gt;
&lt;li&gt;一般の大規模自然勾配に対しては有効に思える。既存研究がないか調査。&lt;ul&gt;
&lt;li&gt;しかし既存研究が無かったとしても、これは技法であって提案手法に足りるか疑問。有効性をどうやって示す？3層パーセプトロンでやるのが良さそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;できない実装のコード共有&lt;ul&gt;
&lt;li&gt;単純に &lt;span class="math"&gt;\(\ve{H}=\ve{R}\)&lt;/span&gt; にした実装が上手くいかんやつ。&lt;/li&gt;
&lt;li&gt;これはなるべく早く。今週中に上げたい。&lt;/li&gt;
&lt;li&gt;次元を落として(2とか)上手く行かない理由を見る。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;摂動展開&lt;ul&gt;
&lt;li&gt;甘利先生の適応的自然勾配学習に近い形になる。つまり、不安定になる未来が見えている。初夏に一回試している。&lt;/li&gt;
&lt;li&gt;しかしいま一度試してみる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sharman-Morrisonをもう一段展開してなにか見えないか&lt;ul&gt;
&lt;li&gt;やるだけやってみるべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重要: 方針相談&lt;ul&gt;
&lt;li&gt;落とし所が上手く定まらない。12月中に先生と相談する機会を設ける。&lt;/li&gt;
&lt;li&gt;なるべく早く。今年中に舵切らないと危険。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指摘事項に対応するのは大事なので、今日は摂動展開を試す。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/2961686/approximating-the-inverse-of-a-perturbed-matrix"&gt;Approximating the inverse of a perturbed matrix&lt;/a&gt; にあるように、行列 &lt;span class="math"&gt;\(\ve{A}\)&lt;/span&gt; に摂動を加えた行列 &lt;span class="math"&gt;\(\partial\ve{A}\)&lt;/span&gt; の逆行列の近似は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\ve{A} + \partial\ve{A})^{-1} \approx \ve{A}^{-1} - \ve{A}^{-1} \partial\ve{A} \ve{A}^{-1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;で与えられる。&lt;/p&gt;
&lt;p&gt;上ページにもあったけど証明を与えておく。 &lt;span class="math"&gt;\(\ve{A}\)&lt;/span&gt; に摂動 &lt;span class="math"&gt;\(\ve{X}\)&lt;/span&gt; を与えることを考え、 &lt;span class="math"&gt;\((\ve{A} + \ve{X})^{-1}\)&lt;/span&gt; をテイラー展開すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\ve{A} + \ve{X})^{-1} = \ve{A}^{-1} + \ve{Y} + O(||\ve{X}||^{2})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と書ける。ここで &lt;span class="math"&gt;\(\ve{Y}\)&lt;/span&gt; は一次（線形）の変化を表す行列。ここで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
&amp;amp; (\ve{A} + \ve{X})^{-1}(\ve{A} + \ve{X}) = \ve{I} \\
&amp;amp; \iff (\ve{A}^{-1} + \ve{Y} + O(||\ve{X}||^{2}))(\ve{A} + \ve{X}) = \ve{I} \\
&amp;amp; \iff \ve{A}^{-1}\ve{A} + \ve{A}^{-1}\ve{X} + \ve{Y}\ve{A} + \ve{Y}\ve{X} + O(||\ve{X}||^{2})(\ve{A} + \ve{X}) = \ve{I} \\
&amp;amp; \iff \ve{A}^{-1}\ve{X} + \ve{Y}\ve{A} + \ve{Y}\ve{X} + O(||\ve{X}||^{2})(\ve{A} + \ve{X}) = \ve{O} \\
&amp;amp; \implies \ve{A}^{-1}\ve{X} + \ve{Y}\ve{A} \approx \ve{O} \quad (\because \ve{Y}\text{は微小だから} \ve{Y}\ve{X} \approx \ve{O}) \\
&amp;amp; \implies \ve{Y} \approx -\ve{A}^{-1}\ve{X}\ve{A}^{-1}
\end{align*}
&lt;/div&gt;
&lt;p&gt;この &lt;span class="math"&gt;\(\ve{Y}\)&lt;/span&gt; をテイラー展開の式に代入して二次以上の項を無視すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\ve{A} + \ve{X})^{-1} \approx \ve{A}^{-1} - \ve{A}^{-1}\ve{X}\ve{A}^{-1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が得られる。&lt;/p&gt;
&lt;p&gt;逐次計算に応用してみよう。 &lt;span class="math"&gt;\(\ve{A} = \epsilon\ve{R}[n], \ \ve{X} = \ve{x}[n]\ve{x}[n]^{\mathsf{T}}\)&lt;/span&gt; とおくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\epsilon\ve{R}[n] + \ve{x}[n]\ve{x}[n]^{\mathsf{T}})^{-1} \approx \epsilon^{-1} \ve{R}[n]^{-1} - \epsilon^{-2} \ve{R}[n]^{-1} \ve{x}[n]\ve{x}[n]^{\mathsf{T}} \ve{R}[n]^{-1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となり、ほぼ適応的自然勾配学習法の式だ（&lt;span class="math"&gt;\(\epsilon^{-1}\)&lt;/span&gt; に対しても近似すると一致する）。&lt;/p&gt;
&lt;p&gt;実装してみて試すのはもちろんだが、安定性をもっと追うべきかとは思っている。上の更新式でちゃんと &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; の真値に収束する？&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;三重対角行列の固有値&lt;/h2&gt;
&lt;p&gt;ぼんやり（すまぬ）行列の性質を見ていたら、ずっと探していた「三重対角行列の固有値」の結果が出ていた:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://nalab.mind.meiji.ac.jp/~mk/labo/text/linear-eq-3.pdf"&gt;連立1次方程式 III — 自分が使うための線型代数 —&lt;/a&gt; これの9.5.2。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;サイズ &lt;span class="math"&gt;\(N \times N\)&lt;/span&gt; の一様三項行列&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left[ \begin{array}{ccccc}
a      &amp;amp; b      &amp;amp; 0      &amp;amp; ...    &amp;amp; 0      \\
c      &amp;amp; a      &amp;amp; b      &amp;amp; \ddots &amp;amp; \vdots \\
0      &amp;amp; c      &amp;amp; \ddots &amp;amp; \ddots &amp;amp; 0      \\
\vdots &amp;amp; \ddots &amp;amp; \ddots &amp;amp; a      &amp;amp; b      \\
0      &amp;amp; ...    &amp;amp; 0      &amp;amp; c      &amp;amp; a      \\
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;の &lt;span class="math"&gt;\((bc \neq 0)\)&lt;/span&gt; 固有値 &lt;span class="math"&gt;\(\lambda_{k}\)&lt;/span&gt; と固有ベクトル &lt;span class="math"&gt;\(\ve{v}_{k}\)&lt;/span&gt; は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\lambda_{k} &amp;amp;= a + 2\sqrt{bc} \cos\left(\frac{k \pi}{N+1}\right) \\
\ve{v}_{k} &amp;amp;= \left[ \sqrt{\frac{c}{b}} \sin\left(\frac{k \pi}{N+1}\right),\  \left(\sqrt{\frac{c}{b}}\right)^{2}\sin\left(\frac{2k \pi}{N+1}\right),\ ...,\ \left(\sqrt{\frac{c}{b}}\right)^{N} \sin\left(\frac{Nk \pi}{N+1}\right) \right]^{\mathsf{T}} \\
k &amp;amp;= 1, ..., N
\end{align*}
&lt;/div&gt;
&lt;p&gt;これを上手くやるにはどうしたらいいか、しばらく考えてた。今では &lt;span class="math"&gt;\(b=c\)&lt;/span&gt; とすればいいから行列は対称行列になって、各固有ベクトルは直交するはず（示せなかった。。。）。また、固有値を並べた行列を使って直交対角化もできるはずなんや。&lt;/p&gt;
&lt;p&gt;さて、依然として残る問題は &lt;span class="math"&gt;\(a,b\)&lt;/span&gt; もしくは &lt;span class="math"&gt;\(\lambda_{k}\)&lt;/span&gt; をどうやって観測から求めればいいかというところ。頭に極配置法が思い浮かぶが、なにか違う。素朴なやり方がありそうで、あと一歩な気がするのだ。&lt;/p&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(19)</title><link href="/r-1-noji-suan-19.html" rel="alternate"></link><published>2020-11-28T10:00:00+09:00</published><updated>2020-11-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-28:/r-1-noji-suan-19.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; はToeplitz（テプリッツ行列）だから …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; はToeplitz（テプリッツ行列）だから、それをFFTベースで高速計算する手法がある（テプリッツ法というらしい）&lt;/p&gt;
&lt;p&gt;『ガウス過程と機械学習』によると、テプリッツ行列を巡回行列に展開して、それに対してFFTを実行して &lt;span class="math"&gt;\(\mathcal{O}(nlogn)\)&lt;/span&gt; で処理を進めるというもの。ただし本には明らかな誤りがある。巡回行列の1行目は &lt;span class="math"&gt;\([ K_{1,1} K_{1,2} ... K_{1,M-1} K_{1,M} K_{1,M-1} K_{1,M-1} ... K_{1,2} ]\)&lt;/span&gt; のはずだ。そうじゃないと巡回して行列を作ったときにおかしなことになる。&lt;/p&gt;
&lt;p&gt;他にも論文がある。下はFFTベースの手法のようだ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.kravanja.eu/pages/Kravanja-2001-Toeplitz.pdf"&gt;A STABILIZED SUPERFAST SOLVER FOR NONSYMMETRIC TOEPLITZ SYSTEMS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;思ったのが、一般の自然勾配法において超巨大なFisher情報行列に対してこれは使えんるんじゃないかというところ。とっくにやってる？&lt;/p&gt;
&lt;p&gt;Fisher情報行列はスコア関数の共分散だからテプリッツ行列。だから行けるんじゃね？&lt;/p&gt;
&lt;p&gt;ん？他にも共分散行列の高速推定手法を提案してる:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.sys.es.osaka-u.ac.jp/sch/paper/B1999/yamamoto-k/index.html"&gt;Toeplitz構造をもつ共分散行列の最尤推定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(18)</title><link href="/r-1-noji-suan-18.html" rel="alternate"></link><published>2020-11-25T10:00:00+09:00</published><updated>2020-11-25T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-25:/r-1-noji-suan-18.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;進捗報告。TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;sklearn.glasso: LARSを試す …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;進捗報告。TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;sklearn.glasso: LARSを試す
- sllearn.glassoを使った。却ってくっそ遅い。また、alpha=1e-4とすると悪条件過ぎて収束せずエラーを出した。
- 性能は自前実装glassoとほぼ同じ。
- 自前実装座標降下 &amp;gt; sklearn座標降下 &amp;gt; sklearn最小角 と言った感じ。sklearnは前処理とか入念にやるから遅いのは当然。しかし最小角が遅い理由はなんだ？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/2961686/approximating-the-inverse-of-a-perturbed-matrix"&gt;摂動展開&lt;/a&gt; を試す&lt;/li&gt;
&lt;li&gt;ガウス過程の文脈で考えてFFTする
- テプリッツ行列を巡回行列化してFFTすれば逆行列が &lt;span class="math"&gt;\(\mathcal{O}(n\log n)\)&lt;/span&gt; で求まる。
- これは大事な別方針なので記事にした。
- &lt;a class="reference external" href="https://ryamada22.hatenablog.jp/entry/20131203/1386210156"&gt;周期性と巡回行列&lt;/a&gt; ここらへんの話もえぐい。&lt;/li&gt;
&lt;li&gt;逐次的glassoにはBaysianの考え方も使える。（Bayesian Graphical LASSO）&lt;/li&gt;
&lt;li&gt;Sherman-Morrisonをもう一段展開する&lt;/li&gt;
&lt;li&gt;厳密解とのズレはどうなっとる？安定性解析は？&lt;/li&gt;
&lt;li&gt;できないやつのコードを共有する
- 次元を落として解軌跡を調査する。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(17)</title><link href="/r-1-noji-suan-17.html" rel="alternate"></link><published>2020-11-21T10:00:00+09:00</published><updated>2020-11-21T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-21:/r-1-noji-suan-17.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;間に合うかわからんが、Wiener-Hopf解を解く共役勾配法を試してみるのだ。
上手く行かなくていじけて寝てたりしたら20:00。大きく変化しすぎているように見えたので …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;間に合うかわからんが、Wiener-Hopf解を解く共役勾配法を試してみるのだ。
上手く行かなくていじけて寝てたりしたら20:00。大きく変化しすぎているように見えたので、係数更新量をステップサイズで調節できるようにしたら、マトモな、NLMS以上の性能を出し始めた。おそらくこれが意図した性能のはず。&lt;/p&gt;
&lt;p&gt;簡単に見てみると、i.i.d.なノイズに対しては収束がかなり早い。NGSA以上。論文で言ってたようにRLSクラスに見える。&lt;/p&gt;
&lt;p&gt;相関ありノイズ入力では性能が落ちる。勾配の尾根には早く達するが、そこからが遅い。最適値に収束するまでにSAに追いつかれるパターンも見られた。&lt;/p&gt;
&lt;p&gt;自己相関行列は事前に計算したほうが性能が良い風に見受けられる（しかし、適応計算を考えて、デフォルトでは指数的更新則を使う）。また、ポラック・リビエールではなくガチの共役勾配法で勾配の結合係数を計算したら性能がより良くなったように見える。&lt;/p&gt;
&lt;p&gt;指数平均の更新則は(alpha * prev + (1-alpha) * current)ではなく(alpha * prev + current)が正しいので見つけ次第直している。&lt;/p&gt;
&lt;p&gt;さて、これをSA化しようと思っている。アルゴリズムの途中にLMSの勾配が現れているので、これをSA化すればいいじゃんと思ったら、非常に性能が悪くなった。最適値周辺で暴れまくる。ちゃんと式を追いましょう。&lt;/p&gt;
&lt;p&gt;うーん、わからん。共役勾配法は完全にWiener-Hopf方程式を解こうとしている。g（勾配）はWiener-Hopfとのズレ（残差ベクトル）として定義されている。そのズレをSAの勾配に置き換えても上手く行かない。。。&lt;/p&gt;
&lt;p&gt;どうしようか、報告としては、共役勾配法があって強力なんだけどSAとして持っていけない…という風に持っていこうかな。glassoはたしかに良いんだけど、効率的な更新方法が見つからない。というかんじ。&lt;/p&gt;
&lt;p&gt;ソース整理開始。glassoをsubmoduleにぶっこむのがTODO。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(16)</title><link href="/r-1-noji-suan-16.html" rel="alternate"></link><published>2020-11-20T23:00:00+09:00</published><updated>2020-11-20T23:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-20:/r-1-noji-suan-16.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;課題祭りで11/19と11/20の昼は潰れる。今から進めるだけ進める。
前までに確認した …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;課題祭りで11/19と11/20の昼は潰れる。今から進めるだけ進める。
前までに確認した「直前の勾配とは必ずしも直交しない」の解決策を今日は考えたい。3連休は準備に入らないとまずそう。色々やっちゃったし。&lt;/p&gt;
&lt;p&gt;解決策は &lt;a class="reference external" href="https://pdfs.semanticscholar.org/2f97/524c54126234535e2741581890f5f65cf627.pdf"&gt;論文&lt;/a&gt; にあると思う。適応的にやるんだったら上の問題は絶対に出てくるはずだし。&lt;/p&gt;
&lt;p&gt;論文に答えが色々書いてあった。手法の要点は、&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;共役勾配の線形結合係数にポラック・ラビエール（Polak-Ribiere）の式を使う。フレッチャー・リーブス（論文では(6)式）より実験的に性能が良かったらしい。&lt;/li&gt;
&lt;li&gt;線形結合係数には2次式を仮定した値を使う。ただし、η倍（定数倍）する（収束が保証される範囲が忘却係数により決まる）。これによって勾配は必ずしもステップ毎に直交しなくなり、定数ステップでの収束が保証されなくなる。（しかし、適応アルゴリズムにとってはむしろこれがいい！）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考になった情報は、&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;論文以前の共役勾配ベースの適応アルゴリズムは、ブロック単位で自己相関行列（とWiener-Hopfの式の右辺のb）を更新していた。この論文ではサンプル単位で更新するアルゴリズムを提案する。&lt;/li&gt;
&lt;li&gt;R,bをブロック単位で求めて更新する方法と、逐次的に忘却係数をかけて更新する手法の性能を比較。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;難点（というか、新規性が生まれそうなところ）は、そのままNGSAには突っ込めないところか。この論文では二乗誤差最小基準で議論している、すなわちWiener-Hopf解を求めようとしている。勾配はWiener-Hopf解とのズレベクトルで定義される。NGSA(SA)の目的関数はなんだ？&lt;/p&gt;
&lt;p&gt;論文のノーテーションに合わせ、実装を整理しつつも実験。でもやっぱ傾向は変わらんよ。SAと同等家それ以下。
気になるのは、NGSA(SA)の目的関数に合わせたことをしなければならないという点。Wiener-Hopf解を解く実装だとパフォーマンスは良いのか？まずはそこから切り込んで調べる。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(15)</title><link href="/r-1-noji-suan-15.html" rel="alternate"></link><published>2020-11-18T10:00:00+09:00</published><updated>2020-11-18T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-18:/r-1-noji-suan-15.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;どうするかな。中間発表まで残り1週間というところ。
話す内容のまとめを、明日辺り考えてからまとめに向けた作業を行いたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;主題 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;どうするかな。中間発表まで残り1週間というところ。
話す内容のまとめを、明日辺り考えてからまとめに向けた作業を行いたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;主題: &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; の計算を避けるか高速に計算したい。&lt;ul&gt;
&lt;li&gt;方策1: Graphical LASSOを使おう&lt;ul&gt;
&lt;li&gt;真の逆行列とかなり近い行列が計算できてる。&lt;/li&gt;
&lt;li&gt;計算負荷が高い。。逐次計算でやるにはどうすればいいか。調査中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方策2: &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; の計算を避けよう&lt;ul&gt;
&lt;li&gt;共役勾配法を使う: 性能が良くない。なんで？理論的には納得いってるのに。&lt;/li&gt;
&lt;li&gt;準ニュートン法を使う: なかなか良い結果。だけど、&lt;span class="math"&gt;\(R\)&lt;/span&gt; すら使ってないから面白くない。準ニュートン法を使いましたで終わってしまう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日は共役勾配法が上手く行かないのが納得行かないから原因を追いたい。&lt;/p&gt;
&lt;p&gt;数式を軽く追ったところ、少し原因が見えた。共役勾配法をおさらいする。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(k\)&lt;/span&gt; ステップ目における共役勾配を &lt;span class="math"&gt;\(\ve{m}[k]\)&lt;/span&gt; 、関数 &lt;span class="math"&gt;\(f\)&lt;/span&gt; の勾配 &lt;span class="math"&gt;\(\parfrac{f}{\ve{h}}\)&lt;/span&gt; は、&lt;span class="math"&gt;\(\ve{R}\ve{m}[k] \propto \parfrac{f}{\ve{h}}\)&lt;/span&gt; の関係が成り立つ。（これは自然勾配法の原理からも自然に出てくる。ていうか、ここでの自然勾配は共役勾配に等しい）
また、直前の勾配と直交するから &lt;span class="math"&gt;\(\innerp{\ve{m}[k-1]}{\ve{R}\ve{m}[k]} = 0\)&lt;/span&gt; が成り立ち、&lt;span class="math"&gt;\(\ve{m}[k]\)&lt;/span&gt; は &lt;span class="math"&gt;\(\parfrac{f}{\ve{h}}\)&lt;/span&gt; と &lt;span class="math"&gt;\(\ve{m}[k-1]\)&lt;/span&gt; の線形結合で書ける: &lt;span class="math"&gt;\(\ve{m}[k] = \parfrac{f}{\ve{h}} + \alpha[k] \ve{m}[k-1]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;直交関係式から、 &lt;span class="math"&gt;\(\alpha[k] = - \frac{\innerp{\ve{m}[k-1]}{\ve{R}\parfrac{f}{\ve{h}}}}{\innerp{\ve{m}[k-1]}{\ve{R}\ve{m}[k-1]}}\)&lt;/span&gt; と求められる。こっから得られた &lt;span class="math"&gt;\(\ve{m}[k]\)&lt;/span&gt; で直線探索すればよい。という話。&lt;/p&gt;
&lt;p&gt;(13)で言った「Wiener-Hopf方程式を共役勾配法で」というのは、要は &lt;span class="math"&gt;\(\ve{R}\ve{h} = \ve{b}\)&lt;/span&gt; を共役勾配法で逐次的に解くということ。ここで、 &lt;span class="math"&gt;\(\ve{b}\)&lt;/span&gt; は入力とリファレンスの相関ベクトル。&lt;/p&gt;
&lt;p&gt;しかし、適応フィルタでは直交条件（&lt;span class="math"&gt;\(\innerp{\ve{m}[k-1]}{\ve{R}\ve{m}[k]} = 0\)&lt;/span&gt; ）が必ずしも成立しない。実験的に直前の勾配が今の勾配に直交しないことを確かめている。現に、 &lt;span class="math"&gt;\(\parfrac{f}{\ve{h}}\)&lt;/span&gt; は少しずつ変化しているから2ステップ間で直交していない。また、無理やり実装した共役勾配法はカクカクに、つまり前ステップの勾配と直交する方向に動くような挙動を観察している。&lt;/p&gt;
&lt;p&gt;この直交していないのをなんとかすれば解決できそうだけど、今の所解決策が思いつかない。考え中。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(14)</title><link href="/r-1-noji-suan-14.html" rel="alternate"></link><published>2020-11-17T10:00:00+09:00</published><updated>2020-11-17T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-17:/r-1-noji-suan-14.html</id><summary type="html">&lt;p&gt;課題が降ってきて研究が進まねえ。
今日はGraphical LASSOとの連携を試してみたい、かも。
共役勾配法はあんまり良くないでFA、準ニュートン法は統計量使ってないから面白くない、という結論に回す。&lt;/p&gt;
&lt;p&gt;最初は、Rの逆行列を事前に求めちゃってやる方式で試してみる。
よさそうなら逐次的実装にトライ。&lt;/p&gt;
&lt;p&gt;Rの逆行列を事前に求める方式はあんまり良くない、というかSAと同程度。
なんでなのか軽く見てみたら、事前計算でわかったR^-1をそのまま使うのはNGSAでも良くないということがわかった。
事前計算の場合の &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; はほぼ単位行列だから当然か・・・。&lt;/p&gt;
&lt;p&gt;逐次的が求められていると思い、むりやり逐次的にもとめるようにしてみた、が、あんまり結果が変わらん。
繰り返し回数を多くしても傾向は同様。等方的なのが変わらないから良くないのか？しかしそれはNGSAとて同じことでは？？？&lt;/p&gt;
&lt;p&gt;それどころか、相関付きノイズを入力すると発散する…いや、繰り返し回数が少なすぎるからだ。繰り返し回数を10とかにすると収束早め。
（事前計算する場合は発散しなかった。）&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;caption&gt;ここまで見た結果を表にまとめると…&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;手法&lt;/td&gt;
&lt;td&gt;i.i.d.雑音 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; 事前&lt;/td&gt;
&lt;td&gt;i.i.d.雑音 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; 逐次&lt;/td&gt;
&lt;td&gt;相関雑音 &lt;span class="math"&gt;\(R …&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</summary><content type="html">&lt;p&gt;課題が降ってきて研究が進まねえ。
今日はGraphical LASSOとの連携を試してみたい、かも。
共役勾配法はあんまり良くないでFA、準ニュートン法は統計量使ってないから面白くない、という結論に回す。&lt;/p&gt;
&lt;p&gt;最初は、Rの逆行列を事前に求めちゃってやる方式で試してみる。
よさそうなら逐次的実装にトライ。&lt;/p&gt;
&lt;p&gt;Rの逆行列を事前に求める方式はあんまり良くない、というかSAと同程度。
なんでなのか軽く見てみたら、事前計算でわかったR^-1をそのまま使うのはNGSAでも良くないということがわかった。
事前計算の場合の &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; はほぼ単位行列だから当然か・・・。&lt;/p&gt;
&lt;p&gt;逐次的が求められていると思い、むりやり逐次的にもとめるようにしてみた、が、あんまり結果が変わらん。
繰り返し回数を多くしても傾向は同様。等方的なのが変わらないから良くないのか？しかしそれはNGSAとて同じことでは？？？&lt;/p&gt;
&lt;p&gt;それどころか、相関付きノイズを入力すると発散する…いや、繰り返し回数が少なすぎるからだ。繰り返し回数を10とかにすると収束早め。
（事前計算する場合は発散しなかった。）&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;caption&gt;ここまで見た結果を表にまとめると…&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;手法&lt;/td&gt;
&lt;td&gt;i.i.d.雑音 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; 事前&lt;/td&gt;
&lt;td&gt;i.i.d.雑音 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; 逐次&lt;/td&gt;
&lt;td&gt;相関雑音 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; 事前&lt;/td&gt;
&lt;td&gt;相関雑音 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; 逐次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;NGSA&lt;/td&gt;
&lt;td&gt;SAと同程度&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;良&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;良&lt;/td&gt;
&lt;td&gt;良&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;NGSA(glasso)&lt;/td&gt;
&lt;td&gt;SAと同程度&lt;/td&gt;
&lt;td&gt;SAと同程度&lt;/td&gt;
&lt;td&gt;良&lt;/td&gt;
&lt;td&gt;良（繰り返しが少ないと発散）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;表で &lt;strong&gt;強調&lt;/strong&gt; したように、NGSAのi.i.d.雑音の逐次計算が早いのが納得行かない。 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; は単位行列に近いから、早くなるのは妙。
前計算する場合、勾配がどうなってるか気になる。正則化パラメータを弄ったとき、勾配はどこを向くのだろうか。
i.i.d.雑音でなんでNGSAの収束が早いのかもすごい気になる…。&lt;/p&gt;
&lt;p&gt;Jupyterに追記。glassoの正則化パラメータを強く（alphaを大きく）すると通常のSAの勾配に近づく（精度行列が単位行列に近づく）。逆に正則化パラメータを小さくすると自然勾配に近づく。
想像したとおりの結果で、だからどうしたといった感じ。そう、glassoをどう活かせばよいか？がまだ浮かんでこない。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(13)</title><link href="/r-1-noji-suan-13.html" rel="alternate"></link><published>2020-11-16T10:00:00+09:00</published><updated>2020-11-16T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-16:/r-1-noji-suan-13.html</id><summary type="html">&lt;p&gt;共役勾配法が上手く行かない原因を求めようとして、そもそもLMSで共役勾配法使ってんじゃねと思ったら、確かに使ってる事例あり。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/2f97/524c54126234535e2741581890f5f65cf627.pdf"&gt;Analysis of Conjugate Gradient Algorithms for Adaptive Filtering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://researchbank.swinburne.edu.au/file/178f868d-d5a1-4794-8839-a995a6641691/1/PDF%20(Published%20version).pdf"&gt;Conjugate Gradient Algorithm Design with RLS Normal Equation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要は、 &lt;a class="reference external" href="https://engineering.purdue.edu/~mikedz/research/RomeLabTutor.pdf"&gt;Wiener-Hopf方程式を共役勾配法で逐次的に解く手法&lt;/a&gt; に該当する。ただし、2乗誤差基準。&lt;/p&gt;
&lt;p&gt;性能を見るとRLSと張り合っているあたり、だいぶいいはず。少なくとも論文に書いてあるとおり実装すれば良い性能は出るはず。&lt;/p&gt;
&lt;p&gt;自己相関行列だよなあ、やっぱり。もう俺の研究の新規性分かんねぇなあ。
いや、いま気になったことがある。Wiener-Hopf方程式を解くのが最終目標になるんやが、それのスパース解を圧縮に使えないか。
うーん、でも劣決定問題じゃない（Rが正定とすると一意解が出る）からあんまりうまく行かない？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.kurims.kyoto-u.ac.jp/EMIS/journals/ETNA/vol.4.1996/pp14-36.dir/pp14-36.ps"&gt;LMS-NEWTON ADAPTIVE FILTERING USING FFT–BASED CONJUGATE GRADIENT ITERATIONS&lt;/a&gt; 自己相関行列（テプリッツ行列）の分解法を示していた …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;共役勾配法が上手く行かない原因を求めようとして、そもそもLMSで共役勾配法使ってんじゃねと思ったら、確かに使ってる事例あり。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/2f97/524c54126234535e2741581890f5f65cf627.pdf"&gt;Analysis of Conjugate Gradient Algorithms for Adaptive Filtering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://researchbank.swinburne.edu.au/file/178f868d-d5a1-4794-8839-a995a6641691/1/PDF%20(Published%20version).pdf"&gt;Conjugate Gradient Algorithm Design with RLS Normal Equation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要は、 &lt;a class="reference external" href="https://engineering.purdue.edu/~mikedz/research/RomeLabTutor.pdf"&gt;Wiener-Hopf方程式を共役勾配法で逐次的に解く手法&lt;/a&gt; に該当する。ただし、2乗誤差基準。&lt;/p&gt;
&lt;p&gt;性能を見るとRLSと張り合っているあたり、だいぶいいはず。少なくとも論文に書いてあるとおり実装すれば良い性能は出るはず。&lt;/p&gt;
&lt;p&gt;自己相関行列だよなあ、やっぱり。もう俺の研究の新規性分かんねぇなあ。
いや、いま気になったことがある。Wiener-Hopf方程式を解くのが最終目標になるんやが、それのスパース解を圧縮に使えないか。
うーん、でも劣決定問題じゃない（Rが正定とすると一意解が出る）からあんまりうまく行かない？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.kurims.kyoto-u.ac.jp/EMIS/journals/ETNA/vol.4.1996/pp14-36.dir/pp14-36.ps"&gt;LMS-NEWTON ADAPTIVE FILTERING USING FFT–BASED CONJUGATE GRADIENT ITERATIONS&lt;/a&gt; 自己相関行列（テプリッツ行列）の分解法を示していた。Ammar and Gader the cyclic displacement representationというらしいがヒットしない…。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(12)</title><link href="/r-1-noji-suan-12.html" rel="alternate"></link><published>2020-11-15T10:00:00+09:00</published><updated>2020-11-15T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-15:/r-1-noji-suan-12.html</id><content type="html">&lt;p&gt;準ニュートン法をもうちょっと試す。
BFGS法とDFP法をやってるけど、今の所はBFGS法が良さそう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ja.wikipedia.org/wiki/準ニュートン法"&gt;準ニュートン法(wikipedia)&lt;/a&gt; が悔しいけどまとまってる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;準ニュートン法は、直線探索を事後残差最小化に取る限り、中々安定した性能を出す。
いや、NLMSとほぼ同じ性能だった。事後残差最小化が強すぎて、勾配がそれに引っ張られているものと想像。&lt;/p&gt;
&lt;p&gt;NNGSA &amp;lt; NGSA &amp;lt; 準ニュートン法 &amp;lt; SA &amp;lt; 共役勾配法といった感じ。
共役勾配法が弱すぎんのがすごい気になってる。曲率がRで明示的にわかってんだから、もっと早いと思うんだけどなあ。&lt;/p&gt;
&lt;p&gt;そしてちょっと前から気付いてたけど、準ニュートン法はRを一切使っていない。直前の勾配の値を上手く組み合わせて収束を加速させている。
これはモーメンタムに似たものであろう（ちゃんと追いきれてない…）。&lt;/p&gt;
&lt;p&gt;もう一度共役勾配法を整理したい。金谷先生の本でわかった気になってるけど、webの情報と食い違ってる部分がある。。。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf"&gt;An Introduction to the Conjugate Gradient Method Without the Agonizing Pain&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(11)</title><link href="/r-1-noji-suan-11.html" rel="alternate"></link><published>2020-11-14T10:00:00+09:00</published><updated>2020-11-14T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-14:/r-1-noji-suan-11.html</id><content type="html">&lt;p&gt;共役勾配法をもうちょっと見てから、準ニュートン法を試そうかというのが今日の目標。&lt;/p&gt;
&lt;p&gt;共役勾配法の性能をまとめると、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;SAより同程度かそれ以下。&lt;/li&gt;
&lt;li&gt;自己相関行列は逐次的に求めていった方がほんのわずかに性能が良い。&lt;/li&gt;
&lt;/ul&gt;
&lt;img alt="共役勾配法を使ったNGSAとSAの性能比較（i.i.d.な雑音入力, 自己相関は逐次的に計算）" class="align-center" src="./images/ngsa_cg_learning_curves_case01.png" style="width: 400px;" /&gt;
&lt;p&gt;で、なんで？というところで答えが出ない。
勾配プロットすりゃいいんじゃねと思うんだが、共役勾配は明示的に前ステップの情報を使うから、静的な勾配を見ることができない。&lt;/p&gt;
&lt;p&gt;準ニュートン法を試す。勾配をどれくらい進めるかを決める直線探索をいかに上手くやるかがポイントだった。
いつもの事後残差最小化で行ったら実に上手く行った。（直線探索を上手くやらず固定ステップサイズにすると性能悪化）
じゃあ共役勾配も事後残差最小基準でステップサイズ設定してやる→性能向上しない。なぜだ。&lt;/p&gt;
&lt;p&gt;今の所、準ニュートン法の結果は不安定に見える。異常に早いときは2~3イテレーションで極値近くに達する。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(10)</title><link href="/r-1-noji-suan-10.html" rel="alternate"></link><published>2020-11-11T10:00:00+09:00</published><updated>2020-11-11T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-11:/r-1-noji-suan-10.html</id><content type="html">&lt;p&gt;共役勾配法を実装して（fが二次として金谷先生の例題3.5をそのまま使用）試してはいるが、性能が良くない。具体的には普通のSAと変わらんくらい。
実装ミスを疑っている。確かめるためにJupyterで検証しているけど、無難な結果が出ていると思われる。。。&lt;/p&gt;
&lt;p&gt;でもおかしいんだよなあ。発想自体は自然勾配と全く同じはずなのにあまり良くならないのは、やっぱり引っかかる。
もう少し追うけど、ダメそうなら切り替えて、次は準ニュートン法を試してみたい。
しっかし共役勾配法についてはもう少し粘るし、準ニュートン法との比較はちゃんとすること。投げっぱなし良くない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.uno.nuem.nagoya-u.ac.jp/~taji/lecture/mathprog/no9_18.pdf"&gt;制約なし問題の解法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://tm23forest.com/contents/bfgs-formula-quasi-newton-method-scipy-motivated"&gt;BFGS公式による準ニュートン法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;丁寧目の説明。ん？セカント方程式は劣決定問題だと言ってる。スパースな何かを使えないか？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://imclab.sys.okayama-u.ac.jp/~kent/DIR/opt08.pdf"&gt;システム制御最適化特論 非線形最適化&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;証明多め。丁寧な説明。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.orsj.or.jp/archive2/or59-03/or59_3_131.pdf"&gt;無制約最適化問題に対する アルゴリズムの最前線 ―非線形共役勾配法を中心に―&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.coyote009.com/non-linear-optimization"&gt;制約無し非線形最適化手法のいろいろ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.sist.ac.jp/~suganuma/kougi/other_lecture/SE/opt/nonlinear/nonlinear.htm"&gt;システムの最適化 － ２．非線形計画法（ NP: Nonlinear Programming ） －&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;簡単めな説明で実装しやすさがある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(9)</title><link href="/r-1-noji-suan-9.html" rel="alternate"></link><published>2020-11-09T10:00:00+09:00</published><updated>2020-11-09T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-09:/r-1-noji-suan-9.html</id><content type="html">&lt;p&gt;講義受けてて思ったこと。Cramer-RaoをNGSAの学習能力の評価に使えないか？
パット見使えなそう。うーむ。右辺というかFisher情報行列の逆は見えてるんだけど、比較対象の左辺が具体的に構成できない。（思い浮かばない）&lt;/p&gt;
&lt;p&gt;共役勾配法を入れて色々試してみてるけど、普通の勾配法とほぼ性能が変わらないという謎の状態。
2次の情報を使ってるので何かしら変化があるはずなのに、ほぼ変わらないのはおかしい。
自己相関行列を逐次的ではなく、前もって計算してやってみても同じ。謎。&lt;/p&gt;
&lt;p&gt;また共役勾配を見ると高級なモーメンタム法にしか見えないなあ。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(8)</title><link href="/r-1-noji-suan-8.html" rel="alternate"></link><published>2020-11-08T10:00:00+09:00</published><updated>2020-11-08T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-08:/r-1-noji-suan-8.html</id><content type="html">&lt;p&gt;今日は共役勾配法を試してみたい、が、その前にソース整理してcommitしとこう。&lt;/p&gt;
&lt;p&gt;pylintやるなりリファクタしてたら時間的にアウトになった。今日は見送りか...若干焦るけどしゃあない。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(7)</title><link href="/r-1-noji-suan-7.html" rel="alternate"></link><published>2020-11-07T10:00:00+09:00</published><updated>2020-11-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-07:/r-1-noji-suan-7.html</id><summary type="html">&lt;p&gt;課題にかまけていたら平日全く時間を取れなかった。まずい。
なんのためにここに来ているのか改めて考えなければなるまい。&lt;/p&gt;
&lt;p&gt;やるべきは、NGSAにGraphical LASSOを入れるのが最終目的として、
他にもいきなり思い出したことがある。夏に一瞬、共役勾配法を使えないかと言うのを考えていた。
改めて金谷先生の本を読んでもやれそうに見えるのだ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Graphical LASSOを逐次的に実行する手法はあるか？&lt;ul&gt;
&lt;li&gt;手法自体は中々見つかっていない・・・&lt;ul&gt;
&lt;li&gt;繰り返し回数を1で固定して、経験自己相関を逐次的に更新できれば。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ないとしても、自己相関行列を逐次計算する手法はあるか？&lt;ul&gt;
&lt;li&gt;共分散行列としたら色々出てきている…が、ピンとくる手法は無いように思える。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1504.02995.pdf"&gt;An Overview on the Estimation of Large Covariance and Precision Matrices&lt;/a&gt; でかい精度行列を推定する手法のサーベイ&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://faculty.marshall.usc.edu/Jacob-Bien/papers/biometrika2011spcov.pdf"&gt;Sparse Estimation of a Covariance Matrix&lt;/a&gt; 共分散行列のスパース推定&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://webee.technion.ac.il/Sites/People/YoninaEldar/Info/Shrink.pdf"&gt;Shrinkage Algorithms for MMSE Covariance Estimation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://hal.inria.fr/inria-00369468/document"&gt;Efficient Covariance Matrix Update for …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;課題にかまけていたら平日全く時間を取れなかった。まずい。
なんのためにここに来ているのか改めて考えなければなるまい。&lt;/p&gt;
&lt;p&gt;やるべきは、NGSAにGraphical LASSOを入れるのが最終目的として、
他にもいきなり思い出したことがある。夏に一瞬、共役勾配法を使えないかと言うのを考えていた。
改めて金谷先生の本を読んでもやれそうに見えるのだ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Graphical LASSOを逐次的に実行する手法はあるか？&lt;ul&gt;
&lt;li&gt;手法自体は中々見つかっていない・・・&lt;ul&gt;
&lt;li&gt;繰り返し回数を1で固定して、経験自己相関を逐次的に更新できれば。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ないとしても、自己相関行列を逐次計算する手法はあるか？&lt;ul&gt;
&lt;li&gt;共分散行列としたら色々出てきている…が、ピンとくる手法は無いように思える。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1504.02995.pdf"&gt;An Overview on the Estimation of Large Covariance and Precision Matrices&lt;/a&gt; でかい精度行列を推定する手法のサーベイ&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://faculty.marshall.usc.edu/Jacob-Bien/papers/biometrika2011spcov.pdf"&gt;Sparse Estimation of a Covariance Matrix&lt;/a&gt; 共分散行列のスパース推定&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://webee.technion.ac.il/Sites/People/YoninaEldar/Info/Shrink.pdf"&gt;Shrinkage Algorithms for MMSE Covariance Estimation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://hal.inria.fr/inria-00369468/document"&gt;Efficient Covariance Matrix Update for Variable Metric Evolution Strategies&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;対称な3重対角行列であることを活かせない？&lt;ul&gt;
&lt;li&gt;活かすといっても何を活かせばいいんだろう。逆行列の計算が早い？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tridiagonal_matrix#Inversion"&gt;wikipedia&lt;/a&gt; に情報はあるけど、何をどう活かせばいいのか…うーん。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.phys.lsu.edu/faculty/oconnell_new/PDFfiles/241.%20Analytical%20Inversion%20of%20Symmetric%20Tridiagonal%20Matrices.pdf"&gt;Analytical inversion of symmetric tridiagonal matrices&lt;/a&gt; 簡単なケースに対するものは解析解が求まっている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共役勾配法を導入するとどうなる？&lt;ul&gt;
&lt;li&gt;ヘッセ行列の計算を省いたときの、ビール・ソレンソン、ポラック・リビエール、フレッチャー・リーブスはどうなる？&lt;ul&gt;
&lt;li&gt;これらを試すのは十分にあり。 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; を考える必要すらない。 ビール・ソレンソン等によれば &lt;span class="math"&gt;\(R\)&lt;/span&gt; すらいらなくなる。しかし、気になるのは既存研究。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;メモ:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nagahara-masaaki.github.io/assets/pdfs/lecture10.pdf"&gt;Gershgorinの定理の優しい解説&lt;/a&gt; 要約すると、固有値の範囲をその行列の要素から特定できる定理なのだ。スパースモデリングでも度々出てくる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jappstat1971/22/3/22_3_99/_pdf/-char/en"&gt;階層型ニューラルネットとその周辺&lt;/a&gt; NNに対する自然勾配法（Fisherのスコアリング法と言っている）の原始的な定式化。広島大学の栗田先生。甘利先生より早いのでは？&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/profile/Takio_Kurita/publication/2372487_Iterative_Weighted_Least_Squares_Algorithms_For_Neural_Networks_Classifiers/links/0fcfd509460b783ab6000000/Iterative-Weighted-Least-Squares-Algorithms-For-Neural-Networks-Classifiers.pdf"&gt;ITERATIVE WEIGHTED LEAST SQUARES ALGORITHMS FOR NEURAL NETWORKS CLASSIFIERS&lt;/a&gt; Fisherのスコアリング法を提案している論文。&lt;/li&gt;
&lt;li&gt;2乗誤差基準でFisher情報行列を求めると、重み付きの入力の相関になる…まさか、LMSも重み付き相関で求まることを言っている？→簡単に確認したけどそんなことは無いはず…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(6)</title><link href="/r-1-noji-suan-6.html" rel="alternate"></link><published>2020-11-01T10:00:00+09:00</published><updated>2020-11-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-01:/r-1-noji-suan-6.html</id><content type="html">&lt;p&gt;Graphical LASSOを積み込むべきなのかもしれない。
まずは遅くてもいいから、NGSAに入れてみて様子を見よう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(5)</title><link href="/r-1-noji-suan-5.html" rel="alternate"></link><published>2020-10-31T10:00:00+09:00</published><updated>2020-10-31T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-31:/r-1-noji-suan-5.html</id><content type="html">&lt;p&gt;Graphical LASSOの実装ができたように見える。ハマったのは&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;精度行列と共分散行列を逆に見ていた ← 致命的&lt;/li&gt;
&lt;li&gt;座標降下法ではベクトルを一気に更新したらだめ（収束しない！！）で、要素1つづつ更新する必要がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;トイデータ（人工的なノイズ）はOKっぽい。
実データでリファレンス（sklearn実装）と対角要素がかなり違う。何故だ。&lt;/p&gt;
&lt;p&gt;実装ミスで間違いなさそう。入力信号を100で割るなりして小さくすると、共分散行列の逆の対角要素、及び精度行列の対角要素は大きくなるが、
自分の実装は大きくなっていかない。&lt;/p&gt;
&lt;p&gt;ノルム正規化したものを比較したら最大でも0.008程度の誤差。しかし、定数倍除き一致というのもおかしい。&lt;/p&gt;
&lt;p&gt;しばらく追っていたら、入力信号の振幅に対して逆二乗で差が出ていることに気づいた。もっと見たら、共分散行列の初期化で正則化をかけているのが原因であることが分かった。正則化をかけると対角要素が変わってしまう。やるなら、別の正則化パラメータにするかな。今は外した。外すことで入力信号問わずほぼ一致。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(4)</title><link href="/r-1-noji-suan-4.html" rel="alternate"></link><published>2020-10-27T10:00:00+09:00</published><updated>2020-10-27T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-27:/r-1-noji-suan-4.html</id><summary type="html">&lt;p&gt;引き続き&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf3/sklearn/covariance/_graph_lasso.py"&gt;sklearnのソース(Github)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;を見ながら、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ide-research.net/papers/2016_Iwanami_Ide.pdf"&gt;依存関係にスパース性を入れる — グラフィカル lasso の話 ∗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の対応を見出そうとしているが、どうも一致しない。pythonのソース側が対応していると言っているのがFriedman&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://statweb.stanford.edu/~tibs/ftp/graph.pdf"&gt;Sparse inverse covariance estimation with the graphical lasso&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;とあるので、それを参照したが、実装はFortran...（Rは呼び出しインターフェースだけ。。。）&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf39bbdacd6ed713c00724f8f871d60370/sklearn/covariance/_graph_lasso.py#L226"&gt;GLASSOの中身&lt;/a&gt; で &lt;a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf39bbdacd6ed713c00724f8f871d60370/sklearn/linear_model/_cd_fast.pyx#L99"&gt;enet_coordinate_descent関数&lt;/a&gt; を呼んでおり、数値最適化はLASSO(ElasticNetで片方の係数を0にしたもの)に任されている。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;どうやら元論文の実装(LASSO最適化を行う)をそのまま落とし込んだようで、ソフトしきい値作用素は一切出てこない。。。
githubで探してみても同様の実装が多数。&lt;/p&gt;
&lt;p&gt;いや、各 &lt;span class="math"&gt;\(\beta_{i}\)&lt;/span&gt; の最適化は座標降下法だから、むしろそれが正しいのか。&lt;/p&gt;
&lt;p&gt;いずれにしても簡単そうに見えるから実装してみるか。アルゴリズムを紙にまとめてみた。やってみよう。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align …&lt;/script&gt;</summary><content type="html">&lt;p&gt;引き続き&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf3/sklearn/covariance/_graph_lasso.py"&gt;sklearnのソース(Github)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;を見ながら、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ide-research.net/papers/2016_Iwanami_Ide.pdf"&gt;依存関係にスパース性を入れる — グラフィカル lasso の話 ∗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の対応を見出そうとしているが、どうも一致しない。pythonのソース側が対応していると言っているのがFriedman&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://statweb.stanford.edu/~tibs/ftp/graph.pdf"&gt;Sparse inverse covariance estimation with the graphical lasso&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;とあるので、それを参照したが、実装はFortran...（Rは呼び出しインターフェースだけ。。。）&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf39bbdacd6ed713c00724f8f871d60370/sklearn/covariance/_graph_lasso.py#L226"&gt;GLASSOの中身&lt;/a&gt; で &lt;a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf39bbdacd6ed713c00724f8f871d60370/sklearn/linear_model/_cd_fast.pyx#L99"&gt;enet_coordinate_descent関数&lt;/a&gt; を呼んでおり、数値最適化はLASSO(ElasticNetで片方の係数を0にしたもの)に任されている。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;どうやら元論文の実装(LASSO最適化を行う)をそのまま落とし込んだようで、ソフトしきい値作用素は一切出てこない。。。
githubで探してみても同様の実装が多数。&lt;/p&gt;
&lt;p&gt;いや、各 &lt;span class="math"&gt;\(\beta_{i}\)&lt;/span&gt; の最適化は座標降下法だから、むしろそれが正しいのか。&lt;/p&gt;
&lt;p&gt;いずれにしても簡単そうに見えるから実装してみるか。アルゴリズムを紙にまとめてみた。やってみよう。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(3)</title><link href="/r-1-noji-suan-3.html" rel="alternate"></link><published>2020-10-26T10:00:00+09:00</published><updated>2020-10-26T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-26:/r-1-noji-suan-3.html</id><content type="html">&lt;p&gt;要約すると、もうGraphical LASSO実装して試してみるべきかと思う。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf3/sklearn/covariance/_graph_lasso.py"&gt;sklearnのソース(Github)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数式との対応を追っていく。（しっかし昼は全く集中できない。。。）
気になるのはオプティマイザ（勾配法orLARS）の実装が他のモジュールでやってるところか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(2)</title><link href="/r-1-noji-suan-2.html" rel="alternate"></link><published>2020-10-25T10:00:00+09:00</published><updated>2020-10-25T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-25:/r-1-noji-suan-2.html</id><content type="html">&lt;p&gt;今更ながら三重対角行列、かなり具合が良さそうに見える。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mathtrain.jp/tridiagonal"&gt;三重対角行列の特殊形の固有値は綺麗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gg-hogehoge.hatenablog.com/entry/2013/07/20/140341"&gt;三重対角行列の固有値と固有ベクトルを計算したい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://hooktail.org/computer/index.php?%BB%B0%BD%C5%C2%D0%B3%D1%B2%BD"&gt;三重対角化 - [物理のかぎしっぽ]&lt;/a&gt; 頭に入れときたいのは、「対称行列は直交行列との積（直交変換）で3重対角行列に変換できる」ということ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.stat.yale.edu/~hz68/sparsePM.pdf"&gt;Estimating sparse precision matrices&lt;/a&gt; スパース（三重対角）な精度行列（共分散行列の逆行列）を求める。これ、かなり近いのでは。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;やはり、Graphical LASSOを遅くてもいいから試したくある。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://omedstu.jimdofree.com/2018/03/28/graph-lassoによる変数間の関係のグラフ化/"&gt;GraphLassoによる変数間の関係のグラフ化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;sklearnで実装されているから、逐次計算じゃなくても計算してみることはできる。次はsklearnによる結果と比較してみよう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(1)</title><link href="/r-1-noji-suan-1.html" rel="alternate"></link><published>2020-10-24T10:00:00+09:00</published><updated>2020-10-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-24:/r-1-noji-suan-1.html</id><summary type="html">&lt;p&gt;&lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; の計算高速化を考えていく。
なにより対象を知るのが一番だと思うので、まずは確認コードと真値の計算とその確認を行っていく。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src …&lt;/script&gt;</summary><content type="html">&lt;p&gt;&lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; の計算高速化を考えていく。
なにより対象を知るのが一番だと思うので、まずは確認コードと真値の計算とその確認を行っていく。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>論文書き(1)</title><link href="/lun-wen-shu-ki1.html" rel="alternate"></link><published>2020-10-16T10:00:00+09:00</published><updated>2020-10-16T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-16:/lun-wen-shu-ki1.html</id><summary type="html">&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;図:&lt;ul&gt;
&lt;li&gt;実データの結果、グレスケにすると手法の区別がつかない。移動平均サンプル数を多くする？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://linuxtricksandtips.blogspot.com/2015/01/how-to-convert-color-eps-to-grayscale.html"&gt;カラーeps → グレスケepsの裏技&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;移動平均サンプル数を増やした。グレスケ画像を作った。でもグレスケ置換はしない。白黒印刷で問題ないことがわかればOK｡&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;概要:&lt;ul&gt;
&lt;li&gt;短い背景があるだけ。研究の新規性が明確でない。研究の目的が述べられず。すぐにLMSとSAの説明に入ってしまう。&lt;ul&gt;
&lt;li&gt;ラプラス分布がーがいるかも？→いや、うるさい。&lt;/li&gt;
&lt;li&gt;残差をスパースにする必要がある。したがって、圧縮率改善のためには予測モデルの改善を模索する必要がある。SAは…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;論理的なギャップに打ち勝つ新規性(novelty)をはっきりさせる。&lt;/li&gt;
&lt;li&gt;主張を強めるための数量的な改善点を述べよ。（例: 5%良くなった）。行を追加していい。&lt;/li&gt;
&lt;li&gt;実験結果から見れる研究の結論は何？結局コーデックに何が嬉しいの？&lt;/li&gt;
&lt;li&gt;TODO: 背景の既存研究の論理的なギャップを要約。結論の言葉を要約。&lt;ul&gt;
&lt;li&gt;背景と同じで論理的なギャップなんてなくて、「SAの収束改善」が大事で、これを強調する。To overcome...&lt;/li&gt;
&lt;li&gt;結論の言葉、どうするか。（他のSAの論文見てると、実験結果よかった！で終わってて、おれもそうなってるんだが。）ロスレス音声に関するところだと、Future …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;図:&lt;ul&gt;
&lt;li&gt;実データの結果、グレスケにすると手法の区別がつかない。移動平均サンプル数を多くする？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://linuxtricksandtips.blogspot.com/2015/01/how-to-convert-color-eps-to-grayscale.html"&gt;カラーeps → グレスケepsの裏技&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;移動平均サンプル数を増やした。グレスケ画像を作った。でもグレスケ置換はしない。白黒印刷で問題ないことがわかればOK｡&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;概要:&lt;ul&gt;
&lt;li&gt;短い背景があるだけ。研究の新規性が明確でない。研究の目的が述べられず。すぐにLMSとSAの説明に入ってしまう。&lt;ul&gt;
&lt;li&gt;ラプラス分布がーがいるかも？→いや、うるさい。&lt;/li&gt;
&lt;li&gt;残差をスパースにする必要がある。したがって、圧縮率改善のためには予測モデルの改善を模索する必要がある。SAは…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;論理的なギャップに打ち勝つ新規性(novelty)をはっきりさせる。&lt;/li&gt;
&lt;li&gt;主張を強めるための数量的な改善点を述べよ。（例: 5%良くなった）。行を追加していい。&lt;/li&gt;
&lt;li&gt;実験結果から見れる研究の結論は何？結局コーデックに何が嬉しいの？&lt;/li&gt;
&lt;li&gt;TODO: 背景の既存研究の論理的なギャップを要約。結論の言葉を要約。&lt;ul&gt;
&lt;li&gt;背景と同じで論理的なギャップなんてなくて、「SAの収束改善」が大事で、これを強調する。To overcome...&lt;/li&gt;
&lt;li&gt;結論の言葉、どうするか。（他のSAの論文見てると、実験結果よかった！で終わってて、おれもそうなってるんだが。）ロスレス音声に関するところだと、Future workを述べるか？&lt;/li&gt;
&lt;li&gt;定量的な結果…。実験結果から言えることがない。どうしよう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;導入:&lt;ul&gt;
&lt;li&gt;関連する象徴的な(iconic)研究を載せるのを推奨→亀岡の研究のつもり。他にはOptimFROGか？→「A novel normalized sign algorithm for system identifica- tion under impulsive noise interference」を入れた。&lt;/li&gt;
&lt;li&gt;新規性をもっと明確に喋れ。既存研究の論理的ギャップに対する改善点は何？現状の問題の解決策になっている？&lt;/li&gt;
&lt;li&gt;研究の背後に有る動機は？&lt;/li&gt;
&lt;li&gt;TODO: 概要とかぶるが、既存研究の論理的なギャップは何か洗い出す。そして本研究が何を解決しているか（→適切な分布の仮定を満たす、収束の早い適応アルゴリズムが得られた。）整理。他に、関連する象徴的な研究を洗い出す。&lt;ul&gt;
&lt;li&gt;論理的なギャップなんてなくて、「SAの収束改善」が大事で、これを強調する。&lt;/li&gt;
&lt;li&gt;象徴的な研究としては「A novel normalized sign algorithm for system identification under impulsive noise interference」を入れた。新しめのまとまった、というかSAの方向性を述べた論文。もう一個くらい見繕っておくか。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ディスカッション:&lt;ul&gt;
&lt;li&gt;制限を述べただけになってる。&lt;/li&gt;
&lt;li&gt;他手法と比べて提案手法はどうなのか？得られた結果に対するコメントを述べるべし。&lt;/li&gt;
&lt;li&gt;他手法はどうなのか？&lt;/li&gt;
&lt;li&gt;結果が意味するのはなにか？（最終段落で短く述べられてるだけになっている。もっと書くべし。）&lt;/li&gt;
&lt;li&gt;TODO: 他手法との比較を追加。結果の吟味を追加。&lt;ul&gt;
&lt;li&gt;他と比べてよかった。はまず言う。 It is obvious that proposed algorithms show better convergence performance than that of the SA.&lt;/li&gt;
&lt;li&gt;RLSと似たパフォーマンスを出していたのも頷ける。The NNGSA had similar performances as RLS.&lt;/li&gt;
&lt;li&gt;しかし…負荷が…というつなぎ方に変える。On the other hand, however,&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;結論:&lt;ul&gt;
&lt;li&gt;コーデックや社会にどんな影響がある？&lt;/li&gt;
&lt;li&gt;コーデックにどのように適用する？&lt;/li&gt;
&lt;li&gt;今後の展望（研究範囲）をもっと掘り下げるべし。&lt;/li&gt;
&lt;li&gt;TODO: Future studyにロスレス音声予測モデルへの組み込みを検討する、とまず言う。そのために…をやる。という流れに。&lt;ul&gt;
&lt;li&gt;ロスレス音声への組み込みを将来研究に組み込んだ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio"></category><category term="Sign Algorithm"></category></entry><entry><title>論文読み(4)</title><link href="/lun-wen-du-mi4.html" rel="alternate"></link><published>2020-10-13T10:00:00+09:00</published><updated>2020-10-13T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-13:/lun-wen-du-mi4.html</id><content type="html">&lt;p&gt;論文読みのコメント:&lt;/p&gt;
&lt;p&gt;「新板 情報幾何学の新展開」の15.7節（p190）にFisher情報行列の固有値の分布の議論が有る。なにか使えないか？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;DCの件、自分の研究内容にフォーカスしすぎてて広がりが見えにくかったという指摘があった。来年早いうちに着手する。春休み入ってからとか。&lt;/li&gt;
&lt;li&gt;筆者(Tianshu Quさん)に連絡してできたらソース貰う。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="BP"></category><category term="Lossless Audio"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>論文読み(3)</title><link href="/lun-wen-du-mi3.html" rel="alternate"></link><published>2020-10-10T10:00:00+09:00</published><updated>2020-10-10T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-10:/lun-wen-du-mi3.html</id><summary type="html">&lt;p&gt;一気に追い込んで資料を作成。雑かも。&lt;/p&gt;
&lt;p&gt;一点気になっていたのが &lt;span class="math"&gt;\(l^{2}\)&lt;/span&gt; と &lt;span class="math"&gt;\(L^{2}\)&lt;/span&gt; の違い。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://scicomp.stackexchange.com/questions/21761/difference-between-l2-norm-and-l2-norm"&gt;Difference between l2 norm and L2 norm&lt;/a&gt; 実数列に対するノルムは &lt;span class="math"&gt;\(l\)&lt;/span&gt; 、有界な定義域 &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; 上に定義されたルベーグ可測関数のノルムは &lt;span class="math"&gt;\(L\)&lt;/span&gt; で良さそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;クソ大雑把に言うと、列に対するノルムは &lt;span class="math"&gt;\(l\)&lt;/span&gt; となり、関数に対するノルムは &lt;span class="math"&gt;\(L\)&lt;/span&gt; と考えて良さそう。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent …&lt;/script&gt;</summary><content type="html">&lt;p&gt;一気に追い込んで資料を作成。雑かも。&lt;/p&gt;
&lt;p&gt;一点気になっていたのが &lt;span class="math"&gt;\(l^{2}\)&lt;/span&gt; と &lt;span class="math"&gt;\(L^{2}\)&lt;/span&gt; の違い。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://scicomp.stackexchange.com/questions/21761/difference-between-l2-norm-and-l2-norm"&gt;Difference between l2 norm and L2 norm&lt;/a&gt; 実数列に対するノルムは &lt;span class="math"&gt;\(l\)&lt;/span&gt; 、有界な定義域 &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; 上に定義されたルベーグ可測関数のノルムは &lt;span class="math"&gt;\(L\)&lt;/span&gt; で良さそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;クソ大雑把に言うと、列に対するノルムは &lt;span class="math"&gt;\(l\)&lt;/span&gt; となり、関数に対するノルムは &lt;span class="math"&gt;\(L\)&lt;/span&gt; と考えて良さそう。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="BP"></category><category term="Lossless Audio"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>論文読み(2)</title><link href="/lun-wen-du-mi2.html" rel="alternate"></link><published>2020-10-07T10:00:00+09:00</published><updated>2020-10-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-07:/lun-wen-du-mi2.html</id><content type="html">&lt;p&gt;今日でCBCの概要を掴んで、プロット、スライド作成に入りたい。
Context-dependent bitplane coding in China AVS Audio あった。読んでる。なんとなくつかめたので、説明を試みたい。&lt;/p&gt;
</content><category term="雑記"></category><category term="BP"></category><category term="Lossless Audio"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>論文読み(1)</title><link href="/lun-wen-du-mi1.html" rel="alternate"></link><published>2020-10-06T10:00:00+09:00</published><updated>2020-10-06T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-06:/lun-wen-du-mi1.html</id><summary type="html">&lt;p&gt;標準化されたロスレス音声規格IEEE 1857.2、くっそ怪しい。 &lt;a class="reference external" href="https://hydrogenaud.io/index.php?topic=111683.0"&gt;リファレンスエンコーダが公開されてないっぽい。&lt;/a&gt;
一応概要みたいのは以下:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://150.162.46.34:8080/icassp2014/papers/p6984-haibin.pdf"&gt;LOSSLESS AUDIO COMPRESSION IN THE NEW IEEE STANDARD FOR ADVANCED AUDIO CODING&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さっと読んだ。工夫したのは、ブロック先頭で残差が大きくなるから、それをビットシフトして振幅を潰し、下位ビットの情報は別に送ること、算術符号はテンプレートとなる確率分布を使用すること、がメインである。うーん。かなり泥臭いと思う。モデルがすごいと言うよりは工夫メインな印象を受ける。また、他の論文でウェーブレットを使っているみたいな話があるけど、どうにもこちらも怪しい。&lt;/p&gt;
&lt;p&gt;ロスレス音声でウェーブレット+BPを使う話。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://150.162.46.34:8080/icassp2013/pdfs/0000552.pdf"&gt;AUDIO LOSSLESS CODING/DECODING METHOD USING BASIS PURSUIT ALGORITHM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;音声圧縮でウェーブレットを使うのは筋が悪かったので、少なくとも自分には衝撃ではある。で、ちゃんと読んでみようと思ったのだが4pで概要しか示されてない。&lt;/p&gt;
&lt;p&gt;肝となる部分でわからないのが、ウェーブレット辞書を結合して過完備な辞書を作るところ。基礎が抜けていることを疑って、Donohoを読む …&lt;/p&gt;</summary><content type="html">&lt;p&gt;標準化されたロスレス音声規格IEEE 1857.2、くっそ怪しい。 &lt;a class="reference external" href="https://hydrogenaud.io/index.php?topic=111683.0"&gt;リファレンスエンコーダが公開されてないっぽい。&lt;/a&gt;
一応概要みたいのは以下:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://150.162.46.34:8080/icassp2014/papers/p6984-haibin.pdf"&gt;LOSSLESS AUDIO COMPRESSION IN THE NEW IEEE STANDARD FOR ADVANCED AUDIO CODING&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さっと読んだ。工夫したのは、ブロック先頭で残差が大きくなるから、それをビットシフトして振幅を潰し、下位ビットの情報は別に送ること、算術符号はテンプレートとなる確率分布を使用すること、がメインである。うーん。かなり泥臭いと思う。モデルがすごいと言うよりは工夫メインな印象を受ける。また、他の論文でウェーブレットを使っているみたいな話があるけど、どうにもこちらも怪しい。&lt;/p&gt;
&lt;p&gt;ロスレス音声でウェーブレット+BPを使う話。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://150.162.46.34:8080/icassp2013/pdfs/0000552.pdf"&gt;AUDIO LOSSLESS CODING/DECODING METHOD USING BASIS PURSUIT ALGORITHM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;音声圧縮でウェーブレットを使うのは筋が悪かったので、少なくとも自分には衝撃ではある。で、ちゃんと読んでみようと思ったのだが4pで概要しか示されてない。&lt;/p&gt;
&lt;p&gt;肝となる部分でわからないのが、ウェーブレット辞書を結合して過完備な辞書を作るところ。基礎が抜けていることを疑って、Donohoを読む:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.stanford.edu/group/SOL/papers/BasisPursuit-SIGEST.pdf"&gt;Atomic Decomposition by Basis Pursuit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そして論文ではliftingを使ったと行っているが、liftingを使った場合、どうなるのか？画像に対して試したのが下:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://aircconline.com/ijma/V7N1/7115ijma01.pdf"&gt;IMAGE COMPRESSION BASED ON COMPRESSIVE SENSING USING WAVELET LIFTING SCHEME&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ロッシーなんだよなあ。&lt;/p&gt;
&lt;p&gt;BPで辞書作るときって、基底をサンプリングして作るんだっけか？BPの動きを確認し始める。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://eeweb.poly.edu/iselesni/teaching/lecture_notes/sparsity_intro/html/Example_BP.html#2"&gt;Example: Basis pursuit (BP)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ウェーブレットの場合の答えが以下にある。精読していく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://elad.cs.technion.ac.il/wp-content/uploads/2018/02/MultiScale-KSVD-IEEE-Selected-Topics.pdf"&gt;Multi-Scale Dictionary Learning using Wavelets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://danielmckenzie.github.io/DictLearning.pdf"&gt;Dictionary Learning Using Wavelets&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そもそもウェーブレット変換って行列表現できたっけ？と思ったら、余裕でできてた。これの高速算方が離散ウェーブレット変換(DWT)だったわ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cfme.chiba-u.jp/~haneishi/class/iyogazokougaku/Wavelet2.pdf"&gt;1次元ウェーブレット変換&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;論文が参照しているウェーブレット系のペーパーが重い。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cm-bell-labs.github.io/who/wim/papers/athome/athome.pdf"&gt;Building Your Own Wavelets at Home&lt;/a&gt; 有名なペーパー。ウェーブレット自分自身で構築できるようだ（2nd Generation Wavelet）。その計算方法がLifting Schemeとなる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://services.math.duke.edu/~ingrid/publications/J_Four_Anal_Appl_4_p247.pdf"&gt;Factoring Wavelet Transforms into Lifting Steps&lt;/a&gt; 1st Generation WaveletはLiftingの形式に持っていけると言っている&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非常にボリュームが大きい。。。弱った。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.tut.fi/~tabus/NOKIA_PS/Doru_nsip.ps"&gt;INTEGER WAVELET TRANSFORM BASED LOSSLESS AUDIO COMPRESSION&lt;/a&gt; 古いけど、ウェーブレットを使ったロスレス音声圧縮がここに。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理論一切抜きで、計算法は分かった。しかし、BPによってどのように基底を選んでいるのかさっぱり分からん。ウェーブレットは固定辞書だから、L1正則化問題を解析的に解いてはいないはず。Basis Pursuitはアルゴリズムじゃなくて原理だと &lt;a class="reference external" href="https://web.stanford.edu/group/SOL/papers/BasisPursuit-SIGEST.pdf"&gt;原論文&lt;/a&gt; で言っていたし:&lt;/p&gt;
&lt;blockquote&gt;
BP is an optimization principle, not an algorithm. Over the last 40 years, a tremendous amount of work has been done on the solution of linear programs. Until the 1980s, most work focused on variants of Dantzig’s sim- plex algorithm, which many readers have no doubt studied. In the last ten years, some spectacular breakthroughs have been made by the use of so-called interior-point methods, which use an entirely different principle.&lt;/blockquote&gt;
&lt;p&gt;うーん、妄想してみると、こんなかんじだろうか？&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;辞書作成: Cohen-Daubechies-Feuveau(cdf) wavelet, Daubechies(db) wavelet, Symlets(sym) 等（&amp;quot;等&amp;quot;は謎。全部書いてくれよ...）から辞書を作る。ここでは、cdf,db,symの3つ使ったと考える。&lt;/li&gt;
&lt;li&gt;ウェーブレット変換: cdf, db, symの3つで変換を行う。変換はLifting Schemeで行う。&lt;/li&gt;
&lt;li&gt;基底選択: 最もL1ノルム（残差絶対値和）が小さかったウェーブレット基底を選び、出力を確定させる。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;この操作を低域/高域成分の両方に対し、高解像度から低解像度に向かって行っていく。（高域/低域両方に対して分析をおこなうのをウェーブレットパケット解析というようだ。低域成分（画像で言うなら左上）だけに分析を続けるのはウェーブレット解析。ウェーブレットパケット解析は二分木をなす。）&lt;/p&gt;
&lt;p&gt;最終的に得られた出力をエントロピー符号化する。
解像度の深さと、選んだ基底の情報はside informationとして渡す。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.osaka-kyoiku.ac.jp/~morimoto/WSPRO/wavelet2014proceedingsR3.pdf"&gt;ウェーブレット理論と工学への応用&lt;/a&gt; 日本語でちゃんと書かれたリフティングの話。印刷して、読もう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;わからないのは後はエントロピー符号化(BCB)のはず。クローズっぽいんだよなあ…。
明日、プロットをまとめる。&lt;/p&gt;
</content><category term="雑記"></category><category term="BP"></category><category term="Lossless Audio"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>論文書きつつ(1)</title><link href="/lun-wen-shu-kitsutsu1.html" rel="alternate"></link><published>2020-09-24T10:00:00+09:00</published><updated>2020-09-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-24:/lun-wen-shu-kitsutsu1.html</id><content type="html">&lt;p&gt;英語論文シコシコ書きつつ。断然収まらないので削ることを考えながら。&lt;/p&gt;
&lt;p&gt;GLASSO見てる。2重ループ最適化で、重そうに見える。。。
βの更新でO(N)、さらに変数選択でO(N)。。。&lt;/p&gt;
&lt;p&gt;簡略化して、一回の更新でβの一要素更新でいいのでは？
とりあえず、実装を考えていく。&lt;/p&gt;
&lt;p&gt;しっかし書き始める前に、論文を軽く漁ってみよう。&lt;/p&gt;
</content><category term="雑記"></category><category term="GLASSO"></category></entry><entry><title>自由工作(10)</title><link href="/zi-you-gong-zuo-10.html" rel="alternate"></link><published>2020-09-16T10:00:00+09:00</published><updated>2020-09-16T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-16:/zi-you-gong-zuo-10.html</id><summary type="html">&lt;p&gt;黙々と進めた。残タスクは、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;コマンドラインの整備:DONE&lt;ul&gt;
&lt;li&gt;残差出力モードの追加(-e):DONE&lt;/li&gt;
&lt;li&gt;統計情報出力モードの追加(-c):DONE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;テストケース追加:DONE&lt;ul&gt;
&lt;li&gt;白色雑音入力(randで生成したものでよい):DONE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;リリース実行確認:DONE&lt;/li&gt;
&lt;li&gt;先頭で一発空エンコードして適応を早める:DONE&lt;/li&gt;
&lt;li&gt;コード整理&lt;ul&gt;
&lt;li&gt;エンコーダとデコーダを分ける: DONE&lt;/li&gt;
&lt;li&gt;ブロックデータエンコード/デコード関数が大きいので関数化: 小さくまとまったのでいいかな。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;音質向上への工夫&lt;ul&gt;
&lt;li&gt;MS処理の再興。MS処理のスイッチオプションを追加&lt;ul&gt;
&lt;li&gt;もう一度試してみたらRMSEが悪化していることが分かった。（BGMとアイカツ音源で調べた）&lt;/li&gt;
&lt;li&gt;実際に聞いてみるとパチパチ言ってる。不連続点が出ている。パチパチ言ってた記憶はないので、何かがおかしい。デバッグ。&lt;ul&gt;
&lt;li&gt;デコード時にLRに戻す前にオーバーフローしていた。&lt;/li&gt;
&lt;li&gt;バグや。ブロックヘッダにLRが入っているが、フィルタはMSで予測していた。そらパチパチ言うわ。&lt;/li&gt;
&lt;li&gt;パチパチは直したが、得られた結果は微妙と言わざるを得ない。最大誤差は減ってるけど、平均誤差は増大した傾向。
オプションにしてもデフォルトでオフかなあ。&lt;/li&gt;
&lt;li&gt;MSでうまく行かない例としては、振幅が大きい振動波で、side成分が割れている場合。（ピエトロの気絶の55秒付近）そこをADPCM化すると …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;黙々と進めた。残タスクは、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;コマンドラインの整備:DONE&lt;ul&gt;
&lt;li&gt;残差出力モードの追加(-e):DONE&lt;/li&gt;
&lt;li&gt;統計情報出力モードの追加(-c):DONE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;テストケース追加:DONE&lt;ul&gt;
&lt;li&gt;白色雑音入力(randで生成したものでよい):DONE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;リリース実行確認:DONE&lt;/li&gt;
&lt;li&gt;先頭で一発空エンコードして適応を早める:DONE&lt;/li&gt;
&lt;li&gt;コード整理&lt;ul&gt;
&lt;li&gt;エンコーダとデコーダを分ける: DONE&lt;/li&gt;
&lt;li&gt;ブロックデータエンコード/デコード関数が大きいので関数化: 小さくまとまったのでいいかな。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;音質向上への工夫&lt;ul&gt;
&lt;li&gt;MS処理の再興。MS処理のスイッチオプションを追加&lt;ul&gt;
&lt;li&gt;もう一度試してみたらRMSEが悪化していることが分かった。（BGMとアイカツ音源で調べた）&lt;/li&gt;
&lt;li&gt;実際に聞いてみるとパチパチ言ってる。不連続点が出ている。パチパチ言ってた記憶はないので、何かがおかしい。デバッグ。&lt;ul&gt;
&lt;li&gt;デコード時にLRに戻す前にオーバーフローしていた。&lt;/li&gt;
&lt;li&gt;バグや。ブロックヘッダにLRが入っているが、フィルタはMSで予測していた。そらパチパチ言うわ。&lt;/li&gt;
&lt;li&gt;パチパチは直したが、得られた結果は微妙と言わざるを得ない。最大誤差は減ってるけど、平均誤差は増大した傾向。
オプションにしてもデフォルトでオフかなあ。&lt;/li&gt;
&lt;li&gt;MSでうまく行かない例としては、振幅が大きい振動波で、side成分が割れている場合。（ピエトロの気絶の55秒付近）そこをADPCM化すると、エフェクターを通したように割れてしまう。&lt;ul&gt;
&lt;li&gt;ロスレスではないから、エンコード時にsideも右シフトすることで、sideが割れる問題は緩和した。採用。しかしMSはオプションとする（デフォルトOFF）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;振幅がでかいときに誤差が大きくなる。じゃあ、入力を1bit右シフトして、出力時に1bit左シフトしていいんじゃない。&lt;ul&gt;
&lt;li&gt;純粋に情報量が落ちそう。試してみるが。→うん、だめ。1bitぶん何かがわからなくなるのはつらい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NG的なアイデア入らないか？&lt;ul&gt;
&lt;li&gt;プリエンファシスを掛けたもので勾配計算する。重いか…？&lt;/li&gt;
&lt;li&gt;爆裂に精度悪化。とりやめ。時間切れ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IIR的（出力）の適応: ダメだった。負荷も増えるし、やらん。&lt;/li&gt;
&lt;li&gt;モーメンタムみたいに、前の勾配を使えないか？&lt;ul&gt;
&lt;li&gt;やってみたが微妙。たいていRMSEが悪くなる。良くなっても劇的じゃない。&lt;/li&gt;
&lt;li&gt;SLAのLogSignを強引に入れてみたけど良くない。&lt;/li&gt;
&lt;li&gt;その他、残差と履歴をlog/sign化したけど芳しくなかった。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;コードを2の補数にしたい。&lt;ul&gt;
&lt;li&gt;上位ビットを埋めるのが帰って辛いように思えた。保留。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ノイズシェーピングが芳しくない。&lt;ul&gt;
&lt;li&gt;ちょっと考えると、品質の低いフィルター突っ込んでんのと同じに思えた。実際外すとRMSEが向上した。&lt;/li&gt;
&lt;li&gt;廃止の方向で検討。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;負荷 instruments -t &amp;quot;Time Profiler&amp;quot; ./aad ... でいける。&lt;/li&gt;
&lt;li&gt;今更だが、 &lt;a class="reference external" href="http://web.archive.org/web/20060818165032/http://ku-www.ss.titech.ac.jp:80/~yatsushi/adx.html"&gt;資料1&lt;/a&gt; , &lt;a class="reference external" href="https://www.ffmpeg.org/doxygen/0.6/adx_8h.html#bf98059cca648e492906344dd0873907"&gt;ffmpeg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Macでinstrumentsが廃止されたようだ。 xcrun xctrace record --template 'Time Profiler' --target-stdout - --launch -- ./aad -e ManiMani.wav a.aad で計測を行っている。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;感想・展望&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;うーん、性能が良くない。IMA-ADPCMに毛が生えた程度か。XMAみたく、ブロック区間の残差の最大振幅値を計測して割った方がええのかな。&lt;ul&gt;
&lt;li&gt;4bitのときは、残差を max(-最小残差/8, 最大残差/7) で割れば、残差が4bit収まる。&lt;/li&gt;
&lt;li&gt;3bitならば max(-最小残差/4, 最大残差/3), 2bitならば max(-最小残差/2, 最大残差/1) となるはず。&lt;/li&gt;
&lt;li&gt;一般化すると max(-最小残差/(1 &amp;lt;&amp;lt; (bits-1)), 最大残差/((1 &amp;lt;&amp;lt; (bits-1)) - 1))&lt;/li&gt;
&lt;li&gt;ブランチ切ってやってみたい...と思ったらできないことがすぐに分かった。量子化誤差が適応中にわからない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LPCを使うのもありだな。係数の絶対値が1を超えるから係数のスケール情報を入れる必要があるが。&lt;/li&gt;
&lt;li&gt;量子化誤差が適応的に出る（しかも、エンコード/デコードで全く同じ値が出る）から、これに応じてステップサイズ、もしくは符号化値を変えられないか。&lt;/li&gt;
&lt;li&gt;複数回エンコードを回すの有効かも。少なくともファイル先頭では効いた。&lt;ul&gt;
&lt;li&gt;単純に単一ブロックを繰り返しエンコードするのは効果が薄かった。&lt;/li&gt;
&lt;li&gt;次（前）の区間と合わせてエンコードするのもいいかも。オーバーラップする形。これは効いたので取り入れた。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;テーブルの見直し。急激に振幅がかわる（2〜3サンプルで-1から1に近づくときがある）ので、おそらく、テーブルの150以降の要素はもっと大きい値をとってもいいと思う。&lt;/li&gt;
&lt;li&gt;ステップサイズを適応的に計算するyamaha形式を試してみたい。IMAではテーブルの256階調に限られるが、こちらはより柔軟に思える。
* &lt;a class="reference external" href="http://www.piece-me.org/piece-lab/adpcm/adpcm1.html"&gt;ADPCMの仕組み#1&lt;/a&gt; や &lt;a class="reference external" href="https://github.com/mguentner/rockbox/blob/master/apps/codecs/libpcm/yamaha_adpcm.c"&gt;rockbox&lt;/a&gt; や &lt;a class="reference external" href="https://ffmpeg.org/doxygen/0.6/adpcm_8c-source.html"&gt;ffmpeg&lt;/a&gt; が参考になる。
* やっつけでやってみた。音圧の低い音源では少しよくなったが、りんごの木など音圧が大きい音源で軒並みRMSEが2割ほど悪化。取り下げていく。逆に考えると、低音圧音源で現在の実装があんまり良くないともいえる結果やな。&lt;/li&gt;
&lt;li&gt;残差波形を見ているとピッチの残差立ち上がりが大きくて、また、それによって聞こえやすいノイズが発生している。周期は170サンプル=282Hz(&amp;#64;48k)とか。&lt;ul&gt;
&lt;li&gt;ピッチを潰すのは有効かも。自己相関を計算して周期を解析して、その一点で潰しにかかる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;タイムオーバー。現実にもどりましょ。&lt;/p&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(9)</title><link href="/zi-you-gong-zuo-9.html" rel="alternate"></link><published>2020-09-14T10:00:00+09:00</published><updated>2020-09-14T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-14:/zi-you-gong-zuo-9.html</id><summary type="html">&lt;p&gt;AADのフォーマットを書いてく。デバッグ効率のため（データ到着順で見れるようにしたい）に、ビッグエンディアンで...&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;ヘッダフォーマット&lt;/h2&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="28%" /&gt;
&lt;col width="9%" /&gt;
&lt;col width="63%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;名前&lt;/th&gt;
&lt;th class="head"&gt;サイズ[byte]&lt;/th&gt;
&lt;th class="head"&gt;内容（補足）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;AADシグネチャ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'A', 'A', 'D', '0'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;フォーマットバージョン番号&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;チャンネル数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプル数&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1チャンネルあたりの全サンプル数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプリングレート&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプルあたりビット数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2, 3, 4のいずれか。1もいつかは対応したい。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックサイズ&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;ブロックのヘッダと圧縮済みデータを含めたサイズ。末尾のブロックではこの値以下になる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックあたりサンプル数&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;末尾のブロックではこの値以下になる&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ブロックサイズは256の倍数にしたい。デフォルト1024で。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;ブロックヘッダフォーマット&lt;/h2&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="27%" /&gt;
&lt;col width="12%" /&gt;
&lt;col width="61%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;名前&lt;/th&gt;
&lt;th class="head"&gt;サイズ[byte]&lt;/th&gt;
&lt;th class="head"&gt;内容（補足）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;フィルタ係数&lt;/td&gt;
&lt;td&gt;8 …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;AADのフォーマットを書いてく。デバッグ効率のため（データ到着順で見れるようにしたい）に、ビッグエンディアンで...&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;ヘッダフォーマット&lt;/h2&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="28%" /&gt;
&lt;col width="9%" /&gt;
&lt;col width="63%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;名前&lt;/th&gt;
&lt;th class="head"&gt;サイズ[byte]&lt;/th&gt;
&lt;th class="head"&gt;内容（補足）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;AADシグネチャ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'A', 'A', 'D', '0'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;フォーマットバージョン番号&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;チャンネル数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプル数&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1チャンネルあたりの全サンプル数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプリングレート&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプルあたりビット数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2, 3, 4のいずれか。1もいつかは対応したい。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックサイズ&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;ブロックのヘッダと圧縮済みデータを含めたサイズ。末尾のブロックではこの値以下になる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックあたりサンプル数&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;末尾のブロックではこの値以下になる&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ブロックサイズは256の倍数にしたい。デフォルト1024で。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;ブロックヘッダフォーマット&lt;/h2&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="27%" /&gt;
&lt;col width="12%" /&gt;
&lt;col width="61%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;名前&lt;/th&gt;
&lt;th class="head"&gt;サイズ[byte]&lt;/th&gt;
&lt;th class="head"&gt;内容（補足）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;フィルタ係数&lt;/td&gt;
&lt;td&gt;8 * チャンネル数&lt;/td&gt;
&lt;td&gt;符号付き16bit整数の係数が4つ それがチャンネル数ぶん&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;フィルタ入力履歴&lt;/td&gt;
&lt;td&gt;8 * チャンネル数&lt;/td&gt;
&lt;td&gt;符号付き16bit整数のサンプルが4つ（先頭4サンプル） それがチャンネル数ぶん&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;テーブルインデックス&lt;/td&gt;
&lt;td&gt;1 * チャンネル数&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;予約領域&lt;/td&gt;
&lt;td&gt;1 * チャンネル数&lt;/td&gt;
&lt;td&gt;偶数にするため。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ヘッダサイズは18 * チャンネル数[byte]。&lt;/p&gt;
&lt;p&gt;しかしヘッダが大きすぎるかもしれない。入力履歴は毎回リセットすべきか？
SLAではブロックごとにフィルタ係数をリセットしていたけど、こっちではまずそう。ブロックあたりサンプル数が少なくて適応が遅くなる。
→ホールド（直前サンプルが続いている）でもOK。軽く試したけど、当然、誤差は増える。&lt;/p&gt;
&lt;p&gt;まずは富豪的に、上のフォーマットで作る。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;ブロックデータフォーマット&lt;/h2&gt;
&lt;p&gt;サンプルあたりビット数で異なる。ビッグエンディアンで、上位bitから順に書いていく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;4bit: 2サンプル(=1byte)単位でインターリーブ。&lt;/li&gt;
&lt;li&gt;3bit: 8サンプル(=3byte)単位でインターリーブ。&lt;/li&gt;
&lt;li&gt;2bit: 4サンプル(=1byte)単位でインターリーブ。&lt;/li&gt;
&lt;li&gt;1bit: 8サンプル(=1byte)単位でインターリーブ。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ブロックデータサイズは、(インターリーブの単位*チャンネル数)の倍数に設定する。&lt;/p&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;フォーマット&lt;/h3&gt;
&lt;p&gt;ビッグエンディアンで記録する。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;ヘッダフォーマット&lt;/h2&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="28%" /&gt;
&lt;col width="9%" /&gt;
&lt;col width="63%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;名前&lt;/th&gt;
&lt;th class="head"&gt;サイズ[byte]&lt;/th&gt;
&lt;th class="head"&gt;内容（補足）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;AADシグネチャ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'A', 'A', 'D', '0'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;フォーマットバージョン番号&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;コーデックバージョン番号&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;チャンネル数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプル数&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1チャンネルあたりの全サンプル数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプリングレート&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプルあたりビット数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2, 3, 4のいずれか。1もいつかは対応したい。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックサイズ&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;ブロックのヘッダと圧縮済みデータを含めたサイズ。末尾のブロックではこの値以下になる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックあたりサンプル数&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;末尾のブロックではこの値以下になる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;マルチチャンネル処理法&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0:何もしていない、1:LR-&amp;gt;MS処理（効果が薄いため、廃止予定）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;ブロックヘッダフォーマット&lt;/h2&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="37%" /&gt;
&lt;col width="10%" /&gt;
&lt;col width="53%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;名前&lt;/th&gt;
&lt;th class="head"&gt;サイズ[byte]&lt;/th&gt;
&lt;th class="head"&gt;内容（補足）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;テーブルインデックス上位8bit&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;テーブルインデックス下位4bit / 係数シフト数&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;下位4bitは固定小数の小数部。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;フィルタ係数&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;符号付き16bit整数の係数が4つ。係数シフト数分左シフトして使う。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;フィルタ入力履歴&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;符号付き16bit整数のサンプルが4つ（先頭4サンプル）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;これがチャンネル数分並ぶ。ヘッダサイズは18 * チャンネル数[byte]。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2&gt;ブロックデータフォーマット&lt;/h2&gt;
&lt;p&gt;サンプルあたりビット数で異なる。ビッグエンディアンで、上位bitから順に書いていく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;4bit: 2サンプル(=1byte)単位でインターリーブ。&lt;/li&gt;
&lt;li&gt;3bit: 8サンプル(=3byte)単位でインターリーブ。&lt;/li&gt;
&lt;li&gt;2bit: 4サンプル(=1byte)単位でインターリーブ。&lt;/li&gt;
&lt;li&gt;1bit: 8サンプル(=1byte)単位でインターリーブ。（未サポート。将来的にやりたい。）&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(8)</title><link href="/zi-you-gong-zuo-8.html" rel="alternate"></link><published>2020-09-13T10:00:00+09:00</published><updated>2020-09-13T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-13:/zi-you-gong-zuo-8.html</id><summary type="html">&lt;ul class="simple"&gt;
&lt;li&gt;ステップサイズテーブルの再設計。256エントリでいいはず。8bitの領域を使い切るべき。
* インデックス更新テーブルの吟味(特に3bit)。&lt;/li&gt;
&lt;li&gt;LMSフィルタの吟味（プリエンファシスもやったところで再度SAを確かめてみたい。→かんたんにやってみたけど、低音圧でSA、高音圧でLMSの印象。一応SAにしておく。発散する場合がみられている。。。nibbleが2の補数になったらそれを残差として突っ込むという夢がある。）&lt;/li&gt;
&lt;li&gt;フォーマット再度策定。2,3,4bitの書き出し処理分割。&lt;/li&gt;
&lt;li&gt;nibble（出力コード）は2の補数でいい。符号+絶対値だとエンコードデコードが複雑になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここまでやってて色々弄ってたら、なーんか音質が悪化していることに気付く。デフォルトのADPCMの方がよくね？
耳で聞くよりはRMSでがっちり評価していきたい。&lt;/p&gt;
&lt;p&gt;プリエンファシスが悪そう。実装を整理してON/OFFできるようにして調査する。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;インデックス更新値を持ち越して次サンプルで使う手法、あんまり美味しくない。&lt;/li&gt;
&lt;li&gt;テーブルを256エントリに拡張したら、高音圧音源ではグッドだけど、低音圧音源でジャリジャリが目立つ。sin波で適応が遅い感じ。&lt;ul&gt;
&lt;li&gt;2bitだとどうしても適応が遅い印象。&lt;/li&gt;
&lt;li&gt;フィルタの学習も遅い印象も受ける。最初のブロックを何回か回して処理開始するとかどうでしょう。いいアイデアだけど、フィルタの状態をブロックヘッダに入れる実装がまだなので、それができてから。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さて、コーデックとして仕立てていくか。基本的なAPIはIMAADPCMと同じで良いとして、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;命名規則の変更: IMAADPCM -&amp;gt; AAD (Ayashi Adaptive Differential …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;ステップサイズテーブルの再設計。256エントリでいいはず。8bitの領域を使い切るべき。
* インデックス更新テーブルの吟味(特に3bit)。&lt;/li&gt;
&lt;li&gt;LMSフィルタの吟味（プリエンファシスもやったところで再度SAを確かめてみたい。→かんたんにやってみたけど、低音圧でSA、高音圧でLMSの印象。一応SAにしておく。発散する場合がみられている。。。nibbleが2の補数になったらそれを残差として突っ込むという夢がある。）&lt;/li&gt;
&lt;li&gt;フォーマット再度策定。2,3,4bitの書き出し処理分割。&lt;/li&gt;
&lt;li&gt;nibble（出力コード）は2の補数でいい。符号+絶対値だとエンコードデコードが複雑になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここまでやってて色々弄ってたら、なーんか音質が悪化していることに気付く。デフォルトのADPCMの方がよくね？
耳で聞くよりはRMSでがっちり評価していきたい。&lt;/p&gt;
&lt;p&gt;プリエンファシスが悪そう。実装を整理してON/OFFできるようにして調査する。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;インデックス更新値を持ち越して次サンプルで使う手法、あんまり美味しくない。&lt;/li&gt;
&lt;li&gt;テーブルを256エントリに拡張したら、高音圧音源ではグッドだけど、低音圧音源でジャリジャリが目立つ。sin波で適応が遅い感じ。&lt;ul&gt;
&lt;li&gt;2bitだとどうしても適応が遅い印象。&lt;/li&gt;
&lt;li&gt;フィルタの学習も遅い印象も受ける。最初のブロックを何回か回して処理開始するとかどうでしょう。いいアイデアだけど、フィルタの状態をブロックヘッダに入れる実装がまだなので、それができてから。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さて、コーデックとして仕立てていくか。基本的なAPIはIMAADPCMと同じで良いとして、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;命名規則の変更: IMAADPCM -&amp;gt; AAD (Ayashi Adaptive Differential pulse code modulation) 拡張子.aad&lt;/li&gt;
&lt;li&gt;フォーマット策定: ヘッダ, ブロックヘッダ, ブロック&lt;/li&gt;
&lt;li&gt;エンコードパラメータの整理&lt;/li&gt;
&lt;li&gt;プリエンファシス、デエンファシスをプロセッサハンドルを介してできるように。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(7)</title><link href="/zi-you-gong-zuo-7.html" rel="alternate"></link><published>2020-09-12T10:00:00+09:00</published><updated>2020-09-12T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-12:/zi-you-gong-zuo-7.html</id><summary type="html">&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.drdobbs.com/database/algorithm-alley/184410326"&gt;Inside IMA ADPCM&lt;/a&gt;  &lt;a class="reference external" href="http://orion.lcg.ufrj.br/Dr.Dobbs/books/book10/9711m/9711m.htm"&gt;こっちも同じ内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://multimedia.cx/simpleaudio.html#tth_sEc4.2"&gt;Simple Time Domain Audio Coding&lt;/a&gt; MediaWikiの前身となる資料。時間領域符号化の包括的なまとめでもある。有益そう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;強引に3,2bit化してみた。なんとなくできてしまっているが、2bitは流石にジリジリいう。
なんでかな、と思ったらステップサイズが4bitむけのものになっていて、テーブル参照インデックスが0でも7になってしまい、確実に揺れてしまうのが問題であると想像している。テーブル自作を試みているが、なかなかに苦戦。&lt;/p&gt;
&lt;p&gt;IMA-ADPCMのステップサイズが謎。どっから導出したんだろうか。
純粋な指数関数ではなさそう。とくに、最初の8要素は線形関数になってるのが奇特。（テーブルの情報量を増やしたいのかな？）しかし、後になると指数関数 &lt;span class="math"&gt;\(2^{\log_{2}(32767/7)/88 x + \log_{2}(7)}\)&lt;/span&gt; とほぼ一致。
自作のテーブルより、IMA-ADPCMのテーブルの方がいいRMSを出している。。。何故やろ・・・。&lt;/p&gt;
&lt;p&gt;テーブルは一旦諦めて、モデルの改善を考えたが、あんまり良くない。
フィルタ次数を8にしたり、IIR（予測値をフィードバック …&lt;/p&gt;</summary><content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.drdobbs.com/database/algorithm-alley/184410326"&gt;Inside IMA ADPCM&lt;/a&gt;  &lt;a class="reference external" href="http://orion.lcg.ufrj.br/Dr.Dobbs/books/book10/9711m/9711m.htm"&gt;こっちも同じ内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://multimedia.cx/simpleaudio.html#tth_sEc4.2"&gt;Simple Time Domain Audio Coding&lt;/a&gt; MediaWikiの前身となる資料。時間領域符号化の包括的なまとめでもある。有益そう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;強引に3,2bit化してみた。なんとなくできてしまっているが、2bitは流石にジリジリいう。
なんでかな、と思ったらステップサイズが4bitむけのものになっていて、テーブル参照インデックスが0でも7になってしまい、確実に揺れてしまうのが問題であると想像している。テーブル自作を試みているが、なかなかに苦戦。&lt;/p&gt;
&lt;p&gt;IMA-ADPCMのステップサイズが謎。どっから導出したんだろうか。
純粋な指数関数ではなさそう。とくに、最初の8要素は線形関数になってるのが奇特。（テーブルの情報量を増やしたいのかな？）しかし、後になると指数関数 &lt;span class="math"&gt;\(2^{\log_{2}(32767/7)/88 x + \log_{2}(7)}\)&lt;/span&gt; とほぼ一致。
自作のテーブルより、IMA-ADPCMのテーブルの方がいいRMSを出している。。。何故やろ・・・。&lt;/p&gt;
&lt;p&gt;テーブルは一旦諦めて、モデルの改善を考えたが、あんまり良くない。
フィルタ次数を8にしたり、IIR（予測値をフィードバック）したり。&lt;/p&gt;
&lt;p&gt;効果があったのが3つ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ノイズシェーピング。残差を量子化するからその量子化誤差を1/16を掛けてフィードバックする（大きすぎると発散する）。残差わずかに減少。&lt;/li&gt;
&lt;li&gt;LR-&amp;gt;MS。ステレオ音源で残差減少。注意点としては、16bit幅を超えるからやるならPCMを32bit幅で持つべき。いまは破壊的な処理をしてる。&lt;/li&gt;
&lt;li&gt;プリエンファシス。1サンプルエンコード/デコード処理でやりたいが、そうなってない（汚い実装になってる）。一回RMS減ったのは見たけど、本当かもう一度確かめたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらはスイッチできるといいなあ。
2bitとなると音質クッソ厳しい（りんごの木、Mani Mani等音圧変化の激しい曲はかなりきびしい。声のみだけだったらいける。）けど、ここらで独立させてみるか。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(6)</title><link href="/zi-you-gong-zuo-6.html" rel="alternate"></link><published>2020-09-11T10:00:00+09:00</published><updated>2020-09-11T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-11:/zi-you-gong-zuo-6.html</id><content type="html">&lt;p&gt;群論再開させつつ。&lt;/p&gt;
&lt;p&gt;mac update以降、コンパイル警告がうざったくてしょうがなくなっていた。どうやら /usr/include が消えたようで…&lt;/p&gt;
&lt;p&gt;export SDKROOT=&amp;quot;$(xcrun --sdk macosx --show-sdk-path)&amp;quot;&lt;/p&gt;
&lt;p&gt;で黙らせている。&lt;/p&gt;
&lt;p&gt;4次の適応フィルタを予測に突っ込んでみた。平均的な平均絶対値誤差は前値予測よりもガッツリ減っているが、音質はあんまり替わってない印象。
カレンダーガールを突っ込んだら高域（20k〜）にガッツリノイズがついた。ナイキストレートの早さでノイスがのってる。
48k音源ではどうも共通して現れる特徴のようだ。&lt;/p&gt;
&lt;p&gt;音質は、原音と変わんねえだろと思い続けている。ここがおかしいというのを具体的に指摘できないでいる。スペクトログラムを見て初めて分かる感じ。&lt;/p&gt;
&lt;p&gt;ビット数減らしに行くのがよさそう。試すのであれば、残差は4bitで書き出すけど、内容は3bitまでしか持たないようにするという方策。
3,2bitに応じたテーブル作成が熱い。&lt;/p&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(5)</title><link href="/zi-you-gong-zuo-5.html" rel="alternate"></link><published>2020-09-10T10:00:00+09:00</published><updated>2020-09-10T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-10:/zi-you-gong-zuo-5.html</id><content type="html">&lt;p&gt;ノイズ（差分の量子化誤差）はまさにi.i.d.なラプラスからサンプリングした感じ。全帯域にある。
人間の声のところは調波構造があるけど、それ以外、ピッチのない楽器などは単純な白色雑音といった印象。&lt;/p&gt;
&lt;p&gt;ノイズシェーピングを試しているが…本当にいいのか疑問。
プリエンファシスみたく直前サンプルで引くと、たしかにノイズの低域は消える、けど高域はそのままだし、
ノイズのRMSはむしろ悪化している状態。
逆に直前サンプルで足すとノイズ高域は消えるけど、低域が残ってｺﾞｰという感じのノイズになる。目立つ。うーん。&lt;/p&gt;
&lt;p&gt;ノイズシェーピングの基本は、ノイズ帯域を&amp;quot;おいやる&amp;quot;ことにあるようで、その後になにかしないとうまみがない？
（低域のノイズを消してノイズを高域に追いやってからローパスをかけるかんじ。）&lt;/p&gt;
&lt;p&gt;適応フィルタチックなことも試してみたが、不安定になりがち。
残差の符号だけ使い、ステップサイズをクソ小さくしてなんとか安定するが、ノイズのRMSは何もしないものから悪化。&lt;/p&gt;
&lt;p&gt;一旦ノイズシェーピングなしのやつをアップする。
自己流のやつを試してみたい気持ちがある。&lt;/p&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(4)</title><link href="/zi-you-gong-zuo-4.html" rel="alternate"></link><published>2020-09-09T10:00:00+09:00</published><updated>2020-09-09T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-09:/zi-you-gong-zuo-4.html</id><content type="html">&lt;p&gt;エンコードもできた印象。まずは、量子化誤差の観察を開始している。
ラプラス分布っぽいので頻度を出してみる。→すごいラプラスだった。&lt;/p&gt;
&lt;p&gt;gnuplotで頻度を出すには以下で行ける。素晴らしい。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;::&lt;/dt&gt;
&lt;dd&gt;plot &amp;quot;foo.txt&amp;quot; u 1 smooth frequency with boxes
plot &amp;quot;foo.txt&amp;quot; u 1 smooth frequency with lines&lt;/dd&gt;
&lt;/dl&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(3)</title><link href="/zi-you-gong-zuo-3.html" rel="alternate"></link><published>2020-09-07T10:00:00+09:00</published><updated>2020-09-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-07:/zi-you-gong-zuo-3.html</id><summary type="html">&lt;p&gt;しばらく夏休みしてた。作業再開。エンコード作成中。
ADPCMの音質改善にはノイズシェーピング（量子化ノイズ）をへらすのが有効らしい。特許に注意だけど切れてそう。&lt;/p&gt;
&lt;p&gt;休んでいる間に色々リンク見つけたからまとめてからねる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/dbry/adpcm-xq"&gt;adpcm-xq&lt;/a&gt; WavPackの人のADPCM(IMA)の改良エンコーダ。いいアイデアが2つ。ノイズシェーピングと先読みエンコード。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://sericyb.com.au/audio.html"&gt;A comparison of Internet audio compression formats&lt;/a&gt; 音質比較&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://hydrogenaud.io/index.php?topic=109270.0"&gt;What quality measurement is best for (A)DPCM?&lt;/a&gt; ADPCMの評価指標について&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.kumikomi.net/archives/2010/07/ep22onse.php?page=5"&gt;G.726 ADPCMエンコーダの詳細&lt;/a&gt; 本と同じ内容だけど、こっちはいつでも見れる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/isciesci/61/2/61_76/_pdf/-char/en"&gt;信号品質を保つディジタル化技術: ノイズシェーピング量子化—I&lt;/a&gt; ノイズシェーピングの基礎。Ⅵまである。丁寧。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://kamedo2.hatenablog.jp/entry/20100812/1281640220"&gt;ADPCM音質改善&lt;/a&gt; 重要。ノイズシェーピングの効果について書いてある …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;しばらく夏休みしてた。作業再開。エンコード作成中。
ADPCMの音質改善にはノイズシェーピング（量子化ノイズ）をへらすのが有効らしい。特許に注意だけど切れてそう。&lt;/p&gt;
&lt;p&gt;休んでいる間に色々リンク見つけたからまとめてからねる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/dbry/adpcm-xq"&gt;adpcm-xq&lt;/a&gt; WavPackの人のADPCM(IMA)の改良エンコーダ。いいアイデアが2つ。ノイズシェーピングと先読みエンコード。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://sericyb.com.au/audio.html"&gt;A comparison of Internet audio compression formats&lt;/a&gt; 音質比較&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://hydrogenaud.io/index.php?topic=109270.0"&gt;What quality measurement is best for (A)DPCM?&lt;/a&gt; ADPCMの評価指標について&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.kumikomi.net/archives/2010/07/ep22onse.php?page=5"&gt;G.726 ADPCMエンコーダの詳細&lt;/a&gt; 本と同じ内容だけど、こっちはいつでも見れる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/isciesci/61/2/61_76/_pdf/-char/en"&gt;信号品質を保つディジタル化技術: ノイズシェーピング量子化—I&lt;/a&gt; ノイズシェーピングの基礎。Ⅵまである。丁寧。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://kamedo2.hatenablog.jp/entry/20100812/1281640220"&gt;ADPCM音質改善&lt;/a&gt; 重要。ノイズシェーピングの効果について書いてある。ソースもある。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.a-r-tec.jp/DSADC2.pdf"&gt;ADCの動作原理&lt;/a&gt; ADCとノイズシェーピングの必要性がわかりやすく書いてある。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://kobaweb.ei.st.gunma-u.ac.jp/lecture/DSM_San_2008_pt02[1].pdf"&gt;AD変調器(2)&lt;/a&gt; こちらもADCとノイズシェーピングについて記述有り。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://graphics.stanford.edu/~seander/bithacks.html"&gt;Bit Twiddling Hacks&lt;/a&gt; Hacker's Delightに掲載されてないのもある。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(2)</title><link href="/zi-you-gong-zuo-2.html" rel="alternate"></link><published>2020-08-31T10:00:00+09:00</published><updated>2020-08-31T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-08-31:/zi-you-gong-zuo-2.html</id><summary type="html">&lt;p&gt;ADPCMのデコードはほぼできた。次はエンコード。&lt;/p&gt;
&lt;p&gt;いろんなソース見とるが、予測時に分岐しまくるのやばくね？とおもってたらそのとおりで、ffmpeg実装は乗算を使ってる:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ffmpeg.org/doxygen/trunk/adpcm_8c_source.html"&gt;ffmpegの実装（adpcm_ima_expand_nibble）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ffmpeg.org/doxygen/trunk/adpcmenc_8c_source.html"&gt;ffmpegのエンコーダ実装(adpcm_ima_compress_sample)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="nf"&gt;adpcm_ima_expand_nibble&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ADPCMChannelStatus&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int8_t&lt;/span&gt; &lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;shift&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;predictor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;delta&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;step&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ff_adpcm_step_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;step_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ff_adpcm_index_table&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;step_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;av_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;88&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;sign&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nibble&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;delta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nibble&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;7 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;ADPCMのデコードはほぼできた。次はエンコード。&lt;/p&gt;
&lt;p&gt;いろんなソース見とるが、予測時に分岐しまくるのやばくね？とおもってたらそのとおりで、ffmpeg実装は乗算を使ってる:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ffmpeg.org/doxygen/trunk/adpcm_8c_source.html"&gt;ffmpegの実装（adpcm_ima_expand_nibble）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ffmpeg.org/doxygen/trunk/adpcmenc_8c_source.html"&gt;ffmpegのエンコーダ実装(adpcm_ima_compress_sample)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="nf"&gt;adpcm_ima_expand_nibble&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ADPCMChannelStatus&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int8_t&lt;/span&gt; &lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;shift&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;predictor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;delta&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;step&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ff_adpcm_step_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;step_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ff_adpcm_index_table&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;step_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;av_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;88&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;sign&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nibble&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;delta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nibble&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="cm"&gt;/* perform direct multiplication instead of series of jumps proposed by&lt;/span&gt;
&lt;span class="cm"&gt;     * the reference ADPCM implementation since modern CPUs can do the mults&lt;/span&gt;
&lt;span class="cm"&gt;     * quickly enough */&lt;/span&gt;
    &lt;span class="n"&gt;diff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;delta&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;shift&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;predictor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;predictor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;predictor&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;predictor&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;predictor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;av_clip_int16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predictor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int16_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;predictor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="nf"&gt;adpcm_ima_compress_sample&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ADPCMChannelStatus&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                                &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;sample&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;delta&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sample&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev_sample&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;nibble&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FFMIN&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delta&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;
                       &lt;span class="n"&gt;ff_adpcm_step_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delta&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev_sample&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;ff_adpcm_step_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
                        &lt;span class="n"&gt;ff_adpcm_yamaha_difflookup&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev_sample&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;av_clip_int16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev_sample&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;av_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ff_adpcm_index_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;88&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;nibbleってなんだよ・・・って思って調べたら1/2バイト(4bit)のことだった。&lt;/p&gt;
&lt;p&gt;デコーダ作って安定させてたら、AudacityとffmpegのADPCM(IMA)のデコード結果が違うことに気付く。
原因は、Audacityを始めとした多くのコーデックでは分岐が多い近似実装になっているからだった。 &lt;a class="reference external" href="http://web.mit.edu/ghudson/dev/nokrb/third/audiofile/libaudiofile/modules/adpcm.c"&gt;こいつ&lt;/a&gt; が原因か。
一方、ffmpegは近頃のCPUは十分乗算が早いからと言う理由で厳密計算している。ということで自分も厳密計算を選ぶ。&lt;/p&gt;
&lt;p&gt;もう一点、AudacityにADPCM(IMA)を突っ込むと末尾が伸びてしまう。これは末尾のブロックも同一サンプル数でデコードしているから…。
あきらかな不具合。PR送るか、送らざるべきか…。&lt;/p&gt;
&lt;p&gt;Audacityは内部でlibsndfileを使ってるから、 &lt;a class="reference external" href="https://github.com/erikd/libsndfile/blob/master/src/ima_adpcm.c"&gt;こっち&lt;/a&gt; にPRを送るべき。&lt;/p&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(1)</title><link href="/zi-you-gong-zuo-1.html" rel="alternate"></link><published>2020-08-29T10:00:00+09:00</published><updated>2020-08-29T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-08-29:/zi-you-gong-zuo-1.html</id><summary type="html">&lt;p&gt;まずはIMA-ADPCM互換のデコーダ/エンコーダを作ってみますかね。かなり情報あるし。
FFMPEGで出力する方法は:&lt;/p&gt;
&lt;p&gt;ffmpeg -i &amp;lt;input.wav&amp;gt; -f wav -acodec adpcm_ima_wav &amp;lt;output.wav&amp;gt;&lt;/p&gt;
&lt;p&gt;Macで再生もできた。ほぼ1/4になる。理論的には1/4だけどwavに余計なチャンクが入っているから減っている？&lt;/p&gt;
&lt;p&gt;ステレオ以上はどうなってるのか見ている。インターリーブしているようだ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.multimedia.cx/index.php?title=Microsoft_IMA_ADPCM"&gt;Microsoft IMA ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記のサイト含めてフォーマットをまとめると（ &lt;strong&gt;全て&lt;/strong&gt; リトルエンディアン）&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="25%" /&gt;
&lt;col width="12%" /&gt;
&lt;col width="63%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;名前&lt;/th&gt;
&lt;th class="head"&gt;サイズ[byte]&lt;/th&gt;
&lt;th class="head"&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;RIFFチャンクID&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'R', 'I', 'F', 'F'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;RIFFチャンクサイズ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;ファイルサイズ - 8（これ以降の残りファイルサイズ）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ファイルフォーマットタイプ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'W', 'A', 'V', 'E'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;FMTチャンクID&lt;/td&gt;
&lt;td&gt;4 …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</summary><content type="html">&lt;p&gt;まずはIMA-ADPCM互換のデコーダ/エンコーダを作ってみますかね。かなり情報あるし。
FFMPEGで出力する方法は:&lt;/p&gt;
&lt;p&gt;ffmpeg -i &amp;lt;input.wav&amp;gt; -f wav -acodec adpcm_ima_wav &amp;lt;output.wav&amp;gt;&lt;/p&gt;
&lt;p&gt;Macで再生もできた。ほぼ1/4になる。理論的には1/4だけどwavに余計なチャンクが入っているから減っている？&lt;/p&gt;
&lt;p&gt;ステレオ以上はどうなってるのか見ている。インターリーブしているようだ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.multimedia.cx/index.php?title=Microsoft_IMA_ADPCM"&gt;Microsoft IMA ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記のサイト含めてフォーマットをまとめると（ &lt;strong&gt;全て&lt;/strong&gt; リトルエンディアン）&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="25%" /&gt;
&lt;col width="12%" /&gt;
&lt;col width="63%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;名前&lt;/th&gt;
&lt;th class="head"&gt;サイズ[byte]&lt;/th&gt;
&lt;th class="head"&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;RIFFチャンクID&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'R', 'I', 'F', 'F'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;RIFFチャンクサイズ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;ファイルサイズ - 8（これ以降の残りファイルサイズ）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ファイルフォーマットタイプ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'W', 'A', 'V', 'E'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;FMTチャンクID&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'f', 'm', 't', ' '&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;FMTチャンクサイズ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;これ以降のFMTフィールドのサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;WAVEフォーマットタイプ&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;IMA-ADPCMなら17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;チャンネル数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;IMA-ADPCMの場合は1（モノラル）か2（ステレオ）しかないっぽい&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプリングレート&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;データ速度（byte/sec）&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;= ブロックサイズ * サンプリングレート / ブロックあたりサンプル数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックサイズ&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;ブロックのヘッダと圧縮済みデータを含めたサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプルあたりビット数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;IMA-ADPCMなら4のはず&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;エキストラサイズ&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;これ以降に続く追加データサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックあたりサンプル数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;FACTチャンクID&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'f', 'a', 'c', 't'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;FACTチャンクサイズ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;これ以降のFACTチャンクサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプル数&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;= DATAチャンクサイズ * ブロックあたりサンプル数 / ブロックサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DATAチャンクID&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'d', 'a', 't', 'a'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DATAチャンクサイズ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;これ以降のDATAチャンクサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;圧縮済みデータ&lt;/td&gt;
&lt;td&gt;※&lt;/td&gt;
&lt;td&gt;※ = DATAチャンクサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作</title><link href="/zi-you-gong-zuo.html" rel="alternate"></link><published>2020-08-28T10:00:00+09:00</published><updated>2020-08-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-08-28:/zi-you-gong-zuo.html</id><summary type="html">&lt;p&gt;発表会終わり。発表準備と並行して群論やってた。
夏休みは自由工作（息抜き）としてADPCMエンコーダデコーダ作ろうかと思ってる。
もちろん、群論（リー群まで）と情報幾何（統計的応用まで、行間のまとめ）は進める。&lt;/p&gt;
&lt;p&gt;ADPCMのフォーマットを見ている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://forum.audacityteam.org/viewtopic.php?t=10950"&gt;IMA ADPCM vs MS ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.multimedia.cx/index.php/Microsoft_ADPCM"&gt;Microsoft ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.multimedia.cx/index.php/IMA_ADPCM"&gt;IMA ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.multimedia.cx/index.php/CRI_ADX_ADPCM"&gt;CRI ADX ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.columbia.edu/~hgs/audio/dvi/IMA_ADPCM.pdf"&gt;Recommended Practices for Enhancing Digital Audio Compatibility in Multimedia Systems&lt;/a&gt; IMA公式の推奨規格。実装も掲載されてて有益。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MS-ADPCMかIMA-ADPCMやなあ。IMA-ADPCMの方が説明が充実している。
そして、なんとなくステップ幅をテーブル引きするところにTAKとの類似点を感じる。
G.726もありだがテーブル引きを使ってない。説明は「音声&amp;amp;画像処理の常識」に書いてある。&lt;/p&gt;
&lt;p&gt;研究としてはグラフィカルLASSOの導入忘れずに。もう一度張っとく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ide-research.net/papers/2016_Iwanami_Ide.pdf"&gt;依存関係にスハ …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;発表会終わり。発表準備と並行して群論やってた。
夏休みは自由工作（息抜き）としてADPCMエンコーダデコーダ作ろうかと思ってる。
もちろん、群論（リー群まで）と情報幾何（統計的応用まで、行間のまとめ）は進める。&lt;/p&gt;
&lt;p&gt;ADPCMのフォーマットを見ている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://forum.audacityteam.org/viewtopic.php?t=10950"&gt;IMA ADPCM vs MS ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.multimedia.cx/index.php/Microsoft_ADPCM"&gt;Microsoft ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.multimedia.cx/index.php/IMA_ADPCM"&gt;IMA ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.multimedia.cx/index.php/CRI_ADX_ADPCM"&gt;CRI ADX ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.columbia.edu/~hgs/audio/dvi/IMA_ADPCM.pdf"&gt;Recommended Practices for Enhancing Digital Audio Compatibility in Multimedia Systems&lt;/a&gt; IMA公式の推奨規格。実装も掲載されてて有益。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MS-ADPCMかIMA-ADPCMやなあ。IMA-ADPCMの方が説明が充実している。
そして、なんとなくステップ幅をテーブル引きするところにTAKとの類似点を感じる。
G.726もありだがテーブル引きを使ってない。説明は「音声&amp;amp;画像処理の常識」に書いてある。&lt;/p&gt;
&lt;p&gt;研究としてはグラフィカルLASSOの導入忘れずに。もう一度張っとく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ide-research.net/papers/2016_Iwanami_Ide.pdf"&gt;依存関係にスパース性を入れる — グラフィカル lasso の話&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>研究会に向けて - 執筆(5)</title><link href="/yan-jiu-hui-nixiang-kete-zhi-bi-5.html" rel="alternate"></link><published>2020-08-03T10:00:00+09:00</published><updated>2020-08-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-08-03:/yan-jiu-hui-nixiang-kete-zhi-bi-5.html</id><content type="html">&lt;p&gt;自己相関行列の逆の推定、グラフィカルLASSOが有効ではというありがたい指摘あり。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ide-research.net/papers/2016_Iwanami_Ide.pdf"&gt;依存関係にスパース性を入れる — グラフィカル lasso の話&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他にも精度行列の推定を（スパース制約を入れて）高速にやるみたいな話がたくさん出てきている。参考にすべし。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>IGおべんきょ(4)</title><link href="/igobenkiyo4.html" rel="alternate"></link><published>2020-08-01T10:00:00+09:00</published><updated>2020-08-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-08-01:/igobenkiyo4.html</id><summary type="html">&lt;p&gt;しばらくIGをおべんきょしてた。行間メモは公開していきたい。
で、いまはChentsovの定理で絶賛ハマってる。(0,4)-テンソル場で定数倍にならない理由って何よ。&lt;/p&gt;
&lt;p&gt;証明の1ステップと言ったらラベルに対する付替えで、
4次元以上で起こる特殊なこと…を調べていて、群論が関わってくるのでは。と。
ラベルの付替えは対称群に相当するはず。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://orz107orz.hatenablog.com/entry/20140218/1392724434"&gt;交代群が非可換になること&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.tsuyama-ct.ac.jp/matsuda/eBooks/galios.pdf"&gt;ガロア理論を理解しよう&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;でももっと単純に考えるべきかも。 &lt;span class="math"&gt;\(F\)&lt;/span&gt; は当然計算できる上で、 &lt;span class="math"&gt;\(\~{F}\)&lt;/span&gt; も不変性の要求を満たす。
でも &lt;span class="math"&gt;\(\~{F}\)&lt;/span&gt; は &lt;span class="math"&gt;\(F\)&lt;/span&gt; の定数倍にならない、みたいな論法。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768 …&lt;/script&gt;</summary><content type="html">&lt;p&gt;しばらくIGをおべんきょしてた。行間メモは公開していきたい。
で、いまはChentsovの定理で絶賛ハマってる。(0,4)-テンソル場で定数倍にならない理由って何よ。&lt;/p&gt;
&lt;p&gt;証明の1ステップと言ったらラベルに対する付替えで、
4次元以上で起こる特殊なこと…を調べていて、群論が関わってくるのでは。と。
ラベルの付替えは対称群に相当するはず。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://orz107orz.hatenablog.com/entry/20140218/1392724434"&gt;交代群が非可換になること&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.tsuyama-ct.ac.jp/matsuda/eBooks/galios.pdf"&gt;ガロア理論を理解しよう&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;でももっと単純に考えるべきかも。 &lt;span class="math"&gt;\(F\)&lt;/span&gt; は当然計算できる上で、 &lt;span class="math"&gt;\(\~{F}\)&lt;/span&gt; も不変性の要求を満たす。
でも &lt;span class="math"&gt;\(\~{F}\)&lt;/span&gt; は &lt;span class="math"&gt;\(F\)&lt;/span&gt; の定数倍にならない、みたいな論法。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="IG"></category></entry><entry><title>IGおべんきょ(3)</title><link href="/igobenkiyo3.html" rel="alternate"></link><published>2020-07-30T10:00:00+09:00</published><updated>2020-07-30T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-30:/igobenkiyo3.html</id><content type="html">&lt;p&gt;IGがだいぶ止まってたので、レビューが帰るまでのあいだ進める。
今日の合言葉：写像の微分は接ベクトルの写像。&lt;/p&gt;
</content><category term="雑記"></category><category term="IG"></category></entry><entry><title>研究会に向けて - 執筆(4)</title><link href="/yan-jiu-hui-nixiang-kete-zhi-bi-4.html" rel="alternate"></link><published>2020-07-28T11:00:00+09:00</published><updated>2020-07-28T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-28:/yan-jiu-hui-nixiang-kete-zhi-bi-4.html</id><content type="html">&lt;p&gt;引き続き執筆。今日あたりであらすじ書いてレビュー予定。&lt;/p&gt;
&lt;p&gt;思ったのが、先にデータの自己相関行列の逆を計算して勾配計算用のデータを用意しちゃう発想はどうよ？という点。
もしくは、自己相関（の偏り）を打ち消すようなフィルタを先にかけてからフィルタ処理をおこなうのはどうか？演算誤差が気になるけど、ありえる発想。
これはもしかしたらプリエンファシスの一般化かもしれない。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて - 執筆(3)</title><link href="/yan-jiu-hui-nixiang-kete-zhi-bi-3.html" rel="alternate"></link><published>2020-07-26T11:00:00+09:00</published><updated>2020-07-26T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-26:/yan-jiu-hui-nixiang-kete-zhi-bi-3.html</id><content type="html">&lt;p&gt;土日は黙々と執筆してた。
1点気になったのが、自然勾配法を共役勾配法的にやれないかというところ。そうすれば逆行列を計算しなくて済む。
ここらへん誰かやってないのかな？誰でも思いつくと思うけど。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://edisciplinas.usp.br/pluginfile.php/227194/mod_resource/content/1/Nascimento_Silva_2014_Adaptive_Filters.pdf"&gt;Adaptive Filters&lt;/a&gt; 適応フィルタの新しい良さげなまとめ。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて - 執筆(2)</title><link href="/yan-jiu-hui-nixiang-kete-zhi-bi-2.html" rel="alternate"></link><published>2020-07-24T11:00:00+09:00</published><updated>2020-07-24T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-24:/yan-jiu-hui-nixiang-kete-zhi-bi-2.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\inprod[2]{\langle #1,\ #2 \rangle}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;うーん、SAの原典を探ってるときに&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://read.pudn.com/downloads125/ebook/529634/Adaptive_Filtering_-_Algorithms_and_Practical_Implementation.pdf"&gt;Adaptive Filtering: Algorithms and Practical Implementation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が参照されてて、その中で&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www02.smt.ufrj.br/~diniz/conf/confi12.pdf"&gt;Performance of LMS-Newton Adaptation Algorithms With Variable Convergence Factor in Nonstationary Environments&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が参照されてたけど、全く同じやん…&lt;/p&gt;
&lt;p&gt;どうも、Winner解を求める最適化問題のニュートン法を求めると、自己相関行列の逆が自然に出てくるみたい。そして、その適応ステップ版アルゴリズム（LMS Newton Algorithm, 初出はAdaptive Signal …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\inprod[2]{\langle #1,\ #2 \rangle}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;うーん、SAの原典を探ってるときに&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://read.pudn.com/downloads125/ebook/529634/Adaptive_Filtering_-_Algorithms_and_Practical_Implementation.pdf"&gt;Adaptive Filtering: Algorithms and Practical Implementation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が参照されてて、その中で&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www02.smt.ufrj.br/~diniz/conf/confi12.pdf"&gt;Performance of LMS-Newton Adaptation Algorithms With Variable Convergence Factor in Nonstationary Environments&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が参照されてたけど、全く同じやん…&lt;/p&gt;
&lt;p&gt;どうも、Winner解を求める最適化問題のニュートン法を求めると、自己相関行列の逆が自然に出てくるみたい。そして、その適応ステップ版アルゴリズム（LMS Newton Algorithm, 初出はAdaptive Signal Processing(Widrow)）は上記論文と完全に同一。&lt;/p&gt;
&lt;p&gt;LMS Newton Algorithmは、Adaptive Signal Processingのp142あたり（Chapter8冒頭）が詳しいが、残差の二乗を目的関数（Adaptive Filter Theory p105 2.38, 2.50に注目）としたときのニュートン法を近似して得られる。導出にあたり勾配を近似（確率降下）することでNewton法が成立している。&lt;/p&gt;
&lt;p&gt;適応ステップサイズの設定法には他にもある。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/ieejeiss1987/119/8-9/119_8-9_1027/_pdf/-char/ja"&gt;準最適ステップゲインを用いたBlock LMS-Newtonアルゴリズム&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;これはLMS Newton Algorithmに関する話だけど、ここで提案されているやり方をSAに持っていけないか？→ブロック単位で更新しているから話が違う？いや、もうちょっと読み込もう。&lt;ul&gt;
&lt;li&gt;この論文で可変ステップサイズに関する議論が出てきている。最適係数から垂線を下ろしたところでステップサイズを決めるという方針。それにしたがってNGSAにおいても最適なステップサイズを求めたら今までのNNGSAと同一の結果が出た。&lt;/li&gt;
&lt;li&gt;勾配 &lt;span class="math"&gt;\(\ve{g}[n] = \mathrm{sgn}(\varepsilon[n])\ve{x}[n]\)&lt;/span&gt; に対して &lt;span class="math"&gt;\(\inprod{\ve{R}^{-1}\ve{g}[n]}{\ve{h}_{\rm opt} - (\ve{h}[n] + \mu[n] \ve{R}^{-1} \ve{g}[n])}_{\ve{R}} = 0\)&lt;/span&gt; を満たす &lt;span class="math"&gt;\(\mu[n]\)&lt;/span&gt; こそ、勾配のなす方向に対して &lt;span class="math"&gt;\(\ve{h}_{\rm opt}\)&lt;/span&gt; から垂線を降ろせているから最適になる。直交条件を展開すると、 &lt;span class="math"&gt;\(\ve{g}[n]^{\mathsf{T}} \ve{R}^{-1} \ve{R} (\ve{h}_{opt} - \ve{h}[n]) - \mu[n] \ve{g}[n]^{\mathsf{T}} \ve{R}^{-1} \ve{R} \ve{R}^{-1} \ve{g}[n] = 0\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(\ve{g}[n] = \mathrm{sgn}(\varepsilon[n])\ve{x}[n]\)&lt;/span&gt; を突っ込むと &lt;span class="math"&gt;\(\mathrm{sgn}(\varepsilon[n]) \ve{x}[n]^{\mathsf{T}} (\ve{h}_{\rm opt} - \ve{h}[n]) - \mu[n] \ve{x}[n]^{\mathsf{T}} \ve{R}^{-1} \ve{x}[n] = \mathrm{sgn}(\varepsilon[n]) \varepsilon[n] + \mathrm{sgn}(\varepsilon[n]) v[n] - \mu[n] \ve{x}[n]^{\mathsf{T}} \ve{R}^{-1} \ve{x}[n] = 0\)&lt;/span&gt; より、&lt;span class="math"&gt;\(v[n]=0\)&lt;/span&gt; ならばいつものステップサイズが出てくる。論文間違ってると思う。。。&lt;/li&gt;
&lt;li&gt;つまり、NNGSAはその意味でも最適。追記すべきかも。しかし、勾配 &lt;span class="math"&gt;\(\ve{g}[n]\)&lt;/span&gt; がLMSのときとの差異が気になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有益そうなのは、ブロックあたり1回だけ逆行列補題を使うだけでもよいという主張（問題ないことを示している）。つまり自己相関行列の更新を間引く。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.academia.edu/14148013/Performance_of_LMS-Newton_adaptation_algorithms_with_variable_convergence_factor_in_nonstationary_environments"&gt;Analysis of LMS-Newton Adaptive Filtering Algorithms with Variable Convergence Factor&lt;/a&gt; Academaから落とした。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Newton LMS AlgorithmはRLSと等価。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.academia.edu/17820650/Optimal_variable_step_size_for_the_LMS_Newton_algorithm_with_application_to_subband_adaptive_filtering?auto=download"&gt;Optimal variable step size for the LMS/Newton algorithm with application to subband adaptive filtering&lt;/a&gt; これもAcademiaから&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;でも、NNGSAまで至らないと上記の一致は指摘できない。また、こっちはFisher情報行列ベースで話を進めているから、射影の足がKLダイバージェンスに一致することを議論できる。&lt;/p&gt;
&lt;p&gt;あ、でもNGSAは残差のsgnとってるだけだから、LMS Newton Algorithmのステップサイズを荒く量子化したやつに対応するのか。いや、それでも、ラプラス分布仮定時に最急勾配になってるはずなんや。最適値近傍で頑張って0に近づけるし、しかも遠いときはゆっくり近づいてロングテールな分布を作っているんや。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://core.ac.uk/download/pdf/52288867.pdf"&gt;Adaptive filters: stable but divergent&lt;/a&gt; なんか適応フィルタのまとめ。時間があれば。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SAの収束性能解析論文がヒットし始めた&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Adaptive Filtering with Binary Reinforcement とても重要な論文。SAの限界について基本的な定理が述べられている。そして、SAはLMSより遅いという指摘あり。これが欲しかった。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/fe70/e6867138651ac95130ec53cebc2ba8b7ecab.pdf?_ga=2.105956032.2125347977.1595579214-2033161310.1595579214"&gt;CONVERGENCE ANALYSIS OF THE SIGN ALGORITHM FOR ADAPTIVE FILTERING&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて - 執筆(1)</title><link href="/yan-jiu-hui-nixiang-kete-zhi-bi-1.html" rel="alternate"></link><published>2020-07-22T11:00:00+09:00</published><updated>2020-07-22T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-22:/yan-jiu-hui-nixiang-kete-zhi-bi-1.html</id><summary type="html">&lt;p&gt;今日から執筆していく。目標、7/27に第一般。&lt;/p&gt;
&lt;p&gt;しかしまだ書き始めず、プロットを練る。プロットの構成はだいたい発表とおんなじだが、
イントロをしっかり書きたいから、既存のロスレス音声の論文の構成を参考にしていく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.tut.fi/~tabus/2013GhidoTabus.pdf"&gt;Sparse modeling for lossless audio compression&lt;/a&gt; OptimFROGのひと。&lt;ul&gt;
&lt;li&gt;オーディオ環境は高級化している。その中でロスレス圧縮は現実的である。プレーヤが使うから、デコーダは高速実装できるべきだ。今現在使われているいろんなコーデックがある。MP4-ALS, WMAL, ALAC, Monkey's Audio, FLAC, OptimFROG等。それぞれ異なる予測モデルと圧縮アルゴリズムを使用している。圧縮率、エンコード速度、デコード速度の3つの評価軸があるが、全てを最大にすることはできず、トレードオフの関係にある。例えば、予測次数を最大にすれば圧縮率は向上するが、エンコード/デコード速度が悪化する。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://decoy.iki.fi/dsound/ambisonic/motherlode/source/01215233.pdf"&gt;An Introduction to Super Audio CD and DVD-Audio&lt;/a&gt; Super Audio CD(SACD …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;今日から執筆していく。目標、7/27に第一般。&lt;/p&gt;
&lt;p&gt;しかしまだ書き始めず、プロットを練る。プロットの構成はだいたい発表とおんなじだが、
イントロをしっかり書きたいから、既存のロスレス音声の論文の構成を参考にしていく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.tut.fi/~tabus/2013GhidoTabus.pdf"&gt;Sparse modeling for lossless audio compression&lt;/a&gt; OptimFROGのひと。&lt;ul&gt;
&lt;li&gt;オーディオ環境は高級化している。その中でロスレス圧縮は現実的である。プレーヤが使うから、デコーダは高速実装できるべきだ。今現在使われているいろんなコーデックがある。MP4-ALS, WMAL, ALAC, Monkey's Audio, FLAC, OptimFROG等。それぞれ異なる予測モデルと圧縮アルゴリズムを使用している。圧縮率、エンコード速度、デコード速度の3つの評価軸があるが、全てを最大にすることはできず、トレードオフの関係にある。例えば、予測次数を最大にすれば圧縮率は向上するが、エンコード/デコード速度が悪化する。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://decoy.iki.fi/dsound/ambisonic/motherlode/source/01215233.pdf"&gt;An Introduction to Super Audio CD and DVD-Audio&lt;/a&gt; Super Audio CD(SACD)なんてあったのか…すでに死んでるが…。OptimFROGでは高級なオーディオの規格として挙げていた。&lt;/li&gt;
&lt;li&gt;A hierarchical lossless/lossy coding system for high quality audio up to 192 kHz sampling 24 bit format: 公開されてない...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.kecl.ntt.co.jp/people/harada.noboru/doc/thesis_noboru_harada_201630173_final.pdf"&gt;Lossless Compression of Speech and Audio Signals, and Its Application&lt;/a&gt; NTTの原田さんの博論。成果は符号化メイン。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://mi.eng.cam.ac.uk/reports/svr-ftp/auto-pdf/robinson_tr156.pdf"&gt;SHORTEN: Simple lossless and near-lossless waveform compression&lt;/a&gt; シンプルで宜しい。うざったるい背景描写ほとんどなし。&lt;ul&gt;
&lt;li&gt;デジタル化した音声ファイルをそのまま保存するとかなりの容量を食う。ZIP等の一般的な圧縮アルゴリズムは、音声の特徴を捉えていないからうまく圧縮できない。一般的な音声データは16bitで、サンプル間に相関がある。これらのファイルに対する圧縮ユーティリティは高速で、移植性があり、多くのデータを処理可能で素晴らしい圧縮率を達成する必要がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jas-audio.or.jp/jas_cms/wp-content/uploads/2017/03/201703_027-033.pdf"&gt;国際標準 MPEG-4 ALS による ハイレゾ音源ロスレス伝送&lt;/a&gt; MPEG4-ALSの分かりやすい説明。飾り言葉がおおいので注意。（「コト」や「モノ」の下りは使えない）&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://elvera.nue.tu-berlin.de/files/1216Liebchen2009.pdf"&gt;MPEG­4 ALS – The Standard for Lossless Audio Coding&lt;/a&gt; MPEG4-ALSのもうちょっと分かりやすい説明。厚すぎず手軽で良い。&lt;ul&gt;
&lt;li&gt;ロッシー符号化は編集やアーカイビングに向かない。歪みを生む。MP3やAACを知覚符号化と言っていた。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/7991/abe1173b7ad06b23d5a51d7e5b5092b2f201.pdf"&gt;予測誤差の Golomb-Rice 符号量を最小化する線形予測分析&lt;/a&gt; これは遊びが無くて良いように見える。というかこれ引用するだろうし、しっかり参考にすべき。&lt;ul&gt;
&lt;li&gt;やはりバックグラウンドにロスレス音声は使える。うまく話を作ろう。&lt;/li&gt;
&lt;li&gt;「最小絶対値推定量がロバスト推定量で あることから線形予測分析に基づく音声分析の耐雑音 性能を向上する目的として応用されている」もよいアイデア。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.eie.polyu.edu.hk/~enyhchan/ce_ac_p1.pdf"&gt;Lossless compression of digital audio&lt;/a&gt; 今の発表につながる概観書。基礎は変わってない。&lt;ul&gt;
&lt;li&gt;デジタル配信で重要な役割を果たす、ミキシングを高い忠実性を保てる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://cs.joensuu.fi/sipu/pub/RLS-LMS_TIP2008.pdf"&gt;Cascaded RLS–LMS Prediction in MPEG-4 Lossless Audio Coding&lt;/a&gt; MPEG4にカスケード接続したLMS+RLSを突っ込むと3%程圧縮率がよくなるという話。MPEG4-ALSも適応フィルタを使っているので、引用する必要はある。そらそうよ。負荷大丈夫か。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;既存研究調査&lt;/h2&gt;
&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;1回ざっと目を通した論文&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.452.7280&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Natural Gradient Works Efficiently in Learning&lt;/a&gt; LMS界隈からの引用多数。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www2.ee.ic.ac.uk/publications/p3943.pdf"&gt;Adaptive algorithms for sparse echo cancellation&lt;/a&gt; 俯瞰した背景描写もある。&lt;ul&gt;
&lt;li&gt;PNLMSに偏っているか。古い。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://iiav.org/ijav/content/volumes/21_2016_590031458046128/vol_1/835_fullpaper_1207561458214850.pdf"&gt;Review and Comparison of Variable Step-Size LMS Algorithms&lt;/a&gt; 適応ステップサイズ手法の比較。2015年。&lt;ul&gt;
&lt;li&gt;比較について多くの手法を3つの応用例から見ている。結論はNLMSが最高ということだったけど、比較過程については要注目。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/bf3b/fe757d9156cc863ffdde15b1664c337819bd.pdf"&gt;Proportionate Normalized Least-Mean-Squares Adaptation in Echo Cancelers&lt;/a&gt; 頻繁に参照されるPNLMS。係数の絶対値をその最大値で正規化した値を対角要素に持つ対角行列をフィッシャー情報行列の逆行列とする。&lt;ul&gt;
&lt;li&gt;NLMSと比較。DSP実装して実ノイズで試してもいる。理論的解析（定常雑音に対する収束レート解析）もしている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://scholarsmine.mst.edu/cgi/viewcontent.cgi?article=2780&amp;amp;context=ele_comeng_facwork"&gt;Normalized Natural Gradient Adaptive Filtering for Sparse and Nonsparse Systems&lt;/a&gt; フィッシャー情報行列を対角行列で与えている。&lt;ul&gt;
&lt;li&gt;まさに自然勾配をがっつり使う論文。絶対参照すべき。対角行列を計量にしたINLMSを導入し、スパース係数（1つだけ1.0で他全部0）ではPNLMSに負けたけど、非スパース係数（全部1）ではPNLMSよりも結果が良いとか言ってる。&lt;/li&gt;
&lt;li&gt;シミュレーション節が短すぎ。システム同定をやったらしいがよく分からん。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.eurasip.org/Proceedings/Eusipco/Eusipco2017/papers/1570346064.pdf"&gt;Full Proportionate Functional Link Adaptive Filters for Nonlinear Acoustic Echo Cancellation&lt;/a&gt; これも。謎のリーマン計量を作る。&lt;ul&gt;
&lt;li&gt;比較データの生成が恣意的すぎるので無し。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.907.849&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;New Sparse Adaptive Algorithms Based on the Natural Gradient and the l0-Norm&lt;/a&gt; これも謎のリーマン計量を使っている…。損失関数に計量が入っちゃってるけどいいのか？→大丈夫っぽい。損失関数の設計は自由。&lt;ul&gt;
&lt;li&gt;応用が特殊すぎる。オレオレデータセットに対して有効性を示されても困る。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arl.nus.edu.sg/twiki6/pub/ARL/BibEntries/Konstantinos_-_2011_-_Natural_Gradient-Based_Adaptive_Algorithms_For_Spa.pdf"&gt;NATURAL GRADIENT-BASED ADAPTIVE ALGORITHMS FOR SPARSE UNDERWATER ACOUSTIC CHANNEL IDENTIFICATION&lt;/a&gt; L0ノルム最小化に自然勾配法をあわせた。とある。やけに性能が良い。&lt;ul&gt;
&lt;li&gt;↑と著者が同じ。データセットも同じ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1303.2261.pdf"&gt;l0 Norm Constraint LMS Algorithm for Sparse System Identification&lt;/a&gt; 係数l0ノルム最小化。l0ノルムをexpで近似して解析的最小化。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;この論文で相関のあるガウス雑音の作り方が明確に示されている。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ITU-Tのデータを使ってるのは参考になった、&lt;/li&gt;
&lt;li&gt;が、スパースなデータの作り方が恣意的すぎる。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1311.5242.pdf"&gt;AN IMPROVED VARIABLE STEP-SIZE AFFINE PROJECTION SIGN ALGORITHM FOR ECHO CANCELLATION&lt;/a&gt; &lt;strong&gt;これが一番近いかも。&lt;/strong&gt; なんでここまできて自然勾配に至らないのか？こいつの引用を漁ったけど同一の研究なし。&lt;ul&gt;
&lt;li&gt;謎の手順（ガウス雑音に1次のIIRフィルタを通して、しかもベルヌーイ試行で出力判定する）で入力を生成している。よくあるのか？？？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://asl.epfl.ch/wp-content/uploads/publications/journal_articles/spl_feb_2004_b.pdf"&gt;Variable Step-Size NLMS and Affine Projection Algorithms&lt;/a&gt; これもそれなりに近い。affine projection algorithm で情報行列の逆を使っている。&lt;ul&gt;
&lt;li&gt;移動平均フィルタを理想フィルタにしている。ガウス雑音に謎の2次IIRフィルタを通したものをリファレンスとしている…。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1110.2907.pdf"&gt;System Identification Using Reweighted Zero Attracting Least Absolute Deviation Algorithms&lt;/a&gt; ZA-LADの原典。自分のやっている研究に近いかも。残差L1ノルム最小化はロバストだいう主張。&lt;ul&gt;
&lt;li&gt;スパースなときに有利であることを言いたいらしい。&lt;/li&gt;
&lt;li&gt;16タップの係数を使い、最初のXXXXイテレーションでは5番目のタップだけ1（他全部0）、次に奇数タップをすべて1にしてYYYYイテレーション、最後に偶数タップを-1にしてZZZZイテレーション。。。&lt;ul&gt;
&lt;li&gt;ノイズとして非ガウス的（α-stableと言っていた）なものを使用。SNRはGeneralized SNRという尺度を使用。&lt;/li&gt;
&lt;li&gt;他に、白色ガウス雑音に1次のフィルタを通して入力していた。出力に相関をもたせる意図か。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1311.6809.pdf"&gt;A Novel Family of Adaptive Filtering Algorithms Based on The Logarithmic Cost&lt;/a&gt; LLADの原典。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;これのデータよい。採用。&lt;/strong&gt; 単純明快。(理論ばっかりで分かりにくいと思っていたが）&lt;ul&gt;
&lt;li&gt;リファレンス信号 &lt;span class="math"&gt;\(d_{t} = \ve{w}_{0}^{\mathsf{T}} \ve{x}_{t} + n_{t}\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(\ve{w}_{0}\)&lt;/span&gt; はリファレンス係数（論文ではランダム選択にしていた。スパースじゃないならいいかも。）、 &lt;span class="math"&gt;\(\ve{x}_{t}\)&lt;/span&gt; は分散 &lt;span class="math"&gt;\(\sigma_{x}^{2} = 1\)&lt;/span&gt; の i.i.d な平均0ガウス信号系列、 &lt;span class="math"&gt;\(n_{t}\)&lt;/span&gt; はノイズ信号（分散0.01のガウス雑音と分散10000(偏差100)で一定確率(1,2,5%)で発生するインパルス雑音）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一定確率でインパルス雑音が発生するケースはロバスト性を示すために使われていた。LMSは全く等化できずにいた。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://gr.xjtu.edu.cn/c/document_library/get_file?folderId=1540809&amp;amp;name=DLFE-38423.pdf"&gt;Sparse Least Logarithmic Absolute Difference Algorithm with Correntropy-Induced Metric Penalty&lt;/a&gt; 重みによくわからないペナルティを付加したSigned LMS。&lt;ul&gt;
&lt;li&gt;これもしかしたら重要かもしれない。ちゃんと書けてる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Convergence Analysis of Zero Attracting Natural Gradient Non-Parametric Maximum Likelihood Algorithm これ読めないんだけどAbstract読み限り相当やってそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下、日本語論文&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jasj/50/1/50_KJ00001456848/_pdf/-char/ja"&gt;音響エコー経路の変動特性を反映させたRLS適応アルゴリズム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.tara.tsukuba.ac.jp/~maki/reprint/Makino/sm92ieice9-20.pdf"&gt;室内インパルス応答の統計的性質に基づく指数重み付けLMSフィルタ&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;実験としては微妙で、理論と一致しているかどうかの議論で終わっている。比較実験なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cepstrum.co.jp/rd/nlms/nlms_txt.pdf"&gt;エコーキャンセラ向けのNormalizedLMSアルゴリズムの改良&lt;/a&gt; 社内発表資料？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://leo.ec.t.kanazawa-u.ac.jp/staffs/nakayama/pub/file/dsp_symp03_dougahara.pdf"&gt;適応フィルタにおけるブロック形重み付けステップサイズの制御法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://ir.lib.u-ryukyu.ac.jp/bitstream/20.500.12000/1487/1/No59p107.pdf"&gt;直交ECLMSアルゴリズムを用いたエコーキャンセラーの設計&lt;/a&gt; ダブルトーク問題も入ってきちゃってる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.topic.ad.jp/sice/htdocs/papers/242/242-3.pdf"&gt;エコーキャンセラにおける適応アルゴリズムとダブルトーク検出の関係&lt;/a&gt; これもダブルトーク問題。しっかしNLMSとの比較のみ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;比較対象にすべき手法&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;NLMS, Signed-LMS, RLS&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/bf3b/fe757d9156cc863ffdde15b1664c337819bd.pdf"&gt;PNLMS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;IPNLMS(Improved PNLMS)&lt;/li&gt;
&lt;li&gt;APA(Affine Projection Algorithm)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;比較対象にすべきデータ&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;発話音声（ソースがない...）&lt;/li&gt;
&lt;li&gt;理想係数に入力として単位インパルス（雑音源よりもレベルの小さいノイズもあり）をXXXX回繰り返し入れ続け（途中で理想係数を急に変える）、同時にレベルを決めた雑音源を入力。&lt;ul&gt;
&lt;li&gt;シードのみを変えて、XXX回独立した試行を行ってその平均を（残差トレンドの平均も）とる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ITU G.168のエコーパスモデル&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.itu.int/ITU-T/recommendations/rec.aspx?rec=12451&amp;amp;lang=en"&gt;公式&lt;/a&gt; から資料入手可能。&lt;/li&gt;
&lt;li&gt;Annex Dに8つのエコーインパルスのデータが乗っかっている。5番目のインパルスがスパースだから良いらしい。&lt;/li&gt;
&lt;li&gt;また、リファレンスの波形にフィルタを通して使うらしい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ほぼ0で、ランダムに選んだいくつかの係数だけが1になっているリファレンスフィルタの出力
* 入力例1: ガウス雑音に1次（極が1つの）のIIRを通し、さらにベルヌーイ過程として、一定確率pでノイズ、1-pで0となる信号
* 入力例2: ガウス雑音に2次のIIRを通す&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3&gt;比較基準&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2乗誤差(misalignmentとか行ったりする)[dB]&lt;/li&gt;
&lt;li&gt;計算量（畳み込み、係数更新における乗算+加算回数）&lt;/li&gt;
&lt;li&gt;定常状態での係数の分散&lt;/li&gt;
&lt;li&gt;理想係数との誤差MSE（MSD(Mean Square Deviationとも言う。Simonの本から来てると思われる)。もし計算できるなら。正規化してdB表示する: &lt;span class="math"&gt;\(10 \log_{10} ( ||h - \hat{h}|| / ||h|| )\)&lt;/span&gt; ）&lt;/li&gt;
&lt;li&gt;定常状態でのMSE&lt;/li&gt;
&lt;li&gt;MSEの和（全実験での）&lt;/li&gt;
&lt;li&gt;可変ステップサイズアルゴリズムの場合は、ステップサイズの変化&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;思ったこと&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ブロック線図を書くと良さそう？多くの論文が書いてる。エコーキャンセラーのアーキテクチャは示すべきか。&lt;/li&gt;
&lt;li&gt;提案手法はウィーナー解に収束するか？&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://onsen-mula.org/wp-content/uploads/2017/04/inoue.pdf"&gt;ロバスト適応同定手法によるエコーキャンセラの設計&lt;/a&gt; ここにウィーナー解との関連がある&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.bode.amp.i.kyoto-u.ac.jp/~kashima/lecture/ss/slide17_8.pdf"&gt;信号とシステム&lt;/a&gt; ここにもそれなりにある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;音響データベースがある...&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.nii.ac.jp/dsc/idr/speech/submit/RWCP-SSD.html"&gt;6. RWCP 実環境音声・音響データベース (RWCP-SSD)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sign アルゴリズムの概観については、以下もどっかで見ておきたい。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/essfr/8/4/8_292/_pdf/-char/ja"&gt;再考・適応アルゴリズム&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;実は自然勾配法による適応アルゴリズムは非線形適応アルゴリズムになってる？&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ykw.elec.keio.ac.jp/yukawa/yukawa_tutorial2014.pdf"&gt;非線形適応信号処理技術の新潮流 ──再生核の応用──&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(17) - 中間発表</title><link href="/yan-jiu-hui-nixiang-kete17-zhong-jian-fa-biao.html" rel="alternate"></link><published>2020-07-20T11:00:00+09:00</published><updated>2020-07-20T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-20:/yan-jiu-hui-nixiang-kete17-zhong-jian-fa-biao.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;資料に追い込みを掛けていたので、あまり進捗なし。発表してもらったコメントで大きそうなのをメモる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;SA、実はヘブ則そのものでは？&lt;ul&gt;
&lt;li&gt;全くその通り。識別タスクにしたらまんまそれ。NN的に見ると〜はヘブ則と言ってもいいくらい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;グラフは正方形にすべし。&lt;ul&gt;
&lt;li&gt;全くその通り。すぐに修正するべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;尤度は独立な観測では不完全。独立同分布な(i.i.d.)な観測や&lt;/li&gt;
&lt;li&gt;NNGSAの最適化問題による定式化ってリッジ回帰に似てる。対角行列を計量にしてる。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\mathrm{E}\left[ \left\{ \frac{\mathrm{sgn}(\varepsilon[n])}{\sigma} \right\}^{2} \ve{x}[n] \ve{x}[n]^{\mathsf{T}} \right …&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;資料に追い込みを掛けていたので、あまり進捗なし。発表してもらったコメントで大きそうなのをメモる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;SA、実はヘブ則そのものでは？&lt;ul&gt;
&lt;li&gt;全くその通り。識別タスクにしたらまんまそれ。NN的に見ると〜はヘブ則と言ってもいいくらい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;グラフは正方形にすべし。&lt;ul&gt;
&lt;li&gt;全くその通り。すぐに修正するべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;尤度は独立な観測では不完全。独立同分布な(i.i.d.)な観測や&lt;/li&gt;
&lt;li&gt;NNGSAの最適化問題による定式化ってリッジ回帰に似てる。対角行列を計量にしてる。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\mathrm{E}\left[ \left\{ \frac{\mathrm{sgn}(\varepsilon[n])}{\sigma} \right\}^{2} \ve{x}[n] \ve{x}[n]^{\mathsf{T}} \right] = \frac{1}{\sigma^{2}} \mathrm{E} \left[ \ve{x}[n] \ve{x}[n]^{\mathsf{T}} \right]\)&lt;/span&gt; はほんまか？a.e.では？近似では？ &lt;span class="math"&gt;\(\mathrm{E}\)&lt;/span&gt; だから厳密？&lt;ul&gt;
&lt;li&gt;やっぱり要審査。自分は期待値操作でルベーグ積分するから、測度0の点は抜いても大丈夫だと思っている。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;厳密にいけそう。&lt;/strong&gt; &lt;span class="math"&gt;\(\mathrm{sgn}(x) := \frac{x}{|x|}\)&lt;/span&gt; と定義すると、 &lt;span class="math"&gt;\((\mathrm{sgn}(x))^{2} = \frac{x^{2}}{|x|^{2}} = 1\)&lt;/span&gt; 。 &lt;span class="math"&gt;\(x=0\)&lt;/span&gt; のときが怪しくなるが、これは、 &lt;span class="math"&gt;\(\mathrm{sgn}(x) \approx \frac{x}{\sqrt{x^{2} + \varepsilon}}\)&lt;/span&gt; としてやって（ &lt;span class="math"&gt;\(\varepsilon \to 0\)&lt;/span&gt; とすれば符号関数に一致）、 &lt;span class="math"&gt;\((\mathrm{sgn}(x))^{2} \approx \frac{x^{2}}{x^{2} + \varepsilon}\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(\varepsilon \to 0\)&lt;/span&gt; としてやれば恒等的に1になる。多分、近似を使ったやり方のほうが &lt;span class="math"&gt;\(x=0\)&lt;/span&gt; でややこしくならないから筋がいい。&lt;/li&gt;
&lt;li&gt;答えとしては、 &lt;span class="math"&gt;\(\mathrm{sgn}(x) := \lim_{\varepsilon \to 0} \frac{x}{\sqrt{x^{2} + \varepsilon}}\)&lt;/span&gt; がいいかも。&lt;/li&gt;
&lt;li&gt;いや、まだ怪しい… &lt;span class="math"&gt;\(\mathrm{sgn}(0) = 0\)&lt;/span&gt; という定義だから、絶対 &lt;span class="math"&gt;\((\mathrm{sgn}(0))^{2} = 0\)&lt;/span&gt; になる。積分を絡めて考えないとだめか。至るところ1なんだけど、1点 &lt;span class="math"&gt;\(x=0\)&lt;/span&gt; において &lt;span class="math"&gt;\(0\)&lt;/span&gt; を取る関数の平均。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;グラフのitaration → iteration&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; の計算について。&lt;ul&gt;
&lt;li&gt;低ランク近似、とくに、 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 重対角行列で近似できん？→確かに。相関行列は端っこに近づくほど0になっていくから、有効かも。&lt;/li&gt;
&lt;li&gt;DFTしてなだらかに変化する要素（つまり低域信号）のパワーは切り捨てる近似がオッケーだったりしないか。→まったくそのとおり、&lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; をDFTすると、ウィーナ・ヒンチンが顔を出しそう。&lt;/li&gt;
&lt;li&gt;スレ―ビングというらしい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;（所感）残差がガウス分布に従うとしたLMS ←ちょっと突然すぎる。&lt;ul&gt;
&lt;li&gt;LMS（残差がガウス分布に従う）は… ←こっちのほうがいい。むしろ、ガウス分布の話はいらない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;損失関数はReLuにしても良いのでは→あり。でもどうなるんだろう。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(16)</title><link href="/yan-jiu-hui-nixiang-kete16.html" rel="alternate"></link><published>2020-07-14T11:00:00+09:00</published><updated>2020-07-14T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-14:/yan-jiu-hui-nixiang-kete16.html</id><content type="html">&lt;p&gt;引き続き資料を作っている。&lt;/p&gt;
&lt;p&gt;昨日気になっていた&lt;/p&gt;
&lt;blockquote&gt;
NNGSAの収束する最適係数はWienner解で間違いないのか検証する必要あり。&lt;/blockquote&gt;
&lt;p&gt;は並行して確認中。直交原理（勾配が0になる解）を満たす解はWienner解に一致するのか？というところ。
怪しいかもしれない。適応ステップサイズがミソで、最適係数時、そいつを含めて平均をとったときにゼロになるとは思えない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://towardsdatascience.com/natural-gradient-ce454b3dcdfa"&gt;Natural Gradient A better gradient for gradient descent?&lt;/a&gt; 面白そうだけどちとタイミングが悪い。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(15)</title><link href="/yan-jiu-hui-nixiang-kete15.html" rel="alternate"></link><published>2020-07-13T11:00:00+09:00</published><updated>2020-07-13T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-13:/yan-jiu-hui-nixiang-kete15.html</id><content type="html">&lt;p&gt;淡々と資料を作っている。
NNGSAの収束する最適係数はWienner解で間違いないのか検証する必要あり。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(14)</title><link href="/yan-jiu-hui-nixiang-kete14.html" rel="alternate"></link><published>2020-07-12T11:00:00+09:00</published><updated>2020-07-12T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-12:/yan-jiu-hui-nixiang-kete14.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand{\parfrac}[2]{{\frac{\partial #1}{\partial #2}}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;今日から発表資料作る。久々にBeamerでやろうかね。&lt;/p&gt;
&lt;p&gt;資料作ってたら、ラグランジュ未定乗数法による定式化で &lt;span class="math"&gt;\((\ve{h} - \ve{h}^{\prime})^{\mathsf{T}}\ve{R}(\ve{h} - \ve{h}^{\prime})\)&lt;/span&gt; の最小化を考えたけど、これってレイリー商の下限すなわち最小固有値が答えでは。もうちょっと考えたくなってきた。 &lt;span class="math"&gt;\(\mu(n)\)&lt;/span&gt; は垂線の長さに対応するんだっけ？&lt;/p&gt;
&lt;p&gt;アフィン写像アルゴリズムへの拡張は、NLMSの制約を増やしたものに過ぎない。ラグランジュの未定乗数法を使って、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mathcal{L} &amp;amp;= (\ve{h …&lt;/div&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand{\parfrac}[2]{{\frac{\partial #1}{\partial #2}}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;今日から発表資料作る。久々にBeamerでやろうかね。&lt;/p&gt;
&lt;p&gt;資料作ってたら、ラグランジュ未定乗数法による定式化で &lt;span class="math"&gt;\((\ve{h} - \ve{h}^{\prime})^{\mathsf{T}}\ve{R}(\ve{h} - \ve{h}^{\prime})\)&lt;/span&gt; の最小化を考えたけど、これってレイリー商の下限すなわち最小固有値が答えでは。もうちょっと考えたくなってきた。 &lt;span class="math"&gt;\(\mu(n)\)&lt;/span&gt; は垂線の長さに対応するんだっけ？&lt;/p&gt;
&lt;p&gt;アフィン写像アルゴリズムへの拡張は、NLMSの制約を増やしたものに過ぎない。ラグランジュの未定乗数法を使って、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mathcal{L} &amp;amp;= (\ve{h} - \ve{h}^{\prime})^{\mathsf{T}}\ve{R}(\ve{h} - \ve{h}^{\prime}) + (\ve{d} - \ve{A}\ve{h}^{\prime})^{\mathsf{T}} \ve{\lambda} \\
\parfrac{\mathcal{L}}{\ve{h}^{\prime}} &amp;amp;= 2\ve{R}(\ve{h} - \ve{h}^{\prime}) - \parfrac{}{\ve{h}^{\prime}} \ve{h}^{\prime\mathsf{T}} \ve{A}^{\mathsf{T}} \ve{\lambda} \\
&amp;amp;= 2\ve{R}(\ve{h} - \ve{h}^{\prime}) - \ve{A}^{\mathsf{T}} \ve{\lambda} \\
\implies \ve{h}^{\prime} &amp;amp;= \ve{h} + \frac{1}{2} \ve{R}^{-1} \ve{A}^{\mathsf{T}} \ve{\lambda} \\
\implies \ve{\lambda} &amp;amp;= 2 (\ve{A} \ve{R}^{-1} \ve{A}^{\mathsf{T}})\ve{e}
\end{align*}
&lt;/div&gt;
&lt;p&gt;から、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{h}^{\prime} &amp;amp;= \ve{h} + \ve{R}^{-1}\ve{A}^{\mathsf{T}}(\ve{A} \ve{R}^{-1} \ve{A}^{\mathsf{T}})^{-1} \ve{e} \\
&amp;amp;= \ve{h} + \ve{R}^{-1}\ve{A}^{\mathsf{T}}(\ve{A} \ve{R}^{-1} \ve{A}^{\mathsf{T}})^{-1}(\ve{d} - \ve{A} \ve{h}) \\
&amp;amp;= \left\{ \ve{I} - \ve{R}^{-1}\ve{A}^{\mathsf{T}}(\ve{A} \ve{R}^{-1} \ve{A}^{\mathsf{T}})^{-1}\ve{A} \right\} \ve{h} + \ve{R}^{-1}\ve{A}^{\mathsf{T}}(\ve{A} \ve{R}^{-1} \ve{A}^{\mathsf{T}})\ve{d}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\ve{P} = \ve{R}^{-1}\ve{A}^{\mathsf{T}}(\ve{A} \ve{R}^{-1} \ve{A}^{\mathsf{T}})^{-1}\ve{A}\)&lt;/span&gt; とすれば &lt;span class="math"&gt;\(\ve{P}^{2} = \ve{P}\)&lt;/span&gt; だから射影行列になっている。&lt;/p&gt;
&lt;p&gt;アルゴリズムを導いたけどあんまりいい考察は出てこない、というか、煩雑。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(13)</title><link href="/yan-jiu-hui-nixiang-kete13.html" rel="alternate"></link><published>2020-07-11T11:00:00+09:00</published><updated>2020-07-11T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-11:/yan-jiu-hui-nixiang-kete13.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;発表向けの脚本を書いてた。&lt;/p&gt;
&lt;p&gt;正規化アルゴリズムに関して、まだしたりない考察がある。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;射影先の超平面の曲率はもしかして &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; だったりしない？漠然とした超平面ではなく、何らかの性質がないか？&lt;ul&gt;
&lt;li&gt;これは、制約が一次式だから絶対に超平面になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;アフィン写像アルゴリズムへ拡張するべきでは？&lt;ul&gt;
&lt;li&gt;やってみた。次の日へどうぞ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen …&lt;/script&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;発表向けの脚本を書いてた。&lt;/p&gt;
&lt;p&gt;正規化アルゴリズムに関して、まだしたりない考察がある。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;射影先の超平面の曲率はもしかして &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; だったりしない？漠然とした超平面ではなく、何らかの性質がないか？&lt;ul&gt;
&lt;li&gt;これは、制約が一次式だから絶対に超平面になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;アフィン写像アルゴリズムへ拡張するべきでは？&lt;ul&gt;
&lt;li&gt;やってみた。次の日へどうぞ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(12)</title><link href="/yan-jiu-hui-nixiang-kete12.html" rel="alternate"></link><published>2020-07-10T11:00:00+09:00</published><updated>2020-07-10T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-10:/yan-jiu-hui-nixiang-kete12.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;発表に向けてのプロットに集中したい。また、正規化自然勾配SAが事後残差最小化ではなくラグランジュから導いて同じ結論が得られるか見たい。（もしかしたら、別の更新式が出る可能性がある）&lt;/p&gt;
&lt;p&gt;ラグランジュの結果、かなり良い解釈が得られた。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document …&lt;/script&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;発表に向けてのプロットに集中したい。また、正規化自然勾配SAが事後残差最小化ではなくラグランジュから導いて同じ結論が得られるか見たい。（もしかしたら、別の更新式が出る可能性がある）&lt;/p&gt;
&lt;p&gt;ラグランジュの結果、かなり良い解釈が得られた。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(11)</title><link href="/yan-jiu-hui-nixiang-kete11.html" rel="alternate"></link><published>2020-07-09T11:00:00+09:00</published><updated>2020-07-09T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-09:/yan-jiu-hui-nixiang-kete11.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;乗せるデータをまとめる。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;自然勾配SA法の有効性を示す。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;人口データに対する実験: SA(ステップサイズ=0.005,0.01,0.02)と比較して収束が速いことを示す。しかし係数適応は遅いことは同時に指摘。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;正規化自然勾配SA法の有効性を示す。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;人口データに対する実験: RLS(忘却係数=1,0.9,0.99)と比較。収束は遅い場合があるが、定常誤差は小さく、また係数変更時の適応が早い。忘却係数に依存せず安定した収束性能を示す。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;自然勾配法の有効性を示す。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;実データに対する実験: 音楽の一部データに対する比較。SA, RLS(忘却係数=0.99), 正規化自然勾配SA, 自然勾配SAで比較。&lt;/li&gt;
&lt;li&gt;RMSを比較。RLSとほぼ同等の性能を達成している。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document …&lt;/script&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;乗せるデータをまとめる。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;自然勾配SA法の有効性を示す。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;人口データに対する実験: SA(ステップサイズ=0.005,0.01,0.02)と比較して収束が速いことを示す。しかし係数適応は遅いことは同時に指摘。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;正規化自然勾配SA法の有効性を示す。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;人口データに対する実験: RLS(忘却係数=1,0.9,0.99)と比較。収束は遅い場合があるが、定常誤差は小さく、また係数変更時の適応が早い。忘却係数に依存せず安定した収束性能を示す。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;自然勾配法の有効性を示す。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;実データに対する実験: 音楽の一部データに対する比較。SA, RLS(忘却係数=0.99), 正規化自然勾配SA, 自然勾配SAで比較。&lt;/li&gt;
&lt;li&gt;RMSを比較。RLSとほぼ同等の性能を達成している。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(10)</title><link href="/yan-jiu-hui-nixiang-kete10.html" rel="alternate"></link><published>2020-07-08T11:00:00+09:00</published><updated>2020-07-08T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-08:/yan-jiu-hui-nixiang-kete10.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;今日あたりで目処を…というか、デフォルトの自然勾配法に対する言い訳を考えておきたい。
ガチャガチャいじっていると、LMSに &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を掛けたのも強いということが分かってくる…。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{h}^{\prime} \leftarrow \ve{h} + \mu \ve{R}^{-1} \varepsilon(n) \ve{x}(n)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;何度も見てきた通りだが、上式のステップサイズを（事後誤差最小化基準により）適応化すると正規化版の式に一致する。ちなみに、LMSに対してはフィッシャー情報行列が意味のある統計量に結びつかない。Signアルゴリズムの改良から話を初めて、ステップサイズ適応化してまでたどり着くと、初めてLMS版に対応する式が導かれる。&lt;/p&gt;
&lt;p&gt;確かに上は性能が良いが、裏付けが薄く眉唾の感を逃れられない。疑似自然勾配LMSと名付けて実装しておく。名目としては …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;今日あたりで目処を…というか、デフォルトの自然勾配法に対する言い訳を考えておきたい。
ガチャガチャいじっていると、LMSに &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を掛けたのも強いということが分かってくる…。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{h}^{\prime} \leftarrow \ve{h} + \mu \ve{R}^{-1} \varepsilon(n) \ve{x}(n)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;何度も見てきた通りだが、上式のステップサイズを（事後誤差最小化基準により）適応化すると正規化版の式に一致する。ちなみに、LMSに対してはフィッシャー情報行列が意味のある統計量に結びつかない。Signアルゴリズムの改良から話を初めて、ステップサイズ適応化してまでたどり着くと、初めてLMS版に対応する式が導かれる。&lt;/p&gt;
&lt;p&gt;確かに上は性能が良いが、裏付けが薄く眉唾の感を逃れられない。疑似自然勾配LMSと名付けて実装しておく。名目としては、正規化の簡略版と見れるはず。収束議論もしておきたい。&lt;/p&gt;
&lt;p&gt;と思ったら、疑似自然勾配LMSは実データですっ飛ぶ傾向あり。誤差が急上昇するところで係数が吹っ飛んでしまう。。トレードオフのようで、誤差の符号をとる（自然勾配SA）は適応が遅すぎて、残差をそのまま使う（疑似自然勾配LMS）は適応が敏感すぎてすっ飛ぶ傾向がある。正規化は本質的な働きをしているように見える。&lt;/p&gt;
&lt;p&gt;まとめようか。
勾配を観察すれば分かることだけど、やっぱり自然勾配SAは勾配が平坦になりすぎるきらいがある。どんなに最適値との差があっても同一の勾配になりやすい。
実データでは十分なサンプルが取れて、しかも特性はのんびり変化するから性能が良くなる。
忘却係数は高く取れば定常誤差を小さくできるが、1.0にすると特性追従が遅くなるので、1にほど近い0.997等に設定する。ステップサイズは実験では1.0等大きめに、実データは0.1等にとる。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(9)</title><link href="/yan-jiu-hui-nixiang-kete9.html" rel="alternate"></link><published>2020-07-07T11:00:00+09:00</published><updated>2020-07-07T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-07:/yan-jiu-hui-nixiang-kete9.html</id><summary type="html">&lt;p&gt;トイデータに対する実験をやっているが、色々と悲しい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;自然勾配SignAlgorithmの性能が悪い。下手するとSignAlgorithmとどっこい&lt;ul&gt;
&lt;li&gt;実データに対しては良い結果を出していた。&lt;/li&gt;
&lt;li&gt;原因を調べていたら、係数の初期値が最適値の近くにあると収束が早いということが分かった。&lt;/li&gt;
&lt;li&gt;トイデータ実験は[-1,1]から一様乱数選択していたので、それだと広すぎるらしく、収束が遅い。勾配が平坦に広がりすぎている可能性がある。&lt;/li&gt;
&lt;li&gt;忘却係数を低く（ステップサイズを大きく）すると応答は良くなるけどオフセットが残る。&lt;/li&gt;
&lt;li&gt;実データはサンプル数が多いのと、係数が大きな値を取りにくいことから性能が良かったものと想像。&lt;ul&gt;
&lt;li&gt;正規化版は自己相関行列の逆行列の二次形式で割ってるから、自己相関の逆数で割ってる、即ち、自己相関を掛けてると見れる。じゃあ、簡易的に入力データのノルムの平均値を掛けてやればいいんじゃねと思ってやってみたらそれなりに安定してきた。&lt;/li&gt;
&lt;li&gt;眉唾だから再度要検証。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RLSが強すぎる。忘却係数付きRLSが一番強い。&lt;ul&gt;
&lt;li&gt;忘却係数はトレードオフという感じ。0.9まで下げると収束は早いけどオフセットが残る。0.99だと係数が変わったときに収束が遅くなる。1.0（普通のRLS）だと係数が変わったときにまったく収束していかない。&lt;/li&gt;
&lt;li&gt;正規化自然勾配SignAlgorithmは忘却係数の値によらずほぼ同じ学習曲線になる。依存するのはステップサイズくらいか。そこは主張できるかも。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NLMSもMSD（係数誤差）の意味ではRLSと同程度まで下げられているが、正規化自然勾配SignAlgorithmは収束ははやいがそこまで誤差が下がらない。&lt;/li&gt;
&lt;li&gt;実装ミスあり。係数更新がFinvの更新前に行われていた。&lt;ul&gt;
&lt;li&gt;普通の自然勾配法は大きな影響あり。あれ？でも正規化自然勾配の方はあまり影響がない。&lt;/li&gt;
&lt;li&gt;実装ミスなのか微妙 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;トイデータに対する実験をやっているが、色々と悲しい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;自然勾配SignAlgorithmの性能が悪い。下手するとSignAlgorithmとどっこい&lt;ul&gt;
&lt;li&gt;実データに対しては良い結果を出していた。&lt;/li&gt;
&lt;li&gt;原因を調べていたら、係数の初期値が最適値の近くにあると収束が早いということが分かった。&lt;/li&gt;
&lt;li&gt;トイデータ実験は[-1,1]から一様乱数選択していたので、それだと広すぎるらしく、収束が遅い。勾配が平坦に広がりすぎている可能性がある。&lt;/li&gt;
&lt;li&gt;忘却係数を低く（ステップサイズを大きく）すると応答は良くなるけどオフセットが残る。&lt;/li&gt;
&lt;li&gt;実データはサンプル数が多いのと、係数が大きな値を取りにくいことから性能が良かったものと想像。&lt;ul&gt;
&lt;li&gt;正規化版は自己相関行列の逆行列の二次形式で割ってるから、自己相関の逆数で割ってる、即ち、自己相関を掛けてると見れる。じゃあ、簡易的に入力データのノルムの平均値を掛けてやればいいんじゃねと思ってやってみたらそれなりに安定してきた。&lt;/li&gt;
&lt;li&gt;眉唾だから再度要検証。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RLSが強すぎる。忘却係数付きRLSが一番強い。&lt;ul&gt;
&lt;li&gt;忘却係数はトレードオフという感じ。0.9まで下げると収束は早いけどオフセットが残る。0.99だと係数が変わったときに収束が遅くなる。1.0（普通のRLS）だと係数が変わったときにまったく収束していかない。&lt;/li&gt;
&lt;li&gt;正規化自然勾配SignAlgorithmは忘却係数の値によらずほぼ同じ学習曲線になる。依存するのはステップサイズくらいか。そこは主張できるかも。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NLMSもMSD（係数誤差）の意味ではRLSと同程度まで下げられているが、正規化自然勾配SignAlgorithmは収束ははやいがそこまで誤差が下がらない。&lt;/li&gt;
&lt;li&gt;実装ミスあり。係数更新がFinvの更新前に行われていた。&lt;ul&gt;
&lt;li&gt;普通の自然勾配法は大きな影響あり。あれ？でも正規化自然勾配の方はあまり影響がない。&lt;/li&gt;
&lt;li&gt;実装ミスなのか微妙。。負荷減らしのための方策だった（フィッシャー情報行列の逆との積を使い回せるから）&lt;/li&gt;
&lt;li&gt;性能差が顕著なのでこれはよく考えたほうが良い。アルゴリズムの整合性的にもあやしい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(8)</title><link href="/yan-jiu-hui-nixiang-kete8.html" rel="alternate"></link><published>2020-07-06T11:00:00+09:00</published><updated>2020-07-06T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-06:/yan-jiu-hui-nixiang-kete8.html</id><summary type="html">&lt;p&gt;昨日の結果を受けて、相関があるガウス雑音信号を実験の対象にしたいと思っている。（なぜなら、現実のデータは相関があるから。そして、NLMSは相関のあるデータに弱いから。）いろんな論文で構成法が乗っていたので再調査。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1303.2261.pdf"&gt;l0 Norm Constraint LMS Algorithm for Sparse System Identification&lt;/a&gt; に明確に記述あり。v[t]をi.i.dなガウス雑音として、1次の自己回帰(Auto Regressive)フィルタ x[t] = x[t-1] * 0.8 + v[t] で信号に相関をもたせたあとに、正規化（標準偏差で割る）して分散を1にしている。有色雑音と言っていた。&lt;/p&gt;
&lt;p&gt;また、昨日の夜にモデルに係数を状態として持たせるか考えた。係数が途中で変わるケースの結果が取りにくいので。
でも、扱う側でうまく計算すればできそうなのでやめた。モデル側の実装が複雑になるのは避けたい。&lt;/p&gt;
&lt;p&gt;実験ケースを分類しよう。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;人口データ: 観測雑音: -40dBの白色ガウス雑音、MSD …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;昨日の結果を受けて、相関があるガウス雑音信号を実験の対象にしたいと思っている。（なぜなら、現実のデータは相関があるから。そして、NLMSは相関のあるデータに弱いから。）いろんな論文で構成法が乗っていたので再調査。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1303.2261.pdf"&gt;l0 Norm Constraint LMS Algorithm for Sparse System Identification&lt;/a&gt; に明確に記述あり。v[t]をi.i.dなガウス雑音として、1次の自己回帰(Auto Regressive)フィルタ x[t] = x[t-1] * 0.8 + v[t] で信号に相関をもたせたあとに、正規化（標準偏差で割る）して分散を1にしている。有色雑音と言っていた。&lt;/p&gt;
&lt;p&gt;また、昨日の夜にモデルに係数を状態として持たせるか考えた。係数が途中で変わるケースの結果が取りにくいので。
でも、扱う側でうまく計算すればできそうなのでやめた。モデル側の実装が複雑になるのは避けたい。&lt;/p&gt;
&lt;p&gt;実験ケースを分類しよう。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;人口データ: 観測雑音: -40dBの白色ガウス雑音、MSD（Mean Square Deviations, 係数2乗誤差）とMSE（Mean Square Error, 二乗誤差）を比較&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;入力: i.i.d.ガウス雑音、係数: 一様乱数で選択&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;主張: NLMSと同程度、RLSは収束が早い&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;入力: 相関のあるi.i.d.ガウス雑音、係数: 一様乱数で選択&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;主張: NLMSよりは早い&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;入力: 相関のあるi.i.d.ガウス雑音、係数: 一様乱数で選択、XXXXサンプル後に係数を一様乱数で変更&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;主張: 係数変更後の適応でRLSより収束が早い&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;実データに対する等価実験: MSEを比較。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;音源は著作権切れデータベースから10秒程度を切り出して使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;この通りにコードをまとめていく。水曜日あたりで結果が出ると◎。
人口データについてはまとまったかな。火曜日で実データ選定と実験をやっていく。&lt;/p&gt;
&lt;p&gt;「信号とシステム」にシステムを等価する際の図が描かれている。ロスレス音声ではどうなっているか、資料作りまでに要観察。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(7)</title><link href="/yan-jiu-hui-nixiang-kete7.html" rel="alternate"></link><published>2020-07-05T11:00:00+09:00</published><updated>2020-07-05T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-05:/yan-jiu-hui-nixiang-kete7.html</id><content type="html">&lt;p&gt;トイデータ対象の実験スクリプトを作ってた。で、RLSが強いことが分かった。
定常的なガウス雑音（ラプラス雑音でも！）環境下では、指数レートよりも早く最適解に入っていく。
途中で最適係数を変えると収束は他よりも鈍くなる。そこを突くべきか。
（RLSの忘却係数を0.8くらいにしないと同等にならない。）&lt;/p&gt;
&lt;p&gt;また、正規化込みの自然勾配法はNLMSと同程度の収束レートだった。ていうか性能ほぼ同じ。
→入力に強い相関をもたせる（x[t] += x[t-1] * 0.97）とNLMSの性能が大幅悪化することを確認した。
入力に相関がない場合は（自己相関行列が等方的になるので）NLMSと同等になるようだ。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(6)</title><link href="/yan-jiu-hui-nixiang-kete6.html" rel="alternate"></link><published>2020-07-04T11:00:00+09:00</published><updated>2020-07-04T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-04:/yan-jiu-hui-nixiang-kete6.html</id><content type="html">&lt;p&gt;&lt;a class="reference external" href="https://www.cs.tut.fi/~tabus/course/ASP/SGN2206LectureNew5.pdf"&gt;Lecture 5: Variants of the LMS algorithm&lt;/a&gt; を見ていたらNLMSをラグランジュ未定乗数法で求める方法があった。今までは事後残差最小化で見ていたけど、これは本質かもしれない。持ち帰って再度計算してみるべきかも。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.cs.tut.fi/~tabus/course/ASP/SGN2206LectureNew4.pdf"&gt;Lecture 4: Stochastic gradient based adaptation: Least Mean Square (LMS) Algorithm&lt;/a&gt; にHeykinの簡易まとめあり。有益。&lt;/p&gt;
&lt;p&gt;t-wadaさんのプレゼンテーションで情熱を持って話しているか？をチェックポイントにしている。 &lt;a class="reference external" href="https://www.slideshare.net/t_wada/the-only-one-big-thing-every-programmer-should-know/51"&gt;ここ&lt;/a&gt; 。 全くそのとおりだと思うので思い出しておく。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(5)</title><link href="/yan-jiu-hui-nixiang-kete5.html" rel="alternate"></link><published>2020-07-03T11:00:00+09:00</published><updated>2020-07-03T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-03:/yan-jiu-hui-nixiang-kete5.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;引き続き周辺を見るが、そろそろRLSとPNLMSの実装に入ろうかな。
トイデータの実験条件も整理したい。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1311.6809.pdf"&gt;A Novel Family of Adaptive Filtering Algorithms Based on The Logarithmic Cost&lt;/a&gt; のデータの作り方を参考にしようと思う。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;リファレンス信号 &lt;span class="math"&gt;\(d_{t} = \ve{w}_{0}^{\mathsf{T}} \ve{x}_{t} + n_{t}\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(\ve{w}_{0}\)&lt;/span&gt; はリファレンス係数（論文ではランダム選択にしていた。スパースじゃないならいいかも。）、 &lt;span class="math"&gt;\(\ve{x …&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;引き続き周辺を見るが、そろそろRLSとPNLMSの実装に入ろうかな。
トイデータの実験条件も整理したい。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1311.6809.pdf"&gt;A Novel Family of Adaptive Filtering Algorithms Based on The Logarithmic Cost&lt;/a&gt; のデータの作り方を参考にしようと思う。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;リファレンス信号 &lt;span class="math"&gt;\(d_{t} = \ve{w}_{0}^{\mathsf{T}} \ve{x}_{t} + n_{t}\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(\ve{w}_{0}\)&lt;/span&gt; はリファレンス係数（論文ではランダム選択にしていた。スパースじゃないならいいかも。）、 &lt;span class="math"&gt;\(\ve{x}_{t}\)&lt;/span&gt; は分散 &lt;span class="math"&gt;\(\sigma_{x}^{2} = 1\)&lt;/span&gt; の i.i.d な平均0ガウス信号系列、 &lt;span class="math"&gt;\(n_{t}\)&lt;/span&gt; はノイズ信号（分散0.01のガウス雑音と分散10000(偏差100)で一定確率(1,2,5%)で発生するインパルス雑音）&lt;ul&gt;
&lt;li&gt;一定確率でインパルス雑音が発生するケースはロバスト性を示すために使われていた。LMSは全く等化できずにいた。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;念の為Simon, Heykinを見てから方針を固める。
5.7節(p285)あたりから実験の記述あり。図5.19(p287)は必要になるはず。しかし、入力はベルヌーイ列、フィルタ係数は偶対称。。。
p297あたりに誤差曲面が書いてあった。遅いケースが有るということを、たしかに自分も確認している。&lt;/p&gt;
&lt;p&gt;RLSを実装し、トイデータ向けの実験フレームワークを作ってしまうべきか。
その後にPNLMSを追加できれば良い。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(4)</title><link href="/yan-jiu-hui-nixiang-kete4.html" rel="alternate"></link><published>2020-07-02T11:00:00+09:00</published><updated>2020-07-02T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-02:/yan-jiu-hui-nixiang-kete4.html</id><content type="html">&lt;p&gt;外出したのであんまり進捗なし。周辺調査してるけど、よい（コンセンサスのとれた）比較方法ないなあ…
実音声でやるのは確定として、トイデータはどうしようか。再考・適応アルゴリズムにあるように、完全に人工のインパルス応答（指数敵減衰信号）でもいいかも。係数をスパースにするのが目的ではないし。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(3)</title><link href="/yan-jiu-hui-nixiang-kete3.html" rel="alternate"></link><published>2020-07-01T11:00:00+09:00</published><updated>2020-07-01T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-01:/yan-jiu-hui-nixiang-kete3.html</id><content type="html">&lt;p&gt;今日は予定を立てよう。ちょうど良いタイミングでゼミ発表も入った。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.math.titech.ac.jp/~kawahira/courses.html"&gt;Tomoki Kawahira Courses&lt;/a&gt; 東工大の教授の数学の資料集&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.math.titech.ac.jp/~kawahira/courses/kiso.html"&gt;多様体の基礎のキソ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.math.titech.ac.jp/~kawahira/courses/lebesgue.pdf"&gt;ルベーグ積分の基礎のキソ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;係数をスパースにするLMSって、そういえば更新をたまにしか行わない手法もあったな。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>IGおべんきょ(2)</title><link href="/igobenkiyo2.html" rel="alternate"></link><published>2020-06-30T11:00:00+09:00</published><updated>2020-06-30T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-30:/igobenkiyo2.html</id><content type="html">&lt;p&gt;学会までには3-4章が手一杯に見える。しっかし先に進みたい。Fisher情報行列の意味付けをしないといかん。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.helsinki.fi/pages/viewpage.action?pageId=59051195"&gt;ヘルシンキ大の幾何学講義ノート？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.helsinki.fi/pages/viewpage.action?pageId=59051195&amp;amp;preview=/59051195/67371372/luku3.pdf"&gt;アフィン接続について&lt;/a&gt;
- p79の座標変換則を満たすことを証明するときの切り口として参考になった&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Information Geometry"></category></entry><entry><title>FCMの係数更新式の導出</title><link href="/fcmnoxi-shu-geng-xin-shi-nodao-chu.html" rel="alternate"></link><published>2020-06-29T17:00:00+09:00</published><updated>2020-06-29T17:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-29:/fcmnoxi-shu-geng-xin-shi-nodao-chu.html</id><summary type="html">&lt;p class="first last"&gt;FCMの係数更新式がすぐ出てこなくてムラムラした。&lt;/p&gt;
</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;FCMの目的関数:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
J = \sum_{i = 1}^{N} \sum_{j = 1}^{c} \mu_{ij}^{m} D_{ij}^{2}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで、 &lt;span class="math"&gt;\(N,c\)&lt;/span&gt; はそれぞれデータ数とクラスタ数、 &lt;span class="math"&gt;\(\mu_{ij}\)&lt;/span&gt; はファジイ係数で &lt;span class="math"&gt;\(i\)&lt;/span&gt; 番目のデータがクラスタ &lt;span class="math"&gt;\(j\)&lt;/span&gt; に持つ重みを示す。 &lt;span class="math"&gt;\(m \in [1, \infty)\)&lt;/span&gt; はファジイ度合いを決める係数で大きく取ればよりファジイ（曖昧さを許す）になる。 &lt;span class="math"&gt;\(m = 1\)&lt;/span&gt; のときはハードなクラスタリングになる（らしい）
。 &lt;span class="math"&gt;\(D_{ij}\)&lt;/span&gt; は &lt;span class="math"&gt;\(i\)&lt;/span&gt; 番目のデータと &lt;span class="math"&gt;\(j\)&lt;/span&gt; 番目のクラスタの中心との距離。&lt;/p&gt;
&lt;p&gt;各データの重みの総和は1になるように制約を課す。式で書くと&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\sum_{j = 1}^{c} \mu_{ij} = 1 \quad i = 1, ..., N
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この制約条件下でのラグランジュ関数（ラグランジアン） &lt;span class="math"&gt;\(L\)&lt;/span&gt; は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
L = \sum_{i = 1}^{N} \sum_{j = 1}^{c} \mu_{ij}^{m} D_{ij}^{2} + \sum_{i = 1}^{N} \lambda_{i} \left[ 1 - \sum_{j = 1}^{c} \mu_{ij} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる。偏微分して0とおき、最適条件を求めることを考える。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\parfrac{L}{\mu_{ij}} &amp;amp;= m \mu_{ij}^{m-1} D_{ij}^{2} - \lambda_{j} = 0 \tag{1} \\
\parfrac{L}{\lambda_{i}} &amp;amp;= 1 - \sum_{j = 1}^{c} \mu_{ij} = 0 \tag{2}
\end{align*}
&lt;/div&gt;
&lt;p&gt;より、まず(1)式から &lt;span class="math"&gt;\(\mu_{ij}\)&lt;/span&gt; について解くと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mu_{ij} = \left( \frac{\lambda_{i}}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}} = \lambda_{i}^{\frac{1}{m-1}} \left( \frac{1}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}} \tag{3}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これを(2)式に代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
1 &amp;amp;= \sum_{j=1}^{c} \mu_{ij} = \sum_{j=1}^{c} \left( \frac{\lambda_{i}}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}} \\
&amp;amp;= \lambda_{i}^{\frac{1}{m-1}} \sum_{j=1}^{c} \left( \frac{1}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}} \\
\implies \lambda_{i}^{\frac{1}{m-1}} &amp;amp;= \frac{1}{\sum_{j=1}^{c} \left( \frac{1}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}}}
\end{align*}
&lt;/div&gt;
&lt;p&gt;これを(3)式に代入すれば、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mu_{ij} &amp;amp;= \lambda_{i}^{\frac{1}{m-1}} \left( \frac{1}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}} = \frac{1}{\sum_{k=1}^{c} \left( \frac{1}{mD_{ik}^{2}} \right)^{\frac{1}{m-1}}} \left( \frac{1}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}} \\
&amp;amp;= \frac{1}{\sum_{k=1}^{c} \left( \frac{1}{mD_{ik}^{2}} \right)^{\frac{1}{m-1}} \left( \frac{1}{mD_{ij}^{2}} \right)^{-\frac{1}{m-1}}} = \frac{1}{\sum_{k=1}^{c} \left( \frac{mD_{ij}^{2}}{mD_{ik}^{2}} \right)^{\frac{1}{m-1}}} \\
&amp;amp;= \frac{1}{\sum_{k=1}^{c} \left( \frac{D_{ij}}{D_{ik}} \right)^{\frac{2}{m-1}}}
\end{align*}
&lt;/div&gt;
&lt;p&gt;最後が気持ちよかった（小並感）&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://fuzzy.cs.ovgu.de/ci/fs/fs_ch09_clustering.pdf"&gt;Fuzzy Systems Fuzzy Clustering 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://homes.di.unimi.it/~valentini/SlideCorsi/Bioinformatica05/Fuzzy-Clustering-lecture-Babuska.pdf"&gt;4 FUZZY CLUSTERING&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Fuzzy Clustering"></category></entry><entry><title>IGおべんきょ(1)</title><link href="/igobenkiyo1.html" rel="alternate"></link><published>2020-06-24T11:00:00+09:00</published><updated>2020-06-24T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-24:/igobenkiyo1.html</id><content type="html">&lt;p&gt;月内は情報幾何重視で行こう。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.grammarly.com/"&gt;英文校正サービス&lt;/a&gt; よさそう。研究会向け原稿もOverleaf上でやるべく整理するか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Information Geometry"></category></entry><entry><title>研究会に向けて(2)</title><link href="/yan-jiu-hui-nixiang-kete2.html" rel="alternate"></link><published>2020-06-22T11:00:00+09:00</published><updated>2020-06-22T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-22:/yan-jiu-hui-nixiang-kete2.html</id><content type="html">&lt;p&gt;AdaBoostのリスクがexpなのはリスクの上界を与えているから。また、更新式は学習理論p64など以下で。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.iip.ist.i.kyoto-u.ac.jp/member/keisuke/resources/11adaboost.pdf"&gt;AdaBoost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://cmp.felk.cvut.cz/~sochmj1/adaboost_talk.pdf"&gt;AdaBoost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ysk24ok.github.io/2016/09/27/hajipata-boosting.html"&gt;はじめてのパターン認識 第11章 boosting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=46B996D5722EB4734D3A7381AFBA95CE?doi=10.1.1.56.9855&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;A decision-theoretic generalication of on-line learning and application to boosting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;情報幾何本読み進め中。
美しい結果（曲線上に平行移動はすごいと思った）が次々出てくるが、リーマン曲率テンソルのテンソル性を示すのに手間取ってる。&lt;/p&gt;
&lt;p&gt;研究会に向けては、実験計画を立てておきたい。
既存研究調査を引き続きやっていき、比較対象の手法をまとめる。また、比較対象手法と、対象のデータを纏めていく。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(1)</title><link href="/yan-jiu-hui-nixiang-kete1.html" rel="alternate"></link><published>2020-06-19T11:00:00+09:00</published><updated>2020-06-19T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-19:/yan-jiu-hui-nixiang-kete1.html</id><content type="html">&lt;p&gt;今週前半は休んでいた。流石にイベント中止が連打されて精神的に余裕がなくなった。
イベントレポートをこっちに移動しようか考えている。&lt;/p&gt;
&lt;p&gt;研究の方は、研究会への申込みに着手した。
正則化はタイムアップ。将来の課題に回す。研究会の準備をしていく。
他にも、事故相関行列の計算高速化が色々試せそう。例えば、クロネッカ積に分解したり。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>逆写像定理までの整理(3)</title><link href="/ni-xie-xiang-ding-li-madenozheng-li-3.html" rel="alternate"></link><published>2020-06-13T11:00:00+09:00</published><updated>2020-06-13T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-13:/ni-xie-xiang-ding-li-madenozheng-li-3.html</id><content type="html">&lt;p&gt;記事に起こしてたら誤りなども見つかって1週間かかってしまった。。
これでようやく情報幾何学に入門できそう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Manifold"></category></entry><entry><title>逆写像定理までの整理(2)</title><link href="/ni-xie-xiang-ding-li-madenozheng-li-2.html" rel="alternate"></link><published>2020-06-07T11:00:00+09:00</published><updated>2020-06-07T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-07:/ni-xie-xiang-ding-li-madenozheng-li-2.html</id><content type="html">&lt;p&gt;ついでにラグランジュ未定乗数法とKKT条件まで行ってしまった。欲張った。
予定より断然時間かかってしまったけど、だいたい落ち着いたかも。記事に起こす。&lt;/p&gt;
</content><category term="雑記"></category><category term="Manifold"></category></entry><entry><title>逆写像定理までの整理</title><link href="/ni-xie-xiang-ding-li-madenozheng-li.html" rel="alternate"></link><published>2020-06-05T11:00:00+09:00</published><updated>2020-06-05T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-05:/ni-xie-xiang-ding-li-madenozheng-li.html</id><content type="html">&lt;p&gt;評価を待つ間逆写像定理までを写経中。だいたい飲み込めてるが、やっぱ基礎の抜けがある…。
陰関数定理はだいたいOK。ついでにラグランジュ未定乗数法の厳密な証明を与えたい。（いままでなんとなくで済ませていたので止めを刺す。）&lt;/p&gt;
</content><category term="雑記"></category><category term="Manifold"></category></entry><entry><title>正則化(8)</title><link href="/zheng-ze-hua-8.html" rel="alternate"></link><published>2020-06-04T11:00:00+09:00</published><updated>2020-06-04T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-04:/zheng-ze-hua-8.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;前日思い立った内容って既に試していて、だめなところまで見えてた。すなわち直接 &lt;span class="math"&gt;\(\mathrm{E …&lt;/span&gt;&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;前日思い立った内容って既に試していて、だめなところまで見えてた。すなわち直接 &lt;span class="math"&gt;\(\mathrm{E}[(\ve{x} + \ve{a})(\ve{x} + \ve{a})^{\mathsf{T}}]\)&lt;/span&gt; を計算する方針は試行済み。&lt;/p&gt;
&lt;p&gt;色々探しているうちに、K-FACという自然勾配学習法の近似手法を見つける。クロネッカ積を使ってフィッシャー情報行列を分解しようというアイデアだ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://medium.com/&amp;#64;osawa1021/k-fac%E3%81%A8%E3%81%AF-de30537f7096"&gt;K-FACとは？ 大規模深層学習のための二次最適化の実現&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;これはすごい。少し前にクロネッカ積で計算できるんじゃないの？とは指摘もらってたけど、普通にメジャーな手法だ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/pjsai/JSAI2017/0/JSAI2017_1A2OS05b4/_pdf/-char/ja"&gt;自然勾配近似法を起点としたバッチ正規化の数理的理解&lt;/a&gt; に近似手法が挙げられている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1810.12281.pdf"&gt;THREE MECHANISMS OF WEIGHT DECAY REGULARIZATION&lt;/a&gt; でWeight Decayの文脈でL2正則化学習則が示されている。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1512.04202.pdf"&gt;Preconditioned Stochastic Gradient Descent&lt;/a&gt; Precondition行列で勾配を更新する方法。ちょっと待て、自然勾配とちょっと違う。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.mdpi.com/2076-3417/9/21/4568/pdf"&gt;Adaptive Natural Gradient Method for Learning of Stochastic Neural Networks in Mini-Batch Mode&lt;/a&gt; ではMatrix cookbookの(191)を使って行列に対する正則化を行っている。&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\((\ve{Q} + \sigma^{2}\ve{M})^{-1} \approx \ve{Q}^{-1} - \sigma^{2}\ve{Q}^{-1}\ve{M}\ve{Q}^{-1}\ (\sigma\text{ is small})\)&lt;/span&gt; という近似。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;逆写像定理までをおべんきょ中。まだ陰関数定理の途中。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(7)</title><link href="/zheng-ze-hua-7.html" rel="alternate"></link><published>2020-06-03T11:00:00+09:00</published><updated>2020-06-03T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-03:/zheng-ze-hua-7.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.math.uwaterloo.ca/~hwolkowi/matrixcookbook.pdf"&gt;Matrix cookbook&lt;/a&gt; を眺めていたら有益そうな等式を見つける。 &lt;span class="math"&gt;\(E[\ve …&lt;/span&gt;&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.math.uwaterloo.ca/~hwolkowi/matrixcookbook.pdf"&gt;Matrix cookbook&lt;/a&gt; を眺めていたら有益そうな等式を見つける。 &lt;span class="math"&gt;\(E[\ve{x}] = \ve{m}\)&lt;/span&gt; として、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mathrm{E}[(\ve{x} + \ve{a})(\ve{x} + \ve{a})^{\mathsf{T}}] &amp;amp;= \mathrm{E}[\ve{x}\ve{x}^{\mathsf{T}} + \ve{x}\ve{a}^{\mathsf{T}} + \ve{a}\ve{x}^{\mathsf{T}} + \ve{a}\ve{a}^{\mathsf{T}}] \\
&amp;amp;= \mathrm{E}[\ve{x}\ve{x}^{\mathsf{T}} - \ve{x}\ve{m}^{\mathsf{T}} - \ve{m}\ve{x}^{\mathsf{T}} + \ve{m}\ve{m}^{\mathsf{T}} + \ve{x}\ve{m}^{\mathsf{T}} + \ve{m}\ve{x}^{\mathsf{T}} - \ve{m}\ve{m}^{\mathsf{T}} + \ve{x}\ve{a}^{\mathsf{T}} + \ve{a}\ve{x}^{\mathsf{T}} + \ve{a}\ve{a}^{\mathsf{T}}] \\
&amp;amp;= \mathrm{E}[\ve{x}\ve{x}^{\mathsf{T}} - \ve{x}\ve{m}^{\mathsf{T}} - \ve{m}\ve{x}^{\mathsf{T}} + \ve{m}\ve{m}^{\mathsf{T}}] + \ve{m}\ve{m}^{\mathsf{T}} + \ve{m}\ve{m}^{\mathsf{T}} - \ve{m}\ve{m}^{\mathsf{T}} + \ve{m}\ve{a}^{\mathsf{T}} + \ve{a}\ve{m}^{\mathsf{T}} + \ve{a}\ve{a}^{\mathsf{T}} \\
&amp;amp;= \mathrm{E}[(\ve{x} - \ve{m})(\ve{x} - \ve{m})^{\mathsf{T}}] + \ve{m}\ve{m}^{\mathsf{T}} + \ve{m}\ve{a}^{\mathsf{T}} + \ve{a}\ve{m}^{\mathsf{T}} + \ve{a}\ve{a}^{\mathsf{T}} \\
&amp;amp;= \mathrm{E}[(\ve{x} - \ve{m})(\ve{x} - \ve{m})^{\mathsf{T}}] + (\ve{m} + \ve{a})(\ve{m} + \ve{a})^{\mathsf{T}} \\
&amp;amp;= \mathrm{E}[\ve{x}\ve{x}^{\mathsf{T}}] - \ve{m}\ve{m}^{\mathsf{T}} + (\ve{m} + \ve{a})(\ve{m} + \ve{a})^{\mathsf{T}}
\end{align*}
&lt;/div&gt;
&lt;p&gt;が成立する。 &lt;span class="math"&gt;\(\ve{a}\)&lt;/span&gt; を正則化で出てくるベクトルとすると、割と有益に見える。しかも &lt;span class="math"&gt;\(\ve{m} = \ve{0}\)&lt;/span&gt; とできるならばもっとさっぱりする。&lt;/p&gt;
&lt;p&gt;早速手元のデータで &lt;span class="math"&gt;\(\ve{m} = \ve{0}\)&lt;/span&gt; とならないか、つまり、勾配 &lt;span class="math"&gt;\(\mathrm{sign}[\varepsilon(n)]\ve{x}(n)\)&lt;/span&gt; の平均が &lt;span class="math"&gt;\(\ve{0}\)&lt;/span&gt; にならないか観察したけど、成り立っていなそう。。。長時間平均をとっても収束している感じはしない。（自然勾配は、当然 &lt;span class="math"&gt;\(\ve{0}\)&lt;/span&gt; に漸近する傾向あり。学習が進んでいるから当然。）&lt;/p&gt;
&lt;p&gt;平均 &lt;span class="math"&gt;\(\ve{m}\)&lt;/span&gt; を逐次推定すれば良さそうで、試してみたい。しかし今は情報幾何もやるのだ。明日やる。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(6)</title><link href="/zheng-ze-hua-6.html" rel="alternate"></link><published>2020-05-31T11:00:00+09:00</published><updated>2020-05-31T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-31:/zheng-ze-hua-6.html</id><content type="html">&lt;p&gt;残った課題をやってたら土日が飛ぶ。ついでにカサゴ本を読み切る。
6月からは英語のおべんきょうをしようかと思っている。同時に情報幾何も進める。
早いところ進捗を見てもらいたいが、まだ無理っぽい。。。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://solid4.mech.okayama-u.ac.jp/%E3%83%86%E3%83%B3%E3%82%BD%E3%83%AB.pdf"&gt;テンソル&lt;/a&gt; テンソルの定義。分かりやすい説明。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(5)</title><link href="/zheng-ze-hua-5.html" rel="alternate"></link><published>2020-05-30T11:00:00+09:00</published><updated>2020-05-30T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-30:/zheng-ze-hua-5.html</id><content type="html">&lt;p&gt;課題やってたら木金が飛んだ。。。&lt;/p&gt;
&lt;p&gt;古い資料を漁ってたら、SPSA（Simultaneous perturbation stochastic approximation）が掘り返された。たしかシステム同定で使ったよな。なんか面白いかも知んない。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(4)</title><link href="/zheng-ze-hua-4.html" rel="alternate"></link><published>2020-05-27T11:00:00+09:00</published><updated>2020-05-27T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-27:/zheng-ze-hua-4.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;引き続きMAP推定における自然勾配を調査する。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1712.02390.pdf"&gt;Noisy Natural Gradient as …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;引き続きMAP推定における自然勾配を調査する。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1712.02390.pdf"&gt;Noisy Natural Gradient as Variational Inference&lt;/a&gt; の式(5)からスタートするも…はっきりしたことを言ってないように見える。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bsi-ni.brain.riken.jp/database/file/215/221.pdf"&gt;Adaptive natural gradient learning algorithms for various stochastic models&lt;/a&gt; これの式(5)も参考になりそう。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1803.09151.pdf"&gt;Natural Gradients in Practice: Non-Conjugate Variational Inference in Gaussian Process Models&lt;/a&gt; 指数族の事後確率最大化を考える。フィッシャー情報行列を計算するための平均のとり方が妙。もうちょっと読みたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(3)</title><link href="/zheng-ze-hua-3.html" rel="alternate"></link><published>2020-05-26T11:00:00+09:00</published><updated>2020-05-26T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-26:/zheng-ze-hua-3.html</id><summary type="html">&lt;p&gt;実装の整理できて、正則化込で動かしているけど芳しくない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;正則化入れたらRMSが悪化。しかも、正則化係数を十分小さく取らないと誤差が大きくなる。&lt;/li&gt;
&lt;li&gt;タップ数が多い場合は多少の効果あり。&lt;ul&gt;
&lt;li&gt;タップ数が少ない（〜16個）のときは旨味が無いように思える。係数がスパースじゃないのでは。&lt;/li&gt;
&lt;li&gt;試しに128個とかにしたら少しの改善が見られた。けど適応が遅くて正則化なしでもRMSが悪い。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;フィッシャー情報行列固定で、勾配だけ正則化かける方は発散していく。&lt;/li&gt;
&lt;li&gt;ついでにLMSでも自然勾配法試してみたけど、SignedLMSの自然勾配よりもRMSが悪い。&lt;/li&gt;
&lt;li&gt;もう一度適応的自然勾配学習法を試したけど、十分に係数を小さく取らないと発散するし、小さくとっても性能が悪い。フィッシャー情報行列はちゃんと更新するべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なんで正則化したら性能落ちるのか？をもっと考えていたら、パラメータの事前分布を入れた瞬間に計量がさらに歪んでいそう（単純な残差の分散ではダメそう）。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1712.02390.pdf"&gt;Noisy Natural Gradient as Variational Inference&lt;/a&gt; の式(5)。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.luigimalago.it/papers/2013GSI.pdf"&gt;Robust Estimation of Natural Gradient in Optimization by Regularized Linear Regression&lt;/a&gt; 線形回帰における正則化に触れている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ipvs.informatik.uni-stuttgart.de/mlr/papers/05-igel-Rprop.pdf"&gt;Rprop Using the Natural Gradient&lt;/a&gt; パラメータの正則化ではない …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;実装の整理できて、正則化込で動かしているけど芳しくない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;正則化入れたらRMSが悪化。しかも、正則化係数を十分小さく取らないと誤差が大きくなる。&lt;/li&gt;
&lt;li&gt;タップ数が多い場合は多少の効果あり。&lt;ul&gt;
&lt;li&gt;タップ数が少ない（〜16個）のときは旨味が無いように思える。係数がスパースじゃないのでは。&lt;/li&gt;
&lt;li&gt;試しに128個とかにしたら少しの改善が見られた。けど適応が遅くて正則化なしでもRMSが悪い。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;フィッシャー情報行列固定で、勾配だけ正則化かける方は発散していく。&lt;/li&gt;
&lt;li&gt;ついでにLMSでも自然勾配法試してみたけど、SignedLMSの自然勾配よりもRMSが悪い。&lt;/li&gt;
&lt;li&gt;もう一度適応的自然勾配学習法を試したけど、十分に係数を小さく取らないと発散するし、小さくとっても性能が悪い。フィッシャー情報行列はちゃんと更新するべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なんで正則化したら性能落ちるのか？をもっと考えていたら、パラメータの事前分布を入れた瞬間に計量がさらに歪んでいそう（単純な残差の分散ではダメそう）。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1712.02390.pdf"&gt;Noisy Natural Gradient as Variational Inference&lt;/a&gt; の式(5)。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.luigimalago.it/papers/2013GSI.pdf"&gt;Robust Estimation of Natural Gradient in Optimization by Regularized Linear Regression&lt;/a&gt; 線形回帰における正則化に触れている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ipvs.informatik.uni-stuttgart.de/mlr/papers/05-igel-Rprop.pdf"&gt;Rprop Using the Natural Gradient&lt;/a&gt; パラメータの正則化ではない。フィッシャー情報行列に正則化パラメータを乗じた単位行列を足して逆行列を求めている。なんでも、正則化パラメータが大きければ普通の勾配法に近づくとのこと。そのとおりだが、一体どういう発想なんだろう。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1703.00209.pdf"&gt;Online Natural Gradient as a Kalman Filter&lt;/a&gt; ドンピシャであった（Proposition 4）けどだいぶ複雑。しかも、自然勾配法とカルマンフィルタの関係性を示している。カルマンフィルタのノイズの事前分布を取り入れている。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あがいてたら適応的自然勾配の近似計算があった。計算負荷削減に有益そう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://papers.nips.cc/paper/3234-topmoumoute-online-natural-gradient-algorithm.pdf"&gt;Topmoumoute online natural gradient algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(2)</title><link href="/zheng-ze-hua-2.html" rel="alternate"></link><published>2020-05-25T11:00:00+09:00</published><updated>2020-05-25T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-25:/zheng-ze-hua-2.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;まだ悩んでいる。今は &lt;span class="math"&gt;\(\ve{R}^{-1 …&lt;/span&gt;&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;まだ悩んでいる。今は &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を直接計算してるので、正則化込みの結果（ &lt;span class="math"&gt;\((\ve{R} + \lambda\ve{I})^{-1}\)&lt;/span&gt; ）になっていない。この式を近似でもいいから計算できないか？&lt;/p&gt;
&lt;p&gt;なんかうまくいきそうなんだけど、定式化にあたって一つ疑問が： &lt;strong&gt;自然勾配って一般の損失関数にも使えるのか？&lt;/strong&gt;
対数尤度を損失関数に使った場合は、無論自然勾配になるけど、一般の損失関数の場合、フィッシャー情報行列と損失関数の勾配が噛み合わない気がする。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1808.07172.pdf"&gt;Fisher Information and Natural Gradient Learning of Random Deep Networks&lt;/a&gt; 甘利先生の論文だけど一般の損失に適用しているように見える&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.76.7538&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Why Natural Gradient?&lt;/a&gt; &lt;strong&gt;→大丈夫っぽい。ちゃんと読もう。&lt;/strong&gt; 簡単な例（極座標系）で示している。普通の勾配はユークリッド空間上になるけど、極座標の逆行列を乗じて自然勾配を得ている。&lt;ul&gt;
&lt;li&gt;とは言っても目的関数の構造を適切に表していないと、性能が悪そうに見える。対数尤度以外でどういうときに有効なんだ？&lt;/li&gt;
&lt;li&gt;試してみるしかない？つまり、勾配分散を毎回求める必要があるのか、それとも、一つの計量を複数の損失関数で使い回せるかやってみる。&lt;/li&gt;
&lt;li&gt;もう少し考えた。やっぱり正則化項を入れると損失関数の勾配は歪んでくると思う。だから、正則化項も含めてフィッシャー情報行列を計算しなければいかんと思う。ていうか、もはやフィッシャー情報行列は勾配の分散でしか無いように見えてきた。やり方としては、パラメータの事前分布にガウスorラプラス分布を入れて、そいつの対数尤度をとって最適化問題を考える。フィッシャー情報行列の式変形が難しくなるけど、そんなことは無視して（考察の余地はあるけど）逆行列補題でストレートにフィッシャー情報行列の逆行列を計算できる。&lt;ul&gt;
&lt;li&gt;ようはMAP推定。 &lt;span class="math"&gt;\(\max p(\ve{x} | \ve{\theta}) p(\ve{\theta})\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(p(\ve{x} | \ve{\theta})\)&lt;/span&gt; は誤差分布、 &lt;span class="math"&gt;\(p(\ve{\theta})\)&lt;/span&gt; はパラメータ事前分布。&lt;span class="math"&gt;\(p(\ve{\theta}) = \exp(-\beta ||\ve{\theta}||_{2}), \exp(-\beta ||\ve{\theta}||_{1})\)&lt;/span&gt; なり何でもあり。対数とって勾配の分散をとればフィッシャー情報行列が求まる。&lt;/li&gt;
&lt;li&gt;試すこともできると思うのでやってみたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(1)</title><link href="/zheng-ze-hua-1.html" rel="alternate"></link><published>2020-05-24T11:00:00+09:00</published><updated>2020-05-24T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-24:/zheng-ze-hua-1.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;逆行列補題を使えば、どんな自然勾配法でも上手く動きそうな気がしてきた…。
勾配の分散行列を逐次的に求められるから相当強い。
自己相関行列であることはそんなに重要でもないかも。。。。でも評価待ちましょう …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;逆行列補題を使えば、どんな自然勾配法でも上手く動きそうな気がしてきた…。
勾配の分散行列を逐次的に求められるから相当強い。
自己相関行列であることはそんなに重要でもないかも。。。。でも評価待ちましょう。。。&lt;/p&gt;
&lt;p&gt;一方で今日から正則化をどうすればいいか考えている。答えはフィッシャー情報行列に &lt;span class="math"&gt;\(\lambda \ve{I}\)&lt;/span&gt; を足すだけなんだが、意味づけというか解釈が上手くできない。どういう損失関数ならばフィッシャー情報行列に単位行列を足す形になるのか。。。&lt;/p&gt;
&lt;p&gt;SignedLMSで試したけど難航中。どうしても &lt;span class="math"&gt;\(\mathrm{sign}[\varepsilon(n)]\ve{x}(n)\)&lt;/span&gt; との積をとる項が出てきて、その平均がどうなるかわからない。。。&lt;/p&gt;
&lt;p&gt;実験的に勾配に係数ベクトルを足すなり係数の符号ベクトルを足すなりしてるけど、
正則化パラメータをめちゃくちゃ小さく取らないと結果が発散する…。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>成果まとめ中(5) / 自然勾配法の概観</title><link href="/cheng-guo-matomezhong-5-zi-ran-gou-pei-fa-nogai-guan.html" rel="alternate"></link><published>2020-05-23T11:00:00+09:00</published><updated>2020-05-23T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-23:/cheng-guo-matomezhong-5-zi-ran-gou-pei-fa-nogai-guan.html</id><content type="html">&lt;p&gt;昨日まで苦悩しつつ収束条件をまとめた（運良く見つけることができた。同時にNLMSの収束条件も掴んだ。）
でも、同時に新規性が無い気がしてきた。発見となるのは、SignedLMSのフィッシャー情報行列が自己相関行列になっているくらいか？
適応ステップサイズ導出後は、普通のフィッシャー情報行列込みのNLMSと全く同じだし。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>成果まとめ中(4)</title><link href="/cheng-guo-matomezhong-4.html" rel="alternate"></link><published>2020-05-21T23:00:00+09:00</published><updated>2020-05-21T23:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-21:/cheng-guo-matomezhong-4.html</id><content type="html">&lt;p&gt;AdaptiveFilterの本見てNLMSの議論を色々見てる。が、いい結果が出てこない。
本の内容も掴みかねてる。NLMSは係数誤差ベクトルのL2ノルムが指数的に減少するようだが本当か…？&lt;/p&gt;
&lt;p&gt;LMSの収束条件が分かっていないことに気づく。
「Adaptive Filter Theory」では式4.22に、「Adaptive Signal Processing」では式4.45で示されているので確認中。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>成果まとめ中(3)</title><link href="/cheng-guo-matomezhong-3.html" rel="alternate"></link><published>2020-05-20T23:00:00+09:00</published><updated>2020-05-20T23:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-20:/cheng-guo-matomezhong-3.html</id><summary type="html">&lt;p&gt;SGD（確率的最急勾配法）の収束レートが少し気になったのちょっと観察。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/bjsiam/28/3/28_27/_pdf"&gt;機械学習における確率的最適化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もっと初等的な説明があると良いなあ。確率1で極値に収束したような気がしている…。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;適応ステップサイズの分母の &lt;span class="math"&gt;\(\ve{x}(n)^{\mathsf{T}}\ve{R}^{-1}\ve{x}(n)\)&lt;/span&gt; がめちゃくちゃ気になって止まる。学習理論に「例えばパラメタ空間上のベクトル &lt;span class="math"&gt;\(x(\theta)\)&lt;/span&gt; の内積 &lt;span class="math"&gt;\(\innerp{x …&lt;/span&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;SGD（確率的最急勾配法）の収束レートが少し気になったのちょっと観察。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/bjsiam/28/3/28_27/_pdf"&gt;機械学習における確率的最適化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もっと初等的な説明があると良いなあ。確率1で極値に収束したような気がしている…。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;適応ステップサイズの分母の &lt;span class="math"&gt;\(\ve{x}(n)^{\mathsf{T}}\ve{R}^{-1}\ve{x}(n)\)&lt;/span&gt; がめちゃくちゃ気になって止まる。学習理論に「例えばパラメタ空間上のベクトル &lt;span class="math"&gt;\(x(\theta)\)&lt;/span&gt; の内積 &lt;span class="math"&gt;\(\innerp{x}{x}\)&lt;/span&gt; は、座標変換により不変な量として定義するならば &lt;span class="math"&gt;\(x^{\prime}(g_{ij}(\theta))^{-1}x\)&lt;/span&gt; となる。」（なるべく原文ママ）と言ってて、まさにこの不変な量を指していると思っている。&lt;/p&gt;
&lt;p&gt;これどういうこと？と思って探し始めたら沼。相対性理論にぶつかる。わかりやすかったのは下くらいか？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://yuru2physics.blog.fc2.com/blog-entry-99.html"&gt;内積が不変という意味&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://fnorio.com/0180covariant_contravariant/covariant_contravariant.html#3-6"&gt;(6)ベクトル内積の座標変換不変性の確認&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;情報幾何の観点からすると、幾何的に微小線素は座標変換によって値を全く変えないことが重要らしい。&lt;span class="math"&gt;\(\ve{x}(n)\)&lt;/span&gt; をパラメタ空間上のベクトルと捉えると、&lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; はパラメタ空間上の計量（元の空間の計量は:math:&lt;cite&gt;ve{R}&lt;/cite&gt; ）を定め、&lt;span class="math"&gt;\(\ve{x}(n)^{\mathsf{T}}\ve{R}^{-1}\ve{x}(n)\)&lt;/span&gt; はパラメタ空間上のノルムを計算していて、ノルムだから不変でしょっていう議論になる？まだピンとこない。&lt;/p&gt;
&lt;p&gt;あと、AdaptiveFilterの本見てNLMSの議論を色々見てる。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>成果まとめ中(2)</title><link href="/cheng-guo-matomezhong-2.html" rel="alternate"></link><published>2020-05-19T11:00:00+09:00</published><updated>2020-05-19T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-19:/cheng-guo-matomezhong-2.html</id><content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://dsl4.eee.u-ryukyu.ac.jp/DOCS/DSP/p10.pdf"&gt;ディジタル信号処理 第 10 回 適応信号処理&lt;/a&gt; 少し詳しく書いてある。やはり適応フィルタの原典を当たりたい。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>書類整理終わり、復帰 / 成果まとめ中(1)</title><link href="/shu-lei-zheng-li-zhong-wari-fu-gui-cheng-guo-matomezhong-1.html" rel="alternate"></link><published>2020-05-18T11:00:00+09:00</published><updated>2020-05-18T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-18:/shu-lei-zheng-li-zhong-wari-fu-gui-cheng-guo-matomezhong-1.html</id><content type="html">&lt;p&gt;諸々の提出書類で実験できず。1週間空けて復帰。&lt;/p&gt;
&lt;p&gt;報告書類を書いていたら、やっぱりフィッシャー情報行列とヘッセ行列の違いがよくわからなくなってきた。
対数尤度のヘッセ行列とフィッシャー情報行列に何かしらの共通点があるはず。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.inference.vc/on-empirical-fisher-information/"&gt;Notes on the Limitations of the Empirical Fisher Approximation&lt;/a&gt; 経験フィッシャー行列の性能限界について。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ヘッセ行列のくだりから自然勾配の導出まで、紙に証明をまとめた。明日辺りに記事に起こす。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>LMS Filterの挙動観察中(10)</title><link href="/lms-filternoju-dong-guan-cha-zhong-10.html" rel="alternate"></link><published>2020-05-06T11:00:00+09:00</published><updated>2020-05-06T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-06:/lms-filternoju-dong-guan-cha-zhong-10.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Normalizeするやつの意味付けを追っている。非常にRLS(Recursive Least Square)に近い、下手するとRLSそのものかも知れない。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align …&lt;/script&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Normalizeするやつの意味付けを追っている。非常にRLS(Recursive Least Square)に近い、下手するとRLSそのものかも知れない。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>書類整理中</title><link href="/shu-lei-zheng-li-zhong.html" rel="alternate"></link><published>2020-05-06T11:00:00+09:00</published><updated>2020-05-06T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-06:/shu-lei-zheng-li-zhong.html</id><content type="html">&lt;p&gt;色々と書類整理しているためあんまり実験が進んでいない。でも、既存研究がありそうでヒヤヒヤする毎日。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://scholarsmine.mst.edu/cgi/viewcontent.cgi?article=2780&amp;amp;context=ele_comeng_facwork"&gt;Normalized Natural Gradient Adaptive Filtering for Sparse and Nonsparse Systems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;かなり近い。が、LMSベースの計量を自ら設計している。コスト関数に、2乗誤差項に何か変換のL2ノルムを加算しており、それに対しての自然勾配を求めている。そうか、コスト関数の自然勾配を考えればいいのか。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/bf3b/fe757d9156cc863ffdde15b1664c337819bd.pdf"&gt;Proportionate Normalized Least-Mean-Squares Adaptation in Echo Cancelers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自然勾配の発想に近づいていたPNLMSの実装&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.eecs.umich.edu/global/data/hero/images/7/7b/Yilun-icassp2-09.pdf"&gt;SPARSE LMS FOR SYSTEM IDENTIFICATION&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;スパースLMS(ZA-LMS)の最初の論文。定式化が明確。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>LMS Filterの挙動観察中(9)</title><link href="/lms-filternoju-dong-guan-cha-zhong-9.html" rel="alternate"></link><published>2020-05-05T11:00:00+09:00</published><updated>2020-05-05T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-05:/lms-filternoju-dong-guan-cha-zhong-9.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;実装誤りを見直しながらもう一度。&lt;/p&gt;
&lt;p&gt;やはり、自然勾配法が何故うまくいくのか、更新式の導出までやったほうが宜しい。実装間違いするから。適応的自然勾配の更新式は微小量の近似を使っている。微小量の近似は今まで何度も避けてきたが、この際おさらいする。ようはテイラー展開して2次以降の項を打ち切れば良し。高校数学レベルの話。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://physnotes.jp/foundations/approximation/"&gt;近似式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://w3e.kanazawa-it.ac.jp/math/category/suuretu/maclaurin/henkan-tex.cgi?target=/math/category/suuretu/maclaurin/maclaurin_1-x.html"&gt;1/(1-x)のマクローリン展開&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実験が落ち着いたら書いていきたい。&lt;/p&gt;
&lt;p&gt;→実験OK。ステップサイズの設定が難しかったけど、ナイーブなものよりは性能がよいはず。&lt;/p&gt;
&lt;p&gt;また、軽く見た感じでも自然勾配学習法は発散しやすい。以下の記事にあるように、正則化を掛けたほうが良さそう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://tfjgeorge.github.io/articles/note/2018/11/09/empirical-fisher.html"&gt;What is the empirical …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;実装誤りを見直しながらもう一度。&lt;/p&gt;
&lt;p&gt;やはり、自然勾配法が何故うまくいくのか、更新式の導出までやったほうが宜しい。実装間違いするから。適応的自然勾配の更新式は微小量の近似を使っている。微小量の近似は今まで何度も避けてきたが、この際おさらいする。ようはテイラー展開して2次以降の項を打ち切れば良し。高校数学レベルの話。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://physnotes.jp/foundations/approximation/"&gt;近似式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://w3e.kanazawa-it.ac.jp/math/category/suuretu/maclaurin/henkan-tex.cgi?target=/math/category/suuretu/maclaurin/maclaurin_1-x.html"&gt;1/(1-x)のマクローリン展開&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実験が落ち着いたら書いていきたい。&lt;/p&gt;
&lt;p&gt;→実験OK。ステップサイズの設定が難しかったけど、ナイーブなものよりは性能がよいはず。&lt;/p&gt;
&lt;p&gt;また、軽く見た感じでも自然勾配学習法は発散しやすい。以下の記事にあるように、正則化を掛けたほうが良さそう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://tfjgeorge.github.io/articles/note/2018/11/09/empirical-fisher.html"&gt;What is the empirical Fisher ?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ヘッセ行列の計算は少し回り道になったが、理論的最適値との比較において議論できそう。&lt;/p&gt;
&lt;p&gt;逆行列補題を使っていて、最早カルマンフィルタやRLSに近いんでないかと思えてきた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.bode.amp.i.kyoto-u.ac.jp/~kashima/lecture/ss/slide17_8.pdf"&gt;信号とシステム 第6章 適応フィルタ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.tut.fi/~tabus/course/ASP/LectureNew10.pdf"&gt;Recursive Least Squares Estimation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;にLMSからRLSまで記述あり。&lt;/p&gt;
&lt;p&gt;上の「信号とシステム」を眺めていたら、NLMSにおける適応的ステップサイズ決定則が使えそうな印象。NLMSは事後誤差 &lt;span class="math"&gt;\(e^{+}(k)\)&lt;/span&gt; を0にするように適応的なステップサイズ &lt;span class="math"&gt;\(\alpha(k)\)&lt;/span&gt; を定める。普通のSigned-LMSでは、リファレンス信号 &lt;span class="math"&gt;\(d(k)\)&lt;/span&gt;, フィルタ係数 &lt;span class="math"&gt;\(\ve{h}(k)\)&lt;/span&gt;, 入力データ &lt;span class="math"&gt;\(\ve{x}(k)\)&lt;/span&gt; に対し、事後誤差は次のように展開できる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
e^{+}(k) &amp;amp;= d(k) - \innerp{\ve{h}(k+1)}{\ve{x}(k)} \\
&amp;amp;= d(k) - \innerp{\ve{h}(k) + \alpha(k) \mathrm{sign}[e(k)] \ve{x}(k)}{\ve{x}(k)} \\
&amp;amp;= d(k) - \innerp{\ve{h}(k)}{\ve{x}(k)} - \alpha(k) \mathrm{sign}[e(k)] \innerp{\ve{x}(k)}{\ve{x}(k)} \\
&amp;amp;= e(k) - \alpha(k) \mathrm{sign}[e(k)] ||\ve{x}(k)||_{2}^{2}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(e^{+}(k) = 0\)&lt;/span&gt; となるように &lt;span class="math"&gt;\(\alpha(k)\)&lt;/span&gt; を選ぶと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\alpha(k) = \frac{e(k)}{\mathrm{sign}[e(k)] ||\ve{x}(k)||_{2}^{2}} = \frac{|e(k)|}{||\ve{x}(k)||_{2}^{2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;として、事後誤差を最小にするステップサイズが求まった。（Signed-LMSでこういう議論があんまり見られないのはなぜだ？&lt;strong&gt;この&lt;/strong&gt; &lt;span class="math"&gt;\(\alpha(k)\)&lt;/span&gt; &lt;strong&gt;をSigned-LMSの更新則に突っ込むとNLMSになる&lt;/strong&gt; ）&lt;/p&gt;
&lt;p&gt;自然勾配を使った場合が有益（ステップサイズ設定つらい）なので、求めてみると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
e^{+}(k) &amp;amp;= d(k) - \innerp{\ve{h}(k+1)}{\ve{x}(k)} \\
&amp;amp;= d(k) - \innerp{\ve{h}(k) + \alpha(k) \mathrm{sign}[e(k)] \ve{F}(k)^{-1} \ve{x}(k)}{\ve{x}(k)} \\
&amp;amp;= d(k) - \innerp{\ve{h}(k)}{\ve{x}(k)} - \alpha(k) \mathrm{sign}[e(k)] \innerp{\ve{F}(k)^{-1}\ve{x}(k)}{\ve{x}(k)} \\
&amp;amp;= e(k) - \alpha(k) \mathrm{sign}[e(k)] \innerp{\ve{x}(k)}{\ve{F}(k)^{-1}\ve{x}(k)}
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\alpha(k) = \frac{e(k)}{\mathrm{sign}[e(k)] \innerp{\ve{x}}{\ve{F}(k)^{-1}\ve{x}(k)}} = \frac{|e(k)|}{\innerp{\ve{x}(k)}{\ve{F}(k)^{-1}\ve{x}(k)}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が得られる。これは計量としてフィッシャー情報行列の逆行列を使った時の &lt;span class="math"&gt;\(\ve{x}(k)\)&lt;/span&gt; のノルムによる正規化に対応する。すると残差の絶対値が外れる。NLMSとかなり近いけど計量が入っているところが違う。&lt;/p&gt;
&lt;p&gt;実装してみたら実験でも音源に依存せず安定している印象（注意！ノイズのない正弦波で発散した！おそらく、情報行列の要素が全て同一で特異になっている。）。&lt;/p&gt;
&lt;p&gt;結果の意味付けが非常に大事な気がする。資料35pあたりの議論を当てはまると、何か幾何的な解釈が出てくるはずだ。改めて、ここらへんの議論って誰かやっていないか、気になる。明日はそこを考えてみる。改めて既存研究が無いか見て、報告に移そうか。&lt;/p&gt;
&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Normalizeするやつの結果の意味付け&lt;/li&gt;
&lt;li&gt;忘却係数として捉えれば式が簡単にならんか？ &lt;span class="math"&gt;\((\lambda \ve{F} + \ve{x}\ve{x}^{\mathsf{T}})^{-1}\)&lt;/span&gt; で &lt;span class="math"&gt;\(0 &amp;lt; \lambda &amp;lt; 1\)&lt;/span&gt; は1に近い係数。&lt;/li&gt;
&lt;li&gt;自然勾配法がなんでうまくいくのか &lt;a class="reference external" href="https://wiseodd.github.io/techblog/2018/03/14/natural-gradient/"&gt;Natural Gradient Descent&lt;/a&gt; を訳しながら理解していく。 &lt;a class="reference external" href="https://arxiv.org/pdf/1412.1193.pdf"&gt;New insights and perspectives on the natural gradient method&lt;/a&gt; も参考になりそう。&lt;/li&gt;
&lt;li&gt;RLS(Recursive Least Square)の更新式の誤差に符号関数を被せたものが、自分が導いているものかも知れないと思い立つ。確認。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>LMS Filterの挙動観察中(8)</title><link href="/lms-filternoju-dong-guan-cha-zhong-8.html" rel="alternate"></link><published>2020-05-04T11:00:00+09:00</published><updated>2020-05-04T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-04:/lms-filternoju-dong-guan-cha-zhong-8.html</id><summary type="html">&lt;p&gt;まだ粘る。GW終わるまでには何らかのアウトプットがほしい。&lt;/p&gt;
&lt;p&gt;指数移動平均のαを増やすと性能（誤差、エントロピー）が悪化する傾向あり。特に0.5以上（瞬間値の重みを大きく）すると、悪化が顕著。&lt;/p&gt;
&lt;p&gt;分散行列の逆行列を見てみると、非常に大きい値を取っていることが分かる。これは特異にかなり近いのではないかと予測している。&lt;/p&gt;
&lt;p&gt;また、指数移動平均で求めた分散行列の対角要素は経験分散に漸近するはずで、対角要素は時間遅延が加わった自分自身との2乗和で、全てが同じ値になることを期待していたが、なっていなかった。これは、指数移動平均は入力の順序により最終結果が異なるという状態が現れていると思う。（例：1,1,1,0 という系列と 0,1,1,1 という系列では指数移動平均の結果が異なる。）&lt;/p&gt;
&lt;p&gt;学習率の設定も音源依存でだいぶ変わってしまう印象。ボイスでは 0.0001 が、ピアノでは 0.00001、50Hzサイン波では発散した（恐らくこれはほぼ定常な信号になっているからと思われる。定常な信号では全ての分散と共分散が同じ値になって、行列が特異になる。正則化（分散行列に定数を掛けた単位行列を加算）を行ったら安定した...）&lt;/p&gt;
&lt;p&gt;行き詰まりを感じ、適応的自然勾配の更新式を逆行列補題（Woodburyの恒等式 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;まだ粘る。GW終わるまでには何らかのアウトプットがほしい。&lt;/p&gt;
&lt;p&gt;指数移動平均のαを増やすと性能（誤差、エントロピー）が悪化する傾向あり。特に0.5以上（瞬間値の重みを大きく）すると、悪化が顕著。&lt;/p&gt;
&lt;p&gt;分散行列の逆行列を見てみると、非常に大きい値を取っていることが分かる。これは特異にかなり近いのではないかと予測している。&lt;/p&gt;
&lt;p&gt;また、指数移動平均で求めた分散行列の対角要素は経験分散に漸近するはずで、対角要素は時間遅延が加わった自分自身との2乗和で、全てが同じ値になることを期待していたが、なっていなかった。これは、指数移動平均は入力の順序により最終結果が異なるという状態が現れていると思う。（例：1,1,1,0 という系列と 0,1,1,1 という系列では指数移動平均の結果が異なる。）&lt;/p&gt;
&lt;p&gt;学習率の設定も音源依存でだいぶ変わってしまう印象。ボイスでは 0.0001 が、ピアノでは 0.00001、50Hzサイン波では発散した（恐らくこれはほぼ定常な信号になっているからと思われる。定常な信号では全ての分散と共分散が同じ値になって、行列が特異になる。正則化（分散行列に定数を掛けた単位行列を加算）を行ったら安定した...）&lt;/p&gt;
&lt;p&gt;行き詰まりを感じ、適応的自然勾配の更新式を逆行列補題（Woodburyの恒等式）から導いていた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mathtrain.jp/woodbury"&gt;逆行列の補助定理（Woodburyの恒等式）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://sigmagic.net/math/inverse-mat/"&gt;逆行列の公式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そのときに、論文では勾配ベクトルの分散行列を求めていることに気づく。そして自分が間違っている事がわかった。
情報行列は勾配ベクトルの分散行列だった。（データベクトルの分散行列ではない...）
いままで入力データの分散行列を計算していたので、これは明確な誤り。&lt;/p&gt;
&lt;p&gt;フィッシャー情報行列はスコア関数（対数尤度関数の勾配）の分散行列で定義される。よって、情報行列とデータの分散行列は一般に一致しない。&lt;/p&gt;
&lt;p&gt;もう一つ自然勾配とフィッシャー情報行列に関する有益な情報源あり:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://tfjgeorge.github.io/articles/note/2018/11/09/empirical-fisher.html"&gt;What is the empirical Fisher ?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今一度Jupyterから出戻りしてみる。
思ったけど、今考えているのは絶対値誤差最小化のためにSigned-LMSだけど、データ側を符号とするLMSや、Sign-SignLMSの解析もありじゃないかと思ってきた。データ側を符号とするLMSは何を最小化しているのか？などが気になる。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category></entry><entry><title>LMS Filterの挙動観察中(7)</title><link href="/lms-filternoju-dong-guan-cha-zhong-7.html" rel="alternate"></link><published>2020-05-03T11:00:00+09:00</published><updated>2020-05-03T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-03:/lms-filternoju-dong-guan-cha-zhong-7.html</id><content type="html">&lt;p&gt;実データ適用で、どうも上手く行かない。やっぱり分散行列の逆行列が発散している。&lt;/p&gt;
&lt;p&gt;適応的自然勾配をやめて、真面目に（毎サンプル平均を求めて）計算するようにしているけども結果がよろしくない。分散行列を標本平均ではなくて指数移動平均（α=0.1）に置き換えたらそれなりの性能が出ることを確認。しかし、ラプラス分布の計量を取り入れていない...。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category></entry><entry><title>LMS Filterの挙動観察中(6)</title><link href="/lms-filternoju-dong-guan-cha-zhong-6.html" rel="alternate"></link><published>2020-05-02T11:00:00+09:00</published><updated>2020-05-02T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-02:/lms-filternoju-dong-guan-cha-zhong-6.html</id><content type="html">&lt;p&gt;今日は実装整理して実データへ適用してみる。気になってるのが適応的自然勾配の更新式。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;確率の重み付けは正規化しないと使えそうにないということ。&lt;/li&gt;
&lt;li&gt;確率の重み付けをしても問題ないか？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実データ適用、うーん性能が良くない！発散する！実装を確認しながら進行中。情報行列の逆行列を正規化すると発散はしないけど、逆行列がほぼ単位行列とほぼ同一で、元のSignedLMSと性能が同等。。。
まずは、適応的自然勾配じゃなくて負荷でかいけど真面目に計算する方針で行ってみる。&lt;/p&gt;
&lt;p&gt;また、フィルタ処理をfor文でやるよりnumpyの演算にした方が格段に早かった。numpy大事。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category></entry><entry><title>LMS Filterの挙動観察中(5)</title><link href="/lms-filternoju-dong-guan-cha-zhong-5.html" rel="alternate"></link><published>2020-05-01T11:00:00+09:00</published><updated>2020-05-01T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-01:/lms-filternoju-dong-guan-cha-zhong-5.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;別のことをしているときに、ふと適応的自然勾配学習法を弄ってて、なんとなくIRLSに応用できそうな印象が。
以下のような式でヘッセ行列（というか、重み付きの分散行列）を更新する。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{H} \leftarrow \ve{H} + \frac{1}{|y_{i} - \ve{\beta}^{\mathsf{T}} \ve{x}|} \ve{x …&lt;/div&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;別のことをしているときに、ふと適応的自然勾配学習法を弄ってて、なんとなくIRLSに応用できそうな印象が。
以下のような式でヘッセ行列（というか、重み付きの分散行列）を更新する。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{H} \leftarrow \ve{H} + \frac{1}{|y_{i} - \ve{\beta}^{\mathsf{T}} \ve{x}|} \ve{x} \ve{x}^{\mathsf{T}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;他にも、ICA（独立成分分析）の尖度最大化（優ガウス分布化）の学習がなんか使えないかと考えつつある。でもこれはICAによるノイズ除去にだいぶ近い話になりそう。&lt;/p&gt;
&lt;p&gt;分散行列と自己相関行列、だいぶ定義が近いな…間違ってないかなと思って再確認。分散行列と言ってるものはもしかしたら自己相関行列の誤りかもしれない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mathtrain.jp/correlationmatrix"&gt;相関行列の定義と分散共分散行列との関係&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ip.info.eng.osaka-cu.ac.jp/~kazunori/paper/rcs201610_handout.pdf"&gt;初学者のための無線通信信号処理入門&lt;/a&gt; に明確に定義されてる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;平均0化していたら分散行列と自己相関行列は同一になりそうな雰囲気。雰囲気じゃだめでちゃんと確認すべき。&lt;/p&gt;
&lt;p&gt;寄り道しすぎたので、改めて結果をまとめていく。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category></entry><entry><title>LMS Filterの挙動観察中(4)</title><link href="/lms-filternoju-dong-guan-cha-zhong-4.html" rel="alternate"></link><published>2020-04-30T11:00:00+09:00</published><updated>2020-04-30T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-30:/lms-filternoju-dong-guan-cha-zhong-4.html</id><summary type="html">&lt;p&gt;本日も引き続き発散の原因を追う。
→ステップサイズを小さくしたら発散しなくなった…。職人芸じゃないかこんなの。NLMSみたく発散しない条件がほしいな。&lt;/p&gt;
&lt;p&gt;本当に既存研究がないか、再度調査。&lt;/p&gt;
&lt;p&gt;自然勾配を適応的に計算する方法を試している。無論、定義式通りに計算するのは問題ないことは確かめているが、計算量が気になるのです。&lt;/p&gt;
&lt;p&gt;パラメータを色々といじりつつ、論文も参照してそれなりのパラメータを見つける。
パラメータについては &lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=5&amp;amp;ved=2ahUKEwi4ufHi4o_pAhUY_GEKHd-gDBwQFjAEegQIBRAB&amp;amp;url=https%3A%2F%2Fwww.mdpi.com%2F2076-3417%2F9%2F21%2F4568%2Fpdf&amp;amp;usg=AOvVaw0KgakdcC8U_T71ks8hZKDW"&gt;Adaptive Natural Gradient Method for Learning of Stochastic Neural Networks in Mini-Batch Mode&lt;/a&gt; を皮切りに調査開始。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.8668&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Adaptive Method of Realizing Natural Gradient Learning for Multilayer Perceptrons&lt;/a&gt; が甘利先生。（福水先生もいるぞ）&lt;ul&gt;
&lt;li&gt;この論文で適応的更新式の導出が述べられる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bsi-ni.brain.riken.jp/database/file/215/221.pdf"&gt;Adaptive natural gradient learning algorithms for various stochastic models&lt;/a&gt; も甘利先生 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;本日も引き続き発散の原因を追う。
→ステップサイズを小さくしたら発散しなくなった…。職人芸じゃないかこんなの。NLMSみたく発散しない条件がほしいな。&lt;/p&gt;
&lt;p&gt;本当に既存研究がないか、再度調査。&lt;/p&gt;
&lt;p&gt;自然勾配を適応的に計算する方法を試している。無論、定義式通りに計算するのは問題ないことは確かめているが、計算量が気になるのです。&lt;/p&gt;
&lt;p&gt;パラメータを色々といじりつつ、論文も参照してそれなりのパラメータを見つける。
パラメータについては &lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=5&amp;amp;ved=2ahUKEwi4ufHi4o_pAhUY_GEKHd-gDBwQFjAEegQIBRAB&amp;amp;url=https%3A%2F%2Fwww.mdpi.com%2F2076-3417%2F9%2F21%2F4568%2Fpdf&amp;amp;usg=AOvVaw0KgakdcC8U_T71ks8hZKDW"&gt;Adaptive Natural Gradient Method for Learning of Stochastic Neural Networks in Mini-Batch Mode&lt;/a&gt; を皮切りに調査開始。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.8668&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Adaptive Method of Realizing Natural Gradient Learning for Multilayer Perceptrons&lt;/a&gt; が甘利先生。（福水先生もいるぞ）&lt;ul&gt;
&lt;li&gt;この論文で適応的更新式の導出が述べられる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bsi-ni.brain.riken.jp/database/file/215/221.pdf"&gt;Adaptive natural gradient learning algorithms for various stochastic models&lt;/a&gt; も甘利先生。（福水先生もいるぞ）&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://downloads.hindawi.com/archive/2011/407497.pdf"&gt;A Simplified Natural Gradient Learning Algorithm&lt;/a&gt; 更にシンプルにしたもの。2011年。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Toy-problemとして中央値の逐次推定とかアリではと、少しだけ思った。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="LAD"></category></entry><entry><title>LMS Filterの挙動観察中(3)</title><link href="/lms-filternoju-dong-guan-cha-zhong-3.html" rel="alternate"></link><published>2020-04-29T23:40:00+09:00</published><updated>2020-04-29T23:40:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-29:/lms-filternoju-dong-guan-cha-zhong-3.html</id><content type="html">&lt;p&gt;LMSはヘッセ行列の逆行列込みの学習ができているが、Signed-LMSは上手く行かない。分散行列が特異になったり、要素が大きくなりすぎて発散してしまう。。。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="LAD"></category></entry><entry><title>LMS Filterの挙動観察中(2)</title><link href="/lms-filternoju-dong-guan-cha-zhong-2.html" rel="alternate"></link><published>2020-04-28T23:40:00+09:00</published><updated>2020-04-28T23:40:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-28:/lms-filternoju-dong-guan-cha-zhong-2.html</id><summary type="html">&lt;p&gt;つまるところ、以下の計算をどうやるか？に尽きる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right] = \lim_{N \to \infty} \frac{1}{N} \sum_{n = 1, \varepsilon(n) = 0}^{N} x(n - m) x(n - k)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\varepsilon(n)\)&lt;/span&gt; はi.i.d.（独立に同一の分布）から発生しているので、&lt;span class="math"&gt;\(x(n-m), x …&lt;/span&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;つまるところ、以下の計算をどうやるか？に尽きる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right] = \lim_{N \to \infty} \frac{1}{N} \sum_{n = 1, \varepsilon(n) = 0}^{N} x(n - m) x(n - k)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\varepsilon(n)\)&lt;/span&gt; はi.i.d.（独立に同一の分布）から発生しているので、&lt;span class="math"&gt;\(x(n-m), x(n-k)\)&lt;/span&gt; には依存しない（予測係数にも依らず）で勝手に揺れると考える。&lt;/p&gt;
&lt;p&gt;でもそんな計算は見たことがない。そもそもLADの文脈でこの話は出ているはずで、「Laplace Distribution linear regression」で検索掛けていたら、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://downloads.hindawi.com/journals/jam/2014/856350.pdf"&gt;Robust Mean Change-Point Detecting through Laplace Linear Regression Using EM Algorithm&lt;/a&gt; を見つけた。&lt;ul&gt;
&lt;li&gt;イントロで「 &lt;strong&gt;ラプラス分布は正規分布の混合で表せる&lt;/strong&gt; 」と「 &lt;strong&gt;混合を前提にしたEMアルゴリズムが存在する&lt;/strong&gt; 」というのを見つけて、論文探しが改めて動く。混合ガウス分布をEMアルゴリズムで学習する話はよく聞くから、本質的なのは正規分布の混合で表せていることか。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://core.ac.uk/download/pdf/16705381.pdf"&gt;ROBUST MIXTURE REGRESSION MODEL FITTING BY LAPLACE DISTRIBUTION&lt;/a&gt; は2013年の論文。印象的なのは、 &lt;strong&gt;IRLSはEMアルゴリズムの一種だということ。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=2ahUKEwi287j_j4rpAhXKA4gKHUlmAIUQFjAAegQIBBAB&amp;amp;url=https%3A%2F%2Fkwansei.repo.nii.ac.jp%2Findex.php%3Faction%3Dpages_view_main%26active_action%3Drepository_action_common_download%26item_id%3D26097%26item_no%3D1%26attribute_id%3D22%26file_no%3D1%26page_id%3D30%26block_id%3D85&amp;amp;usg=AOvVaw0TY8ejg2Duf0nYYdMvrVD_"&gt;ラプラス確率的フロンティアモデルのベイズ推定&lt;/a&gt; は日本語でラプラス分布の混合について述べた論文&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.math.chalmers.se/Stat/Grundutb/GU/MSA220/S16/bayeslasso.pdf"&gt;The Bayesian Lasso&lt;/a&gt; はLASSOを、パラメータの事前分布をラプラス分布としたものとして定式化している。ラプラス分布は直接扱わず、混合を考えている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実験で試している、勾配ベクトルに分散行列（ヘッセ行列）の逆行列を掛ける行為は、ウィーナーフィルタに等しい。しかしウィーナーフィルタは観測分散行列 &lt;span class="math"&gt;\(\ve{XX}^{\mathsf{T}}\)&lt;/span&gt; が正則でないと計算できない。そこで、観測分散行列の低ランク近似を行ってその擬似逆行列を使ってフィルタ係数を更新していく手法がある。それを Reduced rank adaptive filters というらしい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1504.06054.pdf"&gt;A New Approach to Adaptive Signal Processing&lt;/a&gt; で触れていた。この論文は適応フィルタを広汎的に見ており、有益。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www-users.york.ac.uk/~rcdl500/SPL_JIO_2007.pdf"&gt;Reduced-Rank Adaptive Filtering Based on Joint Iterative Optimization of Adaptive Filters&lt;/a&gt; ではReduced rank adaptive filtersのフィルタバンク版&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;邪念が動いて、パーティクルフィルター（粒子フィルター）でパラメータ決められんか考えてる。でも、LMSは状態空間モデルの範疇に入るのだろうか？（カルマンフィルタの一部だから当てはまったはず）。また、一般の状態空間モデルと違って状態は常に観測できるよな。またパーティクルフィルターもシミュレーションベースなので負荷が高そう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.allisone.co.jp/html/Notes/DSP/Filter/particle-filter/index.html"&gt;パーティクル・フィルタをやさしく解説&lt;/a&gt; が確かに優しい。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.terrapub.co.jp/journals/jjssj/pdf/4401/44010189.pdf"&gt;粒子フィルタの基礎と応用: フィルタ・平滑化・パラメータ推定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="mathrm-e-left-delta-varepsilon-n-x-n-m-x-n-k-right"&gt;
&lt;h2&gt;&lt;span class="math"&gt;\(\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right]\)&lt;/span&gt; の解釈&lt;/h2&gt;
&lt;p&gt;結局 &lt;span class="math"&gt;\(\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right]\)&lt;/span&gt; の解釈から逃げている...。もう少し考えていたら、残差 &lt;span class="math"&gt;\(\varepsilon\)&lt;/span&gt; は入力ベクトル &lt;span class="math"&gt;\(x\)&lt;/span&gt; と独立であることを思い出した。ここから、次が言える。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mathrm{E} \left[\delta(\varepsilon(n)) x(n - m) x(n - k) \right] = \mathrm{E} \left[ \delta(\varepsilon(n)) \right] \mathrm{E} \left[ x(n - m) x(n - k) \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで、 &lt;span class="math"&gt;\(\mathrm{E} \left[ \delta(\varepsilon(n)) \right]\)&lt;/span&gt; はお察しの通りで、以下の通りに、やはり残差が0となる確率が出てくる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mathrm{E} \left[ \delta(\varepsilon(n)) \right] &amp;amp;= \lim_{N \to \infty} \frac{1}{N} \sum_{n = 1}^{N} \delta(\varepsilon(n)) = \lim_{N \to \infty} \frac{1}{N} \sum_{n = 1, \varepsilon(n) = 0}^{N} 1 \\
&amp;amp;= P(\varepsilon = 0)
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mathrm{E} \left[\delta(\varepsilon(n)) x(n - m) x(n - k) \right] = P(\varepsilon = 0) \mathrm{E} \left[ x(n - m) x(n - k) \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(P(\varepsilon = 0)\)&lt;/span&gt; を考える。まず注意したいのは、連続型確率分布においては一点0をとる確率は0ということ（測度0だから）。近似するしかなく、方針としては、&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;残差の閾値を定めて、それ以下の数値を残差0とみなして確率を求める&lt;/li&gt;
&lt;li&gt;離散型確率分布で考える&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ラプラス分布の基本的なことをおさらいすると、確率密度関数 &lt;span class="math"&gt;\(f(x, \mu, \sigma)\)&lt;/span&gt; は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(x, \mu, \sigma) = \frac{1}{2 \sigma} \exp\left( - \frac{|x - \mu|}{\sigma} \right)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;で、観測 &lt;span class="math"&gt;\(x_{1}, ..., x_{N}\)&lt;/span&gt; が得られた時の尤度関数 &lt;span class="math"&gt;\(L(\mu, \sigma)\)&lt;/span&gt; と対数尤度関数は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
L(\mu, \sigma) &amp;amp;= \prod_{i = 1}^{N} \frac{1}{2 \sigma} \exp\left( - \frac{|x_{i} - \mu|}{\sigma} \right) = \frac{1}{(2 \sigma)^{N}} \prod_{i = 1}^{N} \exp\left( - \frac{|x_{i} - \mu|}{\sigma} \right) \\
\log L(\mu, \sigma) &amp;amp;= -N\log(2\sigma) -\sum_{i = 1}^{N} \frac{|x_{i} - \mu|}{\sigma} = -N\log(2\sigma) - \frac{1}{\sigma}\sum_{i = 1}^{N} |x_{i} - \mu|
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\mu\)&lt;/span&gt; の最尤推定量は標本中央値となる。&lt;span class="math"&gt;\(\mu\)&lt;/span&gt; が求まったとして、次は &lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; の最尤推定値を考える。対数尤度関数を &lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; で偏微分すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\partial}{\partial \sigma} \log L(\mu, \sigma) = -2 \frac{N}{2\sigma} + \frac{1}{\sigma^{2}} \sum_{i = 1}^{N} |x_{i} - \mu| = -\frac{N}{\sigma} + \frac{1}{\sigma^{2}} \sum_{i = 1}^{N} |x_{i} - \mu|
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\frac{\partial}{\partial \sigma} \log L(\mu, \sigma) = 0\)&lt;/span&gt; とおいて &lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; について解くと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{N}{\sigma} = \frac{1}{\sigma^{2}} \sum_{i = 1}^{N} |x_{i} - \mu| \Rightarrow \sigma = \frac{1}{N} \sum_{i = 1}^{N} |x_{i} - \mu|
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; の最尤推定値は偏差の絶対値の標本平均となる。次に離散ラプラス分布を考える（ &lt;a class="reference external" href="https://shodhganga.inflibnet.ac.in/bitstream/10603/30871/11/11_chapter%206.pdf"&gt;ここ&lt;/a&gt; を参考にしている）。離散ラプラス分布は次の確率（質量）関数 &lt;span class="math"&gt;\(P\)&lt;/span&gt; を持つ:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
P(X = k) &amp;amp;= \frac{f(k, 0, \sigma)}{\sum_{j = -\infty}^{\infty} f(j, 0, \sigma)} = \frac{\exp\left( -\frac{|k|}{\sigma} \right)}{\sum_{j = -\infty}^{\infty} \exp\left( -\frac{|j|}{\sigma} \right)} \\
&amp;amp;= \frac{\exp\left( -\frac{|k|}{\sigma} \right)}{1 + 2 \sum_{j = 1}^{\infty} \exp\left( -\frac{j}{\sigma} \right)}
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\sum_{j = 1}^{\infty} \exp\left( -\frac{j}{\sigma} \right) = \lim_{n \to \infty} \frac{\exp(-1/\sigma)(1 - \exp(-n/\sigma))}{1 - \exp(-1/\sigma)} = \frac{\exp(-1/\sigma)}{1 - \exp(-1/\sigma)}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;よって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
P(X = k) &amp;amp;= \frac{\exp\left( -\frac{|k|}{\sigma} \right)}{1 + 2 \frac{\exp(-1/\sigma)}{1 - \exp(-1/\sigma)}} = \frac{1 - \exp(-1/\sigma)}{1 + \exp(-1/\sigma)} \exp\left(-\frac{|k|}{\sigma}\right) \\
&amp;amp;= \frac{1 - p}{1 + p} p^{|k|}, \quad p = \exp(-1/\sigma)
\end{align*}
&lt;/div&gt;
&lt;p&gt;これは離散型確率分布であることに注意。&lt;/p&gt;
&lt;p&gt;連続版かつ &lt;span class="math"&gt;\(\mu=0\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(|x|\)&lt;/span&gt; がある閾値 &lt;span class="math"&gt;\(\delta &amp;gt; 0\)&lt;/span&gt; 以下となる確率は次のように計算できる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
P(|x| \leq \delta) &amp;amp;= \int^{\delta}_{-\delta} f(x, \mu, \sigma) dx = \frac{1}{2 \sigma} \int^{\delta}_{-\delta} \exp\left(-\frac{|x|}{\sigma} \right) dx \\
&amp;amp;= \frac{2}{2\sigma} \int^{\delta}_{0} \exp\left(-\frac{x}{\sigma} \right) dx = \frac{1}{\sigma} (-\sigma) \int^{\delta}_{0} \left\{ \exp\left(-\frac{x}{\sigma} \right) \right\}^{\prime} dx \\
&amp;amp;= -\left[ \exp\left(-\frac{x}{\sigma} \right) \right]^{\delta}_{0} = \exp(0) - \exp\left( - \frac{\delta}{\sigma} \right) \\
&amp;amp;= 1 - \exp\left( - \frac{\delta}{\sigma} \right)
\end{align*}
&lt;/div&gt;
&lt;p&gt;この式により分散行列にかける係数を決めることを考えると、次が考察される。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\delta\)&lt;/span&gt; が大きい（分散 &lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; が小さい）と確率が1に近づき、分散行列はLMSのそれと近くなる。&lt;/li&gt;
&lt;li&gt;逆に &lt;span class="math"&gt;\(\delta\)&lt;/span&gt; が小さい（分散 &lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; が大きい）と分散行列に小さいスカラーを乗じる。分散行列の逆行列をとると、大きいスカラーを乗じることになり、勾配ベクトルのノルムが大きくなりそう。&lt;/li&gt;
&lt;li&gt;ノイズレベル（&lt;span class="math"&gt;\(\approx\)&lt;/span&gt; 分散）が小さいときは勾配が小さくなり極値付近を精密に調べ、大きい場合は勾配が大きくなりダイナミックに探索空間を動き回りそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="lms"&gt;
&lt;h2&gt;LMSの性能解析に関する文献&lt;/h2&gt;
&lt;p&gt;色々さまよっているうちに出てきた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ee.cityu.edu.hk/~hcso/it6303_4.pdf"&gt;Adaptive Filter Theory and Applications&lt;/a&gt; にLMSのステップサイズのとり方に関する記述あり。証明に有益。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.dsp-book.narod.ru/DSPMW/19.PDF"&gt;Convergence Issues in the LMS Adaptive Filter&lt;/a&gt; も結構有益。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="todo"&gt;
&lt;h3&gt;TODO&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;評価を続ける。評価がまとまったら結果共有に入りたい。&lt;ul&gt;
&lt;li&gt;LMSの適応動作は、単層パーセプトロンの学習にも該当する。NNの観点からも引き続き論文調査を行うべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OMPを使う。&lt;/li&gt;
&lt;li&gt;メッセージパッシング使えない？&lt;ul&gt;
&lt;li&gt;何らかの確率モデル化をせよ、というふうに受け取った。&lt;/li&gt;
&lt;li&gt;AMP, Survay-Propagation（三村さん、樺島さん）がありえる。&lt;/li&gt;
&lt;li&gt;→ AMP, Survay-Propagationについて調査すべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;いろんな論文で自然勾配をどうやって定義しているか要観察。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;優先度低&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;パーティクルフィルター使えない？&lt;ul&gt;
&lt;li&gt;今日検討した結果、ちょっと今は保留。大量のサンプルが必要そうに見える。計算負荷を気にした結果、優先度を低くした。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="LAD"></category><category term="IRLS"></category></entry><entry><title>LMS Filterの挙動観察中(1)</title><link href="/lms-filternoju-dong-guan-cha-zhong-1.html" rel="alternate"></link><published>2020-04-27T23:40:00+09:00</published><updated>2020-04-27T23:40:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-27:/lms-filternoju-dong-guan-cha-zhong-1.html</id><summary type="html">&lt;p&gt;引き続き観察中。勾配の計算ミスがあったりして厳しかった。&lt;/p&gt;
&lt;p&gt;問題は、やはりというかSignLMSでのヘッセ行列。&lt;span class="math"&gt;\(\mathrm{E}[\varepsilon((n))x(n-m)x(n-k)]\)&lt;/span&gt; の計算でインパルス応答の扱いをどうするのか...連続信号では厳密に0を取る確率は0だ。だからといって離散的に考えていいのか？&lt;/p&gt;
&lt;p&gt;誤差の絶対値を取って閾値以下ならば分散行列に加算する処理を入れたが、分散行列が特異になること多し。&lt;/p&gt;
&lt;p&gt;デジタル的に考えれば、残差が0になる確率で重み付けしていいのでは無いかと思う。 またデジタル的に考えた時
残差が0になる確率は、離散ラプラス分布（ &lt;a class="reference external" href="https://shodhganga.inflibnet.ac.in/bitstream/10603/30871/11/11_chapter%206.pdf"&gt;参考資料&lt;/a&gt; ）を元にサンプリング/もしくは重み付けで求める。（サンプリングの場合は[0,1]乱数を発生させて残差が0になる確率よりも小さければ採択する。まじのMC。というか、サンプリングしても重み付けしても同じでは？）分散パラメータは観測分散で求める。&lt;/p&gt;
&lt;p&gt;一旦残差0の重み付けで実験を進めているが、まだ残差0確率が怪しい感じ。（0.93とかいう現実離れした数値。実際の音声では約0.09とかそんなん）&lt;/p&gt;
&lt;p&gt;見やすいようにパラメータを2つにしている。2つにした時でも同じ出力を与える組み合わせがあり、それが直線上に並んでいる事がわかっている。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent …&lt;/script&gt;</summary><content type="html">&lt;p&gt;引き続き観察中。勾配の計算ミスがあったりして厳しかった。&lt;/p&gt;
&lt;p&gt;問題は、やはりというかSignLMSでのヘッセ行列。&lt;span class="math"&gt;\(\mathrm{E}[\varepsilon((n))x(n-m)x(n-k)]\)&lt;/span&gt; の計算でインパルス応答の扱いをどうするのか...連続信号では厳密に0を取る確率は0だ。だからといって離散的に考えていいのか？&lt;/p&gt;
&lt;p&gt;誤差の絶対値を取って閾値以下ならば分散行列に加算する処理を入れたが、分散行列が特異になること多し。&lt;/p&gt;
&lt;p&gt;デジタル的に考えれば、残差が0になる確率で重み付けしていいのでは無いかと思う。 またデジタル的に考えた時
残差が0になる確率は、離散ラプラス分布（ &lt;a class="reference external" href="https://shodhganga.inflibnet.ac.in/bitstream/10603/30871/11/11_chapter%206.pdf"&gt;参考資料&lt;/a&gt; ）を元にサンプリング/もしくは重み付けで求める。（サンプリングの場合は[0,1]乱数を発生させて残差が0になる確率よりも小さければ採択する。まじのMC。というか、サンプリングしても重み付けしても同じでは？）分散パラメータは観測分散で求める。&lt;/p&gt;
&lt;p&gt;一旦残差0の重み付けで実験を進めているが、まだ残差0確率が怪しい感じ。（0.93とかいう現実離れした数値。実際の音声では約0.09とかそんなん）&lt;/p&gt;
&lt;p&gt;見やすいようにパラメータを2つにしている。2つにした時でも同じ出力を与える組み合わせがあり、それが直線上に並んでいる事がわかっている。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category></entry><entry><title>LMS Filterの挙動観察</title><link href="/lms-filternoju-dong-guan-cha.html" rel="alternate"></link><published>2020-04-24T11:40:00+09:00</published><updated>2020-04-24T11:40:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-24:/lms-filternoju-dong-guan-cha.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;今日はJupyterを使って残差・残差勾配を観察していく。もう夜遅いのでnotebook上げるの挑戦できず。
勾配の計算にミスがあり、残差分布と勾配の結果が一致していなかった…3時間ほど飛ばす。&lt;/p&gt;
&lt;p&gt;ラプラス分布の観測分散が怪しい...&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/922521/deriving-mean-and-variance-of-laplace-distribution"&gt;Deriving Mean and Variance of Laplace Distribution&lt;/a&gt; に1次元の場合がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false …&lt;/script&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;今日はJupyterを使って残差・残差勾配を観察していく。もう夜遅いのでnotebook上げるの挑戦できず。
勾配の計算にミスがあり、残差分布と勾配の結果が一致していなかった…3時間ほど飛ばす。&lt;/p&gt;
&lt;p&gt;ラプラス分布の観測分散が怪しい...&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/922521/deriving-mean-and-variance-of-laplace-distribution"&gt;Deriving Mean and Variance of Laplace Distribution&lt;/a&gt; に1次元の場合がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="Hessian"></category></entry><entry><title>古い記事の移行/Jupyterの環境整備</title><link href="/gu-iji-shi-noyi-xing-jupyternohuan-jing-zheng-bei.html" rel="alternate"></link><published>2020-04-23T23:00:00+09:00</published><updated>2020-04-23T23:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-23:/gu-iji-shi-noyi-xing-jupyternohuan-jing-zheng-bei.html</id><content type="html">&lt;p&gt;評価の前に古い記事の移行とPythonの環境整備。
PythonはJupyterを使う。Vimキーバインドで。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/nakasan/items/ec7741f075f1062350f4#jupyterコマンドモードのショートカットキーまとめ"&gt;Jupyterコマンドモードのショートカットキーまとめ&lt;/a&gt; がよくまとまっていた。これ読んで進めていく。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Jupyter"></category></entry><entry><title>Signed-LMSの2階微分 その2</title><link href="/signed-lmsno2jie-wei-fen-sono2.html" rel="alternate"></link><published>2020-04-22T11:34:00+09:00</published><updated>2020-04-22T12:10:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-22:/signed-lmsno2jie-wei-fen-sono2.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;早速既存研究が無いか見ている。二乗誤差最小化のLMSでもヘッセ行列の逆行列の計算負荷が高いから使わん、という論調がほとんど。Signed-LMSについては今の所、微分してるところも見てない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pt.slideshare.net/mentelibre/neural-network-widrowhoff-learning-adaline-hagan-lms"&gt;NEURAL NETWORK Widrow-Hoff Learning Adaline Hagan LMS&lt;/a&gt; 観測分散行列がヘッセ行列に一致することが書いてあった。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www1.coe.neu.edu/~erdogmus/publications/J013_NEUNET_SpIssueIJCNN03_EWCLMS_Yadu.pdf"&gt;Stochastic error whitening algorithm for linear filter estimation with noisy data&lt;/a&gt; 評価関数として絶対値が入ったものを使っている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://faculty.cord.edu/kamel/09S-380/Presentations/LMS.pdf"&gt;The …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;早速既存研究が無いか見ている。二乗誤差最小化のLMSでもヘッセ行列の逆行列の計算負荷が高いから使わん、という論調がほとんど。Signed-LMSについては今の所、微分してるところも見てない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pt.slideshare.net/mentelibre/neural-network-widrowhoff-learning-adaline-hagan-lms"&gt;NEURAL NETWORK Widrow-Hoff Learning Adaline Hagan LMS&lt;/a&gt; 観測分散行列がヘッセ行列に一致することが書いてあった。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www1.coe.neu.edu/~erdogmus/publications/J013_NEUNET_SpIssueIJCNN03_EWCLMS_Yadu.pdf"&gt;Stochastic error whitening algorithm for linear filter estimation with noisy data&lt;/a&gt; 評価関数として絶対値が入ったものを使っている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://faculty.cord.edu/kamel/09S-380/Presentations/LMS.pdf"&gt;The Least Mean Squares Algorithm&lt;/a&gt; 分かりやすめな解説。そうか、ウィーナーフィルタか。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;行列 &lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}}\)&lt;/span&gt; が正則にならない件について、これ正則化すればいいんじゃねと思い立つ。要は &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; を正則化パラメータとして &lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}} + \lambda \ve{I}\)&lt;/span&gt; に対して逆行列を求めていく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;多分、係数側に正則項を追加することになるはず。&lt;span class="math"&gt;\(\min \mathrm{E}[|\varepsilon(n)|] + \lambda ||\ve{h}||_{2}\)&lt;/span&gt; のような定式化か？&lt;/li&gt;
&lt;li&gt;それでも逆行列 &lt;span class="math"&gt;\((\ve{X}\ve{X}^{\mathsf{T}} + \lambda \ve{I})^{-1}\)&lt;/span&gt; を求めるのは骨が折れそう。そこで、自然勾配学習で使っていた適応的自然勾配学習法（ &lt;a class="reference external" href="https://bsi-ni.brain.riken.jp/database/file/274/280.pdf"&gt;Singularities Affect Dynamics of Learning in Neuromanifolds&lt;/a&gt; より）が使えそう。具体的には、次の式で自然勾配を適応的に求めていく。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{G}_{t+1}^{-1} = (1 + \varepsilon_{t}) \ve{G}_{t}^{-1} - \varepsilon_{t} \ve{G}_{t}^{-1} \parfrac{J(\ve{h})}{\ve{h}} \left( \ve{G}_{t}^{-1} \parfrac{J(\ve{h})}{\ve{h}} \right)^{\mathsf{T}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで &lt;span class="math"&gt;\(\varepsilon_{t}\)&lt;/span&gt; は小さな定数。『情報幾何の新展開』では、カルマンフィルタ由来らしい。うーん、もう試してみたいな。&lt;/p&gt;
&lt;div class="section" id="ve-x-ve-x-mathsf-t-lambda-ve-i"&gt;
&lt;h2&gt;（念の為） &lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}} + \lambda \ve{I}\)&lt;/span&gt; が正則行列になる理由&lt;/h2&gt;
&lt;p&gt;すぐに思い出せなくてヒヤッとしたのでここで示しておく。&lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}}\)&lt;/span&gt; は対称行列だから、直交行列 &lt;span class="math"&gt;\(\ve{P}\)&lt;/span&gt; （&lt;span class="math"&gt;\(\ve{P}^{-1} = \ve{P}^{\mathsf{T}}\)&lt;/span&gt; ）と固有値を並べた対角行列 &lt;span class="math"&gt;\(\ve{\Lambda}\)&lt;/span&gt; を用いて、&lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}} = \ve{P}^{\mathsf{T}} \ve{\Lambda} \ve{P}\)&lt;/span&gt; と対角化できる。よって、&lt;span class="math"&gt;\(\lambda &amp;gt; 0\)&lt;/span&gt; なる定数を用いた時、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{X}\ve{X}^{\mathsf{T}} + \lambda \ve{I} &amp;amp;= \ve{P}^{\mathsf{T}} \ve{\Lambda} \ve{P} + \lambda \ve{P}^{\mathsf{T}} \ve{P} \\
&amp;amp;= \ve{P}^{\mathsf{T}} \ve{\Lambda} \ve{P} + \ve{P}^{\mathsf{T}} \lambda \ve{I} \ve{P} \\
&amp;amp;= \ve{P}^{\mathsf{T}} (\ve{\Lambda} + \lambda \ve{I}) \ve{P}
\end{align*}
&lt;/div&gt;
&lt;p&gt;また、任意のベクトル &lt;span class="math"&gt;\(\ve{v}\)&lt;/span&gt; を使った時、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{v}^{\mathsf{T}} \ve{X} \ve{X}^{\mathsf{T}} \ve{v} &amp;amp;= (\ve{X}^{\mathsf{T}} \ve{v})^{\mathsf{T}} \ve{X}^{\mathsf{T}} \ve{v} = ||\ve{X}^{\mathsf{T}} \ve{v} ||_{2}^{2} \\
\ve{v}^{\mathsf{T}} \ve{X} \ve{X}^{\mathsf{T}} \ve{v} &amp;amp;= \ve{v}^{\mathsf{T}} \ve{P}^{\mathsf{T}} \ve{\Lambda} \ve{P} \ve{v} = \sum_{i}^{N} \ve{\Lambda}_{ii} (\ve{Pv})_{i}^{2} \\
\Rightarrow ||\ve{X}^{\mathsf{T}} \ve{v} ||_{2}^{2} &amp;amp;= \sum_{i}^{N} \ve{\Lambda}_{ii} (\ve{Pv})_{i}^{2} \geq 0
\end{align*}
&lt;/div&gt;
&lt;p&gt;の関係式が成り立つ。最後の不等式が成り立つには、全ての &lt;span class="math"&gt;\(i\)&lt;/span&gt; に対して &lt;span class="math"&gt;\(\ve{\Lambda}_{ii} \geq 0\)&lt;/span&gt; でなければならない。よって &lt;span class="math"&gt;\(\ve{XX}^{\mathsf{T}}\)&lt;/span&gt; の固有値は全て非負。&lt;/p&gt;
&lt;p&gt;ここで &lt;span class="math"&gt;\(\ve{P}^{\mathsf{T}} (\ve{\Lambda} + \lambda \ve{I}) \ve{P}\)&lt;/span&gt; に注目すると、全ての固有値に &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; が足されていることが分かる。&lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; は正だから、 &lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}} + \lambda \ve{I}\)&lt;/span&gt; の固有値は全て正になり正定値行列となる。正定値行列は正則だから、 &lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}} + \lambda \ve{I}\)&lt;/span&gt; は正則行列。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;フィッシャー情報行列とヘッセ行列と分散行列の絡みについて&lt;/h2&gt;
&lt;p&gt;以下の記事が非常にわかりやすい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiseodd.github.io/techblog/2018/03/11/fisher-information/"&gt;Fisher Information Matrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiseodd.github.io/techblog/2018/03/14/natural-gradient/"&gt;Natural Gradient Descent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;結論、ラプラス分布に従う残差を仮定した最尤推定において、観測分散行列はフィッシャー情報行列に一致し、その逆行列は自然勾配に該当するはず。つうかニュートン法の特殊ケースに見えるがどうなんでしょ。フィッシャー情報行列がヘッセ行列に見えるんだが、定義通り（対数尤度のヘッセ行列）そうだよな。指数族の最尤推定をニュートン法で解こうとしたら全部自然勾配学習法にならね？&lt;/p&gt;
&lt;div class="section" id="todo"&gt;
&lt;h3&gt;TODO&lt;/h3&gt;
&lt;p&gt;評価のことを考えて行きたい。固定した信号（答えが分かっている信号。乱数固定。）を使ったときに、誤差平面と勾配はどうなっている？フィルタの次元は2ぐらいにして、フィルタを固定して各統計量がどうなっているかプロットする。まずは絶対値残差と勾配の観察が重要に思える（もちろん、2次の最小化ケースも重要）。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;評価がまとまったら結果共有に入りたい。&lt;/li&gt;
&lt;li&gt;OMPを使う。&lt;/li&gt;
&lt;li&gt;メッセージパッシング使えない？&lt;ul&gt;
&lt;li&gt;何らかの確率モデル化をせよ、というふうに受け取った。&lt;/li&gt;
&lt;li&gt;AMP, Survay-Propagation（三村さん、樺島さん）がありえる。&lt;/li&gt;
&lt;li&gt;→ AMP, Survay-Propagationについて調査すべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;いろんな論文で自然勾配をどうやって定義しているか要観察。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Fisher Information Matrix"></category><category term="Hessian"></category><category term="Natural Gradient"></category></entry><entry><title>残差勾配 \(\mathrm{E}[\varepsilon(n) x(n - m)]\) の挙動観察/Signed-LMSの目的関数の2階微分</title><link href="/can-chai-gou-pei-mathrmevarepsilonn-xn-m-noju-dong-guan-cha-signed-lmsnomu-de-guan-shu-no2jie-wei-fen.html" rel="alternate"></link><published>2020-04-21T12:10:00+09:00</published><updated>2020-04-21T12:10:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-21:/can-chai-gou-pei-mathrmevarepsilonn-xn-m-noju-dong-guan-cha-signed-lmsnomu-de-guan-shu-no2jie-wei-fen.html</id><summary type="html">&lt;div class="section" id="mathrm-e-varepsilon-n-x-n-m"&gt;
&lt;h2&gt;残差勾配 &lt;span class="math"&gt;\(\mathrm{E}[\varepsilon(n) x(n - m)]\)&lt;/span&gt; の挙動観察&lt;/h2&gt;
&lt;p&gt;&lt;span class="math"&gt;\(m\)&lt;/span&gt; が大きいときは無視できるのでは？ なお、長時間平均値は0に収束していることを見た。
&lt;span class="math"&gt;\(m\)&lt;/span&gt; をずらした時の平均値の様子を見る。どこかで影響が小さくなって打ち切れるはず。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ガチャガチャ弄ってるってるけど示唆があんまりない。&lt;/li&gt;
&lt;li&gt;低次（〜10）の係数は大きく変動する傾向。しかし、次に述べるピッチなどに影響しているのか、全てに当てはまる傾向ではない。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\mathrm{E}[\varepsilon(n) x(n - m)]\)&lt;/span&gt; は &lt;span class="math"&gt;\(m\)&lt;/span&gt; を大きくすれば単調減少するわけではない。音源依存で傾向が異なる。ピッチ？か何かに反応して大きくなる場合がある。&lt;/li&gt;
&lt;li&gt;同一発音区間では、フィルタ係数の符号は同一になる傾向が見られる。単一のsin波を等価させたときはわかりやすい。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="440.0Hzのsin波に対する各タップの平均勾配変化グラフ" src="./images/sin_mean_gradient.png" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;440.0Hzのsin波に対する各タップの平均勾配変化&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="ボイス対する各タップの平均勾配変化グラフ" src="./images/voice_mean_gradient.png" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;ボイス対する各タップの平均勾配変化&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="ピアノ演奏に対する各タップの平均勾配変化グラフ" src="./images/ruriko_mean_gradient.png" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;ピアノ演奏に対する各タップの平均勾配変化&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="signed-lms2"&gt;
&lt;h2&gt;Signed-LMSの目的関数の2階微分&lt;/h2&gt;
&lt;p&gt;勇気を出してやってみる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2 …&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="mathrm-e-varepsilon-n-x-n-m"&gt;
&lt;h2&gt;残差勾配 &lt;span class="math"&gt;\(\mathrm{E}[\varepsilon(n) x(n - m)]\)&lt;/span&gt; の挙動観察&lt;/h2&gt;
&lt;p&gt;&lt;span class="math"&gt;\(m\)&lt;/span&gt; が大きいときは無視できるのでは？ なお、長時間平均値は0に収束していることを見た。
&lt;span class="math"&gt;\(m\)&lt;/span&gt; をずらした時の平均値の様子を見る。どこかで影響が小さくなって打ち切れるはず。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ガチャガチャ弄ってるってるけど示唆があんまりない。&lt;/li&gt;
&lt;li&gt;低次（〜10）の係数は大きく変動する傾向。しかし、次に述べるピッチなどに影響しているのか、全てに当てはまる傾向ではない。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\mathrm{E}[\varepsilon(n) x(n - m)]\)&lt;/span&gt; は &lt;span class="math"&gt;\(m\)&lt;/span&gt; を大きくすれば単調減少するわけではない。音源依存で傾向が異なる。ピッチ？か何かに反応して大きくなる場合がある。&lt;/li&gt;
&lt;li&gt;同一発音区間では、フィルタ係数の符号は同一になる傾向が見られる。単一のsin波を等価させたときはわかりやすい。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="440.0Hzのsin波に対する各タップの平均勾配変化グラフ" src="./images/sin_mean_gradient.png" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;440.0Hzのsin波に対する各タップの平均勾配変化&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="ボイス対する各タップの平均勾配変化グラフ" src="./images/voice_mean_gradient.png" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;ボイス対する各タップの平均勾配変化&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="ピアノ演奏に対する各タップの平均勾配変化グラフ" src="./images/ruriko_mean_gradient.png" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;ピアノ演奏に対する各タップの平均勾配変化&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="signed-lms2"&gt;
&lt;h2&gt;Signed-LMSの目的関数の2階微分&lt;/h2&gt;
&lt;p&gt;勇気を出してやってみる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;符号関数を &lt;span class="math"&gt;\(\tanh(Tx)\)&lt;/span&gt; で近似して微分してみる（&lt;span class="math"&gt;\(T\)&lt;/span&gt; は温度パラメータで、&lt;span class="math"&gt;\(\tanh(Tx)\)&lt;/span&gt; を &lt;span class="math"&gt;\(T \to \infty\)&lt;/span&gt; ならしめれば符号関数に近づく）と、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{d}{dx} \tanh(Tx) = T (\tanh(Tx))^{\prime} = T(1 - \tanh^{2}(Tx))
\end{equation*}
&lt;/div&gt;
&lt;p&gt;さて、 &lt;span class="math"&gt;\(1 - \tanh^{2}(Tx)\)&lt;/span&gt; に注目すると、&lt;span class="math"&gt;\(T\)&lt;/span&gt; の極限では &lt;span class="math"&gt;\(x = 0\)&lt;/span&gt; を除き0を取るが、&lt;span class="math"&gt;\(x = 0\)&lt;/span&gt; において1を取る。よってこれはインパルス関数になる（極限と微分操作を交換したけどやかましいことは暗黙で...）。&lt;/p&gt;
&lt;p&gt;符号関数を微分するとインパルス関数が出てくることについては &lt;a class="reference external" href="https://teenaka.at.webry.info/201301/article_10.html"&gt;超関数的微分_δ関数関連（２）&lt;/a&gt; を見るのが早いかも。以下では、その話に従って、&lt;span class="math"&gt;\(\frac{d}{dx} \mathrm{sign}(x) = 2\delta(x)\)&lt;/span&gt; とする。&lt;/p&gt;
&lt;p&gt;さて、今一度評価関数 &lt;span class="math"&gt;\(\mathrm{E}[|\varepsilon(n)|]\)&lt;/span&gt; の偏微分と2階の偏導関数を考える。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\parfrac{}{h(m)} \mathrm{E}[|\varepsilon(n)|] &amp;amp;= \mathrm{E}\left[ \parfrac{}{h(m)} |\varepsilon(n)| \right] \\
&amp;amp;= \mathrm{E}\left[ \left\{ \parfrac{}{h(m)} \varepsilon(n) \right\} \mathrm{sign}[\varepsilon(n)] \right] \\
&amp;amp;= -\mathrm{E}\left[ \mathrm{sign}[\varepsilon(n)]  x(n - m) \right] \\
\frac{\partial^{2}}{\partial h(m) \partial h(k)} \mathrm{E}[|\varepsilon(n)|] &amp;amp;= - \parfrac{}{h(k)} \mathrm{E}\left[ \mathrm{sign}[\varepsilon(n)]  x(n - m) \right] \\
&amp;amp;= - \mathrm{E}\left[ \left\{ \parfrac{}{h(k)} \varepsilon(n) \right\} 2\delta(\varepsilon(n)) x(n - m) \right] \\
&amp;amp;= 2\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで &lt;span class="math"&gt;\(\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right]\)&lt;/span&gt; に注目する。これは &lt;span class="math"&gt;\(\varepsilon(n) = 0\)&lt;/span&gt; のときだけ和を取る演算だ。&lt;span class="math"&gt;\(\sum\)&lt;/span&gt; を用いると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right] = \lim_{N \to \infty} \frac{1}{N} \sum_{n = 1, \varepsilon(n) = 0}^{N} x(n - m) x(n - k)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;という計算に該当する。厳密計算は &lt;span class="math"&gt;\(\varepsilon(n) = 0\)&lt;/span&gt; なる &lt;span class="math"&gt;\(n\)&lt;/span&gt; を見つけたら足していく感じでいいと思うけど、今は &lt;span class="math"&gt;\(\varepsilon(n)\)&lt;/span&gt; はラプラス分布に従うと仮定している。だからラプラス分布に従って &lt;span class="math"&gt;\(P(\varepsilon(n) = 0) = \frac{1}{2\lambda}\)&lt;/span&gt; （分散 &lt;span class="math"&gt;\(2\lambda^{2}\)&lt;/span&gt; ）の重み付けをして計算してしまって良いように見えるのだがどうなんだろう。なんか怪しくて考え続けている。&lt;/p&gt;
&lt;p&gt;もし適応フィルタに組み込むなら、残差が0になったら上の式に従ってヘッセ行列を更新し、ニュートン法を使い続ける。これは試してみたい。問題はヘッセ行列が逆行列を持つかというところ…4-20で半正定値であることは確認したが正定値とは限らない。共役勾配法を検討する必要があるかも。&lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}}\)&lt;/span&gt; は正則になるとは思えない…。（軽く試したけどすぐにだめな例が見つかった。）&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;他の頂いたアイディア&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;周波数領域に一旦飛ばすのはあり？&lt;ul&gt;
&lt;li&gt;ありだけど計算量が高い。圧縮率が上がるのであれば大アリ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;確率的PCAとか使えない？辞書は小さくて済む。&lt;/li&gt;
&lt;li&gt;線形ダイナミクスにより上手く定式化できない？&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="id2"&gt;
&lt;h4&gt;優先度低&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;出す学会については先生に聞くこと。&lt;ul&gt;
&lt;li&gt;相談する機会はどこかで絶対に必要。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;著作権処理済み音源データベースについて相談&lt;ul&gt;
&lt;li&gt;→ 自分で情報をまとめて、申し込んでいいかというところまで進めるべし。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://staff.aist.go.jp/m.goto/PAPER/SIGMUS200205goto.pdf"&gt;RWC 研究用音楽データベース: 音楽ジャンルデータベースと楽器音データベース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://staff.aist.go.jp/m.goto/RWC-MDB/index-j.html"&gt;RWC研究用音楽データベース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;→ 進めた。動けるようになったら書類をまとめていく。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Donohoさんなどが圧縮センシングの文脈で既にやりきってない？&lt;ul&gt;
&lt;li&gt;ありえる。調査すべし。&lt;/li&gt;
&lt;li&gt;→ ライス大学では成果をすべて公開しているから見るだけ見たほうが良い。&lt;/li&gt;
&lt;li&gt;→ &lt;a class="reference external" href="http://dsp.rice.edu/cs/"&gt;http://dsp.rice.edu/cs/&lt;/a&gt; を見よ。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://hal.archives-ouvertes.fr/hal-00424165/document"&gt;Compressed sensing block MAP-LMS adaptive filter for sparse channel estimation and a bayesian Cramer-Rao bound&lt;/a&gt; 残差はガウス分布としてるけどクラメル-ラオ下限との絡みを述べている。何か重要そう。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.dbabacan.info/papers/babacan_CS.pdf"&gt;Bayesian Compressive Sensing Using Laplace Priors&lt;/a&gt; これもパラメータの事前分布にラプラス分布を導入してベイズ推定するもの。残差ではないはず。&lt;/li&gt;
&lt;li&gt;「L1」, 「Laplace」, 「residual」, 「lossless」で検索したけどスパース解を求めるものばかり。今のところはセーフ？&lt;/li&gt;
&lt;li&gt;→ 継続して調査はする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category></entry><entry><title>IRLSの更新式について</title><link href="/irlsnogeng-xin-shi-nitsuite.html" rel="alternate"></link><published>2020-04-20T14:10:00+09:00</published><updated>2020-04-21T12:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-20:/irlsnogeng-xin-shi-nitsuite.html</id><summary type="html">&lt;p&gt;MathJaxの環境を確認しつつ使用中。プリアンブルが無いけどページ内で一回 &lt;tt class="docutils literal"&gt;newcommand&lt;/tt&gt; を行えばずっと使えるみたい。便利。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;逐次的更新の件について。IRLSでは以下の評価関数 &lt;span class="math"&gt;\(J(\ve{\beta})\)&lt;/span&gt; の最小化を考える。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
J(\ve{\beta}) = \sum^{M}_{i = 1} w_{i} (y_{i} - \innerp …&lt;/div&gt;</summary><content type="html">&lt;p&gt;MathJaxの環境を確認しつつ使用中。プリアンブルが無いけどページ内で一回 &lt;tt class="docutils literal"&gt;newcommand&lt;/tt&gt; を行えばずっと使えるみたい。便利。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;逐次的更新の件について。IRLSでは以下の評価関数 &lt;span class="math"&gt;\(J(\ve{\beta})\)&lt;/span&gt; の最小化を考える。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
J(\ve{\beta}) = \sum^{M}_{i = 1} w_{i} (y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}})^{2}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで &lt;span class="math"&gt;\(M\)&lt;/span&gt; は観測数。これは二次式だから評価関数は凸関数になる。早速 &lt;span class="math"&gt;\(\ve{\beta}\)&lt;/span&gt; で偏微分してみると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\parfrac{}{\ve{\beta}} J(\ve{\beta}) &amp;amp;= \sum^{M}_{i = 1} w_{i} 2 \left(- \frac{\partial}{\partial \ve{\beta}} \innerp{\ve{\beta}}{\ve{x}_{i}} \right) (y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}}) \\
 &amp;amp;= -2 \sum^{M}_{i = 1} w_{i} (y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}}) \ve{x}_{i}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\parfrac{}{\ve{\beta}} J(\ve{\beta}) = 0\)&lt;/span&gt; とおくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\sum_{i = 1}^{M} w_{i} \innerp{\ve{\beta}}{\ve{x}_{i}} \ve{x}_{i} &amp;amp;= \sum_{i = 1}^{M} w_{i} y_{i} \ve{x}_{i} \\
\iff
\left[ \ve{x}_{1} ... \ve{x}_{M} \right]
\left[
 \begin{array}{c}
   w_{1} \innerp{\ve{\beta}}{\ve{x}_{1}} \\
   \vdots     \\
   w_{M} \innerp{\ve{\beta}}{\ve{x}_{M}}
 \end{array}
\right]
&amp;amp;=
\left[ \ve{x}_{1} ... \ve{x}_{M} \right]
\left[
 \begin{array}{c}
   w_{1}y_{1} \\
   \vdots     \\
   w_{M}y_{M}
 \end{array}
\right]
\\
\iff
\left[ \ve{x}_{1} ... \ve{x}_{M} \right]
\left[
 \begin{array}{ccc}
   w_{1}  &amp;amp; \dots  &amp;amp; 0      \\
   \vdots &amp;amp; \ddots &amp;amp; \vdots \\
   0      &amp;amp; \dots  &amp;amp; w_{M}
 \end{array}
\right]
\left[
 \begin{array}{c}
   \innerp{\ve{\beta}}{\ve{x}_{1}} \\
   \vdots     \\
   \innerp{\ve{\beta}}{\ve{x}_{M}}
 \end{array}
\right]
&amp;amp;=
\left[ \ve{x}_{1} ... \ve{x}_{M} \right]
\left[
 \begin{array}{ccc}
   w_{1}  &amp;amp; \dots  &amp;amp; 0      \\
   \vdots &amp;amp; \ddots &amp;amp; \vdots \\
   0      &amp;amp; \dots  &amp;amp; w_{M}
 \end{array}
\right]
\left[
 \begin{array}{c}
   y_{1} \\
   \vdots     \\
   y_{M}
 \end{array}
\right]
\\
\iff
\left[ \ve{x}_{1} ... \ve{x}_{M} \right]
\left[
 \begin{array}{ccc}
   w_{1}  &amp;amp; \dots  &amp;amp; 0      \\
   \vdots &amp;amp; \ddots &amp;amp; \vdots \\
   0      &amp;amp; \dots  &amp;amp; w_{M}
 \end{array}
\right]
\left[
 \begin{array}{c}
   \ve{x}_{1}^{\mathsf{T}} \\
   \vdots     \\
   \ve{x}_{M}^{\mathsf{T}}
 \end{array}
\right]
\ve{\beta}
&amp;amp;=
\left[ \ve{x}_{1} ... \ve{x}_{M} \right]
\left[
 \begin{array}{ccc}
   w_{1}  &amp;amp; \dots  &amp;amp; 0      \\
   \vdots &amp;amp; \ddots &amp;amp; \vdots \\
   0      &amp;amp; \dots  &amp;amp; w_{M}
 \end{array}
\right]
\ve{y}
\\
\iff
\ve{X} \ve{W} \ve{X}^{\mathsf{T}} \ve{\beta} &amp;amp;= \ve{X} \ve{W} \ve{y}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\ve{X}\ve{W}\ve{X}^{\mathsf{T}}\)&lt;/span&gt; が正則（TODO: &lt;span class="math"&gt;\(\ve{X}\)&lt;/span&gt; が行フルランク、かつ &lt;span class="math"&gt;\(\ve{W}\)&lt;/span&gt; が正則なら行けそうに見えるけど本当か？）の場合は閉形式で係数が求まる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{\beta} = (\ve{X} \ve{W} \ve{X}^{\mathsf{T}})^{-1} \ve{X} \ve{W} \ve{y}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここまでは一般論。さて、更新式に注目する。&lt;span class="math"&gt;\(\beta_{j}\)&lt;/span&gt; だけで偏微分してみると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\parfrac{J(\ve{\beta})}{\beta_{j}} &amp;amp;= \sum_{i = 1}^{M} \parfrac{}{\beta_{j}} w_{i} (y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}})^{2} \\
&amp;amp;= -2 \sum_{i = 1}^{M} w_{i} (\ve{x}_{i})_{j} (y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}})
\end{align*}
&lt;/div&gt;
&lt;p&gt;残差のL1ノルム最小化を考えるときは &lt;span class="math"&gt;\(w_{i} = \frac{1}{|y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}}|}\)&lt;/span&gt; とおくので代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{J(\ve{\beta})}{\beta_{j}} = -2 \sum_{i = 1}^{M} (\ve{x}_{i})_{j} \mathrm{sign}(y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;瞬間値（&lt;/strong&gt; &lt;span class="math"&gt;\(M=1\)&lt;/span&gt; &lt;strong&gt;とする）を考えるとSigned-LMSの更新式そのものになっている。&lt;/strong&gt; 和を取ると平均操作に近いから、LMSアルゴリズムと考えていることは同じ。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\parfrac{J(\ve{\beta})}{\beta_{j}}\)&lt;/span&gt; を更に &lt;span class="math"&gt;\(\beta_{k}\)&lt;/span&gt; で偏微分してみると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{\partial^{2} J(\ve{\beta})}{\partial \beta_{j} \partial \beta_{k}} &amp;amp;= -2 \sum_{i = 1}^{M} w_{i} (\ve{x}_{i})_{j} \parfrac{}{\beta_{k}} (y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}}) \\
&amp;amp;= 2 \sum_{i = 1}^{M} w_{i} (\ve{x}_{i})_{j} (\ve{x}_{i})_{k} \\
&amp;amp;= 2 \left[ (\ve{x}_{1})_{j} \dots (\ve{x}_{M})_{j} \right]
 \left[
  \begin{array}{c}
    w_{1} (\ve{x}_{1})_{k} \\
    \vdots     \\
    w_{M} (\ve{x}_{M})_{k}
  \end{array}
 \right]
 = 2 \left[ (\ve{x}_{1})_{j} \dots (\ve{x}_{M})_{j} \right] \ve{W}
 \left[
  \begin{array}{c}
    (\ve{x}_{1})_{k} \\
    \vdots     \\
    (\ve{x}_{M})_{k}
  \end{array}
 \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;2次式が出てくるのがわかる（&lt;span class="math"&gt;\(\ve{W}\)&lt;/span&gt; は計量だ）。そして &lt;span class="math"&gt;\((\ve{H})_{jk} = \frac{\partial^{2} J(\ve{\beta})}{\partial \beta_{j} \partial \beta_{k}}\)&lt;/span&gt; なるヘッセ行列 &lt;span class="math"&gt;\(\ve{H}\)&lt;/span&gt; は以下:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{H} = 2 \ve{X} \ve{W} \ve{X}^{\mathsf{T}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ヘッセ行列の性質により関数の最小値・最大値の存在がわかる。対称行列なのは間違いない（&lt;span class="math"&gt;\((\ve{X})_{ij} = (\ve{X})_{ji}\)&lt;/span&gt; は自明）。（固有値分解とは見れない。&lt;span class="math"&gt;\(\ve{H}\)&lt;/span&gt; は &lt;span class="math"&gt;\(N \times N\)&lt;/span&gt; の行列であるのに対して、&lt;span class="math"&gt;\(\ve{X}\)&lt;/span&gt; は &lt;span class="math"&gt;\(N \times M\)&lt;/span&gt; の行列。&lt;span class="math"&gt;\(\ve{X} \ve{X}^{\mathsf{T}}\)&lt;/span&gt; は平均化、除算を抜いた分散共分散行列になり半正定値行列。）また、任意のベクトル &lt;span class="math"&gt;\(\ve{v}\)&lt;/span&gt; に対して、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{v}^{\mathsf{T}} \ve{X} \ve{W} \ve{X}^{\mathsf{T}} \ve{v} &amp;amp;= \ve{v}^{\mathsf{T}} \ve{X} \ve{W}^{1/2} \ve{W}^{1/2} \ve{X}^{\mathsf{T}} \ve{v} \\
&amp;amp;= (\ve{W}^{1/2} \ve{X}^{\mathsf{T}} \ve{v})^{\mathsf{T}} \ve{W}^{1/2} \ve{X}^{\mathsf{T}} \ve{v} \\
&amp;amp;= || \ve{W}^{1/2} \ve{X}^{\mathsf{T}} \ve{v} ||_{2}^{2} \geq 0
\end{align*}
&lt;/div&gt;
&lt;p&gt;だから、&lt;span class="math"&gt;\(\ve{W}\)&lt;/span&gt; が半正定値（&lt;span class="math"&gt;\(\iff\)&lt;/span&gt; すべての重みが非負）ならばヘッセ行列は半正定値行列で、極小値が最小値になる。また、&lt;span class="math"&gt;\(J(\ve{\beta})\)&lt;/span&gt; は凸関数（半正定値だから狭義の凸関数ではない）。
もう少しヘッセ行列を見る。ヘッセ行列を上手く使えたらニュートン法で解けそうな気がして。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\ve{H})_{jk} = 2 \sum_{i = 1}^{M} w_{i} (\ve{x}_{i})_{j} (\ve{x}_{i})_{k}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;より、スペクトル分解的に見ると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{1}{2} \ve{H} &amp;amp;=
w_{1} \left[
  \begin{array}{ccc}
    (\ve{x}_{1})_{1}^{2}  &amp;amp; \dots &amp;amp; (\ve{x}_{1})_{1} (\ve{x}_{1})_{N} \\
    \vdots &amp;amp; \ddots &amp;amp; \vdots \\
    (\ve{x}_{1})_{N} (\ve{x}_{1})_{1} &amp;amp; \dots &amp;amp; (\ve{x}_{1})_{N}^{2} \\
  \end{array}
 \right]
 + \dots +
 w_{M} \left[
  \begin{array}{ccc}
    (\ve{x}_{M})_{1}^{2}  &amp;amp; \dots &amp;amp; (\ve{x}_{M})_{1} (\ve{x}_{M})_{N} \\
    \vdots &amp;amp; \ddots &amp;amp; \vdots \\
    (\ve{x}_{M})_{N} (\ve{x}_{M})_{1} &amp;amp; \dots &amp;amp; (\ve{x}_{M})_{N}^{2} \\
  \end{array}
 \right] \\
 &amp;amp;= w_{1} \ve{x}_{1} \ve{x}_{1}^{\mathsf{T}} + \dots + w_{M} \ve{x}_{M} \ve{x}_{M}^{\mathsf{T}} \\
 &amp;amp;= \sum_{i = 1}^{M} w_{i} \ve{x}_{i} \ve{x}_{i}^{\mathsf{T}}
\end{align*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;信号処理的には &lt;span class="math"&gt;\(\ve{x}_{1}, \ve{x}_{2}, \dots \ve{x}_{M}\)&lt;/span&gt; は系列で現れる。&lt;/li&gt;
&lt;li&gt;LMSフィルタでは &lt;span class="math"&gt;\(i = 1\)&lt;/span&gt; の時だけを考えていたと考えられれる。 &lt;span class="math"&gt;\(i = 2,\dots,M\)&lt;/span&gt; のときの影響は少ないのではないかと思う。&lt;/li&gt;
&lt;li&gt;FIRフィルタを考えるのならば、各 &lt;span class="math"&gt;\(\ve{x}_{1}\)&lt;/span&gt; は入ってきた1次元信号データを時系列順に並べたものだから、直前のベクトル &lt;span class="math"&gt;\(\ve{x}_{2}\)&lt;/span&gt; を使えそうな構造に見える。&lt;/li&gt;
&lt;li&gt;上の仮定を使ってヘッセ行列の逆行列 &lt;span class="math"&gt;\(\ve{H}^{-1}\)&lt;/span&gt; を逐次近似計算できない？&lt;/li&gt;
&lt;li&gt;分散共分散行列がほぼヘッセ行列になってるけどこれは何？&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.iim.cs.tut.ac.jp/~kanatani/papers/jcov.pdf"&gt;金谷さんの解説&lt;/a&gt; にそれとなく解説がある。フィッシャー情報行列との関連もある。。。クラメル・ラオの下限についてわかりやすい説明あり。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://web.econ.keio.ac.jp/staff/bessho/lecture/09/091014ML.pdf"&gt;最尤法&lt;/a&gt; にもそれとなく解説あり。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://oku.edu.mie-u.ac.jp/~okumura/stat/141115.html"&gt;奥村さん&lt;/a&gt; もあり。観測からヘッセ行列を構成できる？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そして自然勾配のアイディアが出てくる。自然勾配を使ったLMSアルゴリズムは…あった…&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://scholarsmine.mst.edu/cgi/viewcontent.cgi?referer=https://www.google.com/&amp;amp;httpsredir=1&amp;amp;article=2780&amp;amp;context=ele_comeng_facwork"&gt;Normalized Natural Gradient Adaptive Filtering for Sparse and Nonsparse Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.76.7538&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;甘利先生による解説&lt;/a&gt; で、LMSアルゴリズム含めて大まかなところはだいたい言ってる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/profile/Ligang_Liu3/publication/44098179_On_Improvement_of_Proportionate_Adaptive_Algorithms_for_Sparse_Impulse_Response/links/00b495315266ab9cfd000000.pdf"&gt;高知工科大学の博論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ワンチャンスL1残差最小化はやってないかも。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;前のMTGで言われたことの整理&lt;/li&gt;
&lt;li&gt;分散行列、ヘッセ行列、フィッシャー情報行列、自然勾配の整理&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiseodd.github.io/techblog/2018/03/11/fisher-information/"&gt;Fisher Information Matrix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OMPが気になる。試してみたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="IRLS"></category><category term="L1ノルム"></category><category term="LAD"></category></entry><entry><title>IRLS(Iteratively Reweighted Least Squares) その2</title><link href="/irlsiteratively-reweighted-least-squares-sono2.html" rel="alternate"></link><published>2020-04-19T19:30:00+09:00</published><updated>2020-04-20T14:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-19:/irlsiteratively-reweighted-least-squares-sono2.html</id><summary type="html">&lt;p&gt;理論ばっかり追っていて悶々してきたので、IRLSでL1残差最小化が解けないか実験してみる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/kibo35/sparse-modeling/blob/master/ch05.ipynb"&gt;第5章 厳密解から近似解へ&lt;/a&gt; に『スパースモデリング』5章のPython実装あり。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/kibo35/items/66ec4479b0899ea4987d#irlsの概要"&gt;スパースモデリング：第3章 追跡アルゴリズム&lt;/a&gt; は『スパースモデリング』3章のPython実装。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IRLSの実装は &lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=2ahUKEwi4wZXEhe3oAhUZMd4KHZrzDqQQFjAAegQIARAB&amp;amp;url=https%3A%2F%2Fis.cuni.cz%2Fwebapps%2Fzzp%2Fdownload%2F130215341&amp;amp;usg=AOvVaw3Cxgr7_WLuDQqhL1aKQl9f"&gt;カレル大学卒論&lt;/a&gt; を参考に。Pythonで簡単にできた。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt;

&lt;span class="c1"&gt;# IRLS法によりPhi @ x = yのスパース解を求める&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;irls_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Phi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;EPSILON&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;8.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;# 重みの計算&lt;/span&gt;
    &lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Phi&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flatten&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="c1"&gt;# 小さくなりすぎた重みは打ち切る&lt;/span&gt;
    &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;EPSILON&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSILON&lt;/span&gt;
    &lt;span class="c1"&gt;# 対角行列に展開&lt;/span&gt;
    &lt;span class="n"&gt;W&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;diag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;weight …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;理論ばっかり追っていて悶々してきたので、IRLSでL1残差最小化が解けないか実験してみる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/kibo35/sparse-modeling/blob/master/ch05.ipynb"&gt;第5章 厳密解から近似解へ&lt;/a&gt; に『スパースモデリング』5章のPython実装あり。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/kibo35/items/66ec4479b0899ea4987d#irlsの概要"&gt;スパースモデリング：第3章 追跡アルゴリズム&lt;/a&gt; は『スパースモデリング』3章のPython実装。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IRLSの実装は &lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=2ahUKEwi4wZXEhe3oAhUZMd4KHZrzDqQQFjAAegQIARAB&amp;amp;url=https%3A%2F%2Fis.cuni.cz%2Fwebapps%2Fzzp%2Fdownload%2F130215341&amp;amp;usg=AOvVaw3Cxgr7_WLuDQqhL1aKQl9f"&gt;カレル大学卒論&lt;/a&gt; を参考に。Pythonで簡単にできた。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt;

&lt;span class="c1"&gt;# IRLS法によりPhi @ x = yのスパース解を求める&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;irls_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Phi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;EPSILON&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;8.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;# 重みの計算&lt;/span&gt;
    &lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Phi&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flatten&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="c1"&gt;# 小さくなりすぎた重みは打ち切る&lt;/span&gt;
    &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;EPSILON&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSILON&lt;/span&gt;
    &lt;span class="c1"&gt;# 対角行列に展開&lt;/span&gt;
    &lt;span class="n"&gt;W&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;diag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;# 更新後の係数: Phi.T @ W @ Phi @ x = Phi.T @ W @ y の解&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linalg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;solve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Phi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;W&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;Phi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Phi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;W&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;DIMENSION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="n"&gt;NUM_SAMPLES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;
    &lt;span class="n"&gt;NUM_ITERATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;

    &lt;span class="c1"&gt;# 解ベクトル&lt;/span&gt;
    &lt;span class="n"&gt;X_ANSWER&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reshape&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;DIMENSION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;DIMENSION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;xhistory&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;DIMENSION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NUM_ITERATION&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;# 観測を生成&lt;/span&gt;
    &lt;span class="n"&gt;Phi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NUM_SAMPLES&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DIMENSION&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Phi&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;X_ANSWER&lt;/span&gt;
    &lt;span class="c1"&gt;# 加法的雑音を重畳&lt;/span&gt;
    &lt;span class="c1"&gt;# yrand = y + numpy.random.normal(0, 0.3, (NUM_SAMPLES, 1))&lt;/span&gt;
    &lt;span class="n"&gt;yrand&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;laplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NUM_SAMPLES&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NUM_ITERATION&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;emp_error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NUM_ITERATION&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# IRLSを繰り返し適用&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NUM_ITERATION&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;irls_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Phi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;yrand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;xhistory&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reshape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linalg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;norm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Phi&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;NUM_SAMPLES&lt;/span&gt;
        &lt;span class="n"&gt;emp_error&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linalg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;norm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;yrand&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Phi&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;NUM_SAMPLES&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実装は楽だったけど、誤差解析が沼。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;誤差を重畳してみると、真の誤差と経験誤差が当然一致しない。&lt;/li&gt;
&lt;li&gt;経験誤差的には局所解に入っている印象。&lt;/li&gt;
&lt;li&gt;サンプル数が少ないと大域最小解に入らないケースあり（経験誤差曲面の最小値が真の誤差の曲面の最小値に不一致）&lt;/li&gt;
&lt;li&gt;経験誤差の曲面は二次曲線に見える。（2次式の最小化を考えているから当然のはず。）&lt;/li&gt;
&lt;li&gt;最小二乗解よりも誤差が悪い時がある。最小二乗解はorder=2とすれば良くて、その時重み行列Wは単位行列になり、普通の最小二乗法と一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;思いつき:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;IRLSは評価関数の最小化を考える時閉形式で求まるので何も考えない。パラメータに関してもう一度微分できるのでニュートン法使えそう。&lt;/li&gt;
&lt;li&gt;フィルタのときのように逐次的に求められない？&lt;ul&gt;
&lt;li&gt;パラメータ全てではなく1こずつ。サンプルについても1こずつ。更新していく。評価関数の最小化は平均値の最小化に見受けられるので、逐次的に更新しても良いように見える。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日は遅いのでもう寝る。&lt;/p&gt;
</content><category term="雑記"></category><category term="LAD"></category><category term="IRLS"></category><category term="L1ノルム"></category></entry><entry><title>IRLS(Iteratively Reweighted Least Squares)</title><link href="/irlsiteratively-reweighted-least-squares.html" rel="alternate"></link><published>2020-04-18T17:30:00+09:00</published><updated>2020-04-19T00:19:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-18:/irlsiteratively-reweighted-least-squares.html</id><summary type="html">&lt;p&gt;LAD(Least Absolute Deviation)を近似的・逐次的に解く方法としてのIRLSについて調査。そういえば基本的な原理を抑えていなかった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://retrofocus28.blogspot.com/2015/09/iteratively-reweighted-least-squares.html"&gt;Iteratively Reweighted Least Squares　についてサクッと。&lt;/a&gt; 文字通りサクッとしたまとめ。OMPを使って解いているというのがとても気になる&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cnx.org/contents/krkDdys0&amp;#64;12/Iterative-Reweighted-Least-Squares"&gt;Iterative Reweighted Least Squares&lt;/a&gt; 導入から解法まで。しかしなぜ解が求まるのかは不明。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cedar.buffalo.edu/~srihari/CSE574/Chap4/4.3.3-IRLS.pdf"&gt;Iterative Reweighted Least Squares&lt;/a&gt; バッファロー大の講義資料？これも何故解けるのかはちゃんと書いてない。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.maths.lth.se/matematiklth/personal/fredrik/Session3.pdf"&gt;Iterative Reweighted Least Squares&lt;/a&gt; これが一番いいかも。なぜ解けるかもざっくり証明がある。&lt;ul&gt;
&lt;li&gt;そこで出てきたsupergradient（優勾配？劣勾配に対応している？）がよくわからん。資料のすぐ下に解説があったけど。 &lt;a class="reference external" href="http://www.its.caltech.edu/~kcborder/Notes/Supergrad.pdf"&gt;Supergradients&lt;/a&gt; に定義はあったけど幾何学的イメージが欲しい。&lt;/li&gt;
&lt;li&gt;Weiszfeld Algorithmsという幾何中央値を求めるアルゴリズムは &lt;a class="reference external" href="http://users.cecs.anu.edu.au/~trumpf/pubs/aftab_hartley_trumpf_PAMI2014.pdf"&gt;Generalized Weiszfeld Algorithms for Lq Optimization&lt;/a&gt; に解説あり。しかしこの論文いいこと言ってる。「Generalized …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;LAD(Least Absolute Deviation)を近似的・逐次的に解く方法としてのIRLSについて調査。そういえば基本的な原理を抑えていなかった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://retrofocus28.blogspot.com/2015/09/iteratively-reweighted-least-squares.html"&gt;Iteratively Reweighted Least Squares　についてサクッと。&lt;/a&gt; 文字通りサクッとしたまとめ。OMPを使って解いているというのがとても気になる&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cnx.org/contents/krkDdys0&amp;#64;12/Iterative-Reweighted-Least-Squares"&gt;Iterative Reweighted Least Squares&lt;/a&gt; 導入から解法まで。しかしなぜ解が求まるのかは不明。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cedar.buffalo.edu/~srihari/CSE574/Chap4/4.3.3-IRLS.pdf"&gt;Iterative Reweighted Least Squares&lt;/a&gt; バッファロー大の講義資料？これも何故解けるのかはちゃんと書いてない。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.maths.lth.se/matematiklth/personal/fredrik/Session3.pdf"&gt;Iterative Reweighted Least Squares&lt;/a&gt; これが一番いいかも。なぜ解けるかもざっくり証明がある。&lt;ul&gt;
&lt;li&gt;そこで出てきたsupergradient（優勾配？劣勾配に対応している？）がよくわからん。資料のすぐ下に解説があったけど。 &lt;a class="reference external" href="http://www.its.caltech.edu/~kcborder/Notes/Supergrad.pdf"&gt;Supergradients&lt;/a&gt; に定義はあったけど幾何学的イメージが欲しい。&lt;/li&gt;
&lt;li&gt;Weiszfeld Algorithmsという幾何中央値を求めるアルゴリズムは &lt;a class="reference external" href="http://users.cecs.anu.edu.au/~trumpf/pubs/aftab_hartley_trumpf_PAMI2014.pdf"&gt;Generalized Weiszfeld Algorithms for Lq Optimization&lt;/a&gt; に解説あり。しかしこの論文いいこと言ってる。「Generalized Weiszfeld Algorithms」は圧縮センシングとは異なりスパース表現を求めるわけではない。スパース性は担保されなくても、よりL1ノルムの意味で小さい解を求める。&lt;/li&gt;
&lt;li&gt;なぜ、IRLSとLMSアルゴリズムを結びつける研究がないのか。IRLSの逐次適用によってもフィルタ係数を更新していけそうだけど。試してみるし、類似研究が無いか引き続き調べる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;『スパースモデリング』の5章にも記述はある。しかし残差のL1最小化ではない。&lt;/p&gt;
</content><category term="雑記"></category><category term="LAD"></category><category term="IRLS"></category><category term="L1ノルム"></category></entry><entry><title>LAD(Least Absolute Deviation)</title><link href="/ladleast-absolute-deviation.html" rel="alternate"></link><published>2020-04-17T23:00:00+09:00</published><updated>2020-04-17T23:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-17:/ladleast-absolute-deviation.html</id><summary type="html">&lt;p&gt;LAD(Least Absolute Deviation)を見ている。これは、残差をL1ノルムにした回帰問題一般のこと。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=2ahUKEwi4wZXEhe3oAhUZMd4KHZrzDqQQFjAAegQIARAB&amp;amp;url=https%3A%2F%2Fis.cuni.cz%2Fwebapps%2Fzzp%2Fdownload%2F130215341&amp;amp;usg=AOvVaw3Cxgr7_WLuDQqhL1aKQl9f"&gt;カレル大学卒論&lt;/a&gt; が結構まとまっている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://core.ac.uk/download/pdf/81785239.pdf"&gt;最尤推定による近似的手法&lt;/a&gt; は軽く読んだ。各傾きと切片を固定して逐次更新していく。更新時は中央値を拾ってくる。うーん中央値だと高速推定が厳しい。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ラプラス分布の最尤推定しようとしてもがく。対数尤度とって見てみても、単純な絶対値和が出て止まるし、反復スケーリング法を参考に、パラメータの増分を加えた時の対数尤度の下限を求めようとしたが上手く行かず。4時間飛ばす。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="最尤推定の計算のあがき" src="./images/IMG_3828.jpg" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;最尤推定の計算のあがき&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;あがいて「A maximum likelihood approach to least absolute deviation regression」を引用している文献を漁ったら辞書学習をL1にしているやつが、やっぱりいた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://winsty.net/papers/onndl.pdf"&gt;Online Robust Non-negative Dictionary Learning for Visual Tracking&lt;/a&gt; パーティクルフィルターを使っておる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上の文献で使ってるHuber Loss結構すごくね？この誤差に基づくLMSアルゴリズムねえの？→「Robust Huber adaptive filter」だけど中身を読めず …&lt;/p&gt;</summary><content type="html">&lt;p&gt;LAD(Least Absolute Deviation)を見ている。これは、残差をL1ノルムにした回帰問題一般のこと。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=2ahUKEwi4wZXEhe3oAhUZMd4KHZrzDqQQFjAAegQIARAB&amp;amp;url=https%3A%2F%2Fis.cuni.cz%2Fwebapps%2Fzzp%2Fdownload%2F130215341&amp;amp;usg=AOvVaw3Cxgr7_WLuDQqhL1aKQl9f"&gt;カレル大学卒論&lt;/a&gt; が結構まとまっている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://core.ac.uk/download/pdf/81785239.pdf"&gt;最尤推定による近似的手法&lt;/a&gt; は軽く読んだ。各傾きと切片を固定して逐次更新していく。更新時は中央値を拾ってくる。うーん中央値だと高速推定が厳しい。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ラプラス分布の最尤推定しようとしてもがく。対数尤度とって見てみても、単純な絶対値和が出て止まるし、反復スケーリング法を参考に、パラメータの増分を加えた時の対数尤度の下限を求めようとしたが上手く行かず。4時間飛ばす。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="最尤推定の計算のあがき" src="./images/IMG_3828.jpg" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;最尤推定の計算のあがき&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;あがいて「A maximum likelihood approach to least absolute deviation regression」を引用している文献を漁ったら辞書学習をL1にしているやつが、やっぱりいた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://winsty.net/papers/onndl.pdf"&gt;Online Robust Non-negative Dictionary Learning for Visual Tracking&lt;/a&gt; パーティクルフィルターを使っておる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上の文献で使ってるHuber Loss結構すごくね？この誤差に基づくLMSアルゴリズムねえの？→「Robust Huber adaptive filter」だけど中身を読めず…&lt;/p&gt;
&lt;p&gt;また、 &lt;a class="reference external" href="https://www.ml.uni-saarland.de/Lectures/CVX-SS10/ConvexOptimization-07-07-10.pdf"&gt;Convex Optimization and Modeling&lt;/a&gt; を読んでたらHuber損失はL1とL2の中間的な性質を示すようで、0に集中しなくなりそうな印象を受けた。&lt;/p&gt;
</content><category term="雑記"></category><category term="LAD"></category><category term="L1ノルム"></category></entry><entry><title>LMSフィルターの挙動観察</title><link href="/lmshuirutanoju-dong-guan-cha.html" rel="alternate"></link><published>2020-04-16T23:20:00+09:00</published><updated>2020-04-16T23:20:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-16:/lmshuirutanoju-dong-guan-cha.html</id><summary type="html">&lt;p&gt;&lt;span class="math"&gt;\(\mathrm{E}[\mathrm{sign}[e(n)]x(n-m)]\)&lt;/span&gt; の挙動を追いたい。色々な信号に対して、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(m\)&lt;/span&gt; が十分大きいとき、0に近づくかどうか&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;を知りたい。もし0に近づくならば有効な過程として解法に使える。
しかしその前に、LMSフィルター自体の挙動を追いたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;残差はどの様に減る？残差の時系列は？&lt;ul&gt;
&lt;li&gt;ステップサイズにより収束の度合い（残差の分布）が違う...&lt;/li&gt;
&lt;li&gt;当然、フィルタ次数でも収束の度合い（残差の分布）が違う&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;残差分布はどうなってる？Signed-LMSでラプラス分布に近づいてる？&lt;ul&gt;
&lt;li&gt;これは本当のようで、Signed-LMSの方が裾が細い残差分布が得られている。&lt;/li&gt;
&lt;li&gt;単純な正弦波に対してはLMSのほうが残差が小さくなるが、ボイスやピアノ音源に対しては圧倒的にSignLMSの方が性能が良い（残差のヒストグラムを見ると、裾が狭い）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\mathrm{E}[\mathrm{sign}[e(n)]x(n-m)]\)&lt;/span&gt;, &lt;span class="math"&gt;\(\mathrm{E}[e(n)x(n-m)]\)&lt;/span&gt; は両方とも0。&lt;ul&gt;
&lt;li&gt;逐次計算していったら …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;span class="math"&gt;\(\mathrm{E}[\mathrm{sign}[e(n)]x(n-m)]\)&lt;/span&gt; の挙動を追いたい。色々な信号に対して、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(m\)&lt;/span&gt; が十分大きいとき、0に近づくかどうか&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;を知りたい。もし0に近づくならば有効な過程として解法に使える。
しかしその前に、LMSフィルター自体の挙動を追いたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;残差はどの様に減る？残差の時系列は？&lt;ul&gt;
&lt;li&gt;ステップサイズにより収束の度合い（残差の分布）が違う...&lt;/li&gt;
&lt;li&gt;当然、フィルタ次数でも収束の度合い（残差の分布）が違う&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;残差分布はどうなってる？Signed-LMSでラプラス分布に近づいてる？&lt;ul&gt;
&lt;li&gt;これは本当のようで、Signed-LMSの方が裾が細い残差分布が得られている。&lt;/li&gt;
&lt;li&gt;単純な正弦波に対してはLMSのほうが残差が小さくなるが、ボイスやピアノ音源に対しては圧倒的にSignLMSの方が性能が良い（残差のヒストグラムを見ると、裾が狭い）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\mathrm{E}[\mathrm{sign}[e(n)]x(n-m)]\)&lt;/span&gt;, &lt;span class="math"&gt;\(\mathrm{E}[e(n)x(n-m)]\)&lt;/span&gt; は両方とも0。&lt;ul&gt;
&lt;li&gt;逐次計算していったら、音源非依存で0に近づいていく&lt;/li&gt;
&lt;li&gt;当然だよな…そもそもの過程として入力と雑音は無相関と仮定しているのだから。&lt;ul&gt;
&lt;li&gt;仮定しているのだからは正しくなくて、無相関にするようにフィルタ係数を更新しているが正しい。&lt;/li&gt;
&lt;li&gt;無相関になったときに勾配が0で最急勾配法が止まる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;なんか絶対値誤差最小化ってどっかで見たよな…と思っていたら、&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Least_absolute_deviations"&gt;https://en.wikipedia.org/wiki/Least_absolute_deviations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;修士のときに一回戦っていた。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=2ahUKEwi4wZXEhe3oAhUZMd4KHZrzDqQQFjAAegQIARAB&amp;amp;url=https%3A%2F%2Fis.cuni.cz%2Fwebapps%2Fzzp%2Fdownload%2F130215341&amp;amp;usg=AOvVaw3Cxgr7_WLuDQqhL1aKQl9f"&gt;カレル大学卒論&lt;/a&gt; が結構まとまっている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(L_{1}\)&lt;/span&gt; ノルム最小化を近接オペレータの繰り返し適用で解けんじゃね？と思っている&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://yamagensakam.hatenablog.com/entry/2018/02/14/075106"&gt;近接勾配法とproximal operator&lt;/a&gt; を読んだが、パラメータ正則化だけだな&lt;/li&gt;
&lt;li&gt;パラメータ正則化はあるけど、残差をスパースにするのがない。なんで？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="LMS Algorithm"></category></entry><entry><title>続・古いロスレス音声コーデックの調査</title><link href="/sok-gu-irosuresuyin-sheng-kodetsukunodiao-cha.html" rel="alternate"></link><published>2020-04-10T23:18:00+09:00</published><updated>2020-04-10T23:18:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-10:/sok-gu-irosuresuyin-sheng-kodetsukunodiao-cha.html</id><content type="html">&lt;p&gt;古いロスレス音声コーデックと理論の概要を取りまとめた雑誌の特集があった:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.eie.polyu.edu.hk/~enyhchan/ce_ac_p1.pdf"&gt;Lossless Compression of Digital Audio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理論としてもその通りだし、雑誌発行時点(1998)からさしたるブレークスルーが無いように見える。&lt;/p&gt;
&lt;p&gt;AudioPak, OggSquish, Philips, Sonarc, WAという謎のコーデック現る…。いったい何個あるんだ。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio"></category><category term="ロスレス音声"></category></entry><entry><title>古いロスレス音声コーデックの調査/スパース適応フィルタ</title><link href="/gu-irosuresuyin-sheng-kodetsukunodiao-cha-supasushi-ying-huiruta.html" rel="alternate"></link><published>2020-04-08T16:45:00+09:00</published><updated>2020-04-08T23:45:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-08:/gu-irosuresuyin-sheng-kodetsukunodiao-cha-supasushi-ying-huiruta.html</id><summary type="html">&lt;p&gt;ロスレス音声の歴史を探るために古いロスレス音声コーデックの情報を探っている。以下のサイトが &lt;a class="reference external" href="https://wiki.hydrogenaud.io/index.php?title=Lossless_comparison"&gt;Hydrogenaudioでの比較&lt;/a&gt; よりも古い内容を扱っている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.firstpr.com.au/audiocomp/lossless/index.html"&gt;Lossless Compression of Audio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;見つけたロスレス音声コーデックを一覧する。というかほぼ &lt;a class="reference external" href="https://www.rarewares.org/rrw/about.php"&gt;Really Rare Wares&lt;/a&gt; 様へのリンク。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;古めのロスレス音声コーデック&lt;/h2&gt;
&lt;div class="section" id="rkau-rk-audio"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.rarewares.org/rrw/rkau.php"&gt;RKAU(RK Audio)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;古い比較において優秀な圧縮率を誇っていた。当時のMonkey's Audioよりも上。サイトを覗いたら exe と dll のみの配布だった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.archive.org/web/20020124045327/http://rksoft.virtualave.net/rkau.html"&gt;RKAUのホームページ（魚拓）&lt;/a&gt; を見ても特に情報なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="audiozip"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.rarewares.org/rrw/audiozip.php"&gt;AudioZip&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;これも圧縮率が比較的優秀。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.archive.org/web/20020207080740/http://www.csp.ntu.edu.sg:8000/MMS/MMCProjects.htm"&gt;AudioZipのホームページ（魚拓）&lt;/a&gt; を見てもこちらも特に情報なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="wavarc"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://www.firstpr.com.au/audiocomp/lossless/wavarc/0readme.html"&gt;WavArc&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;こちらも最大圧縮率(-c5)を選択するとそれなりに優秀な結果を出していた。このページにexeとドキュメントをまとめたzipもあり。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="wavezip"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.rarewares.org/rrw/wavezip.php"&gt;WaveZip&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;圧縮率よりは速度重視のコーデックのようだ。MUSICompress というアルゴリズムの実装。 &lt;a class="reference external" href="https://www.rarewares.org/rrw/files/lossless/musi_txt.txt"&gt;WaveZipのデータシート&lt;/a&gt; によると符号化にはLZ(Lampel-Ziv)を使用しているようだ。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.firstpr.com.au/audiocomp/lossless/index.html#wavezip"&gt;WaveZipの概要&lt;/a&gt; が比較サイトに掲載されていた。どうやら …&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;ロスレス音声の歴史を探るために古いロスレス音声コーデックの情報を探っている。以下のサイトが &lt;a class="reference external" href="https://wiki.hydrogenaud.io/index.php?title=Lossless_comparison"&gt;Hydrogenaudioでの比較&lt;/a&gt; よりも古い内容を扱っている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.firstpr.com.au/audiocomp/lossless/index.html"&gt;Lossless Compression of Audio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;見つけたロスレス音声コーデックを一覧する。というかほぼ &lt;a class="reference external" href="https://www.rarewares.org/rrw/about.php"&gt;Really Rare Wares&lt;/a&gt; 様へのリンク。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;古めのロスレス音声コーデック&lt;/h2&gt;
&lt;div class="section" id="rkau-rk-audio"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.rarewares.org/rrw/rkau.php"&gt;RKAU(RK Audio)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;古い比較において優秀な圧縮率を誇っていた。当時のMonkey's Audioよりも上。サイトを覗いたら exe と dll のみの配布だった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.archive.org/web/20020124045327/http://rksoft.virtualave.net/rkau.html"&gt;RKAUのホームページ（魚拓）&lt;/a&gt; を見ても特に情報なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="audiozip"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.rarewares.org/rrw/audiozip.php"&gt;AudioZip&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;これも圧縮率が比較的優秀。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.archive.org/web/20020207080740/http://www.csp.ntu.edu.sg:8000/MMS/MMCProjects.htm"&gt;AudioZipのホームページ（魚拓）&lt;/a&gt; を見てもこちらも特に情報なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="wavarc"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://www.firstpr.com.au/audiocomp/lossless/wavarc/0readme.html"&gt;WavArc&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;こちらも最大圧縮率(-c5)を選択するとそれなりに優秀な結果を出していた。このページにexeとドキュメントをまとめたzipもあり。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="wavezip"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.rarewares.org/rrw/wavezip.php"&gt;WaveZip&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;圧縮率よりは速度重視のコーデックのようだ。MUSICompress というアルゴリズムの実装。 &lt;a class="reference external" href="https://www.rarewares.org/rrw/files/lossless/musi_txt.txt"&gt;WaveZipのデータシート&lt;/a&gt; によると符号化にはLZ(Lampel-Ziv)を使用しているようだ。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.firstpr.com.au/audiocomp/lossless/index.html#wavezip"&gt;WaveZipの概要&lt;/a&gt; が比較サイトに掲載されていた。どうやら、入力波形を近似波形と誤差波形に分けて符号化するようだ。WaveZipではHu&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="lpac-ltac"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.rarewares.org/rrw/lpac.php"&gt;LPAC/LTAC&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;LPACはMPEG4-ALSの前身。LPACの前身がLTAC。LPACの平均的な圧縮率は優秀なようだ。 &lt;a class="reference external" href="https://web.archive.org/web/20060213124711/http://www.nue.tu-berlin.de/wer/liebchen/lpac.html"&gt;LPAC（魚拓）&lt;/a&gt; に以前公開していたサイトあり。&lt;/p&gt;
&lt;p&gt;LTAC(Lossless Transform Audio Compression)は名前の通り変換符号化に基づくロスレス音声圧縮コーデック、LPAC(Lossless Predictive Audio Compression)は予測に基づくロスレス音声圧縮コーデック。&lt;/p&gt;
&lt;p&gt;LPACに ベルリン工科大学、Real Networks、NTT の改良が加わってMPEG4-ALSが出来上がり、それ以降LPACの開発は停止されている。この経緯については &lt;a class="reference external" href="https://web.archive.org/web/20060212123059/http://www.nue.tu-berlin.de/forschung/projekte/lossless/mp4als.html"&gt;MPEG4-ALS（魚拓）&lt;/a&gt; に記述あり。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="shorten"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://archive.is/Z8k97"&gt;Shorten（魚拓）&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;おそらくロスレス音声の最古参にして基礎。なんと執筆時点（2020-04-08）でも &lt;tt class="docutils literal"&gt;brew&lt;/tt&gt; でインストールできた（ &lt;a class="reference external" href="https://linux.die.net/man/1/shorten"&gt;Shortenのmanページ&lt;/a&gt; もあるから各Linuxディストリビューションで使えるものと想像する）。エンコード速度はピカイチ。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=9797AA37C32F12179AF0803D8C2B22D2?doi=10.1.1.53.7337&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Shortenの論文&lt;/a&gt; （テクニカルレポート）もある。この論文で、今のロスレス音声につながる重要な事実に幾つか触れている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;音声信号は準定常（短い区間では定常とみなせる）だからブロックに分けてエンコード/デコードすべき。&lt;/li&gt;
&lt;li&gt;音声のモデル化には線形予測(LPC, Linear Predictive Coding)が使える。&lt;/li&gt;
&lt;li&gt;残差信号はガウス分布よりもラプラス分布に従っていると見える。その符号化にはライス符号を使うのが良い。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この時点で既にラプラス分布を仮定したパラメータ設定を行っているからかなりの慧眼。他のロスレス音声コーデックはShortenを発展させたものに過ぎないと見える。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;所感&lt;/h2&gt;
&lt;p&gt;どうも2000年代前半までは各自でロスレス音声コーデックを作り、各自で最強を謳っていたらしい。&lt;/p&gt;
&lt;p&gt;歴史を雑にまとめると、1994年にShortenの論文が出てから、それよりも圧縮率の良いもの、圧縮速度（展開速度）が早いものが開発されて混沌に突入し上記のコーデックが現れた。その後、Monkey's Audio, WavPack, FLAC, LPAC（MPEG4-ALS）が生き残り、2000年以降はLa（更新停止）, TAK, TTA, ALAC（更新停止）, WMAL(Windows Media Audio Lossless), 2010年以降はOptimFROGが出現しているようだ。&lt;/p&gt;
&lt;p&gt;気になるのは比較サイトの &lt;a class="reference external" href="http://www.firstpr.com.au/audiocomp/lossless/index.html#rice"&gt;Rice Coding, AKA Rice Packing, Elias Gamma codes and other approaches&lt;/a&gt; である。Rice符号よりも効率の良いとされるPod符号の紹介がある。要観察。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id14"&gt;
&lt;h2&gt;スパース適応フィルタ&lt;/h2&gt;
&lt;p&gt;LPCの定式化をスパースにする試みは多くなされている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.cs.tut.fi/~tabus/2013GhidoTabus.pdf"&gt;Sparse Modeling for Lossless Audio Compression&lt;/a&gt; : Ghidoさん（OptimFROGの人）の試み&lt;ul&gt;
&lt;li&gt;貪欲法によりスパース解を求めている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jasj/71/11/71_KJ00010109335/_pdf/-char/ja"&gt;スパース表現に基づく音声音響符号化&lt;/a&gt; : NTTの試み&lt;ul&gt;
&lt;li&gt;最小二乗解を求めるのではなくL1最小化に置き換えた定式化を行う。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;でも、TTAがやっているような適応フィルタをスパース解に近づける手法はまだロスレス音声に対してやっていないように見える。
スパースな解を目指してフィルタ係数を更新する適応フィルタはスパース適応フィルタ(Sparse Adaptive Filters)というようで、2000年代以降に研究が進んでいるようだ。&lt;/p&gt;
&lt;p&gt;最も基本的な適応フィルタであるLMS(Least Mean Square)フィルタは名前の通り二乗誤差最小化に立脚している。
スパース適応フィルタの主な用途はエコーキャンセル、ブラインド話者分離、複数話者特定ではあるが、やはり変換後の分布がスパースになるというのは大きい。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://signal.ee.bilkent.edu.tr/defevent/papers/cr1256.pdf"&gt;スパース適応フィルタの最近のサーベイ論文&lt;/a&gt; を流し読みした。スパース適応フィルタは、変数更新のときに1部の変数だけ更新する方法と、スパース最適化に従って更新するやり方の2つがあった。PNLMS(Proportionate NLMS), IPNLMS(Improved PNLMS)が後者の定式化で興味あり。引き続き見ていく。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1012.5066.pdf"&gt;Regularized Least-Mean-Square Algorithms&lt;/a&gt; には正則化を入れたLMSアルゴリズムの解説あり。LASSOにモチベーションを受けた最適化アルゴリズムが &lt;a class="reference external" href="https://wiki.eecs.umich.edu/global/data/hero/images/7/7b/Yilun-icassp2-09.pdf"&gt;ZA-LMS&lt;/a&gt; や &lt;a class="reference external" href="http://azadproject.ir/wp-content/uploads/2017/01/2018-Online-Sparse-System-Identification-and-Signal-Reconstruction-Using-Projections-.pdf"&gt;APWL1&lt;/a&gt; として提案されている。&lt;/p&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="SLA"></category><category term="Lossless Audio"></category><category term="ロスレス音声"></category><category term="スパース符号化"></category></entry><entry><title>ブログ導入</title><link href="/burogudao-ru.html" rel="alternate"></link><published>2020-04-02T18:00:00+09:00</published><updated>2020-04-02T21:34:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-02:/burogudao-ru.html</id><content type="html">&lt;p&gt;GitHub io + Pelican を使ってみた。しばらくこちらで日報を書きたい。
GitHub io + Pelicanは以下の記事を参考にしている。まだあんまり分かってない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/yusukew62/items/7b01d2370cdbe170b28d"&gt;Python製静的HTMLジェネレータのPelicanでGitHub Pagesを公開する方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/ririli/items/0e06b21cb709beae4514"&gt;GitHub Pagesで静的サイトを簡単に作る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/saira/items/71faa202efb4320cb41d"&gt;Python製 Pelican を使ってサクッとブログを公開する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.pelicanthemes.com"&gt;Pelicanのテーマ集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/getpelican/pelican-themes/issues/460#issuecomment-346652986"&gt;テーマ導入時にハマったので参考にしたissue comment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日は（というか3月末）からSLAの高速化作業とまとめをしていた。&lt;/p&gt;
&lt;p&gt;格子型フィルタ演算はどうしても1乗算型にできず。次数演算を4次数にしてSSE演算するのがやっと。
SSE化するときに、スカラー演算とベクトル演算が混じったときに処理負荷が大きく上がってハマった。
&lt;a class="reference external" href="https://stackoverflow.com/questions/10313397/where-does-the-sse-instructions-outperform-normal-instructions"&gt;StackOverFlowの記事&lt;/a&gt; では &lt;cite&gt;_mm_set_epi32&lt;/cite&gt; のコストが高い旨記述あり。 &lt;cite&gt;_mm_loadu_si128&lt;/cite&gt; の使用に置き換えた。
&lt;a class="reference external" href="https://stackoverflow.com/questions/24446516/performance-worsens-when-using-sse-simple-addition-of-integer-arrays"&gt;他の記事&lt;/a&gt; で言及があってようやく分かった。全てをベクトル演算化したところ、処理負荷は4/5倍になった。あんまり早くなっていない。遺憾。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://herumi.in.coocan.jp/prog/gcc-and-vc.html"&gt;gccとVC&lt;/a&gt; にはgccとVisual Studioの挙動の差異について色々と書いてあった。&lt;/p&gt;
</content><category term="雑記"></category><category term="SLA"></category><category term="SSE"></category><category term="test"></category><category term="pelican"></category><category term="githubio"></category></entry></feed>