<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Aiki's Blog</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2022-09-02T10:00:00+09:00</updated><entry><title>圧縮率改善検討(11)</title><link href="/ya-suo-lu-gai-shan-jian-tao-11.html" rel="alternate"></link><published>2022-09-02T10:00:00+09:00</published><updated>2022-09-02T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-09-02:/ya-suo-lu-gai-shan-jian-tao-11.html</id><summary type="html">&lt;p&gt;予定が五月雨式に入っておりまとまった時間とれず。今SVRをやっているが、それまでの流れをメモ。&lt;/p&gt;
&lt;p&gt;Hinge Lossに相当する損 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;予定が五月雨式に入っておりまとまった時間とれず。今SVRをやっているが、それまでの流れをメモ。&lt;/p&gt;
&lt;p&gt;Hinge Lossに相当する損失はVapnik ε-sensitiveと論文にあったが、Vapnikの名前からSVMを思い出し、もう一度資料を見てみた所SVRによるFIRシステム同定にほかならないことに気づく。&lt;/p&gt;
&lt;p&gt;SVRの双対問題による定式化ならば凸計画になるので安定している。Gram行列は直前までのp時刻サンプルの内積を取った線形カーネルになる。実装してみてそれなりの性能を示すことが分かった。好適に思えるが問題がいくつか。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Gram行列はNxN（N：サンプル数）なので巨大。8192サンプルとか考えると悲観的。&lt;ul&gt;
&lt;li&gt;近似できないか考え、観察を続けた所pを大きくしたときに自己相関行列に近づくことに気づいた（ただし、遠い相関でもサンプル数が減らずに相関が減らない）。自己相関行列で近似してみたがGram行列はToeplitz行列でもないため性能が悪化。&lt;/li&gt;
&lt;li&gt;計画行列Xを用いればGram行列はXX^Tと分解できるので、分解を使って計算することでO(N)程度に収まった&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Levinson-Durbin法で初期値を定めて、それをSVRで改善していく手段を取りたい&lt;ul&gt;
&lt;li&gt;収束が遅い/学習係数を上げると不安定なため、実用性のためにも必須&lt;/li&gt;
&lt;li&gt;観察していると、双対変数と残差信号が要素ごとに比例しているように見受けられる。理論的に示せないか見ている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;補助関数法を使えそう&lt;ul&gt;
&lt;li&gt;双対変数のL1ロスを2次関数で近似すれば閉経式解を解くことによる効率的な手法が求まるかも？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://alex.smola.org/papers/2003/SmoSch03b.pdf"&gt;A Tutorial on Support Vector Regression&lt;/a&gt; SVRのイントロ。様々なロスに対応する密度が書いてある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;勾配0条件を解くのにLASSOの知見が使えることを思い出す。勾配降下法を漁っていると見覚えのある式が。Glassoだ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ide-research.net/papers/2016_Iwanami_Ide.pdf"&gt;依存関係にスパース性を入れる — グラフィカル lasso の話&lt;/a&gt; で勾配0条件が&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>圧縮率改善検討(10)</title><link href="/ya-suo-lu-gai-shan-jian-tao-10.html" rel="alternate"></link><published>2022-08-21T10:00:00+09:00</published><updated>2022-08-21T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-08-21:/ya-suo-lu-gai-shan-jian-tao-10.html</id><summary type="html">&lt;p&gt;fastICAと勾配に基づくICAを実装して試してみたが、芳しくない&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;L-D法を初期値に設定すると、そこから改善していかない&lt;ul&gt;
&lt;li&gt;か …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;fastICAと勾配に基づくICAを実装して試してみたが、芳しくない&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;L-D法を初期値に設定すると、そこから改善していかない&lt;ul&gt;
&lt;li&gt;かといって適当に初期化するとL-D法よりも良くない統計量で止まってしまう&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;fastICAの場合は尖度（あるいはネゲントロピー）が振動する&lt;ul&gt;
&lt;li&gt;比較的良い状態と悪い状態を言ったり来たりする&lt;/li&gt;
&lt;li&gt;ICAの符号の同定不能性にハマっている？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;勾配法は、尖度の絶対値は上昇しているが、負値が上昇しておりより分布が広がってしまう&lt;/li&gt;
&lt;li&gt;白色化が不完全？&lt;ul&gt;
&lt;li&gt;平均0分散1に正規化したら収束性が若干安定&lt;/li&gt;
&lt;li&gt;時系列方向で白色化するならLPCをかませるしか無いが、完全な白色化にはならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LPC（orプリエンファシス）をかませたデータを散布図で表示したら見事に真円になってた。そりゃそうか。ガウス分布に近づけてんだもんな。
つまり、LPCは情報をふっとばす作用としてはある意味最適なのか。&lt;/p&gt;
&lt;p&gt;LPC（orプリエンファシス）を除いて直接ICAを適用したら、平均化フィルタが得られた。。。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;無論望ましくない。しかし、2次元散布図で見てもy=xに近い分布に対してw[0]=w[1]としているから、適切な射影になっている。&lt;ul&gt;
&lt;li&gt;回転だけで考えてしまうのでICAはめちゃくちゃ厳しいのでは？？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;波形を見るとresidualが波形の再構成結果になっている。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そもそも回転だけで残差がラプラスになるとは思えない。ICAを直接使うのではなく、ICAにインスパイアして優ガウス的な発想から攻めていくのが良いかと考え始める。&lt;/p&gt;
&lt;p&gt;そこで考えているのがL1ロスの近似になる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;logcosh。これは、双曲線正割分布の対数を取ったときに出てくる。logcoshを微分するとtanhが出てくる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jappstat1971/35/1/35_1_17/_pdf/-char/ja"&gt;双曲線正割分布の応用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Huber loss（絶対値が小さい区間で2乗誤差を適用している）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;これ、再帰的Golomb-Riceに対応しているような…&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;少しありえる。 &lt;span class="math"&gt;\(2^{k_{1}}\)&lt;/span&gt; よりも小さいシンボルの長さは全て &lt;span class="math"&gt;\(1 + x\)&lt;/span&gt; としていて、それはすなわち一様分布となっている。&lt;ul&gt;
&lt;li&gt;これHinge lossだわ。微分可能にしたのがHuber lossになるな。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;小さい領域では情報量が増えても構わないからガウスにする。発想として悪くない。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://openaccess.thecvf.com/content/CVPR2021/papers/Meyer_An_Alternative_Probabilistic_Interpretation_of_the_Huber_Loss_CVPR_2021_paper.pdf"&gt;An Alternative Probabilistic Interpretation of the Huber Loss&lt;/a&gt; Huber損失の近似 &lt;a class="reference external" href="https://gregmeyer.info/files/cvpr2021-poster.pdf"&gt;ポスター&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Hinge loss&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;早速Hinge lossとHuber lossの周辺を調査。勾配法で求まることは自明。でも遅いのも自明。できれば閉経式で求めたい。L-D法を初期値として改善していく方向もあり。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/2108.12627.pdf"&gt;Generalized Huber Loss for Robust Learning and its Efficient Minimization for a Robust Statistics&lt;/a&gt; なめらかにしたPseudo-Huber loss&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=61759"&gt;Convergence of EM Image Reconstruction Algorithms with Gibbs Smoothing&lt;/a&gt; ポテンシャル関数として多数提案&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そして既存研究に思い至る。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.kecl.ntt.co.jp/people/kameoka.hirokazu/publications/Kameoka2008IEICEPaper.pdf"&gt;予測誤差のGolomb-Rice符号量を最小化する線形予測分析&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;補助関数法によりやっている。Huber lossも取り込んでいる。&lt;/li&gt;
&lt;li&gt;ワンチャンHinge lossで攻められないか。Hinge lossの滑らかな上界を作って攻める方針。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/2103.00233.pdf"&gt;Learning with Smooth Hinge Losses&lt;/a&gt; のsmooth hinge lossがいいかも。必ず上界を与えているし、sigma-&amp;gt;0でhingelossに一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>圧縮率改善検討(9)</title><link href="/ya-suo-lu-gai-shan-jian-tao-9.html" rel="alternate"></link><published>2022-08-20T10:00:00+09:00</published><updated>2022-08-20T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-08-20:/ya-suo-lu-gai-shan-jian-tao-9.html</id><summary type="html">&lt;p&gt;skleranのfastICAを試してみた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;白色化もライブラリ側でやってくれる。逆にやらないとうまく分離できない&lt;/li&gt;
&lt;li&gt;sklearn.decomposition.FastICAは瞬時混合 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;skleranのfastICAを試してみた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;白色化もライブラリ側でやってくれる。逆にやらないとうまく分離できない&lt;/li&gt;
&lt;li&gt;sklearn.decomposition.FastICAは瞬時混合を解こうとしている&lt;ul&gt;
&lt;li&gt;求まるのは混合行列&lt;/li&gt;
&lt;li&gt;逆畳み込みは対応していない？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;畳み込み係数を得ようと思ったら、自分で頑張るしかない？&lt;/li&gt;
&lt;li&gt;今やりたいのは1信号+雑音から1信号を取り出すやつ&lt;ul&gt;
&lt;li&gt;白色化はいらなそう。雑音はガウスだから。&lt;/li&gt;
&lt;li&gt;フィルタ残差の尖度（ネゲントロピー）最大化問題&lt;/li&gt;
&lt;li&gt;理屈としては単純に思えるから実装してみるか。&lt;ul&gt;
&lt;li&gt;しかし、白色化と係数の正規化が必要そうに思えるのが懸念&lt;/li&gt;
&lt;li&gt;白色化はプリエンファシスや前段のLPCに期待すればもしかして良かったりする？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>圧縮率改善検討(8)</title><link href="/ya-suo-lu-gai-shan-jian-tao-8.html" rel="alternate"></link><published>2022-08-18T10:00:00+09:00</published><updated>2022-08-18T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-08-18:/ya-suo-lu-gai-shan-jian-tao-8.html</id><summary type="html">&lt;p&gt;用事のため間が空いた。優ガウス分布に従う過程で係数を決めたいと考え始めている。ひとまず研究をサーチ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://m-repo.lib.meiji.ac.jp/dspace/bitstream/10291/20858/1/tanji_2020_rikou.pdf"&gt;優ガ …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;用事のため間が空いた。優ガウス分布に従う過程で係数を決めたいと考え始めている。ひとまず研究をサーチ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://m-repo.lib.meiji.ac.jp/dspace/bitstream/10291/20858/1/tanji_2020_rikou.pdf"&gt;優ガウス性の確率分布を用いた統計モデルに基づく信号処理に関する研究&lt;/a&gt; これは特に近い。logcoshをロスに（ &lt;a class="reference external" href="https://ja.m.wikipedia.org/wiki/双曲線正割分布"&gt;双曲線正割分布&lt;/a&gt; 基準になる)して交互最適化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;優ガウスという表現から、ICAの考え方を使って係数を決められないか考えてICA本を読んでいた。尖度でやるのはもちろん、尖度は外れ値に弱いのでネゲントロピー基準で係数を決められないか考える。最適化は不動点法(fastICA)ならば収束が早いし。妄想だが、初期値をL-D法で決めて、よりスパースになるようにICAの手法を適用することを考えている。&lt;/p&gt;
&lt;p&gt;考え方はICA本の19.1.4節。FIRフィルタの畳み込みの行列表現から初め、入力信号の独立性を仮定してフィルタ係数（混合係数）を求める。&lt;/p&gt;
&lt;p&gt;暗中（ブラインド）逆畳み込みで見ていると、適応フィルタ系が多いように思える。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/journalam1998/11/0/11_0_971/_pdf"&gt;独立成分分析 による橋梁振動のブラインド逆畳み込み同定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1309.5004.pdf"&gt;Blind Deconvolution via Maximum Kurtosis Adaptive Filtering&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ICA本を読んでいる。尚更直接fastICAを適用しても良い気がしてきた。。。とにかくどうなるかを見たい。Pythonで試してみよう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>圧縮率改善検討(7)</title><link href="/ya-suo-lu-gai-shan-jian-tao-7.html" rel="alternate"></link><published>2022-08-07T10:00:00+09:00</published><updated>2022-08-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-08-07:/ya-suo-lu-gai-shan-jian-tao-7.html</id><summary type="html">&lt;p&gt;執筆が忙しくなり7月は時間あまりとれず。書きながら思ったこと：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;マルチチャンネル処理はもっとよくできる。MSだ …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;執筆が忙しくなり7月は時間あまりとれず。書きながら思ったこと：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;マルチチャンネル処理はもっとよくできる。MSだけだと心もとない。&lt;/li&gt;
&lt;li&gt;今一度スパース理論に立ち戻って係数設定したい。注目しているのがICA。尖度とかネゲントロピー尺度で最適化したい。fastICAとか使えないか？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、最適符号割当て（音声符号化 p41）の歪みの導出がジャンプしすぎているので理論を探っていた。結果、fine quantizationというのが近いかも。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.icg.isy.liu.se/courses/tsbk02/material/lect5-6.pdf"&gt;Coding with distortion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://iphome.hhi.de/wiegand/assets/pdfs/DIC_rd_theory_quantization_07.pdf"&gt;Rate Distortion Theory &amp;amp; Quantization Rate Distortion Theory &amp;amp; Quantization&lt;/a&gt; これの28p&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もっと見ていたら、ガウス分布に従う確率変数の歪み-レート関数に過ぎないことに気づいた。そうかビット幅がレートに対応する。。。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://reeves.ee.duke.edu/information_theory/lecture9-Rate_Distortion.pdf"&gt;ECE 587 / STA 563: Lecture 9 – Rate Distortion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://yfa23308.a.la9.jp/2016LNs/IT12-20161210.pdf"&gt;情報理論(No.12)&lt;/a&gt; 尖度に関連して、ガウス分布は平均一定の元で最大のエントロピーを与える分布であることも載ってる。最大エントロピー原理ですな。懐かしい。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ict.cei.uec.ac.jp/kawabata/kougi/data_compression/ratedistsec10.pdf"&gt;データ圧縮基礎資料&lt;/a&gt; 日本語講義資料。いちばんわかりやすい。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>圧縮率改善検討(6)</title><link href="/ya-suo-lu-gai-shan-jian-tao-6.html" rel="alternate"></link><published>2022-07-08T10:00:00+09:00</published><updated>2022-07-08T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-07-08:/ya-suo-lu-gai-shan-jian-tao-6.html</id><summary type="html">&lt;p&gt;適応的にマルチチャンネル処理を選ぶのは、粘ったが改善が見られないので取り下げる。&lt;/p&gt;
&lt;p&gt;一方、符号の分割を決めると …&lt;/p&gt;</summary><content type="html">&lt;p&gt;適応的にマルチチャンネル処理を選ぶのは、粘ったが改善が見られないので取り下げる。&lt;/p&gt;
&lt;p&gt;一方、符号の分割を決めるときに、平均符号帳の推定値ではなく本当の符号長を測ってきめたら、0.04%ほどの改善が見られた。これは大きい。エンコード速度は悪くなるが取り入れよう。&lt;/p&gt;
&lt;p&gt;取り入れてみたが0.02%程度の改善であった。それに比してエンコード速度は0.5%悪化。取り入れてしまったがちょっと悲しい。
いやでもここから高速化を考えればいいか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>圧縮率改善検討(5)</title><link href="/ya-suo-lu-gai-shan-jian-tao-5.html" rel="alternate"></link><published>2022-07-07T10:00:00+09:00</published><updated>2022-07-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-07-07:/ya-suo-lu-gai-shan-jian-tao-5.html</id><summary type="html">&lt;p&gt;エンコード時に自己相関の計算に30%掛かっているのを思い出して、FFTの採用に乗り切ってみた。
当然全てFFTだと却っ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;エンコード時に自己相関の計算に30%掛かっているのを思い出して、FFTの採用に乗り切ってみた。
当然全てFFTだと却って遅くなる（次数は低いから）。（『音声の線形予測』にあるように、次数128まではナイーブにやった方が早いので）次数64より大きい場合にFFTするようにしてみたら、負荷が30%が25%になった。うーん微妙。&lt;/p&gt;
&lt;p&gt;また巡回畳み込み回避のためにメモリバッファが2倍いるのも気になる。今のところは導入を見送る。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>圧縮率改善検討(4)</title><link href="/ya-suo-lu-gai-shan-jian-tao-4.html" rel="alternate"></link><published>2022-07-06T10:00:00+09:00</published><updated>2022-07-06T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-07-06:/ya-suo-lu-gai-shan-jian-tao-4.html</id><summary type="html">&lt;p&gt;MS変換以外のチャンネル処理手法があったことを記憶していて、探っていたらLeft-Side(LS), Right-Side(RS)変換だった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ietf.org/id/draft-ietf-cellar-flac-03.html#section-5.2"&gt;Free Lossless Audio Codec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/xiph/flac/blob/633ab36ec51bada8737459e51cc54441544e63b2/src/libFLAC/stream_decoder.c#L3066-L3105"&gt;FLACのデ …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;MS変換以外のチャンネル処理手法があったことを記憶していて、探っていたらLeft-Side(LS), Right-Side(RS)変換だった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ietf.org/id/draft-ietf-cellar-flac-03.html#section-5.2"&gt;Free Lossless Audio Codec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/xiph/flac/blob/633ab36ec51bada8737459e51cc54441544e63b2/src/libFLAC/stream_decoder.c#L3066-L3105"&gt;FLACのデコーダでの実装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;やっつけで分散/絶対値log2の和（WavPackリスペクト。整数エントロピーに比例する値）/予測後分散推定値を使ってMS/LS/RSを切り替えるようにしてみた（最も値が低いのを採用するようにした）が、性能が悪化。0.2%オーダで悪化。まだ、固定でMSやるのが良いという状態になっている。&lt;/p&gt;
&lt;p&gt;M,S,L,R成分を作って予測して、最も符号が短くなる組み合わせを選ぶ、というやり方はありで、確実に圧縮率は向上するだろう。しかし、負荷が2倍になるので戸惑う。それに見合った改善が得られる気がしない。事前情報でうまく判定できないか考えたい。&lt;/p&gt;
&lt;p&gt;Sを選んでも性能悪化が見えるということは、MSのMに秘密がありそうな気がしてきた。
実装から離れて、いつか書こうと思っていたチャンネル間相関を観察してみるか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>圧縮率改善検討(3)</title><link href="/ya-suo-lu-gai-shan-jian-tao-3.html" rel="alternate"></link><published>2022-07-05T10:00:00+09:00</published><updated>2022-07-05T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-07-05:/ya-suo-lu-gai-shan-jian-tao-3.html</id><summary type="html">&lt;p&gt;実験を積んでしまっているので色々試す。&lt;/p&gt;
&lt;p&gt;まず、MSを2連続適用するのは圧縮率悪化の傾向。音源によっては1%オーダー …&lt;/p&gt;</summary><content type="html">&lt;p&gt;実験を積んでしまっているので色々試す。&lt;/p&gt;
&lt;p&gt;まず、MSを2連続適用するのは圧縮率悪化の傾向。音源によっては1%オーダーで悪化。&lt;/p&gt;
&lt;p&gt;また、1年前ぐらいのブログにMSとしてCDFウェーブレットを使ってみたのがあったか悪化を確認していた。しかしここでもう一度試してみる。やっぱ性能悪化だった。CDF22,CDF42で両方ともだめ。&lt;/p&gt;
&lt;p&gt;MS変換は何故有効なんだろうか…&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>圧縮率改善検討(2)</title><link href="/ya-suo-lu-gai-shan-jian-tao-2.html" rel="alternate"></link><published>2022-07-02T10:00:00+09:00</published><updated>2022-07-02T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-07-02:/ya-suo-lu-gai-shan-jian-tao-2.html</id><summary type="html">&lt;p&gt;マルチチャンネル処理を処理後の分散から判断して見る実装を試した（処理後の分散が減るならMSを実行）が、RWCで0 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;マルチチャンネル処理を処理後の分散から判断して見る実装を試した（処理後の分散が減るならMSを実行）が、RWCで0.02%ほど圧縮率が悪化した。つまり、固定でMSやるのが性能が良いという結果。&lt;/p&gt;
&lt;p&gt;分散を使ったのが良くなかったか。1次相関を使ってみて様子を見たが、分散よりも更に悪化。&lt;/p&gt;
&lt;p&gt;重要なのは、MSによって何が大きく変わっているかという点でもある。MS変換後の波形の統計量とか周波数特性がどうなるか観察するといいかも？&lt;/p&gt;
&lt;p&gt;急に思いついた手法：わざと分割時の予測を行わないことで入力を残し，ユニット方向の並列計算を高速化する。たとえば，1分割でもフレーム長/4間隔で次数分だけ予測せず残差を残す．当然圧縮率は落ちるが，4ユニット並列予測/合成が常にできる．&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;早速試してみたが、0.1%オーダで悪化した。取り下げるが、方向としては悪くなさそう。予測していない部分をどうするか考えるといいかも？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MSの替わりにリフティング適用するとどうだったかを思い出している（たしか試していて、良くなかったはず）。そして同時にMSを2回かけるという頭のおかしい発想も浮かんだ。後で試す。&lt;/p&gt;
&lt;p&gt;あと、自己相関の計算をFFTで高速化するというネタはあり。重要なのはどの次数でFFTを使い始めるかというところか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>圧縮率改善検討(1)</title><link href="/ya-suo-lu-gai-shan-jian-tao-1.html" rel="alternate"></link><published>2022-07-01T10:00:00+09:00</published><updated>2022-07-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-07-01:/ya-suo-lu-gai-shan-jian-tao-1.html</id><summary type="html">&lt;p&gt;ユニット並列の効果を確かめるために、2分割以上の探索（=フレームサイズを半減）で試したら、デコード速度はTTAを超 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ユニット並列の効果を確かめるために、2分割以上の探索（=フレームサイズを半減）で試したら、デコード速度はTTAを超えた。FLACの2倍程度の負荷になっている。一方、圧縮率も最大でもWavpack(-hh)と同等になっていた（ポジティブに言えばWavPackの上位互換にはなっているが。。。）。分割数1の最適化がかなり重要なようだ。&lt;/p&gt;
&lt;p&gt;今日から投稿準備に入るので実装は一旦落ち着ける。&lt;/p&gt;
&lt;p&gt;…と思ったが、マルチチャンネル処理にまだ改善の余地がある。適応的にMSか何もしないかを選ぶようにしてみた。
減るはずだと思っていたが、どうも微妙。取り込まずに、ローカルの変更だけで圧縮率を見る。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(42)</title><link href="/huirutakao-cha-42.html" rel="alternate"></link><published>2022-06-30T10:00:00+09:00</published><updated>2022-06-30T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-06-30:/huirutakao-cha-42.html</id><summary type="html">&lt;p&gt;係数を静的ハフマンで圧縮した。狙い通り、ほぼエントロピーレート(6.5bit)に圧縮できて0.1%ほどの改善。あと、ねんがん …&lt;/p&gt;</summary><content type="html">&lt;p&gt;係数を静的ハフマンで圧縮した。狙い通り、ほぼエントロピーレート(6.5bit)に圧縮できて0.1%ほどの改善。あと、ねんがんの32bitビット入出力を実装できた。僅かに速度改善。&lt;/p&gt;
&lt;p&gt;明日から投稿準備に入るので他に改善案はないか考えていた。補助関数法は負荷が重すぎるのがネック。もっと低い負荷でL1ロス最小化できないか考えていたら、NGSAの応用が思い浮かんだ。SAでも僅かに減少することは見ているので、ほぼ同様の負荷でより高い圧縮率が達成できるかもしれない。期待しつつやってみる。&lt;/p&gt;
&lt;p&gt;うまくいかない。今、AR次数と係数次数が一致している状況になっている。それだと、どうしても更新式で全体更新ができない。。。&lt;/p&gt;
&lt;p&gt;詰まったので、AVXでどれくらい早くなるか見ることにする。&lt;/p&gt;
&lt;p&gt;最適化で粘っていたら、予測/合成のときのユニット方向の並列化が有効に思えた。2,4並列で計算するようにしてみたら、4/5くらいの高速化に見えた。その代わりとして、前ユニットを見ることをやめる必要がある。それによって圧縮率がどれくらい悪化するか見たら、手元の5分音源で0.01%未満の悪化であった（何故か圧縮率が上がる音源もあった。謎）。&lt;/p&gt;
&lt;p&gt;ユニット方向の並列化は有効だからやってしまうか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(41)</title><link href="/huirutakao-cha-41.html" rel="alternate"></link><published>2022-06-25T10:00:00+09:00</published><updated>2022-06-25T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-06-25:/huirutakao-cha-41.html</id><summary type="html">&lt;p&gt;係数をハフマンで圧縮する。&lt;/p&gt;
&lt;p&gt;表題とずれている気もするけど、いちおう係数の分布を見ているということでフィルタ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;係数をハフマンで圧縮する。&lt;/p&gt;
&lt;p&gt;表題とずれている気もするけど、いちおう係数の分布を見ているということでフィルタ考察に含める。&lt;/p&gt;
&lt;p&gt;本を引っ張り出して読んでたら、『圧縮アルゴリズム』にあるWyle符号が非効率になっていることが &lt;a class="reference external" href="https://tkuro.hatenadiary.org/entry/20110221/1298311543"&gt;このブログ&lt;/a&gt; で指摘されていた。マジだ。しかし1始まりなのがちょっとな。-1しておけばいいんだけど。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(40)</title><link href="/huirutakao-cha-40.html" rel="alternate"></link><published>2022-06-24T10:00:00+09:00</published><updated>2022-06-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-06-24:/huirutakao-cha-40.html</id><summary type="html">&lt;p&gt;先頭ユニット以外では前ユニットのデータを参照するように修正。わずかに圧縮率向上。&lt;/p&gt;
&lt;p&gt;係数の符号分布を見ると、や …&lt;/p&gt;</summary><content type="html">&lt;p&gt;先頭ユニット以外では前ユニットのデータを参照するように修正。わずかに圧縮率向上。&lt;/p&gt;
&lt;p&gt;係数の符号分布を見ると、やはり単調減少の傾向でエントロピーは7程度。固定ハフマンで圧縮しようかと思っている。もし、うまく行けば7/8になるから0.1%の現象が見込める。週末で試してみる。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(39)</title><link href="/huirutakao-cha-39.html" rel="alternate"></link><published>2022-06-23T10:00:00+09:00</published><updated>2022-06-23T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-06-23:/huirutakao-cha-39.html</id><summary type="html">&lt;p&gt;正則化の探索をコーデックに組み込んだ。同時に補助関数法の繰り返し回数をコマンドラインで設定できるように …&lt;/p&gt;</summary><content type="html">&lt;p&gt;正則化の探索をコーデックに組み込んだ。同時に補助関数法の繰り返し回数をコマンドラインで設定できるようにした（分割探索時は負荷が大きすぎるので補助関数法は実行しない）&lt;/p&gt;
&lt;p&gt;補助関数法の負荷が大きすぎるのが鼻につく。ちょっとSAの勾配法を試した見たが、圧縮率が改善するにはするけど補助関数法ほどではない。&lt;/p&gt;
&lt;p&gt;理論的には行き詰まりを感じたので実装をまとめてコミット。そしてパラメータを弄ってたらパラメータを増やしても圧縮率向上の傾向が見られたので増やして再実験している。正則化が効いている。&lt;/p&gt;
&lt;p&gt;また、プリエンファシスを3回適用してもさらに圧縮率がよくなっていたのを見た。これも要観察。要実験。&lt;/p&gt;
&lt;p&gt;寝る前に、先頭ユニット以外では前のデータ参照してもいいことに気づいて予測に適用してみたら僅かに性能向上した。（10秒の音源で500バイトとか。）実装が複雑にならなければ取り込んでしまおう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(38)</title><link href="/huirutakao-cha-38.html" rel="alternate"></link><published>2022-06-22T10:00:00+09:00</published><updated>2022-06-22T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-06-22:/huirutakao-cha-38.html</id><summary type="html">&lt;p&gt;量子化誤差の揺り戻しの末、やはり係数L2ノルムは小さいほうがよいのではということで正則化が良さそうだと思 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;量子化誤差の揺り戻しの末、やはり係数L2ノルムは小さいほうがよいのではということで正則化が良さそうだと思っている。が、直後にそれでも量子化誤差は小さいということに気づく。すでに議論済み・実験確認済みのことであった。&lt;/p&gt;
&lt;p&gt;そういえば（突飛で申し訳ない）、プリエンファシスを入れたLINNENetowrkの実験をやっていなかったのでやっている。傾向として、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;フレームサイズが小さいと（〜4096）、1層構成の方が性能が良い&lt;ul&gt;
&lt;li&gt;今まで2層構成の性能が良かったのは、1層目がプリエンファシスなどの条件数を下げる処理が入っているののが大きいという示唆。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;フレームサイズが大きくなると2層以降のほうが高い性能&lt;ul&gt;
&lt;li&gt;分割がうまく働いている？&lt;/li&gt;
&lt;li&gt;それなら最初から細かくフレームサイズをとればいいだけでは…？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;predictive gainの式から見れるように、条件数と予測精度がどこかでトレードオフになっている。たとえばjazzとclassicは解析区間内で単純な正弦波の和になっていることが多い。従って条件数が悪く、正則化もプリエンファシスもしないと予測精度が悪い。しかしプリエンファシスで条件数を下げると予測によって分散を大いに減らせる。&lt;/p&gt;
&lt;p&gt;しかしLINNEはプリエンファシスを2段かまして、さらに3段で動かしている。。。何故良いのか、尚更わからない。&lt;/p&gt;
&lt;p&gt;非常に怖いのだが、フレームサイズを落として1層構成で勝負したほうが性能が良いかもしれない。フレームサイズを大きく取ることでフレーム数が減ってパラメータ効率が減るのが効いている用に思える。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;4096フレーム、かつ1層構成で試してみたが、大幅に悪化。謎。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(37)</title><link href="/huirutakao-cha-37.html" rel="alternate"></link><published>2022-06-21T10:00:00+09:00</published><updated>2022-06-21T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-06-21:/huirutakao-cha-37.html</id><summary type="html">&lt;p&gt;ネットワーク単位で同一の正則化パラメータを使ったら圧縮率が向上した。しかし、単層LPCでやるときのような単調 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ネットワーク単位で同一の正則化パラメータを使ったら圧縮率が向上した。しかし、単層LPCでやるときのような単調性は認められず。網羅探索が必要。それによってエンコード負荷がまた増えてしまう。&lt;/p&gt;
&lt;p&gt;エンコードオプションで、固定1/512か、網羅探索か選べるようにするのが吉と見える。&lt;/p&gt;
&lt;p&gt;また、今日は係数の分布に隔たりがあるように見えて、係数を圧縮しようとして係数の分布を見ていた。&lt;/p&gt;
&lt;p&gt;結果は音源依存で、一部の音源ではほぼ幾何分布だったが、他ではほぼ一様で、符号無しで128以降で減少する分布が見られた（これはわかる。右シフトによって128以降は出づらくなっている）。エントロピーは6、低くて4とか出ていたが、平均が係数次数などでまちまちなので一般化が困難。次数ごとにHuffmanテーブル作るのは難しそう。また、一層目では明確に零平均ではない傾向が見られた。2層目以降は零平均っぽい分布を見せる。&lt;/p&gt;
&lt;p&gt;書き捨てるのももったいないので一応スクリプトを残す。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;plt&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;# 係数ファイルを読み込み&lt;/span&gt;
    &lt;span class="c1"&gt;# 列（次数）ごとに解析&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;loadtxt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;col&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]):&lt;/span&gt;
        &lt;span class="n"&gt;uniq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;counts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unique&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt; &lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;return_counts&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;prob&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;counts&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;counts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;prob&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;prob&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt; &lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt; &lt;span class="n"&gt;col&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
    &lt;span class="c1"&gt;# 全体で解析&lt;/span&gt;
    &lt;span class="n"&gt;uniq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;counts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unique&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flatten&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;return_counts&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;prob&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;counts&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;counts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;prob&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;prob&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flatten&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flatten&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flatten&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;bins&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;density&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;# 幾何分布と重ねてみる&lt;/span&gt;
    &lt;span class="n"&gt;mean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flatten&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;mean&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;右シフトで最悪127だけ損するの、もったいないよなあと振り返る。といっても正規化定数を入れるのはどうなんだろうとも思う。最悪どんくらいの誤差が出るのかまた気になっている。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(36)</title><link href="/huirutakao-cha-36.html" rel="alternate"></link><published>2022-06-16T10:00:00+09:00</published><updated>2022-06-16T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-06-16:/huirutakao-cha-36.html</id><summary type="html">&lt;p&gt;コーデックに組み込んでみたが、圧縮率が悪化した。層ごとに正則化パラメータを最適化すると、かえって悪化につな …&lt;/p&gt;</summary><content type="html">&lt;p&gt;コーデックに組み込んでみたが、圧縮率が悪化した。層ごとに正則化パラメータを最適化すると、かえって悪化につながるようだ。&lt;/p&gt;
&lt;p&gt;かくなる上はネットワーク単位で同一の正則化パラメータを使わざるを得ない。実装の修正にかかる。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(35)</title><link href="/huirutakao-cha-35.html" rel="alternate"></link><published>2022-06-09T10:00:00+09:00</published><updated>2022-06-09T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-06-09:/huirutakao-cha-35.html</id><summary type="html">&lt;p&gt;数値演算誤差の結果は理論を支持していたけど、真の係数との誤差は正則化パラメータを増やした方がよいという …&lt;/p&gt;</summary><content type="html">&lt;p&gt;数値演算誤差の結果は理論を支持していたけど、真の係数との誤差は正則化パラメータを増やした方がよいという結果になっていた。例えば、平均値フィルタを真の係数としたときでも、正則化パラメータ=0が最も誤差が大きく、パラメータを増やせば増やすほど誤差が減っていく傾向。&lt;/p&gt;
&lt;p&gt;この原因は、LPCは最小位相特性（最速で反応するフィルタ）を持つように等価しているからと推測している。平均値フィルタは、計測される自己相関（パワースペクトル）はLPFのそれに近い。それに等価すると係数としてはインパルス応答に近い形（係数の前半部分にパワーが集中する）をとるから、それは真の解からは遠くなってしまう。要は、LPCでは表現できない係数が存在するということ。&lt;/p&gt;
&lt;p&gt;議論の簡潔化や実験設定としても解ベクトルの誤差を判定した方がよい。理論的にも &amp;quot;数値演算誤差の軽減&amp;quot; を目的として議論した方がすっきりする。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(34)</title><link href="/huirutakao-cha-34.html" rel="alternate"></link><published>2022-06-04T10:00:00+09:00</published><updated>2022-06-04T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-06-04:/huirutakao-cha-34.html</id><summary type="html">&lt;p&gt;理論に突っ込み始め、まとめた。実験中。&lt;/p&gt;
&lt;p&gt;数値誤差の分散和（誤差ベクトルのL2ノルム）はカイ二乗分布に従って出ている …&lt;/p&gt;</summary><content type="html">&lt;p&gt;理論に突っ込み始め、まとめた。実験中。&lt;/p&gt;
&lt;p&gt;数値誤差の分散和（誤差ベクトルのL2ノルム）はカイ二乗分布に従って出ているように見える。正規分布の和の分布はカイ二乗分布に従うから、各軸の誤差は正規分布に従って出ていそうだ。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(33)</title><link href="/huirutakao-cha-33.html" rel="alternate"></link><published>2022-05-31T10:00:00+09:00</published><updated>2022-05-31T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-05-31:/huirutakao-cha-33.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\tr[1]{\mathrm{tr}\left[ #1 \right]}
\newcommand\det[1]{\mathrm{det}\left[ #1 \right]}
\newcommand\dfrac[2]{\frac{\mathrm{d} #1}{\mathrm{d} #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;条件数の理論的考察に突っ込み始 …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\tr[1]{\mathrm{tr}\left[ #1 \right]}
\newcommand\det[1]{\mathrm{det}\left[ #1 \right]}
\newcommand\dfrac[2]{\frac{\mathrm{d} #1}{\mathrm{d} #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;条件数の理論的考察に突っ込み始めた。『音声の線形予測』で、自己相関関数の固有値の算術平均と幾何平均の比&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\det{\ve{R}}^{\frac{1}{L}}}{\frac{1}{L} \tr{\ve{R}}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;は &lt;span class="math"&gt;\(L \to \infty\)&lt;/span&gt; でspetrum flatnessに収束することが言われていた（Sgezoの定理からいける。証明は省く）。これは条件数を示唆する尺度になっている（ 分子の行列式が &lt;span class="math"&gt;\(0\)&lt;/span&gt; のとき0, 固有値が全て同一で1）。&lt;/p&gt;
&lt;p&gt;spectrum flatnessとの同一視から、上式の逆数は予測利得の近似を与えている。正則化パラメータ &lt;span class="math"&gt;\(\mu\)&lt;/span&gt; との関連を見るため、正則化込みの利得近似を &lt;span class="math"&gt;\(G(\mu)\)&lt;/span&gt; とおく：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
G(\mu) := \frac{\frac{1}{L} \tr{\ve{R} + \mu \ve{I}}}{\det{\ve{R} + \mu \ve{I}}^{\frac{1}{L}}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(G(\mu)\)&lt;/span&gt; の最大化を考える。対数とその &lt;span class="math"&gt;\(\mu\)&lt;/span&gt; による微分は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\log G(\mu) &amp;amp;= \log\left[ \frac{1}{L} \sum_{i = 1}^{L} (\lambda_{i} + \mu) \right] - \frac{1}{L} \sum_{i = 1}^{L} \log(\lambda_{i} + \mu) \\
\dfrac{\log G(\mu)}{\mu} &amp;amp;= \frac{1}{\frac{1}{L} \sum_{i = 1}^{L} (\lambda_{i} + \mu)} - \frac{1}{L} \sum_{i = 1}^{L} \frac{1}{\lambda_{i} + \mu} \\
&amp;amp;= \left\{ \frac{1}{L} \sum_{i = 1}^{L} (\lambda_{i} + \mu) \right\}^{-1} - \left\{ \frac{L}{\sum_{i = 1}^{L} \frac{1}{\lambda_{i} + \mu}} \right\}^{-1} \\
&amp;amp;\leq 0
\end{align*}
&lt;/div&gt;
&lt;p&gt;最後の不等式は、&lt;span class="math"&gt;\(\text{算術平均} \geq \text{調和平均}\)&lt;/span&gt; から出てくる。 同時に &lt;span class="math"&gt;\(\dfrac{\log G(\mu)}{\mu} = 0\)&lt;/span&gt; となるのは固有値が全て等しいとき、かつそのときに限る。このことから、全ての &lt;span class="math"&gt;\(\mu &amp;gt; 0\)&lt;/span&gt; で予測利得は単調減少を続ける。&lt;/p&gt;
&lt;p&gt;従って、正則化パラメータ &lt;span class="math"&gt;\(\mu\)&lt;/span&gt; はどの値に設定しても予測による利得は得られない事がわかる。量子化誤差に関する考察も踏まえて、ここまでは残差分散の減少は説明できない。&lt;/p&gt;
&lt;p&gt;他のアプローチから、残差分散減少の原因を追うことを考える。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(32)</title><link href="/huirutakao-cha-32.html" rel="alternate"></link><published>2022-05-30T10:00:00+09:00</published><updated>2022-05-30T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-05-30:/huirutakao-cha-32.html</id><summary type="html">&lt;p&gt;条件数の評価尺度を正則化パラメータで微分して様子を見ている。&lt;/p&gt;
&lt;p&gt;色々式を弄っていたが、結論は出てこない。しかし、一 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;条件数の評価尺度を正則化パラメータで微分して様子を見ている。&lt;/p&gt;
&lt;p&gt;色々式を弄っていたが、結論は出てこない。しかし、一つ重要な定理として、Ridge回帰によって、最小二乗法よりもMSE（推定量の意味での）が減少するパラメータが存在するというのを思い出した。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.few.vu.nl/~wvanwie/Courses/HighdimensionalDataAnalysis/WNvanWieringen_HDDA_Lecture234_RidgeRegression_20182019.pdf"&gt;Ridge regression&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.statlect.com/fundamentals-of-statistics/ridge-regression"&gt;Ridge regression&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1509.09169.pdf"&gt;Lecture notes on ridge regression&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;だから、減るのはおそらく間違いなくて、通常の最尤推定よりバリアンス（真のパラメータからのずれ）が小さいパラメータを選ぶ可能性がある。Ridge回帰の結果は不偏推定とならないのでバイアスが乗る。しかし、この応用では問題ない。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(31)</title><link href="/huirutakao-cha-31.html" rel="alternate"></link><published>2022-05-29T10:00:00+09:00</published><updated>2022-05-29T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-05-29:/huirutakao-cha-31.html</id><summary type="html">&lt;p&gt;構成固定で正則化パラメータだけ動かしたときに統計量がどうなるかを見よう。→パット見、やはり凸なトレンドを見 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;構成固定で正則化パラメータだけ動かしたときに統計量がどうなるかを見よう。→パット見、やはり凸なトレンドを見せた。しかも、パラメータ数に依存していない（層数だけに依存していそう）。&lt;/p&gt;
&lt;p&gt;入力で決まりそうな統計量ってなんだろう…と考えたところ、variance of fit（推定の分散）が効いていそうな気がした。→量子化誤差解析のまとめから式を追ってみたら、予測誤差最小化の式で織り込み済みだった。&lt;/p&gt;
&lt;p&gt;プリエンファシスに起因しているかと思っていたが、プリエンファシスを抜いても凸なトレンドを確認した。プリエンファシスによって露骨に現れるようになったというのが実態か。&lt;/p&gt;
&lt;p&gt;何かしら正則化によって予測が改善する成分があるということを示しているが、謎だ。double精度で計算しているから量子化誤差ではないはず。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(30)</title><link href="/huirutakao-cha-30.html" rel="alternate"></link><published>2022-05-28T10:00:00+09:00</published><updated>2022-05-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-05-28:/huirutakao-cha-30.html</id><summary type="html">&lt;p&gt;正則化パラメータを変えたときの結果を並べてプロットするようにした。さらに窓サイズを小さくして観察してい …&lt;/p&gt;</summary><content type="html">&lt;p&gt;正則化パラメータを変えたときの結果を並べてプロットするようにした。さらに窓サイズを小さくして観察している。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;プリエンファシスを前処理に入れると1層構成で高いflatnessが出ている（プリエンファシスを含めれば2層だが）。&lt;ul&gt;
&lt;li&gt;窓サイズを小さくしていくと性能差が顕著になる。2048ではっきり見え、16384以上では差がほぼなくなる。&lt;/li&gt;
&lt;li&gt;正則化パラメータも高く取ると性能が向上する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LINNEは窓サイズを変えて最も良い窓サイズを選んでいるから、性能の解析ができていなかった。正則化パラメータ=1/512で良かったのは平均的に良い挙動を示すパラメータだったと想像。
正則化については最適設定が気になり始めている。&lt;/p&gt;
&lt;p&gt;LINNEが採用しているプリエンファシス2段も気になるので実験着手。その際にプリエンファシスでも正則化が動いてしまっている事に気づき修正（影響は僅かであった。）。&lt;/p&gt;
&lt;p&gt;実験回しながら『音声の線形予測』を読んでいる。なぜプリエンファシスが良いのか触れている論文を見る&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=1162572"&gt;A Spectral-Flatness Measure for Studyingthe Autocorrelation Method of Linear Prediction of Speech Analysis&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;一次のプリエンファシスでspectral flatnessが向上することが示されている。条件数も改善する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プリエンファシスや正則化によって条件数は改善していることは間違いない。しかし、なぜ精度が上がっているのかはまだ不明。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;フレームサイズが絡んでいるような気がした。フレームサイズが小さいときにパラメータ数を大きくすると劣決定問題に近づくから、正則化が働きやすい。という想定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;条件数を調べざるを得ない気がした。条件数のヒストグラムを作ってみたいと思う。
同時に条件数についての資料を漁る。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://na-inet.jp/nasoft/chap08.pdf"&gt;第 8 章 ノルム，条件数，連立一次方程式の誤差解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://noreply.sci.hokudai.ac.jp/~yomo/class/saito-notes.pdf"&gt;数値計算の常識&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;条件数を見ていたら行列L2ノルムが出てきて、正則化パラメータを動かしたときにどのようなトレンドを見せるのか興味が出てきた。量子化誤差解析のときと同じように、ある正則化パラメータでflatnessが最大（L2ノルムが最小）になると想定できる。こっちが優先に思えた。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(29)</title><link href="/huirutakao-cha-29.html" rel="alternate"></link><published>2022-05-27T10:00:00+09:00</published><updated>2022-05-27T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-05-27:/huirutakao-cha-29.html</id><summary type="html">&lt;p&gt;昨日出てきた結果がどういうことなのか考えている。窓サイズが2048など小さいと、局所的に定常とみなせるような解 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;昨日出てきた結果がどういうことなのか考えている。窓サイズが2048など小さいと、局所的に定常とみなせるような解析になり、周波数成分が明確に現れる。結果条件数が悪化してしまう。そこで正則化がうまく効く、というストーリーを考えている。また、窓サイズに応じて適切な正則化定数は変わってきそう。&lt;/p&gt;
&lt;p&gt;しかし、多層にしたときに正則化がなぜうまく効くのか（単層と違って性能が落ちていかないのか）、そこがさっぱり。&lt;/p&gt;
&lt;p&gt;パワースペクトルを弄っているのが効いているのか？と想像して板倉-斎藤擬距離を探る。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=1163421"&gt;Distortion Measures for Speech Processing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そうしたら『音声の線形予測』が参照されていた。早速読んでみるがあまり有益な示唆は得られず…。&lt;/p&gt;
&lt;p&gt;と思ってパラパラめくっていたら、条件数についての記述が目に止まった。spectral flatnessは条件数と関連があることが示されていた（自己相関関数の固有値を使っても論じれる）。0に近い（有声音）だと悪条件になる。&lt;/p&gt;
&lt;p&gt;もしかして精度落ちが起きているのだろうか、確かめるには1次のフィルタをかましてやればいい。→やってみたところ、単層が最もよい性能を叩き出すようになった。つまり悪条件であることが効いていたことになる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;精度落ち以外で考えられるのは、『音声の線形予測』で言っていた、低いパワーを持つ帯域は小さい重みがついてマッチングする、という記述。低いパワーの帯域は相対的に無視されることを示唆している。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プリエンファシスに加え、正則化を入れたときの単層が最も良い性能を出している。同時に、階層構成にしたときによくなる理由がわからなくなった。。。プリエンファシスを入れたら単層で良いのでは？という気がしている。&lt;/p&gt;
&lt;p&gt;プロットグラフが多くなってきた。もう少しグラフに線を増やしてもいいかも（正則化パラメータを変えたときも並べて書いて良さそう。今はページ送りで見ている）。あす（今日）もう一度冷静に考察しよう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(28)</title><link href="/huirutakao-cha-28.html" rel="alternate"></link><published>2022-05-26T10:00:00+09:00</published><updated>2022-05-26T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-05-26:/huirutakao-cha-28.html</id><summary type="html">&lt;p&gt;正則化と多段構成の謎を追っている。再度 &lt;a class="reference external" href="http://www-mmsp.ece.mcgill.ca/Documents/Reports/2021/KabalR2021b.pdf"&gt;Ill-Conditioning and Bandwidth Expansion in Linear Prediction of Speech&lt;/a&gt; を見ていたら、プリエンファシス（高域強調）も条件数向 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;正則化と多段構成の謎を追っている。再度 &lt;a class="reference external" href="http://www-mmsp.ece.mcgill.ca/Documents/Reports/2021/KabalR2021b.pdf"&gt;Ill-Conditioning and Bandwidth Expansion in Linear Prediction of Speech&lt;/a&gt; を見ていたら、プリエンファシス（高域強調）も条件数向上に寄与している（音声信号の高域のパワーが0になるのを阻止）のが書いてあった。&lt;/p&gt;
&lt;p&gt;多段にすることでプリエンファシスのような操作になっているのだろうか？そこで、以前も試した気がするけど、LINNENetworkではなく単純なLPCの連結でどうなるか見ている。&lt;/p&gt;
&lt;p&gt;正則化がない場合は、1層が最も良い傾向。正則化を入れると多層のほうがよい傾向。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LINNENetworkと同一の傾向が見られた。しかし、1層構成が落ちただけにも見える&lt;/li&gt;
&lt;li&gt;jazzとclassicは1層構成のときより高いflatness。これらの音源を見てみると単音で鳴っていた。（特定の周波数に成分が集中。popularやrightは全帯域で鳴っている。）&lt;ul&gt;
&lt;li&gt;シンプルな正弦波に近い音源では条件数が高くなるから影響を大きく受ける？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;窓サイズを変えてみる。窓が小さいと単一の周波数成分が入りやすくなって正則化の効果が大きくなる可能性がある。逆に大きいと多くの周波数成分が入るために正則化の効果が薄れる可能性があり、1層構成で十分、という結論になると予測。&lt;/p&gt;
&lt;p&gt;LINNEは分割を行うから、各分割で周波数分解能の高い解析が起こり、そして条件数が悪くなっている。そこで正則化が効いている可能性を推したい。&lt;/p&gt;
&lt;p&gt;窓サイズを大きくすると正則化が強く効く（全パワースペクトルが持ち上がるから）ので、1層における解析で大きな性能悪化が出ると考えている。しかし本当だろうか。もしかしたら影響度は変わらないのかもしれない。Ridge正則化を入れたとき、フレームサイズに応じてパワースペクトルがどのように変化するかは見るべき。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;もしフレームサイズに応じて正則化の効果が変わるなら、フレームサイズに応じて正則化パラメータを変えるべき。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(27)</title><link href="/huirutakao-cha-27.html" rel="alternate"></link><published>2022-05-25T10:00:00+09:00</published><updated>2022-05-25T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-05-25:/huirutakao-cha-27.html</id><summary type="html">&lt;p&gt;5/25、フレームサイズを4096, 窓関数適用しても8192の場合とほぼ同等の結果だった。&lt;/p&gt;
&lt;p&gt;階層的LPCの解析として、フィルタをフ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;5/25、フレームサイズを4096, 窓関数適用しても8192の場合とほぼ同等の結果だった。&lt;/p&gt;
&lt;p&gt;階層的LPCの解析として、フィルタをフーリエ変換すれば階層的にしてもフィルタの積でかけることが見えた（残差演算も &lt;span class="math"&gt;\(h_{0} = 1\)&lt;/span&gt; にすればOK）。分割してノルムが最小になる組み合わせを選ぶ操作もフィルタを通じて書けた。&lt;/p&gt;
&lt;p&gt;総パラメータ数を &lt;span class="math"&gt;\(N\)&lt;/span&gt; 、層数を &lt;span class="math"&gt;\(L\)&lt;/span&gt; とすると、出力の経路の組み合わせ数は &lt;span class="math"&gt;\((\log_{2} N + 2 - L)^{L}\)&lt;/span&gt; となる。その中からロスが最小になるものを選んでいる。しかし、貪欲に層ごとに選択している点と、また最終層で経路が閉じる点があるから実質的な組み合わせ数は減る。&lt;/p&gt;
&lt;p&gt;層数 &lt;span class="math"&gt;\(L\)&lt;/span&gt; を増やすと、組み合わせ数が指数オーダーで上昇する。このことと &lt;a class="reference external" href="https://arxiv.org/pdf/1605.06431.pdf"&gt;ResNetはアンサンブル(Residual Networks Behave Like Ensembles of Relatively Shallow Networks)&lt;/a&gt; がかなり親和性があり、性能向上に寄与しているのではないかと考え始める。&lt;/p&gt;
&lt;p&gt;もう一度多層の実験結果を見ると、今解決すべき課題が2点あることに気付く。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;なぜ多層にしたときにロスが減るのか&lt;/li&gt;
&lt;li&gt;なぜ正則化を入れて多層にするとロスが減るのか&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プリエンファシスの話はどっかにいってしまったが、多層の解析が重要であることは間違いないのでそちらを優先。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(26)</title><link href="/huirutakao-cha-26.html" rel="alternate"></link><published>2022-05-24T10:00:00+09:00</published><updated>2022-05-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-05-24:/huirutakao-cha-26.html</id><summary type="html">&lt;p&gt;昨日の(プリエンファシス後の最小分散)/(プリエンファシス前の最小分散)の尺度で再度解析してみたところ、以下の結 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;昨日の(プリエンファシス後の最小分散)/(プリエンファシス前の最小分散)の尺度で再度解析してみたところ、以下の結果。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;悪化する場合もあり。高域チャープとジャズ音源。&lt;ul&gt;
&lt;li&gt;安易には高周波が入ってるとダメそう、という予測ができる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1次のフィルタ一発を入れるところでほぼ決まる&lt;ul&gt;
&lt;li&gt;多層（残差に対して予測する構成）にしてもあまり減らない&lt;/li&gt;
&lt;li&gt;4層/1層あたり6パラメータくらいまで試したけどほぼ同じ傾向（0.1dBほど下がるが、全体から見るとごくわずかな変化）。&lt;/li&gt;
&lt;li&gt;正則化を入れても同じ傾向。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここで、 &lt;span class="math"&gt;\(G=(\text{プリエンファシス後の最小分散})/(\text{プリエンファシス前の最小分散})\)&lt;/span&gt; の式はいじってみても良さそう。プリエンファシス後の信号は伝達関数を使ってかける。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
G &amp;amp;= \frac{\frac{1}{2\pi} \int_{0}^{2\pi} \log S^{\prime}(\omega) d\omega}{\frac{1}{2\pi} \int_{0}^{2\pi} \log S(\omega) d\omega} = \frac{\int_{0}^{2\pi} \log S^{\prime}(\omega) d\omega}{\int_{0}^{2\pi} \log S(\omega) d\omega} = \frac{\int_{0}^{2\pi} \log |H(\omega)|^{2} S(\omega) d\omega}{\int_{0}^{2\pi} \log S(\omega) d\omega} \\
&amp;amp;= 1 + \frac{\int_{0}^{2\pi} \log |H(\omega)|^{2} d\omega}{\int_{0}^{2\pi} \log S(\omega) d\omega}
\end{align*}
&lt;/div&gt;
&lt;p&gt;第二項が負になればプリエンファシスが有効になる…と思ったら、『The Theory of Linear Prediction』の6.2節に、ARモデルのフィルタ（厳密に言うと、発散しないフィルタ係数）に対して&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\int_{0}^{2\pi} \log |H(\omega)|^{2} d\omega = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成り立つと書いてある。つまり理論的には &lt;span class="math"&gt;\(G=1\)&lt;/span&gt; となる。これは、フィルタを連結させようとあるフィルタを用いて &lt;span class="math"&gt;\(H^{\ast}(\omega) = \prod_{i=1}^{N} H_{i}(\omega)\)&lt;/span&gt; と書けてしまうから、結局最小残差で抑えられてしまうことからうなずける。&lt;/p&gt;
&lt;p&gt;しかし、実験結果はそうなっていない。。。演算誤差にしては無視できないくらい大きい。特に低域チャープでは &lt;span class="math"&gt;\(G=1/2\)&lt;/span&gt; 、つまり分散が半減している。&lt;/p&gt;
&lt;p&gt;もしかして、定常ではない場合が効いてくるのか？？定常に近づけるため時間分解能を高める。フレームサイズを8192でやっていたけど4096に変え、更に窓適用して再度実験してみる。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(25)</title><link href="/huirutakao-cha-25.html" rel="alternate"></link><published>2022-05-23T10:00:00+09:00</published><updated>2022-05-23T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-05-23:/huirutakao-cha-25.html</id><summary type="html">&lt;p&gt;階層的LPCを組んでみた。プリエンファシスにより残差分散最小値が減少していることも見た。評価尺度として、(最小分 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;階層的LPCを組んでみた。プリエンファシスにより残差分散最小値が減少していることも見た。評価尺度として、(最小分散)/(入力データ分散)を使っている。&lt;/p&gt;
&lt;p&gt;しかし同時にプリエンファシスフィルタの次数を上げても残差分散が減っていく傾向。これに対しては、次数に対するペナルティ（符号長）を入れると公平な判断ができそうな印象。でも、これは知りたかったことではない。&lt;/p&gt;
&lt;p&gt;階層的LPCで様々な構成での最小残差分散の変化を見る。概観は以下&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;1次のフィルタ一発を入れるところでほぼ決まる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これでほぼ結果が決った…と思ったら、評価尺度が良くないことに気づく。(最小分散)/(入力データ分散)だとプリエンファシス後で減らせる分散も入ってしまう。(プリエンファシス後の最小分散)/(プリエンファシス前の最小分散)がプリエンファシスのみを測れる尺度になるはず。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(24)</title><link href="/huirutakao-cha-24.html" rel="alternate"></link><published>2022-05-19T10:00:00+09:00</published><updated>2022-05-19T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-05-19:/huirutakao-cha-24.html</id><summary type="html">&lt;p&gt;私用によりしばらく空けていた。結果をOverleafに纏めていたり、リサンプラーを作っていたのも要因。&lt;/p&gt;
&lt;p&gt;結果を見ると、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;多層構 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;私用によりしばらく空けていた。結果をOverleafに纏めていたり、リサンプラーを作っていたのも要因。&lt;/p&gt;
&lt;p&gt;結果を見ると、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;多層構造にすると（パラメータ総数が同一でも）残差が減る傾向&lt;/li&gt;
&lt;li&gt;正則化を入れると、多層構造で残差が減る傾向&lt;ul&gt;
&lt;li&gt;フレームサイズを大きくすると正則化による効果は小さくなる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さて、多層にした際に残差（分散）が減るのはなぜだろうか？&lt;/p&gt;
&lt;p&gt;最小の残差となる分割を選んでいるからではないか？と考えたが、多層にしても選択回数は同一だから成り立たない気がする。&lt;/p&gt;
&lt;p&gt;一方、ミニマムな例としてプリエンファシスを入れると残差が下がるケースを今まで度々見てきた。プリエンファシスを行ったデータに対して残差最小値が下がっているのではないかという予測が立つ。やってみよう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>リサンプラー作成</title><link href="/risanpurazuo-cheng.html" rel="alternate"></link><published>2022-05-11T10:00:00+09:00</published><updated>2022-05-18T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-05-11:/risanpurazuo-cheng.html</id><summary type="html">&lt;p&gt;ずっと前から線形補間リサンプラーに我慢がならない状況が続いていたので作ることを考えていた。大雑把には貴 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ずっと前から線形補間リサンプラーに我慢がならない状況が続いていたので作ることを考えていた。大雑把には貴家先生の『マルチレート信号処理』に従えばいいと考えていた。&lt;/p&gt;
&lt;p&gt;実装に当たって考えたことは、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;なるべく高速な実装、でもエイリアシングはなるべく回避する。44.1k -&amp;gt; 48kをスムーズに変換したい。&lt;/li&gt;
&lt;li&gt;マルチステージ構成&lt;/li&gt;
&lt;li&gt;FIRフィルタ設計は窓関数法でいいかな（Remez法はワークメモリがいるのがつらい）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;お役立ちリンク&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ccrma.stanford.edu/~jos/resample/Free_Resampling_Software.html"&gt;Free Resampling Software&lt;/a&gt; フリーのリサンプリングライブラリ集。実装し始めてから存在に気づいた。あるじゃん。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/chirlu/soxr"&gt;The SoX resampler library&lt;/a&gt; soxの一部分。かなり使われているらしいリサンプラ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ee.ic.ac.uk/hp/staff/dmb/courses/DSPDF/00600_WindowFIR.pdf"&gt;6: Window Filter Design&lt;/a&gt; 窓関数法。遷移幅から近似によりフィルタ次数を決める手法が載っている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.finetune.co.jp/~lyuka/technote/winfunc/"&gt;窓関数のダイナミックレンジと分解能&lt;/a&gt; 色々な窓がある。メインローブの太さとサイドローブの減衰が重要。&lt;/li&gt;
&lt;li&gt;わかりやすいリサンプリングとポリフェーズフィルタの解説。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://edn.itmedia.co.jp/edn/articles/1009/01/news112.html"&gt;ポリフェーズフィルタの基本を知る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://bfin.sakura.ne.jp/oldsite/2191/program/polyphase/polyphase06.shtml"&gt;ポリフェーズ・フィルタ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;解説を見ていると、現在の計算方法（ダウンサンプル分出力を止める/アップサンプル分読み飛ばす）でよさそうな印象を受ける。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ryukau.github.io/filter_notes/downsampling/downsampling.html"&gt;ダウンサンプリング&lt;/a&gt; IIRの設計や最適なマルチステージ構成についても記述あり。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ryukau.github.io/filter_notes/index.html"&gt;波ノート&lt;/a&gt; 音声に関する包括的な実験ノート。大ボリューム。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://src.infinitewave.ca"&gt;SRC Comparisons&lt;/a&gt; リサンプラー性能比較。性能比較に使ったwavもある。入手すべき。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="趣味"></category><category term="リサンプラー"></category><category term="窓関数法"></category></entry><entry><title>フィルタ考察(23)</title><link href="/huirutakao-cha-23.html" rel="alternate"></link><published>2022-04-21T10:00:00+09:00</published><updated>2022-04-21T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-04-21:/huirutakao-cha-23.html</id><summary type="html">&lt;p&gt;引き続き証明を追っていた。 &lt;a class="reference external" href="https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/Mathematical%20Methods%20and%20Algorithms%20for%20Signal%20Processing%20%5BMoon%20%26%20Stirling%201999-08-14%5D.pdf"&gt;Mathematical Methods and Algorithms for Signal&lt;/a&gt; は誤植が多く、また明らかに &lt;a class="reference external" href="https://ieeexplore.ieee.org/document/1054924"&gt;On the asymptotic eigenvalue distribution of Toeplitz matrices&lt;/a&gt; を引用している。&lt;/p&gt;
&lt;p&gt;また、証明に …&lt;/p&gt;</summary><content type="html">&lt;p&gt;引き続き証明を追っていた。 &lt;a class="reference external" href="https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/Mathematical%20Methods%20and%20Algorithms%20for%20Signal%20Processing%20%5BMoon%20%26%20Stirling%201999-08-14%5D.pdf"&gt;Mathematical Methods and Algorithms for Signal&lt;/a&gt; は誤植が多く、また明らかに &lt;a class="reference external" href="https://ieeexplore.ieee.org/document/1054924"&gt;On the asymptotic eigenvalue distribution of Toeplitz matrices&lt;/a&gt; を引用している。&lt;/p&gt;
&lt;p&gt;また、証明に当たってはWeierstrassの多項式近似定理が必要だった（多項式から連続関数への拡張にあたり）。以下の証明が簡明。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://integers.hatenablog.com/entry/2016/07/26/000128"&gt;ワイエルシュトラスの多項式近似定理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日で何とかSzegoの定理の証明を追えた。これで結論に至れそう。日曜日〜来週前半はほぼ動けないので土曜日までにまとめておこう。残りは &lt;a class="reference external" href="https://authors.library.caltech.edu/25063/1/S00086ED1V01Y200712SPR003.pdf"&gt;The Theory of Linear Prediction&lt;/a&gt; の第6章をまとめればよい。&lt;/p&gt;
&lt;p&gt;しかしこの定理の意義は大きい。サイズが大きい場合、Toeplitz行列と巡回行列は同一視してしまってよいと言っている。また、予測誤差の限界値が明示的に得られるのも大きい。階層は1段だけど、理論的な考察には使えると考えている。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(22)</title><link href="/huirutakao-cha-22.html" rel="alternate"></link><published>2022-04-19T10:00:00+09:00</published><updated>2022-04-19T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-04-19:/huirutakao-cha-22.html</id><summary type="html">&lt;p&gt;あがいているうちに、Szego limit theoremはToeplitz行列の固有値の分布に関する定理であるとの記述がみえ、またToqplitz行列と巡回行列の …&lt;/p&gt;</summary><content type="html">&lt;p&gt;あがいているうちに、Szego limit theoremはToeplitz行列の固有値の分布に関する定理であるとの記述がみえ、またToqplitz行列と巡回行列のasymptotically equivalent（漸近的等価性？）を使った定理であることの記述が見えた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.23.2679&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Toeplitz and Circulant Matrices: A review&lt;/a&gt; こちらのp.40のTheorem4.2付近。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;しかし証明が難解だし、全部 &lt;a class="reference external" href="https://babel.hathitrust.org/cgi/pt?id=uc1.31822012438206"&gt;Toeplitz forms and their applications&lt;/a&gt; に投げちゃってる。p.64がその該当範囲。&lt;/p&gt;
&lt;p&gt;しかしasympotically equivalentには見覚えがあった。 &lt;a class="reference external" href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-90.pdf"&gt;Autocorrelation matrix eigenvalues and the power spectrum&lt;/a&gt; で実験もしていたので、その論文が参照している以下の文献を見たら、初等的な証明があった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/Mathematical%20Methods%20and%20Algorithms%20for%20Signal%20Processing%20%5BMoon%20%26%20Stirling%201999-08-14%5D.pdf"&gt;Mathematical Methods and Algorithms for Signal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(21)</title><link href="/huirutakao-cha-21.html" rel="alternate"></link><published>2022-04-18T10:00:00+09:00</published><updated>2022-04-18T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-04-18:/huirutakao-cha-21.html</id><summary type="html">&lt;p&gt;自己相関の比が最小残差になる件、受け入れがたく証明を探していたら名著にぶつかった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://authors.library.caltech.edu/25063/1/S00086ED1V01Y200712SPR003.pdf"&gt;The Theory of Linear Prediction&lt;/a&gt; の2.4.3と6 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;自己相関の比が最小残差になる件、受け入れがたく証明を探していたら名著にぶつかった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://authors.library.caltech.edu/25063/1/S00086ED1V01Y200712SPR003.pdf"&gt;The Theory of Linear Prediction&lt;/a&gt; の2.4.3と6.5.2。かなりよさそうな本なので落としておいた。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そこで &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Szeg%C5%91_limit_theorems"&gt;Szego limit theorems&lt;/a&gt; にぶつかる。行列式の比がexp(うんたら)で書けるというもの。一般の証明はとても難しいように見える。。。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/3349751/szego-limit-theorems-for-toeplitz-matrix"&gt;Szego limit theorems for Toeplitz matrix&lt;/a&gt; に解答があるように見える。積分を算術平均とみなしてそれをexpに押し込めているが、合ってるのだろうか？？？→合ってなさそう。算術平均が等しいからと言って、幾何平均は等しいとは限らない。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(20)</title><link href="/huirutakao-cha-20.html" rel="alternate"></link><published>2022-04-17T10:00:00+09:00</published><updated>2022-04-17T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-04-17:/huirutakao-cha-20.html</id><summary type="html">&lt;p&gt;再度階層の実験を回してflatnessを見ているが、正則化を入れたほうがflatnessが高い結果が出ている。これは全く自明ではない …&lt;/p&gt;</summary><content type="html">&lt;p&gt;再度階層の実験を回してflatnessを見ているが、正則化を入れたほうがflatnessが高い結果が出ている。これは全く自明ではない。どうやら、量子化誤差ではなく純粋に予測性能が上がっているということを示唆されている。&lt;/p&gt;
&lt;p&gt;flatnessについて昨日から引っかかっていた。自己相関行列の行列式の比が最小予測誤差分散に一致していると言っているが、これも全く自明じゃない。証明を探し始めている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://babel.hathitrust.org/cgi/pt?id=uc1.31822012438206&amp;amp;view=1up&amp;amp;seq=199&amp;amp;skin=2021"&gt;Toeplitz forms and their applications&lt;/a&gt; また君か。p183で最小誤差分散との関係式、行列式の比はp76に書いている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ee.stanford.edu/‾gray/toeplitz.pdf"&gt;Toeplitz and Circulant Matrices: A review&lt;/a&gt; （ &lt;a class="reference external" href="https://www.nowpublishers.com/article/DownloadSummary/CIT-006"&gt;こっちも&lt;/a&gt; ）この8pにも記述があり、下の文献を見よと言っている&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ee.stanford.edu/‾gray/sp.pdf"&gt;An Introduction to Statistical Signal Processing&lt;/a&gt; p220に明確に書かれているが、古典的な線形予測理論で知られていると書かれているだけで証明が一切ない。どういうこと？&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(19)</title><link href="/huirutakao-cha-19.html" rel="alternate"></link><published>2022-04-16T10:00:00+09:00</published><updated>2022-04-16T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-04-16:/huirutakao-cha-19.html</id><summary type="html">&lt;p&gt;4/13-4/15は多忙につき動けず。&lt;/p&gt;
&lt;p&gt;前回発想した、2,4分割して右シフト量を決めるようにしてみたが微悪化。予測の改善量 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;4/13-4/15は多忙につき動けず。&lt;/p&gt;
&lt;p&gt;前回発想した、2,4分割して右シフト量を決めるようにしてみたが微悪化。予測の改善量よりも、右シフト量の記録領域の方が大きくなっている（記録領域を無視すれば圧縮率が改善しているが、記録すると悪化）。取り下げざるを得ない。係数の量子化誤差による悪化量は思ったより小さい。&lt;/p&gt;
&lt;p&gt;ここまでくると、1/512の正則化でここまで良くなる理由がさっぱり分からない。係数の量子化誤差では説明できないくらいの改善になっているように見える。多層にすることで正則化が何か良い影響を及ぼしている？もう一度多層構造実験に戻って、正則化を入れたときにどんなflatnessが出てくるか見てみるか。&lt;/p&gt;
&lt;p&gt;別件。spectrum flatnessは予測利得の逆数になっているとの記述が『Digital Coding of Waveforms: Principles and Applications to Speech and Video』のp270にあった。これは階層のない場合の統計量だが、階層を入れると良くなることの議論に使えそう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(18)</title><link href="/huirutakao-cha-18.html" rel="alternate"></link><published>2022-04-12T10:00:00+09:00</published><updated>2022-04-12T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-04-12:/huirutakao-cha-18.html</id><summary type="html">&lt;p&gt;得られたLPC係数をPARCOR係数の形で記録し、予測時にLPC係数に変換する、という実装を試していた。
しかし圧縮率が芳しく …&lt;/p&gt;</summary><content type="html">&lt;p&gt;得られたLPC係数をPARCOR係数の形で記録し、予測時にLPC係数に変換する、という実装を試していた。
しかし圧縮率が芳しくない（50.74%）し、正則化の影響を受けない。また、SLAで良かった不均一ビット割り当てもあまり効果なし。&lt;/p&gt;
&lt;p&gt;消すのももったいないのでブランチ切っておいた。&lt;/p&gt;
&lt;p&gt;じゃあ、最近傍の2の冪になるように正則化パラメータを設定する方針に変えてみようか。負荷が大きくなるのは分かっている。実装してしまって確かめる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;実装した。対数スケールに直して、 &lt;span class="math"&gt;\(\yen lceil \yen log_{2}(\yen max_{i} |h_{i}|) \yen rceil - \yen log_{2}(\yen max_{i} |h_{i}|)\)&lt;/span&gt; が一番小さくなるような正則化パラメータを見つけてやればよい。しかし、1/512に勝てない。なんだろうこのマジックナンバー…。&lt;ul&gt;
&lt;li&gt;でも実装してみて、一旦自己相関が求まればL-D法連打はあまりコストにならないことが分かった。つまり &lt;span class="math"&gt;\(\yen max_{i} |h_{i}|\)&lt;/span&gt; の計算コストは低い。&lt;/li&gt;
&lt;li&gt;この知見から、 &lt;span class="math"&gt;\(E[(x_{t} - x_{t}^{qgrad})^{2}]\)&lt;/span&gt; をL2ノルム近似しないで厳密計算してもよさそうな感触を得て、これをロスにして試してみたけど、正則化パラメータを低く設定しがち（0が最善とか）。依然として1/512が強い。&lt;/li&gt;
&lt;li&gt;レイヤー毎に右シフト量を決めているのが致命的、というか大きな正則化パラメータパラメータを選ぶ原因かも。各ユニットでいい感じの係数に抑えても、レイヤー内で大きな係数が出たらそれに引っ張られてしまう。&lt;ul&gt;
&lt;li&gt;2, 4分割くらいで右シフト量を決めるようにしてみるか。演算負荷への影響は少なそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;量子化誤差についても、まだ乗算誤差を組み入れてない。→ざっと計算してみたが、入力信号の分散に依存せず量子化ステップ幅だけできまるから、かなり小さい値になりそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(17)</title><link href="/huirutakao-cha-17.html" rel="alternate"></link><published>2022-04-07T10:00:00+09:00</published><updated>2022-04-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-04-07:/huirutakao-cha-17.html</id><summary type="html">&lt;p&gt;引き続き粘っていたが、 &lt;span class="math"&gt;\(\yen max_{i} |h_{i}| \yen leq ||h||\)&lt;/span&gt; から正則化パラメータを使って何かうまくやる、というのは良い方針が出 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;引き続き粘っていたが、 &lt;span class="math"&gt;\(\yen max_{i} |h_{i}| \yen leq ||h||\)&lt;/span&gt; から正則化パラメータを使って何かうまくやる、というのは良い方針が出せなかった。。。結局は正則化パラメータを変えながらLevinson-Durbin法を実行して、2の冪に一番近くなるパラメータを採用する、がベストになってしまう。FFTしてRの固有値を近似的に求めるというのも考えたが、計算量がLevinson-Durbin連打の方が低そう。&lt;/p&gt;
&lt;p&gt;しばらく苦悶していたが、LPCの量子化特性の悩みってもしかしてPARCOR係数にいったん保存しておくことで解決しないかと思えてきた。嘗て、自分は16bit精度で係数を扱っていたので問題にしなかったが、今は8bitで大いに影響を受けているはず。やってみたいと思う。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(16)</title><link href="/huirutakao-cha-16.html" rel="alternate"></link><published>2022-04-03T10:00:00+09:00</published><updated>2022-04-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-04-03:/huirutakao-cha-16.html</id><summary type="html">&lt;p&gt;Pythonで固定小数実装（丸め含め）を模擬したところ、丸めのための係数を、係数最大値を2の冪数(2^-2, 2^-1, 2^0, 2^1, ...)に切り …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Pythonで固定小数実装（丸め含め）を模擬したところ、丸めのための係数を、係数最大値を2の冪数(2^-2, 2^-1, 2^0, 2^1, ...)に切り上げて処理していたのが大きく効いていることがわかった。&lt;/p&gt;
&lt;p&gt;これは係数最大値が2の冪から離れてしまうと、丸めによって大幅に情報が落ちてしまうことに起因している。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;（例）係数を符号付き8bitで記録することを考えていた時、係数が[128, 61, 1] となった場合は8bitに丸めるために半分に割られて[64, 30, 0]になる。一方、[127, 61, 1]ならば割られることはない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;だから、係数最大値を2の冪より僅かに小さくするのがベストになる。正則化パラメータに応じて連続的に減少することを見ているが、うまい設定方策が思いつかない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;分散が無視できないくらい大きくなりそうならば、L-D法連打による二分探索を行うのが良いかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この現象はいつも起こるのではなく、以下の特徴がある：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;係数が多いと顕著（FIRフィルタ次数が多ければ誤差が多くなるのでうなずける）&lt;ul&gt;
&lt;li&gt;次数が4とか16なら目立たない。128ならばはっきり出てくる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;係数ビット数が少ないと顕著&lt;ul&gt;
&lt;li&gt;7,8,9bitでは顕著。&lt;/li&gt;
&lt;li&gt;11, 12bitくらいにするとほぼ目立たず、誤差分散も減る。しかし係数の記録領域が増える。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(15)</title><link href="/huirutakao-cha-15.html" rel="alternate"></link><published>2022-04-01T10:00:00+09:00</published><updated>2022-04-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-04-01:/huirutakao-cha-15.html</id><summary type="html">&lt;p&gt;量子化ステップ幅のモデル化がガバガバだった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;8bitで記録しているが、符号ビットを除くと7bit精度になる。&lt;/li&gt;
&lt;li&gt;frexpを取るこ …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;量子化ステップ幅のモデル化がガバガバだった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;8bitで記録しているが、符号ビットを除くと7bit精度になる。&lt;/li&gt;
&lt;li&gt;frexpを取ることで最大2倍量子化幅が荒くなる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（もしかしたら）演算時の誤差は係数量子化と全く同様に効いてくるのかもしれない。するとさらに2倍が必要なのかもしれない。&lt;/p&gt;
&lt;p&gt;うだうだパラメータをいじり始めてしまったのでやめる。Pythonで現象を追う。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(14)</title><link href="/huirutakao-cha-14.html" rel="alternate"></link><published>2022-03-31T10:00:00+09:00</published><updated>2022-03-31T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-31:/huirutakao-cha-14.html</id><summary type="html">&lt;p&gt;量子化誤差の平均ときつめの上界を出せて、そちらはシミュレーションでも合っていることを確かめられた。
その結 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;量子化誤差の平均ときつめの上界を出せて、そちらはシミュレーションでも合っていることを確かめられた。
その結果をコーデックに適用したが、性能が悪い。もっと大きな正則化パラメータを適用する必要になっているが、これは今の理論では説明できないくらい大きくなってしまう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;提案手法だと、補助関数法ありで55.85%&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(1/512\)&lt;/span&gt; 固定だと、補助関数法ありで55.84%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;見逃している誤差としては、残りは演算時の切り捨て誤差が考えられる。演算時の右シフト量は実は係数の大きさに応じて決まるから、やはり正則化パラメータの影響を受ける。地味だが、非常に重要な考察になるので解決を試みる。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(13)</title><link href="/huirutakao-cha-13.html" rel="alternate"></link><published>2022-03-26T10:00:00+09:00</published><updated>2022-03-26T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-26:/huirutakao-cha-13.html</id><summary type="html">&lt;p&gt;量子化誤差の上限が正則化パラメータを含む式で表現できたはものの、実験してみたらガバガバな上界であった。も …&lt;/p&gt;</summary><content type="html">&lt;p&gt;量子化誤差の上限が正則化パラメータを含む式で表現できたはものの、実験してみたらガバガバな上界であった。もう少しきつい上界を出せないか試行錯誤中。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://daichilab.sakura.ne.jp/"&gt;Daichi Laboratory&lt;/a&gt; synth1を作った人らしい。すごい。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://daichilab.sakura.ne.jp/synthprog/index.html"&gt;シンセプログラミング&lt;/a&gt; 面白そう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;どうも自己相関行列の固有値が欲しくなってきた。勘違いしていたのが、自己相関行列はToeplitzではあるが、巡回行列ではないという点。しかし、巡回行列化しても良い近似となっているらしい：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://digitalassets.lib.berkeley.edu/techreports/ucb/text/EECS-2006-90.pdf"&gt;Autocorrelation matrix eigenvalues and the power spectrum&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;証明は &lt;a class="reference external" href="https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/Mathematical%20Methods%20and%20Algorithms%20for%20Signal%20Processing%20%5BMoon%20%26%20Stirling%201999-08-14%5D.pdf"&gt;『mathematical methods and algorithms for signal processing』&lt;/a&gt;　の8.5.2。自己相関行列のサイズを大きくすると一致していくらしい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;近似を行うと行列サイズが増えてしまうのでうーんという感じ。逆行列計算（ガウス仮定回帰で効きそう）や、パワースペクトル密度を高速に求めるには良いのかもしれない。真面目に自己相関行列の固有値求めていくか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(12)</title><link href="/huirutakao-cha-12.html" rel="alternate"></link><published>2022-03-22T10:00:00+09:00</published><updated>2022-03-22T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-22:/huirutakao-cha-12.html</id><summary type="html">&lt;p&gt;正則化による量子化誤差削減、結構式を展開できた。Overleafにまとめ中。今日は参考にしたリンクを掲載して、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/2662508/equivalence-of-two-norm-and-infinity-norm"&gt;Equivalence of Two Norm and Infinity …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;正則化による量子化誤差削減、結構式を展開できた。Overleafにまとめ中。今日は参考にしたリンクを掲載して、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/2662508/equivalence-of-two-norm-and-infinity-norm"&gt;Equivalence of Two Norm and Infinity Norm&lt;/a&gt; L∞ノルムとL2ノルムの関係。ここから全てが始まった。最大絶対値係数が係数L2ノルムに結びついた。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/738478/consistency-of-matrix-norm-a-x-2-leq-a-f-x-2"&gt;Upper bounding the Frobenius norm of the inverse of a positive-definite symmetric matrix&lt;/a&gt; 行列×ベクトルのL2ノルムの不等式。まだちゃんと追えてないけど、多分コーシー・シュワルツ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://seetheworld1992.hatenablog.com/entry/2020/12/20/195235"&gt;エルミート行列のスペクトルノルムは最大固有値の絶対値に等しいことを証明する&lt;/a&gt; 表題の通り。これでノルムを固有値の形に還元できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今やっているのはフィルタの量子化誤差による損失。これに、本当の損失を加えられたら、適切な正則化パラメータの探索方針が見つかりそう。正則化パラメータは増やしすぎると解が弱くなってロスの増大に転じるはず。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(11)</title><link href="/huirutakao-cha-11.html" rel="alternate"></link><published>2022-03-21T10:00:00+09:00</published><updated>2022-03-21T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-21:/huirutakao-cha-11.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\dfrac[2]{\frac{\mathrm{d} #1}{\mathrm{d} #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;正則化が何故よ …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\dfrac[2]{\frac{\mathrm{d} #1}{\mathrm{d} #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;正則化が何故よいのか？というところで、解の表現力が落ちることで量子化誤差が減ったのがあり得るなと思い始めている。
とくに、最大絶対値に合わせたシフトが減るのは大きいかも。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.mmsp.ece.mcgill.ca/Documents/Reports/2003/KabalR2003a.pdf"&gt;Ill-Conditioning and Bandwidth Expansion in Linear Prediction of Speech&lt;/a&gt; を読んでいて、分散に定数加算することによる正則化で自己相関行列の条件数改善が理論的にできることが示されていたので、ここで確認する。&lt;/p&gt;
&lt;p&gt;Heykin様のAdaptive Filter Theoryのp816に「自己相関行列 &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; の固有値は、時系列のパワースペクトル密度 &lt;span class="math"&gt;\(S(\omega)\)&lt;/span&gt; の最小値 &lt;span class="math"&gt;\(S_{\min}\)&lt;/span&gt; と最大値 &lt;span class="math"&gt;\(S_{\max}\)&lt;/span&gt; の間にある」という命題があるので示す。&lt;/p&gt;
&lt;p&gt;（証明） &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; の各固有値 &lt;span class="math"&gt;\(\lambda_{i}\ (i = 1,...,M)\)&lt;/span&gt; に対する固有ベクトルを &lt;span class="math"&gt;\(\ve{q}_{i}\)&lt;/span&gt; と書くと、レイリー商の性質から、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\lambda_{i} = \frac{\ve{q}_{i}^{H} \ve{R} \ve{q}_{i}}{\ve{q}_{i}^{H} \ve{q}_{i}} \tag{1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と書ける（ &lt;span class="math"&gt;\(\cdot^{H}\)&lt;/span&gt; ：エルミート共役）。(1)の分子は二次形式で&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{q}_{i}^{H} \ve{R} \ve{q}_{i} = \sum_{k=1}^{M} \sum_{l=1}^{M} \overline{q_{ik}} r(l-k) q_{il} \tag{2}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と書ける（ &lt;span class="math"&gt;\(\overline{\cdot}\)&lt;/span&gt; ：共役、 &lt;span class="math"&gt;\(r\)&lt;/span&gt; ：自己相関関数）。ウィーナー・ヒンチンの定理より、 &lt;span class="math"&gt;\(r\)&lt;/span&gt; は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
r(l-k) = \frac{1}{2\pi} \int_{-\pi}^{\pi} S(\omega) \exp[j\omega(l-k)] d\omega \tag{3}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表せるから、(3)を(2)に代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{q}_{i}^{H} \ve{R} \ve{q}_{i} &amp;amp;= \frac{1}{2\pi} \sum_{k=1}^{M} \sum_{l=1}^{M} \overline{q_{ik}} q_{il} \int_{-\pi}^{\pi} S(\omega) \exp[j\omega(l-k)] d\omega \\
&amp;amp;= \frac{1}{2\pi} \int_{-\pi}^{\pi} S(\omega) \left( \sum_{k=1}^{M} \overline{q_{ik}} \exp[-j\omega k] \right) \left( \sum_{l=1}^{M} q_{il} \exp[j\omega l] \right) d\omega \tag{4}
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、 &lt;span class="math"&gt;\(Q_{i}(\omega) = \sum_{k=1}^{M} \overline{q_{ik}} \exp[-j\omega k]\)&lt;/span&gt; （ &lt;span class="math"&gt;\(\overline{q_{ik}}\)&lt;/span&gt; のDFT）とおくと、 &lt;span class="math"&gt;\(\overline{Q_{i}(\omega)} = \overline{\sum_{k=1}^{M} \overline{q_{ik}} \exp[-j\omega k]} = \sum_{k=1}^{M} \overline{\overline{q_{ik}}} \overline{\exp[-j\omega k]} = \sum_{k=1}^{M} q_{ik} \exp[j\omega k]\)&lt;/span&gt; だから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{q}_{i}^{H} \ve{R} \ve{q}_{i} = \frac{1}{2\pi} \int_{-\pi}^{\pi} | Q_{i}(\omega)|^{2} S(\omega) d\omega \tag{5}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;また、インパルス関数 &lt;span class="math"&gt;\(\delta(\cdot)\)&lt;/span&gt; のパワースペクトラムは平坦（全て1）で、再びウィーナー・ヒンチンの定理より&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\delta(l-k) = \frac{1}{2\pi} \int_{-\pi}^{\pi} \exp[j\omega(l-k)]  d\omega
\end{equation*}
&lt;/div&gt;
&lt;p&gt;だから、これを使って &lt;span class="math"&gt;\(\ve{q}_{i}^{H} \ve{q}_{i}\)&lt;/span&gt; を書き換えると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{q}_{i}^{H} \ve{q}_{i} &amp;amp;= \ve{q}_{i}^{H} \ve{I} \ve{q}_{i} = \sum_{k=1}^{M} \sum_{l=1}^{M} \overline{q_{ik}} q_{il} \delta(l-k) \\
&amp;amp;= \frac{1}{2\pi} \sum_{k=1}^{M} \sum_{l=1}^{M} \overline{q_{ik}} q_{il} \int_{-\pi}^{\pi} \exp[j\omega(l-k)] d\omega \\
&amp;amp;= \frac{1}{2\pi} \int_{-\pi}^{\pi} | Q_{i}(\omega)|^{2} d\omega \tag{6}
\end{align*}
&lt;/div&gt;
&lt;p&gt;(5), (6)を(1)に代入することで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\lambda_{i} = \displaystyle\frac{\int_{-\pi}^{\pi} | Q_{i}(\omega)|^{2} S(\omega) d\omega}{\int_{-\pi}^{\pi} | Q_{i}(\omega)|^{2} d\omega}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とまとめられる。ここで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
S_{\min} \int_{-\pi}^{\pi} | Q_{i}(\omega)|^{2} d\omega \leq \int_{-\pi}^{\pi} | Q_{i}(\omega)|^{2} S(\omega) d\omega \leq S_{\max} \int_{-\pi}^{\pi} | Q_{i}(\omega)|^{2} d\omega
\end{equation*}
&lt;/div&gt;
&lt;p&gt;だから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
S_{\min} \leq \lambda_{i} \leq S_{\max}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成立し、命題が示された。（証明終）&lt;/p&gt;
&lt;p&gt;命題からただちに、 &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; の条件数 &lt;span class="math"&gt;\(\kappa(\ve{R})\)&lt;/span&gt; は以下の上界を持つことがわかる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\kappa(\ve{R}) := \frac{\max_{i} \lambda_{i}}{\min_{i} \lambda_{i}} \leq \frac{S_{\max}}{S_{\min}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;未証明だが、 &lt;span class="math"&gt;\(M \to \infty\)&lt;/span&gt; とすると、 &lt;span class="math"&gt;\(\max_{i} \lambda_{i} \to S_{\max}\)&lt;/span&gt; かつ &lt;span class="math"&gt;\(\min_{i} \lambda_{i} \to S_{\min}\)&lt;/span&gt; となる（要確認…）。このことから、 &lt;span class="math"&gt;\(\lim_{M \to \infty} \frac{S_{\max}}{S_{\min}} = \kappa(\ve{R})\)&lt;/span&gt; が成立する。 &lt;span class="math"&gt;\(M\)&lt;/span&gt; が十分大きければ、条件数の良い近似となっていることを示している。&lt;/p&gt;
&lt;p&gt;正則化による影響を考える。行列 &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; の対角要素に &lt;span class="math"&gt;\(\varepsilon &amp;gt; 0\)&lt;/span&gt; を足すことは、自己相関関数としては、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
r^{\prime}(k) = r(k) + \varepsilon \delta(k)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;という修正を行うことに対応する。 &lt;span class="math"&gt;\(r^{\prime}\)&lt;/span&gt; に対応するパワースペクトル密度 &lt;span class="math"&gt;\(S^{\prime}(\omega)\)&lt;/span&gt; は、ウィーナー・ヒンチンの定理より、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
S^{\prime}(\omega) &amp;amp;= \int_{-\pi}^{\pi} r^{\prime}(k) \exp(-j\omega k) dk \\
&amp;amp;= \int_{-\pi}^{\pi} r(k) \exp(-j\omega k) dk + \varepsilon \int_{-\pi}^{\pi} \delta(k) \exp(-j\omega k) dk = S(\omega) + \varepsilon \exp(0) \\
&amp;amp;= S(\omega) + \varepsilon
\end{align*}
&lt;/div&gt;
&lt;p&gt;（全帯域が &lt;span class="math"&gt;\(\varepsilon\)&lt;/span&gt; だけ持ち上がることになる）このことより、正則化を行った場合の条件数は以下の上界を持つ：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{S_{\max} + \varepsilon}{S_{\min} + \varepsilon}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;なお、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{S_{\max}}{S_{\min}} - \frac{S_{\max} + \varepsilon}{S_{\min} + \varepsilon} &amp;amp;= \frac{1}{S_{\min}(S_{\min} + \varepsilon)} \left\{ S_{\max}(S_{\min} + \varepsilon) - S_{\min}(S_{\max} + \varepsilon) \right\} \\
&amp;amp;= \frac{\varepsilon(S_{\max} - S_{\min})}{S_{\min}(S_{\max} + \epsilon)} \geq 0
\end{align*}
&lt;/div&gt;
&lt;p&gt;だから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{S_{\max} + \varepsilon}{S_{\min} + \varepsilon} \leq \frac{S_{\max}}{S_{\min}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となって、上界を抑えることができる。とくに &lt;span class="math"&gt;\(\lim_{\varepsilon \to \infty} \frac{S_{\max} + \varepsilon}{S_{\min} + \varepsilon} = 1\)&lt;/span&gt; だから条件数も1に漸近する。これは、自己相関関数がほぼ単位行列に近づく（対角優位になる）ことに一致する。&lt;/p&gt;
&lt;p&gt;条件数については理解が足りてない部分があった。端的に言って、Ax=bにおけるbの変化による解xの変化率の上限。以下の資料が分かりやすかった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ipsj.ixsq.nii.ac.jp/ej/?action=repository_uri&amp;amp;item_id=141628&amp;amp;file_id=1&amp;amp;file_no=1"&gt;数値計算における数学 連立一次方程式の求解法を題材として&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://nm.mathforcollege.com/mws/gen/04sle/mws_gen_sle_spe_adequacy.pdf"&gt;Chapter 04.09 Adequacy of Solutions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(10)</title><link href="/huirutakao-cha-10.html" rel="alternate"></link><published>2022-03-19T10:00:00+09:00</published><updated>2022-03-19T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-19:/huirutakao-cha-10.html</id><summary type="html">&lt;p&gt;論文再投稿や他作業に追われて手を付けられていない。スキマに読んでいた「線形システム同定の基礎」が素晴らしか …&lt;/p&gt;</summary><content type="html">&lt;p&gt;論文再投稿や他作業に追われて手を付けられていない。スキマに読んでいた「線形システム同定の基礎」が素晴らしかった。式展開が丁寧でサクサク読めた。以下の点で示唆あり。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;持続的励振性(p.91)&lt;ul&gt;
&lt;li&gt;例：単純な正弦波では最尤推定量が一致性を持たない（サンプル数を増やしても誤差が減少しない）&lt;/li&gt;
&lt;li&gt;一般に、フィルタ次数mに対して &lt;span class="math"&gt;\(\lfloor x/2 \rfloor\)&lt;/span&gt; 個の周波数成分を持たないと一致性がない&lt;/li&gt;
&lt;li&gt;これ、実験で見たことある。チャープや正弦波の誤差が他より大きかったのはこれが原因か。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LPCの予測で正則化を入れるとロスが小さくなりうる(p.170)&lt;ul&gt;
&lt;li&gt;これは有益な示唆。ノイズを取り入れている可能性がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正則化項をカーネル行列を使った2次形式であらわしたカーネル正則化がある&lt;ul&gt;
&lt;li&gt;これでインパルス応答を精度よく同定できる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;システム同定のお話なので、これらはすぐに取り入れられそう。読んでよかった。
実験に再着手する前に、正則化込みのLPCを調査する。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://penta3.ufrgs.br/normasITU/ITUTSOFT/G723-1/ANNEXB/01-01/SRC/LPC2.C"&gt;lpc2.c&lt;/a&gt; かなりフォーマルにやってるな、察しの通り0次（分散）を大きくしている&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*  Do Ridge regression  */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;curAcf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;FLOAT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mf"&gt;1025.0&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLOAT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mf"&gt;1024.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curAcf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLOAT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LpcOrder&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;curAcf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLOAT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LpcOrder&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;curAcf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DotProd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Vect&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Vect&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LpcFrame&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LpcFrame&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;LpcFrame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BinomialWindowTable&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ソース先頭に ITU-T G.723.1 と書いてあってどうもACELPのコードらしい（ &lt;a class="reference external" href="https://www.kyastem.co.jp/technical/explanation-codec/itu-t-g-723-1/"&gt;参考&lt;/a&gt; ）&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ソースは &lt;a class="reference external" href="https://www.itu.int/rec/T-REC-G.723.1-200605-I/en"&gt;ここ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Ridgeについては &lt;cite&gt;A white noise correction factor of (1025/1024) is applied by using the formula R[0] = R[0](1 + 1/1024).&lt;/cite&gt; と書いてある。書いてあるだけで何を参照したかさっぱり。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.mmsp.ece.mcgill.ca/Documents/Reports/2003/KabalR2003a.pdf"&gt;Ill-Conditioning and Bandwidth Expansion in Linear Prediction of Speech&lt;/a&gt; これの2.2.1にかなり書いてある。固有値の散らばりを抑制する（条件数を改善する）効果がある。white noise compensationというらしい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;この論文素晴らしい。高域補償（プリエンファシス？）と窓かけについても効果を検証している。&lt;/li&gt;
&lt;li&gt;自己相関行列の固有値は、パワースペクトル密度の最小値以上かつ最大値以下である。（確かめたら自明だったけど重要だ）&lt;/li&gt;
&lt;li&gt;純音は完全に予測しやすいから（事実、線形システム同定の基礎にあったように、2基底で十分だから）条件数が悪くなる。女性や子供の鼻音が純音に近く、窓かけしても条件数に影響がでるとのこと。&lt;/li&gt;
&lt;li&gt;0次相関に定数倍することで、残差は悪化する傾向だが、悪化するフレームは元々の予測がかなり正確にできたフレームであり、レアとのこと。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LPCの正則化、ITU-T G.723.1に従って &lt;span class="math"&gt;\(1025/1024 \approx 1.0009765625\)&lt;/span&gt; を分散に乗じると、手元のデータで改善傾向が出た。 &lt;span class="math"&gt;\(513/512 \approx 1.001953125\)&lt;/span&gt; だとさらにいい。ガチデータでも回したい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(513/512\)&lt;/span&gt; でRWCで55.87%となり（補助関数法抜きで）、良くなっている。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正則化パラメータを最適に選択できればいいなあと思って、正則化パラメータを変えたときのLPCの残差分散を見たが、パラメータが小さい（正則化をかけないほうが）良かった。そらそうだよな、パラメータ=0で残差ペナルティがなくなるから。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;別の尺度（符号長とか）で判断しないとダメかもなあ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なぜ正則化で良くなるんだ？自明なのは、条件数が良くなるくらいしかないぞ？演算精度が原因で、結果ロスが悪くなっている？&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category><category term="WavPack"></category></entry><entry><title>フィルタ考察(9)</title><link href="/huirutakao-cha-9.html" rel="alternate"></link><published>2022-03-11T10:00:00+09:00</published><updated>2022-03-11T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-11:/huirutakao-cha-9.html</id><summary type="html">&lt;p&gt;それこそAICやFPE（Final Prediction Error, 最終予測残差）で理論的な議論ができそうな気がしてきた。モデル選択に近い話。&lt;/p&gt;
&lt;p&gt;FPEの文献が少 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;それこそAICやFPE（Final Prediction Error, 最終予測残差）で理論的な議論ができそうな気がしてきた。モデル選択に近い話。&lt;/p&gt;
&lt;p&gt;FPEの文献が少ない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ism.ac.jp/editsec/aism/pdf/021_2_0243.pdf"&gt;Fitting Autoregressive Models for Prediction&lt;/a&gt; 赤池先生の原典。導出はどこに…&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://people.stern.nyu.edu/churvich/Regress/Handouts/Chapt18.pdf"&gt;18: MODEL SELECTION&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;しかしなかなか進まない。FPEやAICでは最尤推定量として分散が出るけど、それは音源依存で大きくなったり小さくなるから一般的な議論ができない。&lt;/p&gt;
&lt;p&gt;実験に立ち戻って考えると、分割選択なし（各層1分割）だと層を深くしてもロス, flatnessは良くならない。
構造選択がロスの改善に寄与していることは間違いない。また、論理的にロスが小さくなる構造を選んでいるから良くなるのはわかる。
しかし、それが1層構成よりも良くなる理由がわからない。直感的には構造選択が多い（2層では2回）というのがあるけど、定量的な議論に持っていけない。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category><category term="WavPack"></category></entry><entry><title>フィルタ考察(8)</title><link href="/huirutakao-cha-8.html" rel="alternate"></link><published>2022-03-10T10:00:00+09:00</published><updated>2022-03-10T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-10:/huirutakao-cha-8.html</id><summary type="html">&lt;p&gt;理論的考察の続き。残差に対して連続して線形予測している部分について、変形相関はまさに使えそう（音声の高能率 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;理論的考察の続き。残差に対して連続して線形予測している部分について、変形相関はまさに使えそう（音声の高能率符号化p88にあった。この本すげえな。。。）。これは、予測残差の相関を線形予測係数から計算できるというもの。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/sicejl1962/16/6/16_6_481/_pdf"&gt;線形予測理論とその応用&lt;/a&gt; 線形予測の基本的なところを含む。LPCに対するAICの式もある。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ocw.u-tokyo.ac.jp/lecture_files/engin_01/3/notes/ja/C2-Residual.pdf"&gt;応用音響学 : 残差信号とピッチ抽出&lt;/a&gt; ここにもある。やはり残差分散は線形予測係数の自己相関行列を入力信号ベクトルで挟んだ2次形式で計算できるっぽいな。&lt;ul&gt;
&lt;li&gt;係数の自己相関行列から何かを判定できない？？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既存研究から探りたいかも。多段構成のLPCってあるはずなんだよなあ。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category><category term="WavPack"></category></entry><entry><title>フィルタ考察(7)</title><link href="/huirutakao-cha-7.html" rel="alternate"></link><published>2022-03-09T10:00:00+09:00</published><updated>2022-03-09T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-09:/huirutakao-cha-7.html</id><summary type="html">&lt;p&gt;実験的に多層構造が良いのはわかってきた。次は理論的なところを考え始めている。&lt;/p&gt;
&lt;p&gt;今日、WaVPackにxオプションがあるこ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;実験的に多層構造が良いのはわかってきた。次は理論的なところを考え始めている。&lt;/p&gt;
&lt;p&gt;今日、WaVPackにxオプションがあることを知った。負荷が非対称にする代わりに圧縮率を向上するオプションらしい。オイオイオイオイ。&lt;a class="reference external" href="https://github.com/cmpute/audio-codec-benchmark"&gt;ベンチマーク&lt;/a&gt; でx3でTAKを超える圧縮率を叩き出している。。。。&lt;/p&gt;
&lt;p&gt;実装を見てみる(モノラル: extra1.c, ステレオ: extra2.c)と、残差絶対値のLOG2和をとって(LOG2BUFFER)、これを最小化するようなterm（フィルタパラメータ）を探している。LOG2BUFFERにLOG2の和は符号長に比例すると書いてある&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// This function scans a buffer of longs and accumulates the total log2 value&lt;/span&gt;
&lt;span class="c1"&gt;// of all the samples. This is useful for determining maximum compression&lt;/span&gt;
&lt;span class="c1"&gt;// because the bitstream storage required for entropy coding is proportional&lt;/span&gt;
&lt;span class="c1"&gt;// to the base 2 log of the samples. On some platforms there is an assembly&lt;/span&gt;
&lt;span class="c1"&gt;// version of this.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;が、あっているか微妙。式変形しても符号長との関係は出てこないように見える。&lt;/p&gt;
&lt;p&gt;気持ちとしては符号量に関して最適化のようだ。term（とdelta）が適応フィルタの何らかのパラメータになってて、LOG2和が最小になるフィルタを探しているっぽい。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category><category term="WavPack"></category></entry><entry><title>フィルタ考察(6)</title><link href="/huirutakao-cha-6.html" rel="alternate"></link><published>2022-03-08T10:00:00+09:00</published><updated>2022-03-08T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-08:/huirutakao-cha-6.html</id><summary type="html">&lt;p&gt;引き続き実験。多層構成の方がflatnessはよいけど、L1ロスは1層が良い結果。
L2ロスにしてみると多層構成の方が良い結果 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;引き続き実験。多層構成の方がflatnessはよいけど、L1ロスは1層が良い結果。
L2ロスにしてみると多層構成の方が良い結果を出し始める。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/profile/Nilesh-Madhu/publication/224078693_Note_on_measures_for_spectral_flatness/links/55e16abe08aecb1a7cc65dd8/Note-on-measures-for-spectral-flatness.pdf"&gt;Note on measures for spectral flatness&lt;/a&gt; 別のflatness尺度の提案。&lt;ul&gt;
&lt;li&gt;素朴なflatnessでは、ほぼ1の平坦で1点だけが0になっている場合かなりflatnessが落ちてしまう&lt;/li&gt;
&lt;li&gt;そこで、パワースペクトル密度のエントロピー（に定数をかけて[0,1]にしたもの）を新しいflatnessとして提案する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;『スパースモデリング』（青本）で、双対基底の片方の表現がスパースならば、もう片方はスパースにならない定理がある。いまエントロピーを上げることは周波数領域でスパース表現から離れていくことを意味するから、もう片方、つまり時間波形表現はスパースになるのではないかと思った。しかし、定理が上界を与えていない（つまり、スパースにならない方向ではいくらでも表現できる）のでうまくいかなそう。ちょっと考えると、ホワイトノイズは時間表現でも周波数表現でもスパースになっていない。&lt;/p&gt;
&lt;p&gt;上記のエントロピーを追加して実験に戻る。
分割探索は効果が大きく、ない場合は1層の方がロスは低く、flatnessは高い（窓サイズ/音源に依存しない傾向が見られた）。分割していることが意味のあることだと主張するのが良い？&lt;/p&gt;
&lt;p&gt;つーか、これ既にやってる人いない？？？？？&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category><category term="ResNet"></category></entry><entry><title>フィルタ考察(5)</title><link href="/huirutakao-cha-5.html" rel="alternate"></link><published>2022-03-07T10:00:00+09:00</published><updated>2022-03-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-07:/huirutakao-cha-5.html</id><summary type="html">&lt;p&gt;総パラメータ数を横軸、L1損失やspectral flatness(Wiener entropy)を縦軸に計算して、なぜ多層構成がいいのかを見ている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;パラメータの割り …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;総パラメータ数を横軸、L1損失やspectral flatness(Wiener entropy)を縦軸に計算して、なぜ多層構成がいいのかを見ている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;パラメータの割り振りは全ての層で等しくなるようにした。&lt;/li&gt;
&lt;li&gt;補助関数法とLevinson-Durbin法でグラフの概形はほぼ変わらなかった。（補助関数法、とても遅い）&lt;/li&gt;
&lt;li&gt;音源は聖者の行進先頭4秒Lch, アルファベット読み上げLch, 0hz-2500Hzを2秒かけて線形に変化させるチャープ。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;結果の図は以下（結果は補助関数法によるものだが、L-Dでもほぼ変わらず）:&lt;/p&gt;
&lt;div class="section" id="l1"&gt;
&lt;h2&gt;L1ロス&lt;/h2&gt;
&lt;img alt="聖者の行進に対するロス比較" src="../images/loss_result_seijya.png" /&gt;
&lt;img alt="アルファベット読み上げに対するロス比較" src="../images/loss_result_alphabet.png" /&gt;
&lt;img alt="チャープに対するロス比較" src="../images/loss_result_chirp.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="spectral-flatness"&gt;
&lt;h2&gt;spectral flatness&lt;/h2&gt;
&lt;img alt="聖者の行進に対するspectral flatness比較" src="../images/flatness_result_seijya.png" /&gt;
&lt;img alt="アルファベット読み上げに対するロス比較" src="../images/flatness_result_alphabet.png" /&gt;
&lt;img alt="チャープに対するロス比較" src="../images/flatness_result_chirp.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;考察&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ロスは1層構成が一番よいが、ほぼ2層構成と同等。パラメータ数を増やすと漸近していく。&lt;/li&gt;
&lt;li&gt;Spectral flatnessはパラメータ数を増やすと2,4,8層構成が良くなる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spectral flatnessってそもそも何よ、というところ。今回の場合は、残差がどれくらい白色雑音に近いかを測る尺度以上のことは出てこない・・・&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/1162572"&gt;A spectral-flatness measure for studying the autocorrelation method of linear prediction of speech analysis&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;flatnessを使ったLPCの自己相関法等価とのからみ。flatnessの原典ぽいな。&lt;/li&gt;
&lt;li&gt;自己相関行列の条件数との絡みも書いてある。&lt;/li&gt;
&lt;li&gt;pre-whiteing（プリエンファシス）をすることで大幅に悪条件を防げると言っている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://ee602.wdfiles.com/local--files/report-presentations/Group_15"&gt;こちら&lt;/a&gt; でも読める。こっちは要約版。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://dsp.stackexchange.com/questions/42598/spectral-flatness-or-wiener-entropy-for-ar1-and-ar2"&gt;Spectral flatness or Wiener Entropy for AR(1) and AR(2)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;AR(1), AR(2)は理論的に計算できる。一般のAR(p)も書いてある。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://musicweb.ucsd.edu/~sdubnov/Papers/SPL.pdf"&gt;Generalization of Spectral Flatness Measure for Non-Gaussian Linear Processes&lt;/a&gt; 一般の計算についての原典はここ&lt;ul&gt;
&lt;li&gt;ラプラス分布残差を仮定した場合も計算できるな、おっ…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A spectral-flatness measure for studying ...の論文で条件数が改善するという記述を見て、適応フィルタを入れるのがよさそうと思って、Sign-Sign Algotrithm(SSFilter)を突っ込んだら軒並み改善の傾向。しかし、負荷上昇も間違いないのでオプションにするべきかも。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;RWCで実験してみたら、圧縮率は微悪化かつデコード速度は0.3から0.38くらいまで悪化。&lt;/li&gt;
&lt;li&gt;負荷に対するゲインがないのでやめる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hacker newsで上がっていたwikipediaのLoudness warの記事が面白い。売れた楽曲の音圧は単調に上がっている。一方で歪みまくっている。
参考文献もパット見面白いこと書いてあるので時間があれば腰を入れて読みたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.sfxmachine.com/docs/loudnesswar/loudness_war.pdf"&gt;The Loudness War: Background, Speculation and Recommendations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://tech.ebu.ch/docs/techreview/trev_310-lund.pdf"&gt;Level and distortion in digital broadcasting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://tech.ebu.ch/docs/techreview/trev_2010-Q3_loudness_Camerer.pdf"&gt;On the way to Loudness Nirvana ? Audio levelling with EBU R 128&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category></entry><entry><title>変換符号化ベースのロスレス音声コーデック検討</title><link href="/bian-huan-fu-hao-hua-besunorosuresuyin-sheng-kodetsukujian-tao.html" rel="alternate"></link><published>2022-03-05T10:00:00+09:00</published><updated>2022-03-05T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-05:/bian-huan-fu-hao-hua-besunorosuresuyin-sheng-kodetsukujian-tao.html</id><summary type="html">&lt;p&gt;整数DCTベースでロスレス音声コーデックが構築できるはずで、試してみたい。
整数DCT、やけにリフティングという単語 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;整数DCTベースでロスレス音声コーデックが構築できるはずで、試してみたい。
整数DCT、やけにリフティングという単語が出てくるが、もしかしてウェーブレットとして考えられる？いや自明か。フーリエ変換はウェーブレット変換の一種なのだから。再構成条件を満たすようにフィルタを作るということになるんだろな。&lt;/p&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;記事&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://stackoverflow.com/questions/18621167/dct-using-integer-only"&gt;DCT using integer only&lt;/a&gt; このあたりから探りを入れる&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://fgiesen.wordpress.com/2013/11/04/bink-2-2-integer-dct-design-part-1/"&gt;Bink 2.2 integer DCT design, part 1&lt;/a&gt; 整数DCTの手法比較が載っている&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/rygorous/dct_blog"&gt;rygorous/dct_blog&lt;/a&gt; そのソース&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="趣味"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category></entry><entry><title>フィルタ考察(4)</title><link href="/huirutakao-cha-4.html" rel="alternate"></link><published>2022-03-05T10:00:00+09:00</published><updated>2022-03-05T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-05:/huirutakao-cha-4.html</id><summary type="html">&lt;p&gt;別件であまり動けていない、焦り始めている。&lt;/p&gt;
&lt;p&gt;なぜ3層がいいのかを検証していった方がいいかも。総パラメータ数を …&lt;/p&gt;</summary><content type="html">&lt;p&gt;別件であまり動けていない、焦り始めている。&lt;/p&gt;
&lt;p&gt;なぜ3層がいいのかを検証していった方がいいかも。総パラメータ数を横軸に、縦軸最もよい構成での平均flatness。1層、2層、3層で比較していく。
この実験を日曜日に回していく。&lt;/p&gt;
&lt;p&gt;また、思い付きでプリエンファシス後にCDF42つっこんで見たけど大幅に圧縮率が悪化した。据え置きませう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category></entry><entry><title>ロスレス音声コーデックの開発メモ</title><link href="/rosuresuyin-sheng-kodetsukunokai-fa-memo.html" rel="alternate"></link><published>2022-03-05T00:00:00+09:00</published><updated>2022-03-05T00:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-05:/rosuresuyin-sheng-kodetsukunokai-fa-memo.html</id><summary type="html">&lt;p&gt;技術書典7に向けたロスレス音声コーデックの作成日誌。はてなブログから移行。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;主な成果物リンク&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://ec.toranoana.jp/tora_r/ec/item/040030776670/"&gt;できた本（とらのあな通販）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/MrAiki/ALA"&gt;できたもの(github)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/MrAiki/SLA"&gt;できたもの2(github)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/aikiriao/introduction_to_lossless_audio_compression/releases"&gt;本をpdfで無料公開しました&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;要件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ロスレス&lt;/li&gt;
&lt;li&gt;16bit, 24bit深度&lt;/li&gt;
&lt;li&gt;192kHz&lt;/li&gt;
&lt;li&gt;16ch&lt;/li&gt;
&lt;li&gt;ストリーミング&lt;/li&gt;
&lt;li&gt;ブロック単位に分ける&lt;/li&gt;
&lt;li&gt;各ブロックの破損確認(CRCでOK)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まずは、16bit, 48k, 1ch, ブロック単位分割でできるのが良いのでは？&lt;/p&gt;
&lt;h2&gt;比較研究&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://wiki.hydrogenaud.io/index.php?title=Lossless_comparison"&gt;比較wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.audiograaf.nl/downloads.html"&gt;比較レポート&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OptimFROGという圧縮率重視のコーデックがあることを知る。他にもTTA, TAKも強力か。FLACはデコード速度重視の様相。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.firstpr.com.au/audiocomp/lossless/"&gt;古い比較レポート&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiph.org/flac/comparison.html"&gt;FLACと他のフォーマットの比較&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www7a.biglobe.ne.jp/~fortywinks/music4.htm"&gt;houyhnhnmのエキセントリックらぶらぶ音声データ講座 第4回 ～ WAVE・音楽CD→可逆圧縮 ～&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mi.eng.cam.ac.uk/reports/svr-ftp/auto-pdf/robinson_tr156.pdf"&gt;SHORTEN - FLACの基礎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://codecs.multimedia.cx/2010/11/why-lossless-audio-codecs-generally-suck/"&gt;Why Lossless Audio Codecs generally suck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;何でロスレスオーディオは総じてひどいのか。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;色々なロスレス音声コーデック&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://read.pudn.com/downloads167/ebook/769449/dataCompress.pdf"&gt;データ圧縮全般（犯罪では）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://xiph.org/flac/"&gt;FLAC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.lossless-audio.com/"&gt;La&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elvera.nue.tu-berlin.de/files/0737Liebchen2005.pdf"&gt;MPEG-4 ALS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.monkeysaudio.com/index.html"&gt;Monkey's Audio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/fernandotcl/monkeys-audio"&gt;CIツール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.wavpack.com"&gt;WavPack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.wavpack.com/WavPack.pdf"&gt;背景理論についての作者の開発論文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.hydrogenaud.io/index.php?title=TAK"&gt;TAK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;高圧縮率・高速デコード。バランスが取れていて、現段階で最強に見える。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ja.wikipedia.org/wiki/Apple_Lossless"&gt;Apple lossless(ALAC)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ja.wikipedia.org/wiki/TTA"&gt;TTA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;酷評...なぜ&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ja.wikipedia.org/wiki/ATRAC#ATRAC_Advanced_Lossless"&gt;ATRAC Advanced Lossless&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.mega-nerd.com/libsndfile/"&gt;libsndfile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.mega-nerd.com/libsndfile/#Features"&gt;変換対応表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nue.tu-berlin.de/menue/research/research_topic/compression_and_transmission/mpeg_4_audio_lossless_coding_als/parameter/en/#c230252"&gt;MPEG-4 ALSのエンコーダ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;手法妄想&lt;/h2&gt;
&lt;h3&gt;2018.10.6&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MPEG4-ALSを真似てPARCORとLong-term PARCORを組み合わせる。Long-term PARCORは最初のPARCORの誤差をFFTしてピークに出た周波数に対応するラグで予測する。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FLACはどうもゴロム符号化（→ライス符号化だった。高速化の為）を使用している。より良いエントロピー符号化を使用すべき。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高次の自己相関を使えないか？高橋治久教授の。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LPCの計算はつまるところ標本自己相関の計算負荷に尽きる。ウィーナ・ヒンチンの定理を使用して早くできないか？真のパワースペクトルは計算できないことは知っているが、ゼロ埋めか平均回数を多くすることで近似精度を上げられないか？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;この話はエンコード時にのみ起こる問題なので、置いといていいか。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;日記&lt;/h2&gt;
&lt;h3&gt;2018.10.14&lt;/h3&gt;
&lt;p&gt;下回りの整備をしていた。wavファイル読み込みモジュールと、LPC解析（+PARCOR係数計算、音声合成）まではいけている。&lt;/p&gt;
&lt;p&gt;次にやるべきは単純なロスレス音声コーデックを作ること。ブロック分割しないで係数を出し、係数と予測誤差を記録してみる。恐らく量子化誤差が大きな敵になるであろう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.fon.hum.uva.nl/praat/old/src/sources_4623/FLAC/flac_lpc.c"&gt;FLACのLPC実装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2018.10.21&lt;/h3&gt;
&lt;p&gt;家に帰って早速エントロピー計算モジュールとLPCのnan問題にあたっていた。エントロピー計算モジュールはOK。頻度の計算に二分木を使用。nan問題はfloatの精度の問題だった。サンプル数を増やしたとき、自己相関関数の値に誤差が出ているのが原因。内部的な結果は全てdoubleで持つように修正することで解決。&lt;/p&gt;
&lt;p&gt;floatを簡単に整数量子化して予測するルーチンも完成している。
改めて単純なロスレスコーデックを作るべし。&lt;/p&gt;
&lt;h3&gt;2018.10.23&lt;/h3&gt;
&lt;p&gt;音声処理とDSPという本を読んでいたら、LSPはPARCORと比べ（ロッシーだけど）60%の情報量圧縮ができるとの文面あり。
恐らく量子化感度に鈍いというのと補間が効くのが理由？LSPも試してみたい。&lt;/p&gt;
&lt;h3&gt;2018.10.28&lt;/h3&gt;
&lt;p&gt;音声符号化（守谷）をチラチラ見ている。面白い結果が少し出ているので精査したい。特にPARCOR係数から予測利得（予測によって残差利得がどれくらい減ったか）が勘弁に計算できるのは大きい。係数評価に使えそう。&lt;/p&gt;
&lt;p&gt;いつもの海ベローチェで作業。一番簡単なロスレスコーデックが完成した。&lt;/p&gt;
&lt;p&gt;仕様：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入力wav全体を一つのPARCOR係数で予測符号化&lt;/li&gt;
&lt;li&gt;PARCOR係数の次数は10, 係数は全て[-1,1]の範囲で16bit線形量子化（符号化する時は浮動小数点数を15bit左シフト）&lt;/li&gt;
&lt;li&gt;残差は適応型ハフマンで符号化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;フォーマットは以下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;サイズ(bits)&lt;/th&gt;
&lt;th align="center"&gt;内容&lt;/th&gt;
&lt;th align="center"&gt;補足&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;シグネチャ &lt;code&gt;"SolA"&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;Soleil Aikatsuの略（Sound of lossless Audioの略）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;16&lt;/td&gt;
&lt;td align="center"&gt;フォーマットバージョン番号&lt;/td&gt;
&lt;td align="center"&gt;バージョン1では1。フォーマットに変更がある度に上げる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;チャンネル数&lt;/td&gt;
&lt;td align="center"&gt;足りるでしょ…（怠慢）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;サンプル数&lt;/td&gt;
&lt;td align="center"&gt;全チャンネルでサンプル数は同一とする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;サンプリングレート&lt;/td&gt;
&lt;td align="center"&gt;足りるでしょ…（怠慢）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;サンプルあたりビット数&lt;/td&gt;
&lt;td align="center"&gt;wavに戻すときに必要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;符号化（復号）に必要なビット数&lt;/td&gt;
&lt;td align="center"&gt;適応型ハフマンの初期化に必要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;チャンネル数 * 16 * 11&lt;/td&gt;
&lt;td align="center"&gt;PARCOR係数&lt;/td&gt;
&lt;td align="center"&gt;各チャンネル毎のPARCOR係数[-1,1]の数値を16bit固定小数点数で符号化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;不定&lt;/td&gt;
&lt;td align="center"&gt;ハフマン符号化された残差&lt;/td&gt;
&lt;td align="center"&gt;チャンネルインターリーブではない。1ch目の符号化された信号列先頭, ..., 1ch目の符号化された信号列末尾, 2ch目の符号化された信号先頭, ..., 2ch目の符号化された信号末尾,...という並び。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ブロック化するにあたり、ストリームを意識するのでCRCチェックを入れたい。ファイル全体ではCRC32でいいけど、データブロックの破損チェックはCRC16でいいかなと。&lt;/p&gt;
&lt;p&gt;CRC16の実装で大ハマリ。CRC16には各種の規格がある...とりあえずCCITT-FALSEの実装を目指す...
HCAはCRC16-IBM(多項式0x8005)だった。揃えるべきかも。&lt;/p&gt;
&lt;p&gt;色々CRC16について見ていて、良質な纏めは以下（それ以外は &lt;strong&gt;どの&lt;/strong&gt; CRC16を実装したのかわからない）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://doc.plasticheart.info/crc-16"&gt;CRC-16のおぼえがき&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://reveng.sourceforge.net/crc-catalogue/16.htm"&gt;Catalogue of parametrised CRC algorithms with 16 bits&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linuxは流石に嘘ついてなさそうだからリファレンスに：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/torvalds/linux/blob/master/include/linux/crc-ccitt.h"&gt;linux/include/linux/crc-ccitt.h&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/torvalds/linux/blob/master/lib/crc-ccitt.c"&gt;linux/lib/crc-ccitt.c&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2018.11.3&lt;/h3&gt;
&lt;p&gt;version2.のフォーマットを以下のようにしてみた。（ドラフト）&lt;/p&gt;
&lt;h4&gt;SolAヘッダ&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;サイズ(bits)&lt;/th&gt;
&lt;th align="center"&gt;内容&lt;/th&gt;
&lt;th align="center"&gt;補足&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;シグネチャ &lt;code&gt;"SolA"&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;Soleil Aikatsuの略（Sound of lossless Audioの略）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;一番最初のデータブロックまでのオフセット（自分除く）&lt;/td&gt;
&lt;td align="center"&gt;240bit = 30byteSのはず&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;16&lt;/td&gt;
&lt;td align="center"&gt;フォーマットバージョン番号&lt;/td&gt;
&lt;td align="center"&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;チャンネル数&lt;/td&gt;
&lt;td align="center"&gt;足りるでしょ…（怠慢）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;全サンプル数&lt;/td&gt;
&lt;td align="center"&gt;足りるでしょ…（怠慢）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;サンプリングレート&lt;/td&gt;
&lt;td align="center"&gt;足りるでしょ…（怠慢）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;1サンプルあたりのビット数&lt;/td&gt;
&lt;td align="center"&gt;wavへの復元で必要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;符号化（復号）に必要なビット数&lt;/td&gt;
&lt;td align="center"&gt;適応型ハフマンの初期化に必要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;PARCOR係数次数&lt;/td&gt;
&lt;td align="center"&gt;全ブロックで同一&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;SolAブロック数&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;SolAブロックあたりの最大サンプル数&lt;/td&gt;
&lt;td align="center"&gt;等ビットレート実現のため末尾以外は最大サンプル数に揃える。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;ヘッダ以降のCRC32値&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;ヘッダのCRC32値（自分除く）&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;SolAブロック&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;サイズ(bits)&lt;/th&gt;
&lt;th align="center"&gt;内容&lt;/th&gt;
&lt;th align="center"&gt;補足&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;同期コード&lt;code&gt;0xFF&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;次のデータブロックまでのオフセット&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;16&lt;/td&gt;
&lt;td align="center"&gt;これ以降のフィールドで、次のブロック先頭までのCRC16値&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;このブロックのサンプル数&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;16 * チャンネル数 * PARCOR係数次数&lt;/td&gt;
&lt;td align="center"&gt;PARCOR係数&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;不定&lt;/td&gt;
&lt;td align="center"&gt;適応型ハフマン符号化された残差&lt;/td&gt;
&lt;td align="center"&gt;チャンネルインターリーブではない。1ch目の符号化された信号列先頭, ..., 1ch目の符号化された信号列末尾, 2ch目の符号化された信号先頭, ..., 2ch目の符号化された信号末尾,...という並び。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;フォーマットはOK。やるべきはメモリ上での解析実装かも。
メモリ上に読み込まれた要素に対してヘッダの解析とブロックのデコードを行うように実装する。そうなると適応型ハフマン、もしくはBitStreamをメモリ上で動かす必要がある。できるか…？&lt;/p&gt;
&lt;p&gt;MemoryBitStreamを作るか、BitStreamを機能拡張するかに分かれる。恐らくBitStreamを機能拡張して、今までと同じ操作で透過的にメモリに書き読みできるのがスマート。この期にテスト追加しとく。&lt;/p&gt;
&lt;h3&gt;2018.11.25&lt;/h3&gt;
&lt;p&gt;メモリ上の書き込み/読み込み形式で復号ができず（同期コードをうまく発見できない不具合あり）、ひとまずファイル書き込み式で実装した。それでも復号に失敗するときがあり、原因を追っていたところ適応型ハフマンの量子化ビット数が足りないことが原因であることがわかった。&lt;/p&gt;
&lt;p&gt;適応型ハフマンのビット数を増やすことで復号が上手く行くことを確認した。が、符号化のサイズと負荷が激増。ハフマン木が大きくなったのが原因。各ブロックごとに最大誤差を求めてビット数を変える事が考えられるが、それは等ビットレート（負荷変動最小化）に反する。&lt;/p&gt;
&lt;p&gt;こうなるとやはりゴロム（ライス）符号化を試さざるを得ない印象を受ける。バージョン3としてゴロム符号化を使う。&lt;/p&gt;
&lt;p&gt;version3のフォーマットは以下:&lt;/p&gt;
&lt;h4&gt;SolAヘッダ&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;サイズ(bits)&lt;/th&gt;
&lt;th align="center"&gt;内容&lt;/th&gt;
&lt;th align="center"&gt;補足&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;シグネチャ &lt;code&gt;"SolA"&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;Soleil Aikatsuの略（Sound of lossless Audioの略）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;一番最初のデータブロックまでのオフセット（自分除く）&lt;/td&gt;
&lt;td align="center"&gt;240bit = 30byteSのはず&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;16&lt;/td&gt;
&lt;td align="center"&gt;フォーマットバージョン番号&lt;/td&gt;
&lt;td align="center"&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;チャンネル数&lt;/td&gt;
&lt;td align="center"&gt;足りるでしょ…（怠慢）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;全サンプル数&lt;/td&gt;
&lt;td align="center"&gt;足りるでしょ…（怠慢）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;サンプリングレート&lt;/td&gt;
&lt;td align="center"&gt;足りるでしょ…（怠慢）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;1サンプルあたりのビット数&lt;/td&gt;
&lt;td align="center"&gt;wavへの復元で必要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;ゴロム符号のパラメータ&lt;/td&gt;
&lt;td align="center"&gt;全ブロックで同一。負荷が変わらないのならば、ブロックごとに変えることも検討。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;PARCOR係数次数&lt;/td&gt;
&lt;td align="center"&gt;全ブロックで同一&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;SolAブロック数&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;SolAブロックあたりの最大サンプル数&lt;/td&gt;
&lt;td align="center"&gt;等ビットレート実現のため末尾以外は最大サンプル数に揃える。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;ヘッダ以降のCRC32値&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;ヘッダのCRC32値（自分除く）&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;SolAブロック&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;サイズ(bits)&lt;/th&gt;
&lt;th align="center"&gt;内容&lt;/th&gt;
&lt;th align="center"&gt;補足&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;同期コード&lt;code&gt;0xFF&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;次のデータブロックまでのオフセット&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;16&lt;/td&gt;
&lt;td align="center"&gt;これ以降のフィールドで、次のブロック先頭までのCRC16値&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;このブロックのサンプル数&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;16 * チャンネル数 * PARCOR係数次数&lt;/td&gt;
&lt;td align="center"&gt;PARCOR係数&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;不定&lt;/td&gt;
&lt;td align="center"&gt;ゴロム符号化された残差&lt;/td&gt;
&lt;td align="center"&gt;チャンネルインターリーブではない。1ch目の符号化された信号列先頭, ..., 1ch目の符号化された信号列末尾, 2ch目の符号化された信号先頭, ..., 2ch目の符号化された信号末尾,...という並び。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ゴロム符号で復号が失敗する…ワイル符号で上手く復号できることから、ゴロム符号にバグがあるとしか…デバッグ中。…してたら、&lt;code&gt;Golomb_GetCode&lt;/code&gt;の結果を一回変数に受ける必要があるみたい。完全に謎。&lt;/p&gt;
&lt;p&gt;```c:ok
        uint64_t bitsbuf;
        bitsbuf = Golomb_GetCode(strm, golomb_m);
        residual[ch][smpl] = UINT32_TO_SINT32(bitsbuf);&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nl"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NG&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;は&lt;/span&gt;&lt;span class="err"&gt;？）&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;residual&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="o"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;UINT32_TO_SINT32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Golomb_GetCode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;golomb_m&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;→マクロに展開すると展開された分読んじゃうから。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;また、ワイル符号の圧縮率が悪い！これはブロック先頭部分の誤差を出力しているからかも...→やったけど微減。&lt;/p&gt;
&lt;h3&gt;2018.11.29&lt;/h3&gt;
&lt;p&gt;ゴロム符号を使ったときのバグを直した。それでエンコード時のエントロピーを見ていたら、エントロピーの減少を確認したが、まだ削れそうな予感がある。&lt;/p&gt;
&lt;p&gt;Monkey Audioでは単純な差分符号化を行っている...参考にして、差分符号化でエントロピーが減るか観察してみる。&lt;/p&gt;
&lt;p&gt;→手元のデータではエントロピーが増えた。。。&lt;/p&gt;
&lt;p&gt;ゴロム符号パラメータの最適化手法を探した。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://ipnpr.jpl.nasa.gov/progress_report/42-159/159E.pdf"&gt;Selecting the Golomb Parameter in Rice Coding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;どうも次の式を満たす最大の&lt;span class="math"&gt;\(k\)&lt;/span&gt;が最適パラメータのようです（&lt;span class="math"&gt;\(2^k\)&lt;/span&gt;をパラメータに使う。&lt;strong&gt;ライス符号のみで有効なので注意。&lt;/strong&gt;）:&lt;/p&gt;
&lt;div class="math"&gt;$$
2^{k} \leq \mu + f^{\ast}
$$&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\mu\)&lt;/span&gt;は非負整数の平均、&lt;span class="math"&gt;\(f^{\ast}\)&lt;/span&gt;は理論（実験かも…）によって求められた0.382という値で、49/128, 34/89, 3/8で近似できる。&lt;span class="math"&gt;\(f^{\ast} = A / B, \mu = S / J\)&lt;/span&gt;とおく（&lt;span class="math"&gt;\(S\)&lt;/span&gt;:和、&lt;span class="math"&gt;\(J\)&lt;/span&gt;:標本数）と、不等式は、&lt;/p&gt;
&lt;div class="math"&gt;$$
JB \times 2^{k} \leq BS + JA
$$&lt;/div&gt;
&lt;p&gt;と書ける。&lt;span class="math"&gt;\(k\)&lt;/span&gt;は次のプログラムで求まる&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;J&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;J&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class="math"&gt;\(f^{\ast} = 49/128\)&lt;/span&gt;とすれば、&lt;span class="math"&gt;\(A=49,B=128\)&lt;/span&gt;より、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;J&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;J&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;49&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;さらに128をシフトに置き換えて&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;J&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;J&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;49&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（他にもDNNでパラメータ調節するのがあったけど死ねとしか思えなかった。）&lt;/p&gt;
&lt;p&gt;ライスでは2の冪が前提だが、ゴロムでは次でいけるのでは？（理論的根拠なし）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;J&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;J&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;49&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;早速試してみる。ブロックごとにゴロム符号パラメータを調節してみた。単純なサイン波はあんまり結果が良くないように見える。と思ったら、実践的音声でかなりのパフォーマンス改善が見られた…嘘だろ…？エンコード速度が激減し、エントロピーもいきなり8(理想値)に近くなった。&lt;/p&gt;
&lt;p&gt;俺の声では&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff     50360 Nov 30 00:05 kisaragi_chihaya.ape
-rw-r--r--@  1 *  staff     60808 Nov 26 23:26 kisaragi_chihaya.flac
-rw-r--r--@  1 *  staff     54369 Nov 30 00:05 kisaragi_chihaya.sol
-rw-r--r--@  1 *  staff    109612 Nov 26 23:26 kisaragi_chihaya.wav
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;桃山みらいのワン・ツー・スウィーツでは&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  38305036 Nov 30 00:04 one_two_sweets_offvocal.ape
-rw-r--r--@  1 *  staff  40645286 Nov 30 00:03 one_two_sweets_offvocal.flac
-rw-r--r--@  1 *  staff  43886946 Nov 30 00:03 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  54566444 Nov 30 00:03 one_two_sweets_offvocal.wav
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;山下達郎のSPARKLEでは&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  28436216 Nov 30 00:01 SPARKLE.ape
-rw-r--r--@  1 *  staff  30704598 Sep 17 16:06 SPARKLE.flac
-rw-r--r--@  1 *  staff  34847916 Nov 30 00:01 SPARKLE.sol
-rw-r--r--@  1 *  staff  49080364 Sep 17 16:06 SPARKLE.wav
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;短いモノ音声でflacに勝った。工夫を重ねていきたい。
ステレオはmonkey audioがやっているようなMS変換が有利に働くかも。&lt;/p&gt;
&lt;p&gt;ひとまずVersion.3は可変ゴロム符号デコーダを作ったらfixとしたい。&lt;/p&gt;
&lt;h3&gt;2018.11.30&lt;/h3&gt;
&lt;p&gt;結果からも明らかだったけど、&lt;a href="https://ipnpr.jpl.nasa.gov/progress_report/42-159/159E.pdf"&gt;上の論文&lt;/a&gt;曰く、平均が1未満のときはランレングス符号化が効率的。&lt;/p&gt;
&lt;p&gt;ゴロム符号のパラメータを入れたフォーマットは次：&lt;/p&gt;
&lt;h4&gt;SolAヘッダ&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;サイズ(bits)&lt;/th&gt;
&lt;th align="center"&gt;内容&lt;/th&gt;
&lt;th align="center"&gt;補足&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;シグネチャ &lt;code&gt;"SolA"&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;Soleil Aikatsuの略（Sound of lossless Audioの略）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;一番最初のデータブロックまでのオフセット（自分除く）&lt;/td&gt;
&lt;td align="center"&gt;240bit = 30byteSのはず&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;16&lt;/td&gt;
&lt;td align="center"&gt;フォーマットバージョン番号&lt;/td&gt;
&lt;td align="center"&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;チャンネル数&lt;/td&gt;
&lt;td align="center"&gt;足りるでしょ…（怠慢）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;全サンプル数&lt;/td&gt;
&lt;td align="center"&gt;足りるでしょ…（怠慢）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;サンプリングレート&lt;/td&gt;
&lt;td align="center"&gt;足りるでしょ…（怠慢）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;1サンプルあたりのビット数&lt;/td&gt;
&lt;td align="center"&gt;wavへの復元で必要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;PARCOR係数次数&lt;/td&gt;
&lt;td align="center"&gt;全ブロックで同一&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;SolAブロック数&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;SolAブロックあたりの最大サンプル数&lt;/td&gt;
&lt;td align="center"&gt;等ビットレート実現のため末尾以外は最大サンプル数に揃える。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;ヘッダ以降のCRC32値&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;ヘッダのCRC32値（自分除く）&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;SolAブロック&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;サイズ(bits)&lt;/th&gt;
&lt;th align="center"&gt;内容&lt;/th&gt;
&lt;th align="center"&gt;補足&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;8&lt;/td&gt;
&lt;td align="center"&gt;同期コード&lt;code&gt;0xFF&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;次のデータブロックまでのオフセット&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;16&lt;/td&gt;
&lt;td align="center"&gt;これ以降のフィールドで、次のブロック先頭までのCRC16値&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;32&lt;/td&gt;
&lt;td align="center"&gt;このブロックのサンプル数&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;16 * チャンネル数 * PARCOR係数次数&lt;/td&gt;
&lt;td align="center"&gt;PARCOR係数&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;16 * チャンネル数&lt;/td&gt;
&lt;td align="center"&gt;ゴロム符号のパラメータ&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;不定&lt;/td&gt;
&lt;td align="center"&gt;ゴロム符号化された残差&lt;/td&gt;
&lt;td align="center"&gt;チャンネルインターリーブではない。1ch目の符号化された信号列先頭, ..., 1ch目の符号化された信号列末尾, 2ch目の符号化された信号先頭, ..., 2ch目の符号化された信号末尾,...という並び。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;デコーダやっつけで作ったけどだめだ！なぜかデコード結果が一致しない！サイズは一致するけど途中で差分が出る！&lt;/p&gt;
&lt;h3&gt;2018.12.1&lt;/h3&gt;
&lt;p&gt;PARCOR係数の非線形量子化に先立ち、いろんな音のPARCOR係数分布を見てみた。&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123143p" src="./images/la_first_attempts/20190929123143.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123232p" src="./images/la_first_attempts/20190929123232.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123256p" src="./images/la_first_attempts/20190929123256.png" /&gt;&lt;/p&gt;
&lt;h5&gt;見れること&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;1次成分は1の近傍になる&lt;/li&gt;
&lt;li&gt;2次成分は-1の近傍になるが、偏りは1次ほどではない&lt;/li&gt;
&lt;li&gt;高次になるに従い、ほぼ振動しながら0に近づく。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;--&lt;/p&gt;
&lt;p&gt;バグを直す。追っていたところ、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;予測誤差計算時に32bit整数でオーバーフローしていた&lt;/li&gt;
&lt;li&gt;計算時に一旦64bit整数に受けることで修正。&lt;/li&gt;
&lt;li&gt;予測誤差先頭出力時に入力wavと同一bit数を超える数値が出ていた（16bit wavで69410を出そうとした）&lt;/li&gt;
&lt;li&gt;差分は2倍の値域が出るので+1bitして出力することで修正。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2.については、修正できたが先頭を（ゴロム符号化しない）生のビットで出力すること自体細かな最適化にしかなっていないので、一旦先頭を生のビットで出力するのをやめることにした。これにより圧縮率は悪化するが、それほど大きなダメージではない。&lt;/p&gt;
&lt;p&gt;圧縮効率を上げるアイデアを挙げると：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PARCOR係数を非線形量子化する&lt;/li&gt;
&lt;li&gt;分布を見れば分かるようにPARCOR係数の分布には偏りがある。偏りに合わせて非線形に量子化すれば予測精度が高まる。『音声の高効率符号化』では等ひずみとなるビット数がかなり減ったとのこと。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ビット割当ても低次係数には多く割り振る。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MS処理を行う&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;M = L + R, S = L - R として処理する&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mでは逆相関が除去され、Sでは正相関が除去される。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;無音部でランレングス符号化を使う&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ゴロム符号のパラメータ計算のときに正値化した差分信号の平均を計算する。平均が1より小さければ無音のはず。ランレングスで符号化する。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等ビットレート原則が崩れるかも...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ロングターム（ピッチ情報）を使う&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ピッチ解析を行い、その長さによる予測符号化を行う。MPEG4-LSで使われている手法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ロングタームは少し重たそうだけど、他はすぐにやれそう。12/2はPARCOR係数の非線形量子化に取り組む。&lt;/p&gt;
&lt;h3&gt;2018.12.2&lt;/h3&gt;
&lt;p&gt;非線形量子化を検証中...しっかしまだ非線形量子化のイメージが掴みきれてない。gnuplotでグラフを出してみる。&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123320p" src="./images/la_first_attempts/20190929123320.png" /&gt;&lt;/p&gt;
&lt;p&gt;```bash:ソース
set samples 41
set xtics 0.2
set ytics 0.2
set grid
set xrange[-1:1]
set yrange[-1:1]
plot tanh(x * pi) w p, atanh(x) / pi w p, asin(x) / (pi/2) w p, sin(x * (pi/2)) w p, x w p&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;求まった係数値$&lt;span class="nv"&gt;x&lt;/span&gt; \&lt;span class="nv"&gt;in&lt;/span&gt; [&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="mi"&gt;1&lt;/span&gt;]$に対して、$\&lt;span class="nv"&gt;tanh&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;{&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;}&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;$を計算すると$&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="mi"&gt;1&lt;/span&gt;$の近傍で粗くなるようにしか見えない...（それどころか$\&lt;span class="nv"&gt;tanh&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;{&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;}&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;\&lt;span class="nv"&gt;infty&lt;/span&gt;$だし...）もしかして$\&lt;span class="nv"&gt;tanh&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;$の誤りでは...？

→いや、合ってる。$\&lt;span class="nv"&gt;tanh&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;{&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;}&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;$で変換をかませると、&lt;span class="mh"&gt;$0&lt;/span&gt;$近傍の値はほとんど同じになる。すなわち近い値が割り当てられやすくなる。逆に$&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="mi"&gt;1&lt;/span&gt;$近傍では急激に値が変化するから少しの$&lt;span class="nv"&gt;x&lt;/span&gt;$のずれで全く違う値が割り当てられる。即ち$&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="mi"&gt;1&lt;/span&gt;$近くの情報量が多くなる。

&lt;span class="nv"&gt;ruby&lt;/span&gt;で符号化関数を試作してみた。

```&lt;span class="nv"&gt;ruby&lt;/span&gt;:符号化関数
# &lt;span class="nv"&gt;f_val&lt;/span&gt;は[&lt;span class="mi"&gt;0&lt;/span&gt;,&lt;span class="mi"&gt;1&lt;/span&gt;]の値を期待
&lt;span class="nv"&gt;def&lt;/span&gt; &lt;span class="nv"&gt;encode&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;n_bits&lt;/span&gt;, &lt;span class="nv"&gt;f_val&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;n_bits&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;max&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;f_val&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="nv"&gt;max&lt;/span&gt;.&lt;span class="nv"&gt;to_f&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;n_bits&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="ss"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;max&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;Math&lt;/span&gt;::&lt;span class="nv"&gt;atanh&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;f_val&lt;/span&gt;&lt;span class="ss"&gt;))&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="nv"&gt;Math&lt;/span&gt;::&lt;span class="nv"&gt;atanh&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;max&lt;/span&gt;.&lt;span class="nv"&gt;to_f&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;n_bits&lt;/span&gt;&lt;span class="ss"&gt;)))&lt;/span&gt;.&lt;span class="nv"&gt;to_i&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;→除算を行っているので桁落ちが無視できない...&lt;/p&gt;
&lt;p&gt;1近傍で&lt;span class="math"&gt;\(+\infty\)&lt;/span&gt;にすっ飛んでるのが危険。&lt;span class="math"&gt;\(\tanh(\pi x)\)&lt;/span&gt;のテーブルを作っておき、範囲検索で正規化値に該当するインデックスを符号化するのが良さそう。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# テーブル作成&lt;/span&gt;
&lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;65536&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map!&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;upto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;65535&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tanh&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_f&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;65536&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;# 符号化関数&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f_val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;f_val&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;inx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;f_val&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;inx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nil?&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;inx&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="c1"&gt;# 復号関数&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class="math"&gt;\(1\)&lt;/span&gt;近傍で取りこぼした（区間&lt;span class="math"&gt;\([65535/65536,1.0]\)&lt;/span&gt;の値）値が多いけど、これは量子化故仕方がないよな...？&lt;/p&gt;
&lt;p&gt;```ruby:符号化値の密度
irb(main):294:0&amp;gt; 0.upto(10) {|v| puts "#{v.to_f/10}- #{encode(table, v.to_f / 10)}" }
0.0- 0
0.1- 2094
0.2- 4230
0.3- 6457
0.4- 8838
0.5- 11459
0.6- 14460
0.7- 18093
0.8- 22918
0.9- 30712
1.0- 65535&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;0.9&lt;/span&gt;&lt;span class="n"&gt;から1&lt;/span&gt;&lt;span class="mf"&gt;.0&lt;/span&gt;&lt;span class="n"&gt;の間に約35000個割り当てていることが分かる。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;さて、C言語での実装を考える。標準ライブラリ関数の&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`tanh`&lt;/span&gt;&lt;span class="n"&gt;はプラットフォーム依存でどんな結果を返すか分からないので、自前で&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`tanh`&lt;/span&gt;&lt;span class="n"&gt;を実装したい。自前&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`tanh`&lt;/span&gt;&lt;span class="n"&gt;は奥村先生の「標準アルゴリズム辞典」を参考にしようと思ったが、実装内部で&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`exp`&lt;/span&gt;&lt;span class="n"&gt;を使っているので結局プラットフォーム依存であることを免れない。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;やはりテイラー展開を使うしか&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;いや$0$近傍以外での誤差がやばいし。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;悩んだところ、&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`tanh`&lt;/span&gt;&lt;span class="n"&gt;の返す値が$1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;65536&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;approx&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.526&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;times&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="n"&gt;$より大きな誤差となるプラットフォームは少ないと考え、ナイーブに&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`tanh`&lt;/span&gt;&lt;span class="n"&gt;でテーブルを作ることにした。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n n-Quoted"&gt;`tanh`&lt;/span&gt;&lt;span class="n"&gt;の$&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;1$付近の誤差がでかいことに悩んでたら、&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`tanh`&lt;/span&gt;&lt;span class="n"&gt;ってそもそもシグモイド関数と同じように$&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;1$に漸近するするだけで通過しないことに気づいた。それじゃだめだ。変換関数を再検討。必ず$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;$を通るようにしたい。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;### 2018.12.4&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;悩んでいたら、良いページがあった&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;その19&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;補間関数あれこれ&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;marupeke296&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;TIPS_No19_interpolation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;html&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;結論、以下の曲線で決まり。$a$をパラメータとして、&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;$$&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;frac&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="k"&gt;left&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;frac&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nf"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nf"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;}\&lt;/span&gt;&lt;span class="n"&gt;frac&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nf"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;}{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nf"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;}\&lt;/span&gt;&lt;span class="k"&gt;right&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;\\&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;2t&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;2t&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;$$&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;20190929123351p&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;la_first_attempts&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;20190929123351.&lt;/span&gt;&lt;span class="n"&gt;png&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;aは3か4かなあ。→&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;1の近傍で32bit数値に差が出る3&lt;/span&gt;&lt;span class="mf"&gt;.0&lt;/span&gt;&lt;span class="n"&gt;を採用。極端だから2&lt;/span&gt;&lt;span class="mf"&gt;.0&lt;/span&gt;&lt;span class="n"&gt;に訂正。（2018&lt;/span&gt;&lt;span class="mf"&gt;.12.4&lt;/span&gt;&lt;span class="n"&gt;）&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;テーブル引きによる非線形変換を使うために、PARCOR係数の計算実装を見ているが、固定シフト&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`PARCOR_COEF_FIXED_SHIFT`&lt;/span&gt;&lt;span class="n"&gt;が15よりも大きいと戻らない現象を観察している。これは多分16bit値を15bitよりも大きく左シフトすると32bit値として表現できないから&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;フィルタ計算のときには64bit値で持つ必要があるかも。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;### 2018.12.4&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;係数シフト量&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`PARCOR_COEF_FIXED_SHIFT`&lt;/span&gt;&lt;span class="n"&gt;を大きくする修正。大きくして戻らなくなった原因はPARCOR係数の出力ビット数。今までは16bitで出していたが、それでは15bit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;符号1bit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;までしか記録できない。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;修正して様子を見たところ5分尺データの圧縮率が改善した。（逆に短いデータでは悪化）。これはPARCOR係数の精度改善とその保存コストのトレードオフだろう。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;非線形変換しようとしているが足踏み。テーブル引きにすることを考えると、&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`PARCOR_COEF_FIXED_SHIFT`&lt;/span&gt;&lt;span class="n"&gt;ビットサイズのテーブルを保存する必要がある&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;。31bitだと超巨大になる。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;これに対するアイデアは、16bitで記録するけど、テーブルによって32bit値に拡張（補完）するというもの。（非線形変換しないときは線形補間；単純な左シフト）だから記録に使うビット幅&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;16bit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;と計算時にシフトする量&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;31bit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;に違いが出る。というかこれしかいい方法がなさそうに見える。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;テーブル引きによる方法と、生の31bit保存でどちらが圧縮率が良いかは検証する必要がある。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;### 2018.12.5&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;非線形テーブル対応。効果あり。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n n-Quoted"&gt;`&lt;/span&gt;&lt;span class="n n-Quoted n-Quoted-Escape"&gt;``&lt;/span&gt;&lt;span class="n n-Quoted"&gt;:非線形テーブル&lt;/span&gt;
&lt;span class="n n-Quoted"&gt;-rw-r--r--@  1 *  staff     54344 Dec  6 00:05 kisaragi_chihaya.sol&lt;/span&gt;
&lt;span class="n n-Quoted"&gt;-rw-r--r--@  1 *  staff  33292840 Dec  6 00:07 SPARKLE.sol&lt;/span&gt;
&lt;span class="n n-Quoted"&gt;-rw-r--r--@  1 *  staff  42188584 Dec  6 00:05 one_two_sweets_offvocal.sol&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;早速単純な31bitシフト時と比較する。結果、非線形テーブルの方が良い結果：&lt;/p&gt;
&lt;p&gt;```:単純な31bitシフト
-rw-r--r--@  1 *  staff     54653 Dec  6 00:17 kisaragi_chihaya.sol
-rw-r--r--@  1 *  staff  33424610 Dec  6 00:16 SPARKLE.sol
-rw-r--r--@  1 *  staff  42335099 Dec  6 00:17 one_two_sweets_offvocal.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="s s-Atom"&gt;最初に算出されるPARCOR係数が&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;float&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;精度なのがまだ気になる。。→取り急ぎ&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;double&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;に変えたけどさしたる変化なし（それどころかSPARKLE&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;wavは1バイト増えた&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="s s-Atom"&gt;）。もしかして&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="s s-Atom"&gt;の&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;float&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;は情報が落ちないのか？でも、精度的には嘘がないので今後は&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;double&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;でいく。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;次はMS処理、もしくはランレングス？MS処理は劇的に効きそう。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2018.12.16&lt;/span&gt;

&lt;span class="s s-Atom"&gt;本日はMS処理を入れてみる。これで数MBは削れてほしい…。&lt;/span&gt;&lt;span class="nv"&gt;MS処理はブロック毎に変えることはしない&lt;/span&gt;&lt;span class="s s-Atom"&gt;。全体で同一の処理方式を取るようにする。ヘッダに修正が入る：&lt;/span&gt;

&lt;span class="s s-Atom"&gt;####&lt;/span&gt; &lt;span class="nv"&gt;SolAヘッダ&lt;/span&gt;

&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nf"&gt;サイズ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;内容&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;補足&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="s s-Atom"&gt;--:&lt;/span&gt;&lt;span class="p"&gt;|:-&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;|:-&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;シグネチャ&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;SolA&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;Soleil&lt;/span&gt; &lt;span class="nv"&gt;Aikatsuの略&lt;/span&gt;&lt;span class="s s-Atom"&gt;（Sound&lt;/span&gt; &lt;span class="s s-Atom"&gt;of&lt;/span&gt; &lt;span class="s s-Atom"&gt;lossless&lt;/span&gt; &lt;span class="nv"&gt;Audioの略&lt;/span&gt;&lt;span class="s s-Atom"&gt;）&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;一番最初のデータブロックまでのオフセット（自分除く）&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;240&lt;/span&gt;&lt;span class="s s-Atom"&gt;bit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="s s-Atom"&gt;byteSのはず&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;フォーマットバージョン番号&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;チャンネル数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;足りるでしょ…（怠慢）&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;全サンプル数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;足りるでしょ…（怠慢）&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;サンプリングレート&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;足りるでしょ…（怠慢）&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="s s-Atom"&gt;サンプルあたりのビット数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;wavへの復元で必要&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;PARCOR係数次数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;全ブロックで同一&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;チャンネル毎の処理方法&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;今は何もしないか、&lt;/span&gt;&lt;span class="nv"&gt;MS処理するかのどちらか&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;SolAブロック数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;SolAブロックあたりの最大サンプル数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;等ビットレート実現のため末尾以外は最大サンプル数に揃える。&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;ヘッダ以降のCRC32値&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;ヘッダのCRC32値（自分除く）&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt;

&lt;span class="s s-Atom"&gt;やった…が速報で結果が渋い…。ロスレスになったら結果をば…。&lt;/span&gt;
&lt;span class="s s-Atom"&gt;と思ったら元に戻らず、ハマる。間違いなくどこかでクリップしているのが原因だが、根本原因が追えず。これからピアノ。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2018.12.19&lt;/span&gt;

&lt;span class="nv"&gt;MSを使ったときに戻らない原因を調査&lt;/span&gt;&lt;span class="s s-Atom"&gt;。簡単なループのミスだった。。。（Sideが決まる前に出力計算していた）&lt;/span&gt;

&lt;span class="s s-Atom"&gt;ロスレスになったけどいかんせん**圧縮率が悪化**。理由はMidをL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nv"&gt;Rで作っているからでダイナミックレンジが広がって結果誤差増大につながったものと思われる&lt;/span&gt;&lt;span class="s s-Atom"&gt;。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;対応は、wavpackが如く、&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;Mid&lt;/span&gt;&lt;span class="s s-Atom"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;L&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;とする。これにより最下位1bitの情報が落ちるが、&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;Side&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;の結果から、&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;Side&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;の最下位1bitが&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;Mid&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;の最下位1bitと一致することを用いてもとに戻せる。次はこれを試す。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;後、高次のPARCOR係数も非線形量子化したい。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2018.12.22&lt;/span&gt;

&lt;span class="s s-Atom"&gt;秋葉原製作所なるところで作業してみる。&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="s s-Atom"&gt;時間で1250円。&lt;/span&gt;
&lt;span class="nv"&gt;MS処理をうまくやるのが今日の目標&lt;/span&gt;&lt;span class="s s-Atom"&gt;。&lt;/span&gt;

&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;M&lt;/span&gt;&lt;span class="s s-Atom"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;L&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;としたときにどうしても戻らなく、苦戦していた。flacのエンコーダソースを見ていたところ、全てをシフト演算でやりきっていたので真似をしたら何と元に戻った。**原因は除算による0方向の丸め**。&lt;/span&gt;

&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nn"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s s-Atom"&gt;flacエンコーダのMS処理&lt;/span&gt;
            &lt;span class="nf"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s s-Atom"&gt;encoder-&amp;gt;private_-&amp;gt;current_sample_number&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="s s-Atom"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="s s-Atom"&gt;blocksize&lt;/span&gt; &lt;span class="s s-Atom"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="s s-Atom"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="s s-Atom"&gt;samples&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="s s-Atom"&gt;i++&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;j++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="s s-Atom"&gt;encoder-&amp;gt;private_-&amp;gt;integer_signal&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s s-Atom"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s s-Atom"&gt;side&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s s-Atom"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;k++&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="s s-Atom"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s s-Atom"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;k++&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="s s-Atom"&gt;encoder-&amp;gt;private_-&amp;gt;integer_signal&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s s-Atom"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="s s-Atom"&gt;mid&lt;/span&gt; &lt;span class="s s-Atom"&gt;+=&lt;/span&gt; &lt;span class="s s-Atom"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="s s-Atom"&gt;side&lt;/span&gt; &lt;span class="s s-Atom"&gt;-=&lt;/span&gt; &lt;span class="s s-Atom"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="s s-Atom"&gt;mid&lt;/span&gt; &lt;span class="s s-Atom"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* NOTE: not the same as &amp;#39;mid = (left + right) / 2&amp;#39; ! */&lt;/span&gt;
                &lt;span class="s s-Atom"&gt;encoder-&amp;gt;private_-&amp;gt;integer_signal_mid_side&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s s-Atom"&gt;side&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="s s-Atom"&gt;encoder-&amp;gt;private_-&amp;gt;integer_signal_mid_side&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s s-Atom"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;NOTE:に注目。実例で行くと、&lt;code&gt;L=-741, R=322, M=L+R=-419&lt;/code&gt;のとき、&lt;code&gt;(L+R)/2=-209&lt;/code&gt;だが&lt;code&gt;(L+R)&amp;gt;&amp;gt;1=-210&lt;/code&gt;。&lt;code&gt;0xFFFFFE5D(-419) &amp;gt;&amp;gt; 1 = 0xFFFFFF2E(-210)&lt;/code&gt;となるから、下位1bitをSideから補えば元に戻る！&lt;/p&gt;
&lt;p&gt;特に著しいのは&lt;code&gt;L+R=-1&lt;/code&gt;のときで、&lt;code&gt;(-1&amp;gt;&amp;gt;1)=-1&lt;/code&gt;だから&lt;strong&gt;&lt;code&gt;M&lt;/code&gt;の符号の情報が飛ばないのがうまくいく理由。&lt;/strong&gt;単純な除算だと&lt;code&gt;(L+R)/2=0&lt;/code&gt;のときにMの符号が分からなくなってしまう。&lt;/p&gt;
&lt;p&gt;早速修正を取り入れる：&lt;/p&gt;
&lt;p&gt;```sh:MS処理追加
-rw-r--r--@  1 *  staff  41939426 Dec 22 18:02 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  32534982 Dec 22 18:04 SPARKLE.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;数百&lt;span class="n"&gt;KB単位の削減になった&lt;/span&gt;。

&lt;span class="c1"&gt;### 2018.12.27&lt;/span&gt;

ロスレス音声では&lt;span class="n"&gt;LSPが気になる&lt;/span&gt;。試すだけはしてみないと。

&lt;span class="c1"&gt;### 2019.1.2&lt;/span&gt;

実家で&lt;span class="n"&gt;LSP係数の計算を試している&lt;/span&gt;。と言っても理論抜きで&lt;span class="n"&gt;LPC係数からLSP係数に変換するのを試している&lt;/span&gt;。

&lt;span class="n"&gt;LSP係数は多項式P&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Qの根を求めることで得ている&lt;/span&gt;。ここでは&lt;span class="n"&gt;DFTした結果のゼロ点を探すことでLSP係数を求めている&lt;/span&gt;。

&lt;span class="n"&gt;LPC&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;LSPの相互変換はできた感じ&lt;/span&gt;。しかしワーク領域がでかい（&lt;span class="n"&gt;FFT使うから&lt;/span&gt;）ため、変換用ハンドルを新しく作った。

さて、これからやりたいことを列挙すると次のようになる：

 &lt;span class="o"&gt;-&lt;/span&gt; 窓を試す
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;LPC&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PARCOR係数を求める際に窓をかけてから処理を行う&lt;/span&gt;。
  &lt;span class="o"&gt;-&lt;/span&gt; 解析精度が上がることで誤差が減るかも。

 &lt;span class="o"&gt;-&lt;/span&gt; 高次係数も非線形量子化する

 &lt;span class="o"&gt;-&lt;/span&gt; ゴロム符号パラメータをサンプル単位で変える
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;wavpackではこちらの方式でやっている&lt;/span&gt;。試す価値はある。

 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;LSP係数で保存する&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;LSP係数は誤差の感度が低く&lt;/span&gt;、&lt;span class="n"&gt;PARCOR係数と比べて等ビットレートでより良い音質を実現しているとの報告がある&lt;/span&gt;。
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;LSPの前向き誤差計算は複雑なので却下&lt;/span&gt;。ここでは、&lt;span class="n"&gt;LSP係数&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;LPC係数の相互変換を使って&lt;/span&gt;、係数保存の際に&lt;span class="n"&gt;LSP係数を使用することを考える&lt;/span&gt;。

 &lt;span class="o"&gt;-&lt;/span&gt; 無音部でランレングス符号化を使う
  &lt;span class="o"&gt;-&lt;/span&gt; ゴロム符号のパラメータ計算のときに正値化した差分信号の平均を計算する。平均が&lt;span class="m"&gt;1&lt;/span&gt;より小さければ無音のはず。ランレングスで符号化する。
  &lt;span class="o"&gt;-&lt;/span&gt; 等ビットレート原則が崩れるかも&lt;span class="kc"&gt;...&lt;/span&gt;

 &lt;span class="o"&gt;-&lt;/span&gt; ロングターム（ピッチ情報）を使う
  &lt;span class="o"&gt;-&lt;/span&gt; ピッチ解析を行い、その長さによる予測符号化を行う。&lt;span class="n"&gt;MPEG4&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;LSで使われている手法&lt;/span&gt;。

&lt;span class="c1"&gt;### 2019.1.5&lt;/span&gt;

本日はいつもの海沿いベローチェで作業。窓掛けを試すのと、&lt;span class="n"&gt;LPCモジュールの出力一致確認をおこなうテストを追加したい&lt;/span&gt;。

窓掛け…簡単にハン窓で試したら効果あり！
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-rw-r--r--@  1 *  staff  41586969 Jan  5 15:38 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31990780 Jan  5 15:39 SPARKLE.sol
-rw-r--r--@  1 *  staff     54991 Jan  5 15:44 kisaragi_chihaya.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ブラックマン窓の結果は以下。ハン窓より軒並み悪い。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-rw-r--r--@  1 *  staff  41595943 Jan  5 15:49 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  32015488 Jan  5 15:50 SPARKLE.sol
-rw-r--r--@  1 *  staff     55317 Jan  5 15:50 kisaragi_chihaya.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;再び数百&lt;span class="nv"&gt;KBの削減&lt;/span&gt;（短い音声では増加&lt;span class="o"&gt;...&lt;/span&gt;）。結果をまとめると：&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;窓の種類&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;ワン・ツー・スウィーツ&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;SPARKLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;俺の声&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;|--:|--:|--:|--:|&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;矩形窓（窓なし）&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;41939426&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32534982&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;54345&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;ハン窓&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;41586969&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;31990780&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;54991&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;ブラックマン窓&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;41595943&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32015488&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;55317&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;サイン窓&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;41575639&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;31957294&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;54468&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Vorbis窓&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;41580579&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;31975238&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;54785&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

サイン窓を採用する。&lt;span class="nv"&gt;Princen&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Bradley条件&lt;/span&gt;（完全再構成条件）を満たす窓が良いのか？&lt;span class="w"&gt;&lt;/span&gt;

テスト書こうと思ったけど時間が中途半端（&lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;閉店で今&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;）。&lt;span class="nv"&gt;PARCORの高次係数の非線形量子化を検討する&lt;/span&gt;。&lt;span class="w"&gt;&lt;/span&gt;

単純には低次非線形量子化関数の逆関数でいいかなと思ったけど、非常に複雑になりそうだったから一旦やめて、単純な関数から見る。&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;ロジット関数：ロジスティックシグモイド関数の逆関数。&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;\&lt;span class="nf"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;\&lt;span class="nf"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)$&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

余談：その後プレエンファシスを試すも性能悪化。&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-rw-r--r--@  1 *  staff  47930310 Jan  5 22:49 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  36947366 Jan  5 22:54 SPARKLE.sol
-rw-r--r--@  1 *  staff     65086 Jan  5 22:59 kisaragi_chihaya.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;### 2019.1.8

高次成分の非線形量子化を試みる。変換曲線は、ロジット関数をベースに、必ず$(-1,-1), (1,1)$を通過する曲線を作る。作り方は、まず$2 * sigmoid(x) - 1$として値域を$(-1,1)$に制限してから、$sigmoid(1)$で割ることで$(-1,-1), (1,1)$を通過するようになる。この関数は$a$をパラメータ、$B=\frac{1 + \exp(-a)}{1 - \exp(-a)}$として、$y = B \frac{1 - \exp(-ax)}{1 + \exp(-ax)}$。これを$x$について解けば、得られた曲線式は、$y = \frac{1}{a} \left\{ \log(B + x) - \log(B - x) \right}$。

いろんな$a$に対してグラフを書いてみると：

![20190929123415p](./images/la_first_attempts/20190929123415.png)

a=4,5,6あたりが狙い目？ひとまず5で様子見。

### 2019.1.9

高次成分もロジット関数で非線形量子化したけど...効果が限りなく薄いどころか効率悪化も見られた...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-rw-r--r--@  1 *  staff  41575637 Jan 10 00:34 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31957302 Jan 10 00:34 SPARKLE.sol
-rw-r--r--@  1 *  staff     54469 Jan 10 00:35 kisaragi_chihaya.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;そもそも、高次成分も精度良く記録する方針が間違ってる？低次成分に多くのビットを割り当てた方が良い方針かも。一旦高次の非線形量子化は取り下げる。

### 2019.1.10

低次係数に32bitを割り当ててみる。...書いていて思ったが、そろそろ圧縮の検証（元に戻るか？+圧縮率計測）プログラムを作るべきかも。

32bitの結果...**悪化。**
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-rw-r--r--@  1 *  staff  41615559 Jan 10 23:02 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31993291 Jan 10 23:06 SPARKLE.sol
-rw-r--r--@  1 *  staff     54554 Jan 10 23:08 kisaragi_chihaya.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;厳しい&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;ビット割当の試作は一旦置いておく&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;ゴロム符号のパラメータをサンプル単位で切り替える対応をやってみる&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;更新式はwavpackのものをぱくって&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;以下のようにした&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nl"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;パラメータ更新&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;エンコード&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 各チャンネルごとにゴロム符号化 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_channels&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;golomb_param&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;golomb_m&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;res_code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_encode_samples&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;res_code&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SINT32_TO_UINT32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;residual&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="o"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;Golomb_PutCode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;golomb_param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;res_code&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res_code&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;golomb_param&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;golomb_param&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;golomb_param&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;127&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;golomb_param&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;golomb_param&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;126&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（wavpackでは、更に急激な誤差変動対策が入っている。連続した1は15個までしか続かないようになっている。それ以上はElias符号化する。）&lt;/p&gt;
&lt;p&gt;すると、やはりというか…性能改善。長い音源で500KBくらい減っているし、短い音源でも効果あり。
FLACとかMonkey's Audioの適応式も見てみたい。後少し気になったのが符号付き整数を符号なしに変換する式。偶数が正で奇数が負の式だけど、もしかしたら幾何分布に従ってないかもしれない。上手く変換すれば減りそう...というか、符号ビット+絶対値（負数は+1して符号反転すると◎。wavpackに書いてあった）の方が絶対値の頻度的に有利かも。&lt;/p&gt;
&lt;h3&gt;2019.1.11&lt;/h3&gt;
&lt;p&gt;ワン・ツー・スウィーツの1ch目の500000-550000サンプルにおける符号の頻度を調べてみた。&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123436p" src="./images/la_first_attempts/20190929123436.png" /&gt;&lt;/p&gt;
&lt;p&gt;青線は偶数を正、奇数を負とする変換、橙線は絶対値（負数は+1して符号反転）して得られた分布。橙が有利なのは以下の点で明らかだろう：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小さい値の頻度が高い&lt;/li&gt;
&lt;li&gt;より幾何分布に近い&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これに符号ビットを1bit付加しても、おそらく効率よく圧縮できるだろう。3連休はこれを試す。&lt;/p&gt;
&lt;p&gt;...やっつけで、符号1bit+絶対値でやってみたのだが、増加...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  41280406 Jan 12 00:28 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31399579 Jan 12 00:28 SPARKLE.sol
-rw-r--r--@  1 *  staff     53348 Jan 12 00:29 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;符号bitの1bitが馬鹿にならないかも。ワン・ツー・スウィーツは2x13641600=27283200サンプルあるが、全てに符号bitをつけると27283200bit = 3410400byte。約3.4MBが符号ビットになっているので、符号ビットの圧縮が次？2値符号化だからランレングスする？
符号ビットを抜いたら37870006バイトで整合性あり。&lt;/p&gt;
&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号ビットのランレングス？符号化&lt;/li&gt;
&lt;li&gt;上のグラフから分かると思うけど、絶対値のピークは0でないことがわかっている（→&lt;strong&gt;大嘘&lt;/strong&gt;。ヒストグラムの作り方を間違っていて0が抜けていた。0にピークがある。）。ピークを0にシフトして符号化する。シフトして負になる部分は別の符号を使う。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.1.12&lt;/h3&gt;
&lt;p&gt;符号ビットの圧縮を試す。ランレングス的に、符号の切り替わりのときだけ1を出力するようにしてみる。そうすることで確実に減る（減らないのは正負が交互に出るときだけ）。&lt;/p&gt;
&lt;p&gt;すると、flacを超え、当初の目的であるワン・ツー・スウィーツ40MBを切った。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  39463779 Jan 12 15:39 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  29681677 Jan 12 15:40 SPARKLE.sol
-rw-r--r--@  1 *  staff     50121 Jan 12 15:42 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;短い素材についてはMonkey's Audioを超えている。また、符号ビットはワン・ツー・スウィーツで1593773byteになっており半分以下になっている。&lt;/p&gt;
&lt;p&gt;復号ができればいけるが、ゴロム符号に上記のビット列を入れたときにどうするか...。ゴロム符号前半のunary符号部分で切り替わりを表現する？&lt;/p&gt;
&lt;p&gt;考えたが、どうやってもunary符号部分が不定な0の連続になっているので、切り替わりの1を挟む余地が無いことに気付いた。PackBits的にやらざるを得ない...やったら増えた。最大ランレングス長を3としたPackBitsでこんな感じ。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  42793987 Jan 12 17:50 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  32595117 Jan 12 17:50 SPARKLE.sol
-rw-r--r--@  1 *  staff     55704 Jan 12 17:49 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;うーん、厳しい。ゴロム符号のアレンジでなんとかならないか...&lt;/p&gt;
&lt;p&gt;困ってMonkey Audioのソースを見る...と、レンジコーダ使っていることに気づく。それじゃあデコードが遅いではないか...。&lt;/p&gt;
&lt;h3&gt;2019.1.13&lt;/h3&gt;
&lt;p&gt;wavpackの論文を読んだら以下の示唆があった。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中央値の更新式&lt;/li&gt;
&lt;li&gt;固定小数を使うことで平滑化し小さい値でのジャンプを防ぐ。&lt;/li&gt;
&lt;li&gt;今の中央値の更新式は最適か？検討が必要。&lt;/li&gt;
&lt;li&gt;Recursive Golomb Coding&lt;/li&gt;
&lt;li&gt;エンコード値のunary部が2より長い（現在の中央値を超えた）場合は、エンコード値から中央値を引いてこれを新しい中央値としてゴロム符号化する。新しい中央値も適応的に変える。&lt;/li&gt;
&lt;li&gt;これは減りそう...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Recursive Golomb Codingの手順：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;パラメータ配列&lt;code&gt;m[MAX_QUOT]&lt;/code&gt;を用意&lt;/li&gt;
&lt;li&gt;符号ビットを1bit出力&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abs &amp;lt;- 絶対値&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;quot &amp;lt;- abs / m&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;quot&lt;/code&gt;をunary符号出力&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for q 0 to MAX_QUOT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if (abs &amp;lt; m[q] or q &amp;gt;= MAX_QUOT) break&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abs &amp;lt;- abs - m[q]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;end for&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abs % m[quot]&lt;/code&gt;をゴロム符号と同様に出力&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt;の更新&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;中央値の更新式を固定小数化することで微減。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  41276050 Jan 14 00:23 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31390861 Jan 14 00:23 SPARKLE.sol
-rw-r--r--@  1 *  staff     53282 Jan 14 00:23 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;wavpackでは4bitを小数部に使っている。自分は12bitを割り当てている。4bitの方が追従が良く、よい結果を出している感触があるが、精度重視で12bitにしてみた。&lt;/p&gt;
&lt;p&gt;（記憶に行き違いがないか、念の為記録）符号bit+絶対値ではなく、偶数を正に、奇数を負に割り当てる方針で行くと、以下のように微増する：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  41349156 Jan 14 02:24 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31557247 Jan 14 02:26 SPARKLE.sol
-rw-r--r--@  1 *  staff     53354 Jan 14 02:26 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2019.1.14&lt;/h3&gt;
&lt;p&gt;符号ビットはランレングスで圧縮できそうだという信念の元、ランの長さをγ符号あたりで符号化することを検討中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://d.hatena.ne.jp/naoya/touch/20090804/1249380645"&gt;γ符号、δ符号、ゴロム符号による圧縮効果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;色々ガチャガチャやり始める前にランの長さの統計を取る。&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123450p" src="./images/la_first_attempts/20190929123450.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;これ、1/(2^x)と比較すれば分かるが、一様乱数列のランレングスでは...&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（ランの長さnは同一符号がn連続していることを示す。ランの長さ1は連続していないことを示す。）&lt;/p&gt;
&lt;p&gt;さらに平均ラン長を計算してみると…（長さ64以上のランは除外）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;入力音声&lt;/th&gt;
&lt;th align="right"&gt;平均ラン長&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;ワン・ツー・スウィーツ&lt;/td&gt;
&lt;td align="right"&gt;2.055&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;SPARKLE&lt;/td&gt;
&lt;td align="right"&gt;2.260&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;俺の声&lt;/td&gt;
&lt;td align="right"&gt;1.976&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;約2。これは何を意味するか...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.quora.com/How-do-you-evaluate-the-sum-of-n-2-n-from-n-1-to-infinity"&gt;級数の収束&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これによると、一様乱数列の平均に一致している…。&lt;/p&gt;
&lt;p&gt;γ符号の実装に2時間ほど持ってかれる...&lt;code&gt;GetBits&lt;/code&gt;の引数が64bitで型が合わずメモリ破壊を起こしていた。&lt;/p&gt;
&lt;p&gt;実装できてランレングスをγ符号で出すようにした。が、増加...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  41783849 Jan 14 17:41 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31753911 Jan 14 17:41 SPARKLE.sol
-rw-r--r--@  1 *  staff     54026 Jan 14 17:41 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;うむ、厳しい。いや、長すぎるランを出している可能性がある。その回避を打ってから次を考える。&lt;/p&gt;
&lt;p&gt;悲しくなってナイーブに符号ビット0,1の頻度を計測したら僅かながら&lt;strong&gt;偏りがあった。&lt;/strong&gt;
さらに2bitパターンにしたら更に&lt;strong&gt;偏りが大きくなった。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;早速8bitパターン化して頻度を見たところ、音源に依存せず現れないパターンを観測した。（どうしてその様なパターンが表れるのかは&lt;strong&gt;謎&lt;/strong&gt;。あとグラフは中心で&lt;strong&gt;対称&lt;/strong&gt;になっていないか？）&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123511" src="./images/la_first_attempts/20190929123511.png" /&gt;&lt;/p&gt;
&lt;p&gt;8bit使ったときのエントロピーは以下：&lt;/p&gt;
&lt;p&gt;| 音源 | 8bit符号ビットパターンのエントロピー | 
|--:|--:|--:|
| ワン・ツー・スウィーツ | 7.827755 |
| SPARKLE | 7.772168 |
| 俺の声 | 7.752156 |&lt;/p&gt;
&lt;p&gt;ハフマン等で上手く割り当てれば3%くらい減らせる余地がある。費用対効果的にきついか？これは最後の手段として取っておこう。先に、効果の有りそうなRecursive Golomb Codingに手を出す。&lt;/p&gt;
&lt;h3&gt;2019.1.15&lt;/h3&gt;
&lt;p&gt;Recursive Golomb Codingに実装着手。アルゴリズムを紙に書いて終わり。&lt;/p&gt;
&lt;h3&gt;2019.1.16&lt;/h3&gt;
&lt;p&gt;Recursive Golomb Codingのテストを書きながら実装中。大阪行きながら実装できるとベストだが…大阪で実装する余裕はあるだろうか。大阪にはルベグ積分だけ持っていこう。&lt;/p&gt;
&lt;h3&gt;2019.1.17&lt;/h3&gt;
&lt;p&gt;Recursive Golomb Coding実装...と行きたいけど寄り道。&lt;/p&gt;
&lt;p&gt;shotenの論文を読んでたら、ゴロム符号の商部分はアルファ符号よりもガンマ符号で出したほうが良いとの記述あり。早速試してみたがサイズ増加。ガンマ符号の実装が誤っている可能性がまだあるため、あとで再度検証したい。&lt;/p&gt;
&lt;p&gt;また、shotenではまず入力データから平均を差っ引くというのを見た。これはもしかしたらLPC解析時に効くかもしれないと思って、窓掛け前に平均除去を入れてみた。結果はさしたる変化なし。（増えるケースもあった）
念の為窓掛け後に平均除去を入れたら、窓掛け後のほうが性能が良かった。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;音源&lt;/th&gt;
&lt;th align="right"&gt;変更前&lt;/th&gt;
&lt;th align="right"&gt;窓掛け前に平均&lt;/th&gt;
&lt;th align="right"&gt;窓掛け後に平均&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;ワン・ツー・スウィーツ&lt;/td&gt;
&lt;td align="right"&gt;41276050&lt;/td&gt;
&lt;td align="right"&gt;41275937&lt;/td&gt;
&lt;td align="right"&gt;41275904&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;SPARKLE&lt;/td&gt;
&lt;td align="right"&gt;31390861&lt;/td&gt;
&lt;td align="right"&gt;31392892&lt;/td&gt;
&lt;td align="right"&gt;31391996&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;俺の声&lt;/td&gt;
&lt;td align="right"&gt;53282&lt;/td&gt;
&lt;td align="right"&gt;53283&lt;/td&gt;
&lt;td align="right"&gt;53282&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;FLACの実装を見ているとテューキー窓を使用していた。試す価値はあるかもしれない。&lt;/p&gt;
&lt;p&gt;次数を増やしたら1MB近くの減少が観測された。その際に自己相関計算時のバグが見られたので修正（float同士の乗算により精度が落ち、PARCOR係数の絶対値が1よりも大きくなった。もっと言うとwavからデータを取るときにdoubleにすべき。）。またブロックサイズを変更することでかなりのパフォーマンス差が見られた。…しかしこれらは最後の手段。高次のPARCOR係数の傾向を見ておくのは良いことかも。&lt;/p&gt;
&lt;p&gt;全く集中できなくてネットをウロウロしていたらexp-golomb符号（Elias-Teuhola符号）が目に止まった。H.264に使われているらしい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.hpl.hp.com/techreports/2006/HPL-2006-74.pdf"&gt;On the Determination of Optimal Parameterized Prefix Codes for Adaptive Entropy Coding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;中央値の逐次計算手法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.91.853&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Effective Computation of Biased Quantiles over Data Streams&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そして、依然として絶対値+符号ビットじゃなくて正を偶数、負を奇数に割り当てた方が圧縮率が良い...。一体どういうことだろうか。符号ビットも混ぜて符号化できるから効率が良い？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一旦立ち返って符号語の分布を見てみるべきかも。幾何分布の尤度を計算して当てはまりを見るのも良い。&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  41242708 Jan 18 01:05 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31367692 Jan 18 01:06 SPARKLE.sol
-rw-r--r--@  1 *  staff     53246 Jan 18 01:06 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最適なゴロム符号パラメータの決定法の資料があったぞ...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://l.web.umkc.edu/lizhu/teaching/2016sp.video-communication/notes/lec03.pdf"&gt;Lec 03 Entropy and Coding II Hoffman and Golomb Coding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2018.1.18&lt;/h3&gt;
&lt;p&gt;1時間ほど作業ができるので誤差分布の統計を取る。&lt;/p&gt;
&lt;p&gt;まずは符号語の分布。&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123528p" src="./images/la_first_attempts/20190929123528.png" /&gt;&lt;/p&gt;
&lt;p&gt;u2が正を偶数、奇を負とする符号語、absが絶対値…ってなんだこりゃ。&lt;strong&gt;正負で分布が違うように見えるのだが&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;正負が非対称になっている可能性があるので、誤差のヒストグラムをそのまま出したところ…&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123542p" src="./images/la_first_attempts/20190929123542.png" /&gt;&lt;/p&gt;
&lt;p&gt;0は最頻値（俺の声では最頻値すらずれている）だけど、平均がずれて存在している…？どういうこと？予測の間違い？&lt;/p&gt;
&lt;h3&gt;2018.1.20&lt;/h3&gt;
&lt;p&gt;秋葉原製作所。平均がずれているのはかなりクリティカルだと思っている。PARCOR係数の次数を変えて観察してみる。音源はSPARKLE（上のグラフで山がわかりやすかったから）&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123559p" src="./images/la_first_attempts/20190929123559.png" /&gt;&lt;/p&gt;
&lt;p&gt;0がピークであることは変わりない。次数を増やすと山が正側に動いていく。差分生成のときに引き残しが発生している？実装を調査。&lt;/p&gt;
&lt;p&gt;SPARKLEに対して整数版の関数を使用すると、確かに正にずれているのが確認できる。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;residual sum:107071606 count:24540160
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;というか、和が減る瞬間がない。。。次数10のときの誤差の和をグラフにすると、&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123617p" src="./images/la_first_attempts/20190929123617.png" /&gt;&lt;/p&gt;
&lt;p&gt;傾きを見れば分かるが、サンプル当り平均4の正の誤差が出ている。グラフを見るにどうもこれは音源に依存しないようだ。&lt;/p&gt;
&lt;p&gt;浮動小数点版の予測関数を使い、誤差の和と平均を取った。これでも正にずれている。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;residual sum:7.148294 sum(fix32):15350843823 count:24540160 mean:0.000000 mean(fix32):625
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;気になったのは係数の非線形量子化。非線形量子化して再度floatに戻すと誤差が出るのでは？と思い誤差の和を計測したら、誤差は正で（仕様。必ず大きい方に割り当てているから）和を取ると結構シャレにならない大きさになっていた。（SPARKLE, 次数10）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;err_sum&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;1.306255&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;01&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2分探索で無条件にtable[index] &amp;lt;= valを満たす値を割り振るのではなく、table[index+1]の方が近ければそちらを割り振るように修正したところ誤差値は改善（誤差分布にさしたる変化なし）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;err_sum&lt;/span&gt;&lt;span class="o"&gt;:-&lt;/span&gt;&lt;span class="mf"&gt;6.461394e-02&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根本的にズレを直すにはアルゴリズムを見直すしか無い？&lt;/p&gt;
&lt;p&gt;実装を次のように、係数の符号を反転して計算してみると山が反転...アルゴリズムに問題ありなのは間違いなさそう。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 前向き誤差計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;gamma&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;parcor_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gamma&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;coef_quantize_shift&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// mul_temp = (parcor_coef[ord] * backward_residual[ord - 1]) &amp;gt;&amp;gt; coef_quantize_shift;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// forward_residual[ord] = forward_residual[ord - 1] - mul_temp;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INT32_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INT32_MIN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 後ろ向き誤差計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;gamma&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;parcor_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gamma&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;coef_quantize_shift&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// mul_temp = (parcor_coef[ord] * forward_residual[ord - 1]) &amp;gt;&amp;gt; coef_quantize_shift;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// backward_residual[ord] = backward_residual[ord - 1] - mul_temp;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INT32_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INT32_MIN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="20190929123633p" src="./images/la_first_attempts/20190929123633.png" /&gt;&lt;/p&gt;
&lt;p&gt;入力データとしては16bit幅しか無いデータを入れているので、固定小数的に怪しい（小数部の余裕がない）と思い、入力データの左16bitシフトを入れた：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* 誤差計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;samp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;samp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;samp&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 格子型フィルタにデータ入力 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int64_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;samp&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 前向き誤差計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parcor_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;coef_quantize_shift&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INT32_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INT32_MIN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 後ろ向き誤差計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parcor_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;coef_quantize_shift&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INT32_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INT32_MIN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 後ろ向き誤差計算部にデータ入力 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int64_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;samp&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 残差信号 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INT32_MAX&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INT32_MIN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;samp&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;分布はほぼ対称になり、0の頻度が向上。が、&lt;strong&gt;裾の減衰が遅くなって音源依存で圧縮率が悪化した。&lt;/strong&gt;（SPARKLEは改善、ワン・ツー・スウィーツは悪化）&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123648p" src="./images/la_first_attempts/20190929123648.png" /&gt;&lt;/p&gt;
&lt;p&gt;固定小数の扱いがまずそう。丸めを忘れている：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.sage-p.com/compone/toda/fixdec.htm"&gt;固定小数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;丸めを入れたところ、山のピークは0に近づいた。微妙にサイズは増加。&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123701p" src="./images/la_first_attempts/20190929123701.png" /&gt;&lt;/p&gt;
&lt;p&gt;丸め+16bitシフトではSPARKLE、ワン・ツー・スウィーツ共に30KBほどサイズ減少。&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123717p" src="./images/la_first_attempts/20190929123717.png" /&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  41219742 Jan 21 01:23 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31336925 Jan 21 01:19 SPARKLE.sol
-rw-r--r--@  1 *  staff     53089 Jan 21 01:24 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;もう一度誤差平均を見てみよう。&lt;/p&gt;
&lt;h3&gt;2019.1.22&lt;/h3&gt;
&lt;p&gt;先輩社員のアドバイスにより、16bit左シフトは必須であることが分かった。小数点が揃わず意図しない計算になっていた。間違いをなくすために32bit固定小数点型を使うべきとも。&lt;/p&gt;
&lt;p&gt;今一度誤差平均を計算してみる。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;音源&lt;/th&gt;
&lt;th align="right"&gt;誤差平均&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;ワン・ツー・スウィーツ&lt;/td&gt;
&lt;td align="right"&gt;-0.455&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;SPARKLE&lt;/td&gt;
&lt;td align="right"&gt;-0.474&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;俺の声&lt;/td&gt;
&lt;td align="right"&gt;-0.442&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;2019.1.23&lt;/h3&gt;
&lt;p&gt;そして、整数版LPC予測合成関数で、データの固定小数ビット幅を可変にできるようにしているが、テストが失敗している…。修復には時間がかかりそう。&lt;/p&gt;
&lt;h3&gt;2019.1.24&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://xiph.org/flac/documentation_tools_flac.html#encoding_options"&gt;FLACのエンコーディングオプション&lt;/a&gt;を見ると-rでライス符号の分割数を決めている。これはwavpackの再帰的ゴロムと同義では？&lt;/p&gt;
&lt;p&gt;帰りが遅くなり何も手が付かない…昨日との落差がありすぎてつらい…。&lt;/p&gt;
&lt;p&gt;で、気付いたのだけど32bit整数だと最大&lt;code&gt;INT32_MAX - INT32_MIN&lt;/code&gt;の誤差が出るはずで、それは32bit整数では表現できない。だから、表現する固定小数ビット数を30bitに、整数ビット数を2bitに妥協することにした。&lt;/p&gt;
&lt;h3&gt;2019.1.26&lt;/h3&gt;
&lt;p&gt;ピアノもコーデックも進まなかったが、ようやく自由になる。&lt;/p&gt;
&lt;p&gt;LPCのライス符号の分割は、網羅探索のことだった。指定した最小分割数から最大分割数でライス符号パラメータを変更してエンコードし、最もサイズが小さくなった分割を採用する、というもの。エンコード速度は犠牲になるけど、確かにデコード速度は早くなる発想だわ…。&lt;/p&gt;
&lt;h3&gt;2019.1.27&lt;/h3&gt;
&lt;p&gt;秋葉原製作所5時間コース。なんとしても今日で直す。
なんとなく起きていることは分かった。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;No.&lt;/th&gt;
&lt;th align="center"&gt;データbit(整数部, 固定小数部)&lt;/th&gt;
&lt;th align="center"&gt;得られた誤差の右シフト量&lt;/th&gt;
&lt;th align="center"&gt;係数bit(整数部, 固定小数部)&lt;/th&gt;
&lt;th align="center"&gt;結果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;①&lt;/td&gt;
&lt;td align="center"&gt;(1,31)&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;(1,31)&lt;/td&gt;
&lt;td align="center"&gt;NG。フィルタ値が[-1.0, 1.0]を超えるケースがある&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;②&lt;/td&gt;
&lt;td align="center"&gt;(1,31) &amp;gt;&amp;gt; (32-データのビット幅)&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;(1,31)&lt;/td&gt;
&lt;td align="center"&gt;OK。元に戻る&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;③&lt;/td&gt;
&lt;td align="center"&gt;(1,31) &amp;gt;&amp;gt; (31-データのビット幅)&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;(1,31)&lt;/td&gt;
&lt;td align="center"&gt;OK。元に戻る&lt;strong&gt;が、圧縮率が悪い&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;④&lt;/td&gt;
&lt;td align="center"&gt;(1,31) &amp;gt;&amp;gt; (31-データのビット幅)&lt;/td&gt;
&lt;td align="center"&gt;1&lt;/td&gt;
&lt;td align="center"&gt;(1,31)&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;NG。&lt;/strong&gt;②より圧縮率良いが、誤差の最下位ビットが吹っ飛ぶので元に戻らない&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;⑤&lt;/td&gt;
&lt;td align="center"&gt;(1,31) &amp;gt;&amp;gt; (33-データのビット幅)&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;(1,31)&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;NG。&lt;/strong&gt;④よりさらに圧縮率が良いが、データ側の最下位ビットが吹っ飛ぶので元に戻らない&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;これらの結果より、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;誤差のbit数は入力データのbit吸うと同一である必要がある。&lt;/li&gt;
&lt;li&gt;誤差を右シフトすると情報が失われる。左シフトすると無駄な情報が増える。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ことが分かるし、②以外の形態にするのは無しという方針で。また、2019.1.20の計算中の左シフトも、誤差記録時に右シフトしたときに情報が失われて、デコード結果が元に戻らないから採用できない。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;でも結局誤差分布の偏りは解消されない…。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有力なヒントは、PARCOR係数の符号を反転させると山が反転することだろう。アルゴリズム内になにかの原因があるはず。
→原因が見えてきた。今の演算では32bit精度が求められる状態になっているのでは。32bitの最下位桁のずれがダイレクトに誤差になっている。&lt;/p&gt;
&lt;p&gt;また、色々試していて非線形量子化が原因かと思って非線形量子化をやめてみたら、誤差の分布があまり変わらず、しかもなぜか圧縮率が向上した…そんな馬鹿な…。1MB程度の差が出るはずなのに。。。&lt;/p&gt;
&lt;p&gt;これで5時間タイムアップ。今の作業項目をまとめるとこんな感じ：&lt;/p&gt;
&lt;p&gt;直近のTODO:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;誤差の分布が非対称になる現象の調査&lt;/li&gt;
&lt;li&gt;非線形量子化が効いていない原因の調査&lt;/li&gt;
&lt;li&gt;ゴロム符号を再帰的にする&lt;/li&gt;
&lt;li&gt;ゴロム符号のパラメータ決定を変更。→統計論的に最適な &lt;span class="math"&gt;\(\log_{e} 2 E[|res|]\)&lt;/span&gt; を使う。&lt;/li&gt;
&lt;li&gt;テューキー窓の使用&lt;/li&gt;
&lt;li&gt;無音部でランレングス符号化を使う&lt;/li&gt;
&lt;li&gt;ゴロム符号のパラメータ計算のときに正値化した差分信号の平均を計算する。平均が1より小さければ無音のはず。ランレングスで符号化する。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等ビットレート原則が崩れるかも...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ロングターム（ピッチ情報）を使う&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ピッチ解析を行い、その長さによる予測符号化を行う。MPEG4-LSで使われている手法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;帰って、誤差分布のズレがどうしても諦められず追っていた。積和の途中でビット幅を広げるのを試したけど、結局、誤差を右シフトする必要があって情報が落ちてしまう。&lt;/p&gt;
&lt;p&gt;で、今は前向き誤差を出すときに減算を重ねた結果正のオフセットが出ていることから、じゃあ丸め分大きくしてやるぜで試したら&lt;strong&gt;誤差分布が対称になった。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;```c:変更前
    /&lt;em&gt; 前向き誤差計算 &lt;/em&gt;/
    for (ord = 1; ord &amp;lt;= order; ord++) {
      mul_temp = (parcor_coef[ord] * backward_residual[ord - 1]) &amp;gt;&amp;gt; 31;
      forward_residual[ord] = forward_residual[ord - 1] - mul_temp;
    }&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nl"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;変更後&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 前向き誤差計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;order&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;parcor_coef&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord - 1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;UL&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cm"&gt;/* 丸めhalf */&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;forward_residual&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord - 1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;これが根本原因なのかはまだ分からない…。結果は以下でちゃんと戻ることは確認済み。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  41216562 Jan 28 01:05 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31339500 Jan 28 01:06 SPARKLE.sol
-rw-r--r--@  1 *  staff     53097 Jan 28 01:05 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;分布はこんな感じで、概形としては理想と考えられる。&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123732p" src="./images/la_first_attempts/20190929123732.png" /&gt;&lt;/p&gt;
&lt;h3&gt;2019.1.28&lt;/h3&gt;
&lt;p&gt;何故丸めが必要なのか。以下のサイトでは0.5足してからFIRの積和演算をしている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://sestevenson.wordpress.com/implementation-of-fir-filtering-in-c-part-2/"&gt;Implementation of FIR Filtering in C (Part 2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;丸めはどうも加算する方向しかだめなようだ。丸めには色々方法があるらしいが、今回の原因となっていていたのは、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://sestevenson.wordpress.com/rounding-in-fixed-point-number-conversions/"&gt;Rounding in Fixed Point Number Conversions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の、&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;truncate(1.25) = 0x0001 = 1&lt;/p&gt;
&lt;p&gt;truncate(1.5) = 0x0001 = 1&lt;/p&gt;
&lt;p&gt;truncate(1.75) = 0x0001 = 1&lt;/p&gt;
&lt;p&gt;truncate(-1.25) = 0xFFFE = -2&lt;/p&gt;
&lt;p&gt;truncate(-1.5) = 0xFFFE = -2&lt;/p&gt;
&lt;p&gt;truncate(-1.75) = 0xFFFE = -2&lt;/p&gt;
&lt;p&gt;For the positive numbers, the result of truncation is that the fractional part is discarded. The negative number results are more interesting. The result is that the fractional part is lost, and the integer part has been reduced by one. If a series of these numbers had a mean of zero before truncation, then the series would have a mean of less than zero after truncation. Rounding is used to avoid this problem of introduced bias and to make results more accurate.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;にあるように、どうも負方向に寄ってしまうのが原因らしい(-1.5の例を注目）。特に3と-3を小数部を2bitとして2bitシフトしてみると、&lt;code&gt;3&amp;gt;&amp;gt;2=0&lt;/code&gt;に対して&lt;code&gt;-3&amp;gt;&amp;gt;2=-1&lt;/code&gt;。だから右シフトでは-1のオフセットが乗ってしまう。だから小数部で加算することで精度を上げることができていたと想像する。3,-3の場合だと1を加算することになるから、&lt;code&gt;(3+1)&amp;gt;&amp;gt;2=1&lt;/code&gt;、&lt;code&gt;(-3+1)&amp;gt;&amp;gt;2=-1&lt;/code&gt;だから精度が上がっている。&lt;/p&gt;
&lt;p&gt;良い窓関数を探そうとして会社の『音声のディジタル信号処理（下）』を読んでいたら、格子型フィルタのより効率的な構成が見つかった。何でも乗算回数がN回（今2N回）で済むらしい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.quora.com/What-is-the-application-of-Lattice-structure-for-digital-filters-I-find-lattice-in-a-lot-of-books-but-none-of-them-explains-why-it-is-important"&gt;質問サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://zone.ni.com/reference/en-XX/help/371325F-01/lvdfdtconcepts/lattice_allpass/"&gt;Lattice Allpass Structures (Digital Filter Design Toolkit)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cas.tudelft.nl/Education/courses/ee2s31/slides/DSP9.pdf"&gt;Filter realizations: lattice filter structures&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;頭にいれるだけ入れておく。&lt;/p&gt;
&lt;h3&gt;2019.1.29&lt;/h3&gt;
&lt;p&gt;窓関数をテューキー窓に置き換える前に資料を覗く。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://org-technology.com/posts/scipy-window-function.html"&gt;SciPy で使用可能な窓関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://community.plm.automation.siemens.com/t5/Testing-Knowledge-Base/Window-Types-Hanning-Flattop-Uniform-Tukey-and-Exponential/ta-p/445063"&gt;Window Types: Hanning, Flattop, Uniform, Tukey, and Exponential&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Window_function#Tukey_window"&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要はテューキー窓は矩形窓に近く、過渡的な信号に強いようだ。&lt;/p&gt;
&lt;p&gt;早速0.5を設定して試してみる。うーん。ワン・ツー・スイーツ以外ではサイン窓の方が性能が良い。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  41214648 Jan 29 22:15 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31342212 Jan 29 22:16 SPARKLE.sol
-rw-r--r--@  1 *  staff     53141 Jan 29 22:14 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ゴロム符号のパラメータを log_{e}2E[|res|] に変えてみると、悪化。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  41258145 Jan 29 22:53 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31420823 Jan 29 22:54 SPARKLE.sol
-rw-r--r--@  1 *  staff     53145 Jan 29 22:54 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="https://ipnpr.jpl.nasa.gov/progress_report/42-159/159E.pdf"&gt;今の手法&lt;/a&gt;の方が良かった。&lt;/p&gt;
&lt;p&gt;また、改めて符号1bit+絶対値符号すると性能が悪化する。何故？符号bitは実は冗長？&lt;/p&gt;
&lt;p&gt;小手先のアイデアは通用しなさそう。さて、再帰的ゴロムの実装に戻ろう。&lt;/p&gt;
&lt;h3&gt;2019.1.30&lt;/h3&gt;
&lt;p&gt;FLACのソースを読んでたらLPC乗算時の右シフトは、積和演算の後に行われていた。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* Here&amp;#39;s a slower but clearer version:&lt;/span&gt;
&lt;span class="cm"&gt;    for(i = 0; i &amp;lt; data_len; i++) {&lt;/span&gt;
&lt;span class="cm"&gt;        sum = 0;&lt;/span&gt;
&lt;span class="cm"&gt;        for(j = 0; j &amp;lt; order; j++)&lt;/span&gt;
&lt;span class="cm"&gt;            sum += qlp_coeff[j] * data[i-j-1];&lt;/span&gt;
&lt;span class="cm"&gt;        residual[i] = data[i] - (sum &amp;gt;&amp;gt; lp_quantization);&lt;/span&gt;
&lt;span class="cm"&gt;    }&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最後に右シフトするので精度が高いはず。
これはLPCが予測誤差算出と復号を同一のアルゴリズムできるから？PARCORでできない理由があるだろうか。
また個人的には非線形量子化があんまり効いていないように見えるのが引っかかっている。&lt;/p&gt;
&lt;h3&gt;2019.1.31&lt;/h3&gt;
&lt;p&gt;再帰的ゴロムの実装。テスト追加しながらやっている。まだ実装途中だが、時間があれなので練る。&lt;/p&gt;
&lt;h3&gt;2019.2.1&lt;/h3&gt;
&lt;p&gt;中央値mはE[|X-m|]を最小化することが知られている。適応的に求められないか？
LMSは適応的に求められる手法が良く知られているが、絶対値はそうはいかない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Least_absolute_deviations"&gt;Least absolute deviations - Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.2.16&lt;/h3&gt;
&lt;p&gt;再帰的ゴロムが何となく動き始めている。次のように符号を割り当てると考えたらうまく行った：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;値域&lt;/th&gt;
&lt;th align="center"&gt;符号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;0 &amp;lt;= val &amp;lt; m&lt;/td&gt;
&lt;td align="center"&gt;1  (val % m)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;m &amp;lt;= val &amp;lt; m + m'&lt;/td&gt;
&lt;td align="center"&gt;01 ((val - m) % m')&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;m + m' &amp;lt;= val&lt;/td&gt;
&lt;td align="center"&gt;001 (((val - (m + m')) をパラメータ(m + m')でゴロム符号出力)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;パラメータの変動を見ていたら、現在値より大きいか小さいかだけで更新値を決めるので追従が遅い。&lt;/p&gt;
&lt;p&gt;やっぱり中央値の逐次修正を改善したい。幾何分布の性質に注目すると、p&amp;gt;=0.5では、必ず平均値が中央値よりも小さくなる結果が見えている。下限を平均値、上限を平均+分散の平方根として、どうにか逐次推定できないか？&lt;/p&gt;
&lt;h3&gt;2019.2.17&lt;/h3&gt;
&lt;p&gt;再帰的ゴロム符号にテスト追加。また、符号割当をループの形で書き直す。
→OK。良好に動いている。で、パラメータを増やしていくと、増やしただけ良くなっていく傾向が見られる。（当然、大きすぎる値は増加に転じる）&lt;/p&gt;
&lt;p&gt;さっそく再帰的ゴロム符号を組み込んだが…結果悪化…。まだ整理しきれてない・あがける部分はありそうなので、一週間粘ってみる。&lt;/p&gt;
&lt;h3&gt;2019.2.18&lt;/h3&gt;
&lt;p&gt;再帰的ゴロム符号の実装を修正。修正前は全パラメータの和に達したらパラメータ和のゴロム符号をしていたが、そうではなく、末尾のパラメータを使用してゴロム符号化するようにした。&lt;/p&gt;
&lt;p&gt;それでパラメータ段数を8にしたら、全体的に減少。長い音声では百KBオーダーで減少が見られた。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  41085053 Feb 20 02:05 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31287228 Feb 20 02:09 SPARKLE.sol
-rw-r--r--@  1 *  staff     53068 Feb 20 02:10 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;まだ改良点がある。パラメータ数で剰余部のアルファ符号は打ち切りができるはず。他にもパラメータ初期値のとり方でだいぶ性能が違っていた。また、パラメータ末尾で符号化するときには、ゴロム符号を使わず、その場で商を計算してアルファ符号化すべきかも。&lt;/p&gt;
&lt;h3&gt;2019.2.20&lt;/h3&gt;
&lt;p&gt;再帰的ゴロム符号の改良に取り掛かる。末尾パラメータ符号化の際に1bit減らした。長い音声では十KBオーダーで減少。&lt;/p&gt;
&lt;p&gt;パラメータは末尾の利を活かすべく（というか今まで損していた）少なめの3つとしている。パラメータ初期値でだいぶパフォーマンスが異なるのが気になる…。更新式も再考の余地がありそう。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  41032143 Feb 21 00:19 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31245120 Feb 21 00:21 SPARKLE.sol
-rw-r--r--@  1 *  staff     52997 Feb 21 00:22 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;後、確実に減らせるのはランレングス分。&lt;/p&gt;
&lt;h3&gt;2019.2.21&lt;/h3&gt;
&lt;p&gt;パラメータが小さければランレングス符号化するように修正。当然減る。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  41006713 Feb 22 00:56 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31233963 Feb 22 00:56 SPARKLE.sol
-rw-r--r--@  1 *  staff     52997 Feb 22 00:56 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;減らすアイデアあり。末尾のパラメータで符号化するときに、商部分が大きくなりすぎることがある（32より大きいものがたくさん出てきた。アルファ符号を使うからかなりのロス）から、長過ぎる商はガンマ符号化する。（wavpackと同じアイデア）
あと、PARCOR係数最初の1つ目は1.0fなのに符号化しているのがもったいない。2つ目以降を符号化するように修正したい。&lt;/p&gt;
&lt;h3&gt;2019.2.24&lt;/h3&gt;
&lt;p&gt;圧縮も佳境だ。
まずは、商部分が長すぎる場合はガンマ符号を使う修正。長い音源で十KBオーダーで減少。wavpackに倣って商が16以上ならばガンマ符号化している。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  40967452 Feb 24 14:19 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31133035 Feb 24 14:26 SPARKLE.sol
-rw-r--r--@  1 *  staff     52962 Feb 24 14:27 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;さらに、係数先頭が0であるからそれを保存しないようにして、係数先頭1つ分の保存を省いた。微減。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  40954128 Feb 24 15:10 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31121051 Feb 24 15:11 SPARKLE.sol
-rw-r--r--@  1 *  staff     52934 Feb 24 15:10 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;あと、桜川駅から大阪港までバスで行く途中で思いついたけど、自己相関の計算で情報落ちが起きているから、それを軽減するように修正しよう。→確かに情報落ちは起きていたけど、積み残しは10^-16程度で圧縮率改善には至らず。&lt;/p&gt;
&lt;p&gt;また、LSPで係数保存してLPCで予測・合成すれば、計算負荷は低く、かつ精度良くやれそう。これは次世代バージョンでのアイデア。&lt;/p&gt;
&lt;h3&gt;2019.2.26&lt;/h3&gt;
&lt;p&gt;PARCOR係数の不均一なビット割当てを試そう。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非線形量子化は切ったほうが性能が高いことが分かっている。&lt;/strong&gt;この機会に非線形量子化を廃止した。&lt;/p&gt;
&lt;p&gt;非線形量子化を切った結果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  40954119 Feb 26 23:12 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31121021 Feb 26 23:13 SPARKLE.sol
-rw-r--r--@  1 *  staff     52936 Feb 26 23:09 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不均一なビット割当てをやってみた。減る。係数ビットは増やすことで予測精度向上を狙うのではなく、ビット数を減らして係数ビットの領域を減らす意図でいくと良い感じ（体感16bitよりも大きいビットでは、予測精度が向上するメリットよりもビット数を増やすことによるデメリットの方が大きくなる）。以下の結果は、4次成分まで16bit, それ以降を8bit割り当ててている。また、double-&amp;gt;int32_tの際ににroundを使用したら結果が改善したことを注記しておく。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  40907480 Feb 27 00:16 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31079276 Feb 27 00:17 SPARKLE.sol
-rw-r--r--@  1 *  staff     52832 Feb 27 00:15 kisaragi_chihaya.sol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;残りの策は…ロングタームか。
後、格子型フィルタの計算負荷をアルゴリズム的に少しでも下げたい。1乗算型を実装したい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.ee.ic.ac.uk/hp/staff/dmb/courses/dspdf/01000_structures.pdf"&gt;10: Digital Filter Structures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.ece.ucsb.edu/Faculty/Rabiner/ece259/digital%20speech%20processing%20course/lectures_new/Lecture%2014_winter_2012_6tp.pdf"&gt;Digital Speech Processing - Lecture 14 Linear Predictive Coding (LPC)-Lattice Methods, Applications&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;共分散法もやろうかと考えたけど、&lt;a href="http://www.ee.imperial.ac.uk/naylor/notes/5_lpc.pdf"&gt;ここ&lt;/a&gt; によると、共分散では不安定になることがあり、またPARCOR係数を求めることができない。&lt;/p&gt;
&lt;h3&gt;2019.3.2&lt;/h3&gt;
&lt;p&gt;秋葉原製作所。ロングタームの実装に手を出す。まずはピッチ予測を試す。残差信号の自己相関（もしくは相互相関）を計算してargmaxを取得し、それをピッチとする。&lt;/p&gt;
&lt;p&gt;自己相関の計算にはパワースペクトルを使用する（ウィーナー・ヒンチン）。ピッチ検出のやり方はよーく知られている &lt;a href="https://qiita.com/programanx1/items/096c68fa935addc1f121"&gt;この手法&lt;/a&gt;。
かなーり適当にピッチ検出を作ったけど、それなりの結果が出ている。&lt;/p&gt;
&lt;h3&gt;2019.3.3&lt;/h3&gt;
&lt;p&gt;ピッチ解析結果からロングターム予測を試してみる。そして、元の誤差から減少するのかどうか簡単に検証してみた…結果は、なんと減ったよ。。。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ロングタームを使用しない場合に比べて、ロングターム予測（1タップ）を使用した場合は誤差のRMS値がほぼすべてのフレームで減少。（増えてしまったフレームは1,2ほどしかない）&lt;/li&gt;
&lt;li&gt;RMS値は音源依存で減少。SPARKLEはRMS値で5、ワン・ツー・スゥイーツは15、俺の声は2減るという結果。それすなわち、1サンプルあたり平均でそれだけ誤差が減っているということ…？当然かも知れないけど、凄いのでは？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この検証結果から、ロングタームを採用する方針に動きたい。減るのは間違いなさそうだ。&lt;/p&gt;
&lt;p&gt;MPEG-4 ALSのエンコーダを入手した。&lt;a href="https://www.nue.tu-berlin.de/menue/research/research_topic/compression_and_transmission/mpeg_4_audio_lossless_coding_als/parameter/en/#c230252"&gt;ここ&lt;/a&gt; からexeが手に入る。
圧縮率はFLACより良くて、Monkey's Audioよりは悪いくらい。（最大圧縮-7でもMonkey's Audioのinsameより悪いし実行時間が長すぎる。高圧縮にするときはギルバート・ムーア（算術）符号使っているのではなかったのか？）&lt;/p&gt;
&lt;h3&gt;2019.3.5&lt;/h3&gt;
&lt;p&gt;LPCモジュールにロングタームを追加する。処理自体は大体まとまっているから、APIをがっちり固めて、単体でテストできるようにする。&lt;/p&gt;
&lt;p&gt;```c:API案
/&lt;em&gt; ロングタームの最大タップ数 &lt;/em&gt;/&lt;/p&gt;
&lt;h1&gt;define LPC_LONGTERM_MAX_NUM_TAP (5)&lt;/h1&gt;
&lt;p&gt;/&lt;em&gt; ロングターム計算ハンドル &lt;/em&gt;/
struct LPCLongTermCalculator;&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; ピッチ解析結果（内部） &lt;/em&gt;/
struct LPCLongTermPitchCalculationResult {
    uint32_t    pitch_num_samples;                          /&lt;em&gt; ピッチに該当するサンプル数 &lt;/em&gt;/
    double      ltm_coef[LPCLONGTERM_MAX_NUM_TAP];          /&lt;em&gt; ロングターム係数 &lt;/em&gt;/
    double      head_acf[LPCLONGTERM_MAX_NUM_TAP];          /&lt;em&gt; 自己相関の先頭からの並び &lt;/em&gt;/
    double      around_pitch_acf[LPCLONGTERM_MAX_NUM_TAP];  /&lt;em&gt; ピッチ周辺の自己相関。タップ数0ならば先頭にピッチの自己相関、3ならば-1,0,1、5ならば-2,-1,0,-1,2が並ぶ &lt;/em&gt;/
};&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; ロングターム計算ハンドルの作成 &lt;/em&gt;/
struct LPCLongTermCalculator* LPCLongTermCalculator_Create(uint32_t fft_size);&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; ロングターム計算ハンドルの破棄 &lt;/em&gt;/
void LPCLongTermCalculator_Destroy(struct LPCLongTermCalculator* ltm_calculator);&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; ロングターム係数の計算（内部的にピッチ解析が走る） &lt;/em&gt;/
LPCApiResult LPCLongTermCalculator_CalculateLongTermCoefficients(
    struct LPCLongTermCalculator&lt;em&gt; ltm_calculator,
    const int32_t&lt;/em&gt; data, uint32_t num_samples,
    uint32_t&lt;em&gt; pitch_num_samples, double&lt;/em&gt; ltm_coef, uint32_t num_taps);&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 残差信号の計算 &lt;/em&gt;/
LPCApiResult LPCLongTerm_PredictInt32(
    const int32_t&lt;em&gt; data, uint32_t num_samples,
    uint32_t pitch_num_samples, 
    const LPCFixedFloat1_31&lt;/em&gt; ltm_coef, uint32_t num_taps, int32_t* residual);&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 残差信号から音声合成 &lt;/em&gt;/
LPCApiResult LPCLongTerm_SynthesizeInt32(
    const int32_t&lt;em&gt; residual, uint32_t num_samples,
    uint32_t pitch_num_samples,
    const LPCFixedFloat1_31&lt;/em&gt; ltm_coef, uint32_t num_taps, int32_t* output);&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;### 2019.3.6

上記API案に従って、既存の実験的実装を関数化。テストを作って、週末辺りに組み込みたい。

### 2019.3.8

秋葉原製作所で2hほど作業。

ロングタームは自己相関に基づいてやってるけど、よく見なくても、低次の自己相関値の方が大きくないか。最悪、直前の値で予測してもまだ減るんじゃないかと思っている。要自己相関確認。

### 2019.3.9

秋葉原製作所5hコース。意外に人がおる。

ロングタームのテストを作りきって元に戻ることを確認次第、組み込む。
2hほど作業して自己相関のピーク検知を微修正。はよ予測合成テストに入らんと…。
→17:40予測までOKぽい。組み込む。

フォーマットに変化もある点に注意。

急ぎ実装で軽く試したら、微妙。というか長い音声ではガッツリ悪化。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-rw-r--r--@  1 *  staff  41123054 Mar  9 19:22 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31461853 Mar  9 19:20 SPARKLE.sol
-rw-r--r--@  1 *  staff     52811 Mar  9 19:22 kisaragi_chihaya.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ピッチ周期を見ていると短い結果（10未満）があまりにも多い。短いピッチは有用な結果ではないとして切り捨てるのが良いか？（俺の声はピッチ周期10以上が多かった。）

そこで、以下の修正を取り込んだ所、安定して減るようになった。

 - 短いピッチを切り捨て
  - 3以上の周期を採用するように変えたら良くなった。
  - 2以下だと悲惨。
 - 「最大の自己相関値から何割以上の自己相関値をピッチとするか」をやめ、単純に最大の自己相関を与えるラグを採用する

あと、自己相関値自体も判定材料にできそう。

ひとまず、上記の修正を取り込んだところの結果を見ると、
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-rw-r--r--@  1 *  staff  40862203 Mar 10 01:16 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31056950 Mar 10 01:17 SPARKLE.sol
-rw-r--r--@  1 *  staff     52810 Mar 10 01:17 kisaragi_chihaya.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nt"&gt;もう少し試行したら&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="nt"&gt;実装をまとめ始めてもいいかな&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="nt"&gt;3月中にα版がまとめられると良い&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;###&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;2019&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;10&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nt"&gt;再度秋葉原製作所&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="nt"&gt;今日で圧縮率改善の試みに一旦ケリを付けておく&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="nt"&gt;並びに&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="nt"&gt;オンメモリ書き出し対応時に必要な変更点についてまとめていきたい&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nt"&gt;日記を見返してみたが&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="nt"&gt;当初の圧縮率改善の試みはほぼ消化できているようだ&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="nt"&gt;LSPを試すという点が残っているが&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="nt"&gt;以下の点で見送る予定&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;フィルタ計算がPARCORに増して複雑&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;LSPで保存してLPCで計算する方法は以下の難点がある&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;フィルタ計算時に変換時のLPC係数に応じて量子化が必要&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="nt"&gt;複雑になる&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;そうして得られたLPC係数は&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="nt"&gt;結局指定次数で得られたLPC係数と変わらないのでは&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nt"&gt;FLACと同程度にしかならない&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nt"&gt;だから&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="nt"&gt;PARCOR係数の格子状フィルタで戦うのが正攻法だと考えている&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nt"&gt;---&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;####&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;オンメモリ書き出しへの変更点要点&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;ソースは独立して切る&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="nt"&gt;新規に書き起こす&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="nt"&gt;無駄な部分を消す&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;バージョンは5&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;再度バイナリフォーマットを考察&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;ブロックサンプル数等&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="nt"&gt;1部フィールドのサイズ見直し&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;エンコードパラメータの整理&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;プリセットを作成&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;低圧縮率でデコード早い&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;高圧縮率でデコード遅い&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;シグネチャを&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nt"&gt;SL&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nt"&gt;に変える&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;拡張子は&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;sla&lt;/span&gt;&lt;span class="err"&gt;`。&lt;/span&gt;&lt;span class="nt"&gt;Sound&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;Lossless&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;Audio&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="nt"&gt;良好なロスレスオーディオ&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;&lt;span class="nt"&gt;の略&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="nt"&gt;あるいはSHINING&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;LINE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;メモリ領域読み書きに変える&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;オンメモリ対応のため&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;高速化にもなるはず&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;ひとまずBitStreamのメモリ版に変えるが&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="nt"&gt;将来的には高速なビット読み書きモジュールを使用する&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;エンコード&lt;/span&gt;&lt;span class="err"&gt;・&lt;/span&gt;&lt;span class="nt"&gt;デコードの関数化&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;ストリームエンコード&lt;/span&gt;&lt;span class="err"&gt;・&lt;/span&gt;&lt;span class="nt"&gt;デコードハンドル作成関数&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;エンコードサイズの計算関数&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;ストリームエンコード&lt;/span&gt;&lt;span class="err"&gt;・&lt;/span&gt;&lt;span class="nt"&gt;デコード関数&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;ゴロム符号パラメータの更新式を再度検討&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;高速化&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;格子型フィルターを1乗算型に変える&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;負荷測定&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;性能検証&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;比較プログラムの作成&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;様々なwavに対してエンコード&lt;/span&gt;&lt;span class="err"&gt;・&lt;/span&gt;&lt;span class="nt"&gt;デコードし性能&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="nt"&gt;圧縮率と速度&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;&lt;span class="nt"&gt;比較&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;TAKと戦っておきたい&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nt"&gt;---&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nt"&gt;ゴロム符号パラメータの更新式をwavpackに寄せる修正を忘れていた&lt;/span&gt;&lt;span class="err"&gt;…。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;→&lt;/span&gt;&lt;span class="nt"&gt;取り急ぎ試したが悪化&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="nt"&gt;しかし&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="nt"&gt;更新式で定数を足す際に固定小数化せずに足したら性能が良化したので取り込む&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;パラメータ更新式の変更&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c"&gt;/* 修正前 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="nn"&gt;define&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;SOLAGOLOMB_PARAMETER_UP&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;param_array&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;order&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="err"&gt;((param_array)&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="err"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;((((param_array)&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="err"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;SOLAGOLOMB_FIXED_FLOAT_TO_UINT32(127))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;7)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c"&gt;/* 修正後 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="nn"&gt;define&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;SOLAGOLOMB_PARAMETER_UP&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;param_array&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;order&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="err"&gt;((param_array)&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="err"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;((((param_array)&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="err"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;127)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;7)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c"&gt;/* 修正後2 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="nn"&gt;define&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;SOLAGOLOMB_PARAMETER_UP&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;param_array&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;order&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="err"&gt;((param_array)&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="err"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;((((param_array)&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="err"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;SOLAGOLOMB_UINT32_TO_FIXED_FLOAT(127))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;7)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;何故良くなったのかは謎...と思ったら間違えてんじゃん。バグや。&lt;code&gt;SOLAGOLOMB_FIXED_FLOAT_TO_UINT32&lt;/code&gt;だと固定小数として計算しちゃう。やりたいのは定数を固定小数にすること。そこで、修正後2に変えたら性能が悪化...。&lt;/p&gt;
&lt;p&gt;更新式については、バグを疑いつつ検討したい…。重要な割にあまり考え抜いていないところだし…。&lt;/p&gt;
&lt;p&gt;ロングタームの最後の試行。以下を試したい&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;タップ数を増やす&lt;/li&gt;
&lt;li&gt;3次の場合は連立方程式を解く必要あり。手が伸びてない。&lt;/li&gt;
&lt;li&gt;減らした誤差に対して更にピッチ解析を行う&lt;/li&gt;
&lt;li&gt;→繰り返せば繰り返すほど減ってる…。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;N次方程式を解くソースがどこかにあったはず。&lt;/p&gt;
&lt;p&gt;→あった。関数内でmallocしているから、手直しして使おう。でもなんだか結果が合っていないように見える…。&lt;/p&gt;
&lt;h3&gt;2018.3.12&lt;/h3&gt;
&lt;p&gt;いっそPARCOR予測を多段適用すべきでは。フィルタの直列連結とどちらが良いか検証の価値はあり。&lt;/p&gt;
&lt;h3&gt;2018.3.16&lt;/h3&gt;
&lt;p&gt;平日あまり動けず。PARCORの多段適用を試している。まず、誤差に対してもう一度同一係数で予測をかけたらサイズが爆増した。とりやめ。&lt;/p&gt;
&lt;p&gt;実際に誤差に対してPARCOR係数を再度求めてみた...係数を符号化しない状態で、長い音源で1MBクラスの減少が見られた。（以下の結果は次数10のPARCOR係数を2段入れている。）&lt;/p&gt;
&lt;p&gt;```sh:注意：係数は符号化していない。参考値
-rw-r--r--@  1 *  staff  39845536 Mar 16 15:02 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  30154328 Mar 16 15:03 SPARKLE.sol
-rw-r--r--@  1 *  staff     52720 Mar 16 15:03 kisaragi_chihaya.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;素直にPARCOR係数を20次数にした方が結果が良かった。結果は以下：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-rw-r--r--@  1 *  staff  39767592 Mar 16 15:07 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  30135816 Mar 16 15:08 SPARKLE.sol
-rw-r--r--@  1 *  staff     52588 Mar 16 15:08 kisaragi_chihaya.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;また&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;PARCOR係数を観察してみると&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;低次係数が小さくなっていた&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;普通に解析すると低次係数は1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;の近傍にある&lt;/span&gt;&lt;span class="err"&gt;）。&lt;/span&gt;&lt;span class="n"&gt;有効なフォルマント情報が抜き出せなかったものと想像している&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;PARCORを使うことで&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;次数を増やしても健全にサイズを減らせるようだ&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;FLACは次数を32まで選択できるが&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;最高圧縮時&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;でも次数を12としている&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;LPC係数の鋭敏性と&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;次数上昇による量子化が大変だからだと推察&lt;/span&gt;&lt;span class="err"&gt;。）。&lt;/span&gt;&lt;span class="n"&gt;だから&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;このコーデックではPARCORを大きめにとる&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;フィルター計算は1乗算型でしっかり高速化するつもり&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;次数によってどれくらいサイズが変わるのか知りたくない&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="err"&gt;？&lt;/span&gt;&lt;span class="n"&gt;知りたいでしょ&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;じゃあ出してみるわ&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;ひとまず30まで&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;ロングタームはOFFにしとく&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;20190929123751p&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;la_first_attempts&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;20190929123751.&lt;/span&gt;&lt;span class="n"&gt;png&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="n"&gt;前半辺りまでは単調に減るけど&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;それ以降はあまり減らず&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;増えたりする&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;あとはゴロム符号の更新式を考察したらまとめましょう&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;###&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;2019.3.17&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;秋葉原製作所5時間コース&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;ゴロム符号のパラメータ適用式を見直し&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;少なくとも自分にとって説明できるものにしたいし&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;まだ改善できる気がする&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;以下のp55にゴロム符号のパラメータ設定について記述あり&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;JPEG2000の解説&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="k"&gt;last&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bme&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;download&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;firtha&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;video&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;JPEG2000&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;David&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="n"&gt;Taubman&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="n"&gt;Michael&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="n"&gt;W&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="n"&gt;Marcellin&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;auth&lt;/span&gt;&lt;span class="p"&gt;.)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="n"&gt;JPEG2000&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="nc"&gt;Image&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="n"&gt;Compression&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="n"&gt;Fundamentals&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="n"&gt;Standards&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="ow"&gt;and&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="n"&gt;Practice&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mf"&gt;202002.&lt;/span&gt;&lt;span class="n"&gt;pdf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;非常に簡単で&lt;/span&gt;&lt;span class="err"&gt;、`&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ceil&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;log2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;平均&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;としてパラメータ&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;とするもの&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;常にライス符号を使うことになる&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;試してみる&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;まずは&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;パラメータを変えないでやる場合と上式を使用する場合で比較する&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;結果&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;パラメータ固定よりも上記の更新式のほうが性能が良い&lt;/span&gt;&lt;span class="err"&gt;（←&lt;/span&gt;&lt;span class="n"&gt;これは前から知ってた&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;wavpackの更新式よりは良くなかった&lt;/span&gt;&lt;span class="err"&gt;（←&lt;/span&gt;&lt;span class="n"&gt;これも前見た気がする&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;で&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;パラメータの変化を見たところ&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;wavpackは値の変動に素早く追従しているが&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;平均値は追従が遅いように見える&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;色々あがいているが&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;平均を使うやり方では&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;どうもwavpackに勝てない&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;wavpackのパラメータ変化が理想として&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;それに近付くにはどうしたらいいか&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;で考えている&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;信念としては&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;wavpackの更新式が最適とは思えない&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;統計的な裏付けがほぼ無いし&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;指数平滑移動平均を使ったら&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;wavpackの更新式による結果を超えた&lt;/span&gt;&lt;span class="err"&gt;。（&lt;/span&gt;&lt;span class="n"&gt;しかもライス符号で&lt;/span&gt;&lt;span class="err"&gt;！）&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nl"&gt;sh&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;wavpack更新式&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;staff&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;41129982&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Mar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;06&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;one_two_sweets_offvocal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sol&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;staff&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;31271982&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Mar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;06&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SPARKLE&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sol&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="c1"&gt;--r--@  1 *  staff     52970 Mar 17 18:06 kisaragi_chihaya.sol&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;```sh:指数平滑移動平均更新式
-rw-r--r--@  1 *  staff  41028253 Mar 17 18:08 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31110736 Mar 17 18:08 SPARKLE.sol
-rw-r--r--@  1 *  staff     52771 Mar 17 18:08 kisaragi_chihaya.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;このときの更新式は以下：

&lt;span class="n"&gt;``&lt;/span&gt;`&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="nf"&gt;meanはSOLAGOLOMB_UINT32_TO_FIXED_FLOAT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;init_golomb_m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;で初期化 &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;golomb_m2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;MAX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;SOLAGOLOMB_FIXED_FLOAT_TO_UINT32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nf"&gt;Golomb_PutCode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nf"&gt;CodingUtility_Log2ceil&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;golomb_m2&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; 固定小数で&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;しているから、&lt;span class="m"&gt;0.5&lt;/span&gt;足したほうがいいかも &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;mean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;15&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;mean&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;SOLAGOLOMB_UINT32_TO_FIXED_FLOAT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="m"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;mean&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;15&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;16&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;mean&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;abs&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;15/16 = 0.9375&lt;/code&gt;がミソ。
他に良いパラメータをあさってみると、&lt;code&gt;119/128 = 0.9296875&lt;/code&gt;、&lt;code&gt;238/256 = 0.9296875&lt;/code&gt;で結果が良い。平滑化係数を&lt;code&gt;0.93&lt;/code&gt;とするとよいのか？&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ci.nii.ac.jp/els/contentscinii_20190317165228.pdf?id=ART0008474240"&gt;平滑化係数はデータから推定できるようだ。&lt;/a&gt;自己相関を使う（！）。簡単に試してみたけど、得られた平滑化係数が[0,1]からはみ出ることが多かった。（要請する制約に入らないこと多数）。&lt;/p&gt;
&lt;p&gt;```c:平滑化係数計算
  {
    uint32_t  j;
    double    auto_corr[2];
    double    rho_1, alpha, b;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cm"&gt;/* 1次までの自己相関計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j - i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;rho_1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;rho_1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rho_1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vm"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rho_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;rho_1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rho_1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vm"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rho_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;4.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rho_1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rho_1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rho_1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vm"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vm"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;%e \n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="n"&gt;パラメータに対して性能向上が見られたので&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;再帰ゴロム符号に適用していきたいが&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;やっつけでやったら事故った&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;ゼロ除算がどこかで起きている&lt;/span&gt;&lt;span class="err"&gt;）。&lt;/span&gt;&lt;span class="n"&gt;ちゃんとした形に整備して&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;性能が上がるか見ていく&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;家に帰って作った&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;結果は次&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-rw-r--r--@  1 *  staff  40937961 Mar 17 23:56 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  31060591 Mar 17 23:58 SPARKLE.sol
-rw-r--r--@  1 *  staff     52656 Mar 17 23:58 kisaragi_chihaya.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;観察した結果は次：


 - パラメータ数は2がベストだった。パラメータ更新は`119/128`を使った。
 - ライス符号が前提になるからか全体的に性能は悪化。
 - しかし振幅が小さい場合は減る方に動いた。大きいほど悪化。
   - 俺の声は減った
   - SPARKLEは少し悪化
   - ワン・ツー・スゥイーツは結構悪化

これは、最終的にライス（負荷）を使うのか、それともゴロム（圧縮率）を使うのかに分かれると思う。圧縮率を改善する取り組みに反するけど、ライス符号形式を推したい。なぜなら説明できるから。

デコーダ作って戻ることを確認したら、実装整理、すなわちバージョン5に入る。

### 2019.3.18

wavpackが符号bit+絶対値で分けていたのが依然として気になっている。-1が0に行くのは大きい。最後に試しておきたい。

→あんまり効果なし。1bit確定で消費するのがあまり望ましくないと考える。

デコーダも苦戦。パラメータの更新が難しくなっている。春分の日一杯でできるかどうかというところか…？

### 2019.3.19

デコーダデバッグ中。OK。戻ることを確認。テスト追加。

DreamGoesOnの圧縮率がどうもalsに比べて低くて、符号の頻度を見たら負方向に偏っていることが分かった。

どうも音源依存で偏りが発生しているようだ…。voice48aも正に偏っている。

SPARKLE, ワン・ツー・スゥイーツは偏っていない。一回ロッシー圧縮するとだめ？
→ワン・ツー・スゥイーツを一回mp3(96Kbps)にしてwavに戻して試してみたが、分布の偏り見られず。

```sh
ffmpeg -i one_two_sweets_offvocal.wav -ab 96k -f mp3 one_two_sweets_offvocal.mp3
ffmpeg -i one_two_sweets_offvocal.mp3 -f wav one_two_sweets_offvocal_frommp3.wav
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;エンコードパラメータが小さくなるフレームがあることに気づいた。それで、元波形の先頭（イントロ前）を見た所、微弱な信号が入っていることがわかった。（ワン・ツー・スゥイーツではしっかり0になっているが、DreamGoesOnは無音にならずわずかな信号が流れている。）&lt;/p&gt;
&lt;p&gt;&lt;img alt="20190929123806p" src="./images/la_first_attempts/20190929123806.png" /&gt;&lt;/p&gt;
&lt;p&gt;上がDream Goes On、下がワン・ツー・スゥイーツ。時間が示すように先頭部分。16bit PCMにして3程度の振動が入っている。&lt;/p&gt;
&lt;p&gt;こういうフレームはランレングスでやってしまうべきかと思う。ランレングスの判定基準を甘くしよう。&lt;/p&gt;
&lt;h3&gt;2019.3.20&lt;/h3&gt;
&lt;p&gt;通勤中に思いついたこと:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自己相関はピークをとらずに、単に最大値をとればよいのでは&lt;/li&gt;
&lt;li&gt;実質今その実装。簡略化する。&lt;/li&gt;
&lt;li&gt;各ブロックの立ち上がりでパラメータが大変動する。先頭は単純符号化でよいのでは&lt;/li&gt;
&lt;li&gt;もしくは、先頭部分だけの平均を計算しておく。&lt;/li&gt;
&lt;li&gt;30以上の高次係数は4bitとかで良さそう&lt;/li&gt;
&lt;li&gt;→悪化傾向。16,20以降の係数を4bitにしたが悪化。&lt;/li&gt;
&lt;li&gt;ライス符号化のパラメータはlog2(e)使うやつじゃなくて良かったか&lt;/li&gt;
&lt;li&gt;m = log2((loge2)E(|e|)) という式&lt;/li&gt;
&lt;li&gt;Wavpackが言及したDataCompressのp67周辺の記述。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.3.21&lt;/h3&gt;
&lt;p&gt;3.20の夜は疲れて何もできず。寝不足か。&lt;/p&gt;
&lt;p&gt;アニソンAnother stageの中止発表を受ける。急いでキャンセルしたい。&lt;/p&gt;
&lt;p&gt;その他は今日はランレングスの調整から始める。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;閾値を上げるのは効果あり。&lt;/li&gt;
&lt;li&gt;残差分布はほぼ対称になった。&lt;/li&gt;
&lt;li&gt;パラメータをいっそ平均に変えるのも効果あり。&lt;/li&gt;
&lt;li&gt;ランレングス中で適応的ライス符号を使うのは悪化。&lt;/li&gt;
&lt;li&gt;ランレングスのときのゴロム符号パラメータは平均をそのまま使う。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ゴロム符号の初期パラメータは先頭だけから求めることをする。
→16bitを越えてしまった。やっつけで16bit上限を設けたら性能が悪化。どうゆうことだ…。&lt;/p&gt;
&lt;p&gt;モジュール簡略化のため、ゴロム符号パラメータはヘッダに含めないようにする。
→やった。&lt;/p&gt;
&lt;p&gt;最後、DreamGoesOnがデコードアサーションしている（ゴロム符号パラメータが0になった）ので、修正してまとめていきたい。他のファイルはもとに戻る。ピッチ検出に失敗するのがトリガー？
→イチローの引退会見を横目にデバッグ。どうも4537回目のブロックデコードで20bitずれている。（20bitの空白ができていて、20bit空読みすると完全一致になる。）ランレングスを読みそこねている？&lt;/p&gt;
&lt;p&gt;無音部分（ランレングス）の圧縮率が悪いかも。他コーデックを参考にすべきか...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大ランレングス長さ（を表現可能なビット長）を先読みで解析しておく…？&lt;/li&gt;
&lt;li&gt;PARCOR係数を出す前に、エンコード対象のデータ列が本当の無音（0列）か否かを判定する。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.3.22&lt;/h3&gt;
&lt;p&gt;バグ直し。
デバッグ中に気づいたけどランレングスのときにあまりランで出力できていない（ほとんど非ラン）…。閾値はもっと厳しくしていいのでは…。あと、まじの無音（0だけ）は特別な符号で表すだけでいいと思った。&lt;/p&gt;
&lt;p&gt;バグ退治。エンコード時、ランレングスで最大長出力時に誤りがあった。&lt;/p&gt;
&lt;p&gt;```c:誤
      /&lt;em&gt; 非ラン分出力 &lt;/em&gt;/
      while (notrunlength &amp;gt;= MAXLENGTH) {
        /&lt;em&gt; snip... &lt;/em&gt;/&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;`&lt;span class="nv"&gt;MAXLENGTH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;length_bits&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;`だから、ピッタリ`&lt;span class="nv"&gt;notrunlength&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nv"&gt;MAXLENGTH&lt;/span&gt;`の時に、本当は何もしなくても出力できるのに、分割出力してしまう。正しくはこちら：

```&lt;span class="nv"&gt;c&lt;/span&gt;:正
      &lt;span class="cm"&gt;/* 非ラン分出力 */&lt;/span&gt;
      &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;notrunlength&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;MAXLENGTH&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt; {
        &lt;span class="cm"&gt;/* snip... */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;日記を見返していたら、最適なライス符号パラメータの式あるやん…平均に0.382(49/128)足すだけでいいじゃん。。。→簡単に適応的なやつに試したけど悪化。しかもゴロム化するのでやめとく。&lt;/p&gt;
&lt;h3&gt;2019.3.23&lt;/h3&gt;
&lt;p&gt;残りTODO:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引き続きランレングスの吟味。&lt;/li&gt;
&lt;li&gt;できれば完全無音のブロックをもっと少ないビットで符号化したい。&lt;ul&gt;
&lt;li&gt;やった。無音フレームか否かを識別するフラグを追加。やらしいのは、係数による結果だと誤りが出る所。入力が全て0かを判定して行う必要がある。&lt;/li&gt;
&lt;li&gt;ワン・ツー・スゥイーツやSPARKLEなどの純正マスタリング音源に効果あり。（リアル無音なんか自然ではほぼ作れないから、当然ではある...。）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ランレングスいらねえんじゃね…。&lt;ul&gt;
&lt;li&gt;ラン長が短すぎる。手元のDreamGoesOnやVoice48aでは最長12とか。&lt;/li&gt;
&lt;li&gt;無音に近い場合は、パラメータを適用変化させないほうが良い？以下の表参照。→分散が小さく分布変動も小さいから、固定したほうが有利かも。&lt;/li&gt;
&lt;li&gt;と思って固定パラメータ出力したら増えた…？なぜ？ほぼラン出力できてないのに増えるのはおかしいと思う。もうちょっと精査する必要あり。&lt;/li&gt;
&lt;li&gt;→ returnし忘れていた。ただのしょうもないミス。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;音源&lt;/th&gt;
&lt;th align="center"&gt;ランレングスあり&lt;/th&gt;
&lt;th align="center"&gt;ランレングス無し&lt;/th&gt;
&lt;th align="center"&gt;ランレングス無し（固定ゴロム符号）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;voice48a&lt;/td&gt;
&lt;td align="center"&gt;789104&lt;/td&gt;
&lt;td align="center"&gt;788643&lt;/td&gt;
&lt;td align="center"&gt;788617&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;DreamGoesOn&lt;/td&gt;
&lt;td align="center"&gt;23927826&lt;/td&gt;
&lt;td align="center"&gt;23962467&lt;/td&gt;
&lt;td align="center"&gt;23922982&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;ロングタームをピークではなく単純最大に置き換える&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;パラメータ固定小数を整数に戻すとき（右シフト時）、0.5を足して丸めるようにしたら性能改善。固定小数は丸めが大事だ…&lt;/p&gt;
&lt;h3&gt;2019.3.25&lt;/h3&gt;
&lt;p&gt;あーLMS（適応的アルゴリズム）を忘れていた…試したい…。
image_comp/LMS/lms_test.rb でテスト可能。&lt;/p&gt;
&lt;p&gt;試してみる。すると、かなり減るように見えるぞ、おい。誤差の分散（と標準偏差）をプロットしてみたけど、増えることはなく、減っている。次数を増やすと減少が鈍るけれども、増えないだけでも有益に思える。次数を増やしても、振幅が小さめのボイスデータはかなりへる傾向が見られたので結構有益かも。&lt;/p&gt;
&lt;p&gt;今は&lt;code&gt;double&lt;/code&gt;で演算していたけど、固定小数に置き換えたときにどうなるか。それを含めてやはり試してみたい。&lt;/p&gt;
&lt;h3&gt;2019.3.26&lt;/h3&gt;
&lt;p&gt;LMSのモジュール化を試みる。APIは極めて簡単に作れる。&lt;/p&gt;
&lt;p&gt;```c:API案
/&lt;em&gt; NLMS計算ハンドル &lt;/em&gt;/
struct NLMSCalculator;&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; NLMS計算ハンドル &lt;/em&gt;/
struct NLMSCalculator {
    LPCFixedFloat1_31   alpha;          /&lt;em&gt; ステップサイズ &lt;/em&gt;/
    LPCFixedFloat1_31&lt;em&gt;  coef;           /&lt;/em&gt; 係数 &lt;em&gt;/
    uint32_t            max_num_coef;   /&lt;/em&gt; 最大の係数個数 */
};&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 計算ハンドルの作成 &lt;/em&gt;/
struct NLMSCalculator* NLMSCalculator_Create(LPCFixedFloat1_31 alpha, uint32_t max_num_coef);&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 計算ハンドルの破棄 &lt;/em&gt;/
void NLMSCalculator_Destroy(struct NLMSCalculator* nlms);&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 予測 &lt;/em&gt;/
LPCApiResult NLMSCalculator_PredictInt32(
    struct NLMSCalculator&lt;em&gt; nlms, uint32_t num_coef,
    const int32_t&lt;/em&gt; data, uint32_t num_samples, int32_t* residual);&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 合成 &lt;/em&gt;/
LPCApiResult NLMSCalculator_SynthesizeInt32(
    struct NLMSCalculator&lt;em&gt; nlms, uint32_t num_coef,
    const int32_t&lt;/em&gt; residual, uint32_t num_samples, int32_t* output);&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n n-Quoted"&gt;`alpha`&lt;/span&gt;&lt;span class="n"&gt;は&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`0.01f`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;32bit固定小数で&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`0x0147ae14`&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;あたりに固定したい。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;### 2019.3.27&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;上記のとおりに実装。LPCが膨れるので、そろそろ整理したい所。&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`predictor.c`&lt;/span&gt;&lt;span class="n"&gt;にリネームしようかな。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;16bitの振動する信号に対しては予測が動いている。定数入力に対して係数が更新されない…（分散が0だから？）。24bitはダメダメ。これは溢れが起きているかも。どうも19bitまでは良くて、20bitからだめみたいです。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;TODO&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;LPC&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;PARCORの24bitテスト。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;### 2019.3.28&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;周りが焦らなくて焦る。木村監督は叩かれてる。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;24bitでだめなのは、やはり桁あふれだろうということで真面目に乗算の度にシフトしていた。すると、誤差がいつまでも残るようになった。それはいやなので、alpha抜き（alpha&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;1と同じ）で計算してみると収束が非常に良くなった。これで行こう。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;→更新式がまだ溢れている。結果は正しくなっているけど。。。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;### 2019.3.29&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;NLMSの更新式間違ってるわ。分散じゃなくて、単純に入力の2乗（パワー）で良かった。したら白色雑音意外は収束するようになった。よし、使える。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;PARCORの24bit版テストを追加。テストは通っている。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;### 2019.3.30&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;秋葉原製作所2時間。GWは小松に行こう。NLMSの更新式で整数除算を使うので、速度が気になっている。以下のサイトが有効かも。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;整数除算の高速化&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;emit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;prog&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;prog_div&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;html&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;適用は難しいことがわかった。32bit精度演算だと、最後の計算で右62bitシフトが必要になる。これはつまり128bit精度で途中結果を持たないと行けない…&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;単純なビットシフトに置き換えてしまって良いように思える。ほか、うろついてたらlog2の切り捨ての計算方法があった。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="nf"&gt;floor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;log2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="n"&gt;の計算&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hatena&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ne&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;homeskill&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;20110806&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;1312626490&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Find&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;integer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;an&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;integer&lt;/span&gt;&lt;span class="n"&gt;（黒魔術）&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;programmizm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sourceforge&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;io&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;blog&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2011&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;integer&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;an&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Integer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Log2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;implemented&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;using&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;binary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;codereview&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stackexchange&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;questions&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;151312&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="kt"&gt;integer&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;log2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;implemented&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;using&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;binary&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;シビアに高速化できそう。もしかしたらハッカーのたのしみに載ってそう。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;高速化はおいておいて、NLMSを取り込んでいく。→取り込んだ。次数はとりあえず10。全体的に減少が見られる：&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-rw-r--r--@  1 *  staff  40586832 Mar 30 14:32 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  30960017 Mar 30 14:30 SPARKLE.sol
-rw-r--r--@  1 *  staff     52560 Mar 30 14:33 kisaragi_chihaya.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;PARCOR係数の次数を増やすとNLMSによる恩恵が少なくなるが、それでも減る。以下の結果はPARCOR係数を20にしたときの結果：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-rw-r--r--@  1 *  staff  39715652 Mar 30 14:37 one_two_sweets_offvocal.sol
-rw-r--r--@  1 *  staff  30101640 Mar 30 14:36 SPARKLE.sol
-rw-r--r--@  1 *  staff     52332 Mar 30 14:35 kisaragi_chihaya.sol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="s s-Atom"&gt;以上で圧縮技術の駒は揃っただろう。&lt;/span&gt;&lt;span class="nv"&gt;NLMSについて気になるのは&lt;/span&gt;&lt;span class="s s-Atom"&gt;、次数と残差計算の順番。&lt;/span&gt;&lt;span class="nv"&gt;PARCORによる残差は最初に出すとして&lt;/span&gt;&lt;span class="s s-Atom"&gt;、&lt;/span&gt;&lt;span class="nv"&gt;NLMSとロングタームはどちらを先に入れるのが良いか&lt;/span&gt;&lt;span class="s s-Atom"&gt;。これらを検証したら切り上げる。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;残差計算の順番は、なんと、順番に依存しない（変わらない）ことがわかった&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="s s-Atom"&gt;。サイズは厳密に一致。これはNLMSの短期予測の結果はロングタームの結果に何ら影響を及ぼさないことを意味しているのだろうか。。。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;次数について見ていく。&lt;/span&gt;&lt;span class="nv"&gt;PARCOR係数は10&lt;/span&gt;&lt;span class="s s-Atom"&gt;、ロングタームありでの比較：&lt;/span&gt;

&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;NLMS次数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;ワン・ツー・スウィーツ&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;SPARKLE&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;俺の声&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|:-&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;|:-&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;|:-&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;|:-&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;未適用&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;40978249&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;31055202&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;52577&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;41098033&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;31274844&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;52572&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;40800621&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;31090112&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;52563&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;40586832&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;30960017&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;52560&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;40499597&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;30931506&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;52559&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;40483976&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;30921234&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;52558&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;40465348&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;30915117&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;52557&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;40450833&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;30910096&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;52553&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; 
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;40397208&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;30896233&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;52535&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;40326600&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;30863911&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;52532&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;

&lt;span class="s s-Atom"&gt;計算負荷高い。サンプル毎に係数更新しているのが結構効いてるかも…（係数更新で除算使ってるし）。でも次数を増やしても悪化しないのは都合が良い。プリセットの設定がしやすい。&lt;/span&gt;

&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;固定小数点数の算術関数ライブラリ&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="nn"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="s s-Atom"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;geocities&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;jp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;midarekazu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;math&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;library&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;html&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2019.3.31&lt;/span&gt;

&lt;span class="s s-Atom"&gt;起床事故。&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="s s-Atom"&gt;に起きる。マジカルミライの予約してたら14:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="s s-Atom"&gt;。その間に除算を減らした。&lt;/span&gt;&lt;span class="nv"&gt;NLMSは処理を共通化できる&lt;/span&gt;&lt;span class="s s-Atom"&gt;。やっておきたい。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;あと、今日はversion&lt;/span&gt;&lt;span class="mf"&gt;.5&lt;/span&gt;&lt;span class="s s-Atom"&gt;に向けたモジュールソース分割を考えて、手をつけていきたい。秋葉原製作所16:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="s s-Atom"&gt;の予定。&lt;/span&gt;

&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt; &lt;span class="nv"&gt;NLMSの処理共通化完了&lt;/span&gt;&lt;span class="s s-Atom"&gt;。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;---&lt;/span&gt;

&lt;span class="s s-Atom"&gt;####&lt;/span&gt; &lt;span class="s s-Atom"&gt;オンメモリ書き出しへの変更点要点（改訂版）&lt;/span&gt;

 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;ソースは独立して切る。新規に書き起こす。無駄な部分を消す。&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;シグネチャを&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;SL&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;に変える。&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;拡張子は&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;sla&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;。&lt;/span&gt;&lt;span class="nv"&gt;Sound&lt;/span&gt; &lt;span class="nv"&gt;Lossless&lt;/span&gt; &lt;span class="nv"&gt;Audio&lt;/span&gt;&lt;span class="s s-Atom"&gt;（良好なロスレスオーディオ）の略。あるいはSHINING&lt;/span&gt; &lt;span class="nv"&gt;LINE&lt;/span&gt;&lt;span class="s s-Atom"&gt;*。&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;バージョンは1&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;再度バイナリフォーマットを考察&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;ブロックサンプル数等、&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="s s-Atom"&gt;部フィールドのサイズ見直し&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;エンコードパラメータの整理&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;プリセットを作成。&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;低圧縮率でデコード早い&lt;/span&gt; &lt;span class="s s-Atom"&gt;?&lt;/span&gt; &lt;span class="s s-Atom"&gt;高圧縮率でデコード遅い&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;メモリ領域読み書きに変える。&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;オンメモリ対応のため。&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;ひとまずBitStreamのメモリ版に変えるが、将来的には高速なビット読み書きモジュールを使用する。&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;エンコード・デコードの関数化&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;ストリームエンコード・デコードハンドル作成関数&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;エンコードサイズの計算関数&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;ストリームエンコード・デコード関数&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;高速化&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;格子型フィルターを1乗算型に変える&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;負荷測定&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;性能検証&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;比較プログラムの作成。&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;様々なwavに対してエンコード・デコードし性能（圧縮率と速度）比較&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;TAKと戦っておきたい&lt;/span&gt;&lt;span class="s s-Atom"&gt;。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;---&lt;/span&gt;

&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;46&lt;/span&gt; &lt;span class="s s-Atom"&gt;気になっていたバイトアラインを退治。サイズは1kほど増えたが、汎用性のためには全く問題なし。よし、&lt;/span&gt;&lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="s s-Atom"&gt;から思い切ってソース切るか。&lt;/span&gt;

&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;48&lt;/span&gt; &lt;span class="s s-Atom"&gt;エンコーダ・デコーダ以外はソースを切った。エンコーダデコーダはAPIを検討する必要がある。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;これは平日に投げよう。&lt;/span&gt;&lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="s s-Atom"&gt;になった。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2019.4.2&lt;/span&gt;

&lt;span class="s s-Atom"&gt;有給とって作業。なんとしても、今日中に第一版を上げたい。仕様を紙に書いたので、まずはここに複写する。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;####&lt;/span&gt; &lt;span class="nv"&gt;SLAヘッダ&lt;/span&gt;

&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nf"&gt;サイズ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;内容&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;補足&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="s s-Atom"&gt;--:&lt;/span&gt;&lt;span class="p"&gt;|:-&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;|:-&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;シグネチャ&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;SL* &amp;quot;&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;Sound&lt;/span&gt; &lt;span class="nv"&gt;Lossless&lt;/span&gt; &lt;span class="nv"&gt;Audio&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;あるいはSHINING&lt;/span&gt; &lt;span class="nv"&gt;LINE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;一番最初のデータブロックまでのオフセット（自分除く）&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;RIFF等の慣習に従って32bit&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;これ以降のフィールドで、ヘッダ末尾までのCRC16&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;フォーマットバージョン番号&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;チャンネル数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;足りるでしょ…（怠慢）&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;全サンプル数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;足りるでしょ…（怠慢）。ストリームエンコード時は未定義=&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="mh"&gt;0xFFFFFFFF&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;サンプリングレート&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;足りるでしょ…（怠慢）&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="s s-Atom"&gt;サンプルあたりのビット数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;wavへの復元で必要&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;PARCOR係数次数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;無音ブロック以外の全ブロックで同一&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;ロングタームタップ数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;ブロック毎に異なる&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;NLMS次数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;無音ブロック以外の全ブロックで同一&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;チャンネル毎の処理法&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;無音ブロック以外の全ブロックで同一&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;SLAブロック数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;ストリームエンコード時は未定義=&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="mh"&gt;0xFFFFFFFF&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;SLAブロックあたりの最大サンプル数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;最大ブロックサイズ&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;最低ビットレートの計算に必要。ストリームエンコード時は未定義=&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="mh"&gt;0xFFFFFFFF&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;

&lt;span class="s s-Atom"&gt;ヘッダサイズは38byte。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;####&lt;/span&gt; &lt;span class="nv"&gt;SLAブロック&lt;/span&gt;

&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nf"&gt;サイズ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;内容&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;補足&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="s s-Atom"&gt;--:&lt;/span&gt;&lt;span class="p"&gt;|:-&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;|:-&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;同期コード&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="mh"&gt;0xFFFF&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;アルファ符号は最大で15個までの連続した1を出すから。&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;次のデータブロックまでのオフセット&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;これ以降のフィールドで、次のブロック先頭までのCRC16値&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;  &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;このブロックのサンプル数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="s s-Atom"&gt;チャンネル数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;無音ブロックか否か？&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="s s-Atom"&gt;チャンネル数&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;MIN&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;PARCOR係数次数&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="s s-Atom"&gt;チャンネル数&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;MAX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;PARCOR係数次数&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;PARCOR係数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;最初の4次までは16bit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;残りは8bitで符号化。非線形量子化は行っていない。&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="s s-Atom"&gt;チャンネル数&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;26&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="s s-Atom"&gt;ロングターム有りch数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;ロングターム係数&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;ロングタームを使用していないチャンネルは0が入る。&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="s s-Atom"&gt;の場合、最初の10bitでピッチ周期、次の16bitで係数が符号化されている。&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;不定&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;再帰的ライス符号化された残差&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;チャンネルインターリーブではない。&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="s s-Atom"&gt;ch目の符号化された信号列先頭&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="s s-Atom"&gt;ch目の符号化された信号列末尾&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="s s-Atom"&gt;ch目の符号化された信号先頭&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="s s-Atom"&gt;ch目の符号化された信号末尾&lt;/span&gt;&lt;span class="p"&gt;,...&lt;/span&gt;&lt;span class="s s-Atom"&gt;という並び。&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;

&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;56&lt;/span&gt; &lt;span class="s s-Atom"&gt;ヘッダを書き下すところまではOK。現段階では壊れたところは見当たらない。実装を埋めていく。今日でとりあえずの第一版を上げて、レビューを受けたい。間に合ってくれ…！&lt;/span&gt;

&lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;34&lt;/span&gt; &lt;span class="s s-Atom"&gt;エンコーダのやっつけ版ができた。まだコンパイル・テストはしていない。コンパイルを頑張って通すようにして、デコーダに手を付ける。&lt;/span&gt;

&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt; &lt;span class="s s-Atom"&gt;なんとかエンコード・デコードができるもの（alpha版1）を作成。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2019.4.3&lt;/span&gt;

&lt;span class="s s-Atom"&gt;先輩に見て頂いているが、いろんな問題が見つかっている。&lt;/span&gt;

 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;M_PI&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;が未定義で怒られる&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;プラットフォームによって圧縮率が異なる&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;まず気になるのはfloatが一部混入している所。思い切ってdoubleにしよう。&lt;/span&gt;
     &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;Rpiでは関係なかった&lt;/span&gt;&lt;span class="s s-Atom"&gt;…原因を追っていたら、&lt;/span&gt;&lt;span class="nv"&gt;C89では&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;round&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;が定義されていなくて、係数が全部0になっていた。。。&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;std&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s s-Atom"&gt;c99&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;にしたらOKだったけども…。下の独自実装を使う。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;splintにかけたら負数の右シフトはやべえぞとあった。確かに。算術シフトとは限らないので静的アサートしよう&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;ハッカーのたのしみを引用すると、算術右シフトをやるには以下の式：&lt;/span&gt;

&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="s s-Atom"&gt;c&lt;/span&gt;
&lt;span class="cm"&gt;/* 算術右シフト(有効範囲:0 &amp;lt;= rshift &amp;lt;= 32) */&lt;/span&gt;
&lt;span class="s s-Atom"&gt;#define&lt;/span&gt; &lt;span class="nv"&gt;SHIFT_RIGHT_SIGNED&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;sint&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;rshift&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;int32_t&lt;/span&gt;&lt;span class="p"&gt;)((((&lt;/span&gt;&lt;span class="s s-Atom"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="s s-Atom"&gt;sint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x80000000&lt;/span&gt;&lt;span class="nv"&gt;UL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s s-Atom"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;rshift&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x80000000&lt;/span&gt;&lt;span class="nv"&gt;UL&lt;/span&gt; &lt;span class="s s-Atom"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;rshift&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;デコードに失敗するケースがある&lt;/li&gt;
&lt;li&gt;テスト追加（移植）&lt;/li&gt;
&lt;li&gt;簡単に負荷を測ったところ、RecursiveRice_PutQuotPartの負荷が高かった。パラメータは絶対2の冪だから、決め打ち（ライス符号化）でいいのでは。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;```c:丸め関数の独自実装
double round(double number)
{
    return (number &amp;gt;= 0) ? (double)((int)(number + 0.5f)) : (double)((int)(number - 0.5f));
}
double round(double f)
{
    return (f &amp;gt;= 0.0) ? floor(f + 0.5f) : -floor(-f + 0.5);
}&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;もう少し警告をうるさくしたいので、オプション探索中。&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`splint`&lt;/span&gt;&lt;span class="n"&gt;もかけたいし、&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`gcc -Wall -Wextra -Q --help=warnings`&lt;/span&gt;&lt;span class="n"&gt;で有効になっている警告を表示できる。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;警告を要求&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;抑止するオプション&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cqpub&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;interface&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;column&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;freesoft&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2003&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;200308&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;3.&lt;/span&gt;&lt;span class="n"&gt;htm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;コマンドラインパーサを作る時が来たかも。&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`getopt_long`&lt;/span&gt;&lt;span class="n"&gt;（GNU拡張）&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;を自前で実装したもの&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;コマンドライン引数の処理&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;linuxc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;stdinout&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;getopt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;コマンドラインオプションの処理&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mm2d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;net&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;prog&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;getopt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;03.&lt;/span&gt;&lt;span class="n"&gt;html&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;性能計測してたら、nlz5の呼び出し回数が多いことが分かった。もしかしたら高速化した方がいいかも。ビットカウント問題に帰着する方法が一番速そう。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;### 2019.4.5&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;準備で4&lt;/span&gt;&lt;span class="mf"&gt;.4&lt;/span&gt;&lt;span class="n"&gt;は何もできず。思いついたのはceil&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;log2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="n"&gt;は2のべき乗切り上げに変えられるということ。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;### 2019.4.6&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="mf"&gt;4.5&lt;/span&gt;&lt;span class="n"&gt;は2時間半しか寝てないので今日は12時間寝た。週末はテスト追加と、上記の修正を入れていきたい。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;テスト追加はOK。はやめにrepo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;作る。&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`-Wpedantic -Wformat=2 -Wconversion`&lt;/span&gt;&lt;span class="n"&gt;をつけて警告を潰す。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;09&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;飯食いながら警告を潰した。15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;00から2回目なのでここで切り上げる。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;macで性能計測する方法がわからなかったので調べた（&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`gprof`&lt;/span&gt;&lt;span class="n"&gt;が使えなくて悲しい）。instrumentsを使う。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n n-Quoted"&gt;`&lt;/span&gt;&lt;span class="n n-Quoted n-Quoted-Escape"&gt;``&lt;/span&gt;&lt;span class="n n-Quoted"&gt;sh&lt;/span&gt;
&lt;span class="n n-Quoted"&gt;$ instruments -t &amp;quot;Time Profiler&amp;quot; ./sla -c voice48a.wav voice48a.sla&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;実行の結果できあがった&lt;code&gt;.trace&lt;/code&gt;ファイルを開けばプロファイル結果が見られる。&lt;/p&gt;
&lt;p&gt;最適化を気にし始める：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2"&gt;Bit Twiddling Hacks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これ以上は、多分根本的に戦って行かないとだめかも。一旦最適化はおいて、CRC16等の機能追加に入ろう。と思ったらCRC16壊れてる。うーんやり直し。秋葉原製作所3時間タイムアップ。&lt;/p&gt;
&lt;p&gt;家で作業。CRC16のリファレンスを入手するのにすげえ苦労した。pythonの&lt;code&gt;pycrc&lt;/code&gt;を使う。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;python3 pycrc.py --model&lt;span class="o"&gt;=&lt;/span&gt;crc-16-ccitt --xor-in&lt;span class="o"&gt;=&lt;/span&gt;0xFFFF --check-file foo.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CRC16の組み込みOK。同時にブロックの次のオフセット記録もOK。未テストだからテスト突っ込みたい。&lt;/p&gt;
&lt;p&gt;あとは、いよいよPARCORを1乗算型に変えるかな…&lt;/p&gt;
&lt;h3&gt;2019.4.7&lt;/h3&gt;
&lt;p&gt;コンパイラをmacの&lt;code&gt;clang&lt;/code&gt;から&lt;code&gt;gcc-8&lt;/code&gt;に変えたら警告がドバーッと出たので消していく。気になるのは論理定数を導入したほうが良さそう（列挙型で良い）。あと1乗算型変更が着手を今日のメインとしたい。できるか…？&lt;/p&gt;
&lt;p&gt;CRC16は、CCITT-FALSEよりCCITTにしたほうが良いな。Linuxカーネルでよく使われるのはCCITTだし。&lt;strong&gt;と思ったらやめた。CCITT-FALSEでいく。Linux内部でも実装がブレブレ。初期値の与え方、結果の反転のやり方が使用箇所毎に違う。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;そして、今&lt;code&gt;assert&lt;/code&gt;を消そうと思って&lt;code&gt;-DNDEBUG&lt;/code&gt;を入れたら圧縮結果が変わった。これは最適化時に何かが起きている。&lt;/p&gt;
&lt;p&gt;→原因が判明。&lt;code&gt;assert&lt;/code&gt;マクロ自体&lt;code&gt;(void)0&lt;/code&gt;に置き換えてしまうから、なにか副作用のある処理を&lt;code&gt;assert&lt;/code&gt;していると、最適化により処理自体が消されてしまう。SLABitStreamを使うところでassertsしているところが多数あってassertを消すと挙動が変わっていた。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLABitStream_GetBit&lt;/code&gt; の負荷が高い。アルファ符号を取得するときに頻繁に呼ばれる。アルファ符号向けにランレングスを取得する関数を追加すべきか…？&lt;/p&gt;
&lt;p&gt;NLZの高速な計算手法があった…もはや黒魔術。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://d.hatena.ne.jp/Koonies/touch/20090708/nlz3"&gt;マジックナンバー0x03F566ED27179461の求め方とHD流のNLZ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hackersdelight.org/hdcodetxt/nlz.c.txt"&gt;Hacker's Delightのソース&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分岐無しで自明に早いので取り込んでいる。&lt;/p&gt;
&lt;p&gt;やりたいこと一つ出てきた。ヘッダのエンコードとデコードはハンドル無しでやるべき。（ハンドルがない状態で呼ばれるかもしれないから）。だから、バイト列の読み書きモジュールを新規に追加したい。おそらくヘッダ実装で間に合うはず。&lt;/p&gt;
&lt;p&gt;うーん、CRC16の選択にまだ迷う。CCITT-FALSEはCCITTのミスみたいな記述があるし…。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://crccalc.com/"&gt;計算リファレンス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://reveng.sourceforge.net/crc-catalogue/16.htm#crc.cat-bits.16"&gt;Catalogue of parametrised CRC algorithms with 16 bits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ross.net/crc/download/crc_v3.txt"&gt;A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;やっぱり社内と統一をとるため、CRC-16/ARCにしようか。&lt;/p&gt;
&lt;p&gt;あと、窓関数の変更対応ができてなくてサイン窓固定になってる…変えなきゃ…&lt;/p&gt;
&lt;h3&gt;2019.4.9&lt;/h3&gt;
&lt;p&gt;週末は完全に予定が入っているのでなんとか進めたい所。GWの予定も考えていかないと。&lt;/p&gt;
&lt;p&gt;CRC16をIBM(ARC)に変えた。&lt;/p&gt;
&lt;p&gt;特許調査始めないとダメかも…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特開2013-120225(P2013-120225A)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.4.11&lt;/h3&gt;
&lt;p&gt;特許を見始めているが、権利一体の原則の見地から見ると、おそらく抵触しないのではという感覚。油断せず継続調査。&lt;/p&gt;
&lt;p&gt;ヘッダのエンコード・デコードをハンドル無しで行うように修正。
あと、入力が32bit整数ににスケールされている整数というのはなんとなく格好悪い。（例：16bitの65535が32bitのINT32_MAXになっている）&lt;/p&gt;
&lt;p&gt;GWでは格子型フィルター演算の高速化・圧縮率改善の最後のあがきをすべきか。ロングタームが1tapしか使えないのがやだ。TAKのサイト見てたら前処理でフィルター入れているとのこと…やってみたい。&lt;/p&gt;
&lt;h3&gt;2019.4.14&lt;/h3&gt;
&lt;p&gt;4.14は夕方から秋葉原製作所3hコース。やるべきは、エンコード・デコードのテスト追加か。&lt;code&gt;Create&lt;/code&gt;関数をワーク渡しにするのはまだ先としたい（メンバ追加はやりそうだから）。&lt;/p&gt;
&lt;h3&gt;2019.4.17&lt;/h3&gt;
&lt;p&gt;15,16はテストを少し追加していただけ。1乗算型PARCORの実装方法をついに見つけた。「音声のディジタル信号処理（上）」のp96だ。&lt;/p&gt;
&lt;h3&gt;2019.4.18&lt;/h3&gt;
&lt;p&gt;1乗算型にしようとしてみるがどうもならない。最初に実装した形がそもそも違うように見える…&lt;/p&gt;
&lt;h3&gt;2019.4.19&lt;/h3&gt;
&lt;p&gt;TAKの圧縮率にビビる。というか、これもうTAKの勝ちでは…。
TAKは線形予測の前に何かしらのフィルターを使用しているが、もしかしたら、NLMSかも？&lt;/p&gt;
&lt;p&gt;下の結果は&lt;code&gt;-p4&lt;/code&gt;（最大圧縮率）を使用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rwxrwxrwx 1 kiriao kiriao 38580251 Apr 19 18:52 one_two_sweets_offvocal.tak
-rwxrwxrwx 1 kiriao kiriao 28597636 Apr 19 18:52 SPARKLE.tak
-rwxrwxrwx 1 kiriao kiriao    50358 Apr 19 18:52 kisaragi_chihaya.tak
-rwxrwxrwx 1 kiriao kiriao 21068517 Apr 19 18:54 Dream_goes_On.tak
-rwxrwxrwx 1 kiriao kiriao   753612 Apr 19 18:52 voice48a.tak
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;日に日に乗算結果を64bitで受けている現実が気になってきている。TAKは14bitだという。SSE化を見越した時に有利なのはどちらかは明らかだ。&lt;/p&gt;
&lt;p&gt;TAKを越えない限り商品化は厳しいと思う。&lt;/p&gt;
&lt;h3&gt;2019.4.20&lt;/h3&gt;
&lt;p&gt;TAKに追いつきたい。まずは今のソースをgitに登録する。→やった。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可変ブロックサイズ対応&lt;/li&gt;
&lt;li&gt;PARCOR係数から残差電力を求められたはず。これで（もしくは符号長から）、最も残差電力が小さくなるブロックサイズを決める。&lt;/li&gt;
&lt;li&gt;フィルタ処理の追加&lt;/li&gt;
&lt;li&gt;TAKでは線形予測の前にフィルタを入れている。ローパス、ハイパス、NLMSを入れてみてどうなるか見る。&lt;/li&gt;
&lt;li&gt;平均が小さい時にLZ符号化を試す&lt;/li&gt;
&lt;li&gt;やってみたけど芳しくない。増える傾向。一方で適応的ハフマンを使ったら圧縮率がわずかに上がった。でも多分、幾何分布に従うことを考えて静的でも良いかもしれない。この結果は参考にしたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まずは可変ブロックサイズ対応の前段階として、PARCOR係数による残差電力が実際の残差電力と一致するか観察する。
→そこそこ一致。傾向は合ってるかも。計算は&lt;code&gt;0次自己相関*Π(1-PARCOR^2)&lt;/code&gt;でやった。誤差が出ているのはfloatじゃないのが問題かも。理論はおそらく正しい。&lt;/p&gt;
&lt;p&gt;以下にその説明有り。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.jstage.jst.go.jp/article/ast/34/2/34_E1250/_pdf/-char/ja"&gt;Low-complexity PARCOR coefficient quantization and prediction order estimation designed for entropy coding of prediction residuals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;得られたPARCOR係数から残差電力を計算する関数を追加しておく。しかし係数の当てはまりの良さを考えるなら、&lt;code&gt;Π(1-PARCOR^2)&lt;/code&gt;（分散比。分散をどれだけ減らせたのかの比。）だけで良いはずなのでこれを計算する関数を追加した。エンコーダはこれを使って最小の残差を与えるブロックサイズを探す方針。&lt;/p&gt;
&lt;p&gt;次は、というか今日のメインとして、線形予測前にフィルタを突っ込んで見る。あと30分しかないけど！&lt;/p&gt;
&lt;p&gt;→NLMSを突っ込んだが悪化。FIRローパスは短い音声で大悪化、長い音声でほんの少し減少。他にできることがないか探してみる。&lt;/p&gt;
&lt;h3&gt;2019.4.21&lt;/h3&gt;
&lt;p&gt;可変ブロック対応に当たり、&lt;a href="https://www.jstage.jst.go.jp/article/ast/34/2/34_E1250/_pdf/-char/ja"&gt;上の論文&lt;/a&gt;を読んでいたら、ラプラス分布を仮定したときの符号長推定について書いてあった。これは大変に有益。これを使い、サンプルあたりの符号長としてブロックサイズを決めてみたい。&lt;/p&gt;
&lt;p&gt;16bit整数として計算したときに、かなりの精度で予測できていることが分かった。計算量的にも大きくないから、取り入れていく。&lt;/p&gt;
&lt;p&gt;なんだか実験がうまく行っていて、残り1時間あるからエイヤで組み込んでしまうか。&lt;/p&gt;
&lt;p&gt;なんか組み込めた。そして減った。観察の結果は次:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SPARKLEと俺の声は減った。しかし、ワン・ツー・スゥイーツでは増えている。&lt;/li&gt;
&lt;li&gt;窓をかけてPARCOR係数を計算して推定を行うと、圧縮率が悪化する。&lt;/li&gt;
&lt;li&gt;最大ブロックサイズを10240(232ms @44.1kHz)まで伸ばすべきかも。&lt;/li&gt;
&lt;li&gt;無音時にどうなっているか怪しい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;バグの調査が甘い（一応戻ることは確認している）が、速報値は以下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  40672844 Apr 21 20:45 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30850345 Apr 21 20:51 SPARKLE.sla
-rw-r--r--@  1 *  staff     51915 Apr 21 20:48 kisaragi_chihaya.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;家帰って試行錯誤。まずはfloatの正規化が抜けていたので&lt;code&gt;pow(2,-31)&lt;/code&gt;をかけた。また、最小ブロックサイズを小さくしすぎると(1024とか)ワン・ツー・スゥイーツの性能が悪くなった。逆に長くすると(4096とか)俺の声が悪化。&lt;/p&gt;
&lt;p&gt;一つバグがあって（符号長のチャンネル平均が取れていなかった）潰したところ、性能改善。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  40245317 Apr 22 00:02 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30800189 Apr 22 00:03 SPARKLE.sla
-rw-r--r--@  1 *  staff     51776 Apr 22 00:03 kisaragi_chihaya.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最大ブロックサイズを16384までしたところ次の結果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  40148214 Apr 22 00:30 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30783283 Apr 22 00:32 SPARKLE.sla
-rw-r--r--@  1 *  staff     53486 Apr 22 00:31 kisaragi_chihaya.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;たぶん最適割り当て問題になっている。今は、現在与えられたサンプル列を一番小さく符号化できそうなブロックサイズを使用している。これはグリーディな方法と言える。もしかしたら、エンコードすべきブロックの内容の先読みなり最適割り当てを行ったほうが性能がいいかも。当然良いはず。最大ブロック数分サンプルを見て、その中で最適な分割を探す問題とする。&lt;/p&gt;
&lt;p&gt;非線形量子化、危ないけど導入すべきか…あと線形予測前のフィルターも気になる…。TTAを参考にすべきか。&lt;/p&gt;
&lt;h3&gt;2019.4.22&lt;/h3&gt;
&lt;p&gt;TTAのソースの可読性が著しく低い（愚痴）。filter関数ですべてをやり切ってるけど、何やってるかさっぱり。コメントもない。
へらへらしていたら、Levinson-Durbin法とは別にBurg法というものがあることを知った。周波数分解能が高い（他に問題もある）らしい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.emptyloop.com/technotes/A%20tutorial%20on%20Burg's%20method,%20algorithm%20and%20recursion.pdf"&gt;Burg’s Method, Algorithm and Recursion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiita.com/hirokisince1998/items/fd50c0515c7788458fce"&gt;Pythonで線形予測分析 (LPC) を学ぶ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.opus-codec.org/docs/vos_fastburg.pdf"&gt;A Fast Implementation of Burg’s Method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pure.tue.nl/ws/portalfiles/portal/4337516/9214707.pdf"&gt;Algorithms for speech coding systems based on linear prediction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://jp.mathworks.com/help/dsp/ref/burgmethod.html"&gt;Burg Method(MATLAB, 自己相関等との比較)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;家帰って実装をしてみた。C++実装をもろ写経。予測してみたけどいい感じ（LPCより予測精度が高い）。
問題はPARCOR係数の解釈があっているかどうかというところ。&lt;/p&gt;
&lt;h3&gt;2019.4.23&lt;/h3&gt;
&lt;p&gt;Burg法実装がプロトタイプでできたので組み込んで様子を見る。三角関数の重ね合わせではLevinson法よりも予測精度が良かったけど、実wavに対しては良くならなかった。（窓を外しても、サイズを固定にしてもだめ）全体的にサイズ増加。何がいけないのかもよくわからない…。&lt;/p&gt;
&lt;p&gt;改めて残りの減少ネタ。上から優先順位高い方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;float → double&lt;/li&gt;
&lt;li&gt;ブロックサイズ決定を最大ブロックサイズから初め、最大ブロックサイズの中の小分割の中で一番サイズが小さくなるものを採用する&lt;/li&gt;
&lt;li&gt;エンコード高速化（最大ブロックサイズ毎で処理が独立になるので並列実行可能）にもなるので、こちらで行きたい。&lt;/li&gt;
&lt;li&gt;ロングタームを3次以上に対応させる&lt;/li&gt;
&lt;li&gt;平均（もしくは最大値が0xFF以下）が少ないときの符号化をハフマンに&lt;/li&gt;
&lt;li&gt;分散が異なるラプラス分布（もしくは幾何分布か？）のハフマン符号テーブルを作っておく。&lt;/li&gt;
&lt;li&gt;線形予測前のフィルター処理&lt;/li&gt;
&lt;li&gt;TAKのページを改めて見ると、2つのフィルターを本チャンの線形予測フィルタの前に入れることができるとのこと。&lt;/li&gt;
&lt;li&gt;一つは窓関数かもしれない。もう一つは一体何だ？プリエンファシスでは無いと思う。&lt;/li&gt;
&lt;li&gt;平均除去とか？&lt;/li&gt;
&lt;li&gt;ブロックサイズ推定を実測してみる&lt;/li&gt;
&lt;li&gt;窓関数の再考&lt;/li&gt;
&lt;li&gt;sin窓を今だに使い続けている&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.maroon.dti.ne.jp/twist/4C616E637A6F73B4D8BFF4A4CBA4E8A4EBB2E8C1FCA4CEB3C8C2E7BDCCBEAE.html"&gt;Lanczos窓&lt;/a&gt;とかどうだろうか&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.4.25&lt;/h3&gt;
&lt;h4&gt;小松観光計画&lt;/h4&gt;
&lt;p&gt;基本はGAFの聖地を優先。しかし一日で回りきれそう。空いた時間は風呂にしたい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://busaboko.net/airforce/"&gt;GAFの聖地一覧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;うつのみや小松城南店（本屋）&lt;/li&gt;
&lt;li&gt;莵橋神社&lt;/li&gt;
&lt;li&gt;8番ラーメン（城南末広店）&lt;/li&gt;
&lt;li&gt;安宅の関（海沿い）&lt;/li&gt;
&lt;li&gt;小松基地周辺&lt;/li&gt;
&lt;li&gt;風呂&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;日付&lt;/th&gt;
&lt;th align="center"&gt;何するか&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;4/27&lt;/td&gt;
&lt;td align="center"&gt;- コーデック圧縮率向上施策考案 &lt;br&gt; - コーデック評価スクリプト作成 &lt;br&gt; - デコードテスト追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;4/28&lt;/td&gt;
&lt;td align="center"&gt;- プリパラフレンドシップツアー &lt;br&gt; - 秋葉原で一泊&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;4/29&lt;/td&gt;
&lt;td align="center"&gt;- 絵師百 &lt;br&gt; - 深夜バス乗車（渋谷）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;4/30&lt;/td&gt;
&lt;td align="center"&gt;- 小松駅着。ロッカーに荷物を入れて聖地巡礼開始。&lt;br&gt; - 本屋→神社→安宅→小松基地？ &lt;br&gt; - 昼は8番ラーメン &lt;br&gt; - 夜は海鮮丼。駅前に戻って松屋旅館へ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;5/1&lt;/td&gt;
&lt;td align="center"&gt;- 温泉につかりながら作業 &lt;br&gt; - 加賀の宿　柴山温泉　ホテル翠湖で一泊。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;5/2&lt;/td&gt;
&lt;td align="center"&gt;- 温泉につかりながら作業 &lt;br&gt; - 金沢18:09発の新幹線で移動→19:59佐久平着。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;2019.4.26&lt;/h3&gt;
&lt;p&gt;ラプラス分布の最尤推定について。なんと、平均が0ならば単純な絶対値の標本平均が分散になる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://ikuro-kotaro.sakura.ne.jp/koramu/2732_s1.htm"&gt;観測データから確率密度関数を求める（その２）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.4.27&lt;/h3&gt;
&lt;p&gt;コーデック評価スクリプトを昨晩にやっつけで仕立て上げた。ほしいのは以下の表。CSVで出せると良い。&lt;/p&gt;
&lt;h5&gt;圧縮率&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;波形 / コマンド&lt;/th&gt;
&lt;th align="center"&gt;元波形[byte]&lt;/th&gt;
&lt;th align="center"&gt;&lt;code&gt;flac -8&lt;/code&gt;[byte]&lt;/th&gt;
&lt;th align="center"&gt;&lt;code&gt;flac -8&lt;/code&gt;[%]&lt;/th&gt;
&lt;th align="center"&gt;&lt;code&gt;wavpack -hh&lt;/code&gt;[byte]&lt;/th&gt;
&lt;th align="center"&gt;&lt;code&gt;wavpack -hh&lt;/code&gt;[%]&lt;/th&gt;
&lt;th align="center"&gt;...&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;いばらの女王&lt;/td&gt;
&lt;td align="center"&gt;20000000&lt;/td&gt;
&lt;td align="center"&gt;12000000&lt;/td&gt;
&lt;td align="center"&gt;50%&lt;/td&gt;
&lt;td align="center"&gt;...&lt;/td&gt;
&lt;td align="center"&gt;...&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;ハローハロー&lt;/td&gt;
&lt;td align="center"&gt;22000000&lt;/td&gt;
&lt;td align="center"&gt;14000000&lt;/td&gt;
&lt;td align="center"&gt;63%&lt;/td&gt;
&lt;td align="center"&gt;...&lt;/td&gt;
&lt;td align="center"&gt;...&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;累計[%]&lt;/td&gt;
&lt;td align="center"&gt;42000000&lt;/td&gt;
&lt;td align="center"&gt;26000000&lt;/td&gt;
&lt;td align="center"&gt;62%&lt;/td&gt;
&lt;td align="center"&gt;...&lt;/td&gt;
&lt;td align="center"&gt;...&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5&gt;デコード速度&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;波形 / コマンド&lt;/th&gt;
&lt;th align="center"&gt;元波形[ms]&lt;/th&gt;
&lt;th align="center"&gt;&lt;code&gt;flac -8&lt;/code&gt;[ms]&lt;/th&gt;
&lt;th align="center"&gt;&lt;code&gt;flac -8&lt;/code&gt;[x]&lt;/th&gt;
&lt;th align="center"&gt;&lt;code&gt;wavpack -hh&lt;/code&gt;[ms]&lt;/th&gt;
&lt;th align="center"&gt;&lt;code&gt;wavpack -hh&lt;/code&gt;[x]&lt;/th&gt;
&lt;th align="center"&gt;...&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;いばらの女王&lt;/td&gt;
&lt;td align="center"&gt;2000&lt;/td&gt;
&lt;td align="center"&gt;20&lt;/td&gt;
&lt;td align="center"&gt;100&lt;/td&gt;
&lt;td align="center"&gt;...&lt;/td&gt;
&lt;td align="center"&gt;...&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;ハローハロー&lt;/td&gt;
&lt;td align="center"&gt;2200&lt;/td&gt;
&lt;td align="center"&gt;22&lt;/td&gt;
&lt;td align="center"&gt;100&lt;/td&gt;
&lt;td align="center"&gt;...&lt;/td&gt;
&lt;td align="center"&gt;...&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;累計[%]&lt;/td&gt;
&lt;td align="center"&gt;4200&lt;/td&gt;
&lt;td align="center"&gt;42&lt;/td&gt;
&lt;td align="center"&gt;100&lt;/td&gt;
&lt;td align="center"&gt;...&lt;/td&gt;
&lt;td align="center"&gt;...&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;秋葉原製作所5hコースで作業し、上記の表に該当する結果は得られた。軽く自分の声で試してみると、やはりまだ圧縮率が悪い。。。tta,wavpackよりも下。振幅が小さいデータに対する圧縮率が悪い傾向がある。&lt;/p&gt;
&lt;h3&gt;2019.4.29&lt;/h3&gt;
&lt;p&gt;今日は22:45渋谷発小松行きに乗るまでで作業する。やることはラプラス分布の最尤推定の当てはまりがどれくらい良いか確かめること。&lt;/p&gt;
&lt;p&gt;見ているけどラプラス分布で当てはまりはあまり良くない…。正規分布はひどい（0近辺の当てはまりが絶望的）。幾何分布が一番当てはまりが良い印象（SPARKLEはよく当てはまるが、それ以外の音源で微妙…）。やるとしても幾何分布か…。&lt;/p&gt;
&lt;p&gt;そもそも、符号化手法を考え直すべきか…。適応的に分布が小さくなっていたらランレングスに切り替える符号化有り。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/Malvar_DCC06.pdf"&gt;Adaptive Run-Length / Golomb-Rice Encoding of Quantized Generalized Gaussian Sources with Unknown Statistics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;wavpackの動作原理はわかっている（つもり）だから、TTAのソース読もうか…&lt;/p&gt;
&lt;p&gt;```c:ttaのエンコードソースの一部
__forceinline void tta_encoder_put_value(TTA_adapt *rice, TTAint32 value) {
    TTAuint32 k, unary, outval;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ENC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Rice&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice-&amp;gt;k0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice-&amp;gt;k0 + 1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_shift&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_shift&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice-&amp;gt;k1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice-&amp;gt;k1 + 1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;write_byte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;23&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;binary&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;write_byte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;} // tta_encoder_put_value&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nt"&gt;おそらく2つのライス符号パラメータで再帰ライス符号になっている&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="nt"&gt;値が小さいときの処理は特にしていないように見える&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="nt"&gt;固定フィルター&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;31&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;32&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*(&lt;/span&gt;&lt;span class="nt"&gt;前サンプル&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;のあとに謎の適応フィルタを入れている&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;__固定フィルターはプリエンファシスだ&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="nt"&gt;そういえば整数で試してなかった&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="nt"&gt;俺も試すべき__&lt;/span&gt;&lt;span class="err"&gt;）。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;固定フィルター処理&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="nn"&gt;define&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;PREDICTOR1&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;k&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;k&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;k&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c"&gt;/* ...snip... */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;compress&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;stage&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;fixed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;prediction&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;temp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;curr&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;curr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;PREDICTOR1&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;enc-&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;prev&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;5&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;enc-&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;prev&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;temp&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;FLACについても、値が小さいときの処置は特に無い。wavpackも多分無い（読んでみようと思うが…）。&lt;/p&gt;
&lt;h3&gt;2019.4.30&lt;/h3&gt;
&lt;p&gt;小松観光。ガーリー・エアフォースの聖地を一通りあさった。今日はあんまり何もできないだろうけど、明日明後日は場所を変えて作業するつもり。5/3からは実家にて作業予定。&lt;/p&gt;
&lt;p&gt;上記のプリエンファシスを試してみる…と100KBクラスで減少した。効果あり。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  40129181 Apr 30 23:07 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30704135 Apr 30 23:06 SPARKLE.sla
-rw-r--r--@  1 *  staff     51787 Apr 30 23:07 kisaragi_chihaya.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;実装を整理（関数化）して就寝。令和が始まった。
振幅が小さい音声の圧縮率がwavpack, ttaと比べて低いのが気になる。&lt;/p&gt;
&lt;h3&gt;2019.5.1&lt;/h3&gt;
&lt;p&gt;15:00ホテル翠湖にチェックイン。wi-fiが飛んでいないので、オフラインで作業する。&lt;/p&gt;
&lt;p&gt;テーマを1つ決めて試してみたい。昨日今日でやろうと思ったのが、非線形量子化。以前試した時はむしろ悪化する事がわかっていた。そこで、今回は2次成分までを&lt;code&gt;arcsin&lt;/code&gt;によって非線形量子化してみた。&lt;/p&gt;
&lt;p&gt;結果は、微減（俺の声は1バイト減少、SPARKLEは数百バイト減少、ワン・ツー・スィーツは数十バイト減少）。16bitも割り当ててあれば線形量子化でも十分ということを示している結果だと思う。本を読んでいると、ビット割当数は4-12bitと低くなっている。如何に低いビット数で同一の結果が出せるか…というところに着目すると、非線形量子化は効いてくるらしい。もし、極限までサイズを減らすことを考えるならば、非線形量子化を適用して良いかもしれない。が、処理の単純化（サイズ削減が処理の複雑化に対して見合ってない）と、減らせるサイズが高々数KBで本質的にサイズ削減になっていないので、16bitで良いと思う。&lt;/p&gt;
&lt;p&gt;非線形量子化があまり美味しい策では無いことが分かった。本日は、ブロックサイズ決定の処理を&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ブロックサイズ決定を最大ブロックサイズから初め、最大ブロックサイズの中の小分割の中で一番サイズが小さくなるものを採用する&lt;/li&gt;
&lt;li&gt;エンコード高速化（最大ブロックサイズ毎で処理が独立になるので並列実行可能）にもなるので、こちらで行きたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;に変えてみる。これ、一見減らないように見えるけどどうだろうか。FLACはこれとほぼ同じやり方をしている。wavpackとTTAのブロックサイズ決定方式を見て、風呂に入る。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TTAはサンプリングレート依存で決まる固定サイズっぽい。（かなり大きい。フィルターがLPCじゃないから、20ms程度にしなくてもOKなのかも）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;```c:libtta.h
typedef struct {
    TTAuint32 format;   // audio format
    TTAuint32 nch;  // number of channels
    TTAuint32 bps;  // bits per sample
    TTAuint32 sps;  // samplerate (sps)
    TTAuint32 samples;  // data length in samples
} TTA_ALIGNED(16) TTA_info;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;libtta&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;c&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="nn"&gt;define&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;MUL_FRAME_TIME&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;256&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;245&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;FRAME_TIME&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c"&gt;/* ...snip... */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;dec_flen_std&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;MUL_FRAME_TIME&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;info-&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;sps&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;wavpackはサンプリングレートとチャンネル数依存ぽい。けど謎ルール。。。コメントに妥協しているみたいなことが書いてある。計算の結果&lt;code&gt;wpc-&amp;gt;block_size&lt;/code&gt;にブロックサイズが入り、処理途中に変更することはない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;```c:pack_utils.c
int WavpackPackInit (WavpackContext *wpc)
{
    if (wpc-&amp;gt;metabytes &amp;gt; 16384)             // 16384 bytes still leaves plenty of room for audio
        write_metadata_block (wpc);         //  in this block (otherwise write a special one)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// The default block size is a compromise. Longer blocks provide better encoding efficiency,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// but longer blocks adversely affect memory requirements and seeking performance. For WavPack&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// version 5.0, the default block sizes have been reduced by half from the previous version,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// but the difference in encoding efficiency will generally be less than 0.1 percent.&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nf"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dsd_multiplier&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;block_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sample_rate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;48000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;44100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nf"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_HIGH_FLAG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;block_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nf"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;num_channels&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;block_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;block_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;12000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;block_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;num_channels&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;300000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;block_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;divisor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_HIGH_FLAG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sample_rate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;divisor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;divisor&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;block_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sample_rate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;divisor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;block_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;12000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;block_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;num_channels&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;75000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;block_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;block_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;num_channels&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;wpc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;block_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;wavpackの予測はsign&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LMSに基づいているらしい。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;9.10&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;THE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NORMALIZED&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SIGN&lt;/span&gt;&lt;span class="nv"&gt;?&lt;/span&gt;&lt;span class="n"&gt;SIGN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LMS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;ALGORITHM&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;oreilly&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;library&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;view&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;adaptive&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;filtering&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;9781482253351&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;xhtml&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;20_Chapter09a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xhtml&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Lecture&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;RX&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FIR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CTLE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DFE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Adaptive&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Eq&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ece&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tamu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;edu&lt;/span&gt;&lt;span class="o"&gt;/~&lt;/span&gt;&lt;span class="n"&gt;spalermo&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ecen689&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lecture8_ee720_rx_adaptive_eq&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pdf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Lecture&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Variants&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LMS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;algorithm&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tut&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fi&lt;/span&gt;&lt;span class="o"&gt;/~&lt;/span&gt;&lt;span class="n"&gt;tabus&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;course&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ASP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;SGN2206LectureNew5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pdf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;3番目の記事を読んでいたら、Signed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LMSは絶対値誤差の最小化に基づいているので、もしかしたらライス符号化に適しているかもしれない。実装は簡単なので早速試したところ、俺の声は1バイト減少したが、SPARKLEとワン・ツー・スィーツは悪化。これは、大振幅音源に弱いという、wavpackと同様の傾向を示している？&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;ちょっと待て、sign&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LMS&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;性能高いのでは…？今までのNLMSの性能を超えている（タップを増やした時のサイズ減少が大きい）。ちょっと冷静になるために風呂に入る。確かめること：&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;係数の重み&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;高次数にした時は重みを小さくしないと性能悪化に転じる。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;高次数で小さくなるような重み付けをすると性能改善が見られた。次数を増やすと性能悪化することもあった。次数に応じた重み付けを定式化できると良さそう。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;カスケード接続は有効か？&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;一部有効だった。（次数20を1回適用するより、次数5を4回適用したほうが減る。しかし、1つあたり次数を1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;2等減らしすぎると悪化する。これはNLMS（正規化LMS）では見られなかったことだ。）&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;冷静になってwavpackの実装を見ている。&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`decorr_tables.h`&lt;/span&gt;&lt;span class="n"&gt;にテーブルが示されているが固定値のマジックナンバーにしか見えない…。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LMSが有効で、NLMSよりも良い結果が出せることが明らかになったため、NLMSをsign&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LMSに切り替える。同時にカスケード数をパラメータ化する。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;軽く負荷を測ったらLMSの係数更新で結構食ってた。でも、係数更新は符号だけできまるから、テーブル引きに変えられるはず。→2019&lt;/span&gt;&lt;span class="mf"&gt;.5.2&lt;/span&gt;&lt;span class="n"&gt;の朝にやった。x400がx200になった。しかしまだ負荷が高い状態。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;### 2019.5.2&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;金沢に移動。特急券の時間を変えてもらって16&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;09発の新幹線に乗った。17&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;56佐久平着までに進められるだけ進める。やりたいのは、上記の高速化。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;『音声の線形予測』を読んでいると、1乗算型を実現するのは困難であることが分かる。1乗算型は通常の格子フィルタをKelly&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Lochbaumモデルに変形してから導き出すが、それを行うと、追加でタップパラメータを計算する必要が出てくる。タップパラメータの計算精度を担保するのは難しい上に、（次数分の）追加の記憶容量が必要になるので到底許容できない。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;### 2019.5.3&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;実家にて作業。RGRいわきはしゃあない。圧縮をどうしても優先したかった（人生に関わることだから）。本日は以下の作業を行う予定：&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ブロックサイズ決定を最大ブロックサイズから初め、最大ブロックサイズの中の小分割の中で一番サイズが小さくなるものを採用する&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;エンコード高速化（最大ブロックサイズ毎で処理が独立になるので並列実行可能）にもなるので、こちらで行きたい。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n n-Quoted"&gt;`float -&amp;gt; double`&lt;/span&gt;&lt;span class="n"&gt;はエイヤでやる。なまじ高速化を意識するから気持ちが悪いことになっているのだ。&lt;/span&gt;&lt;span class="n n-Quoted"&gt;`double`&lt;/span&gt;&lt;span class="n"&gt;でちゃんと動くものを作って（アルゴリズム的に高速化して）、後で実装レベルの高速化を行えば良い。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;→やった。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;ブロックサイズ決定の前に、今の圧縮結果をメモしておく。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-rw-r--r--@  1 *  staff  39849911 May  3 12:37 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30014592 May  3 12:37 SPARKLE.sla
-rw-r--r--@  1 *  staff     51122 May  3 12:36 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff    777422 May  3 12:40 voice48a.sla
-rw-r--r--@  1 *  staff  23332503 May  3 12:39 Dream_goes_On.sla&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;当初の目標&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;ワン&lt;/span&gt;&lt;span class="err"&gt;・&lt;/span&gt;&lt;span class="n"&gt;ツー&lt;/span&gt;&lt;span class="err"&gt;・&lt;/span&gt;&lt;span class="n"&gt;スィーツで40MB切る&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;&lt;span class="n"&gt;は既に達成済みではある&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;長尺の音声ではwavpack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;hhの最高圧縮&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ttaよりよい圧縮率を出している状況&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;しかし眼前にはTAKがいる&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;最大ブロックサイズの小分割の件&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;等分割による実装はできたが&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;圧縮率が悪化&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;当然な気がする&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;以前は現段階での最小推定値を常に使用していたのだから&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;最大ブロックサイズ内の分割についていい方法は無いか考えていたら&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;どうも最短経路問題に帰着できそうな気配&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;符号長さが辺の重みになる&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;ダイクストラ法が適用できる&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ダイクストラ法(C言語)&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;9.&lt;/span&gt;&lt;span class="n"&gt;hatenadiary&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;entry&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2018&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;01&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;190000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ダイクストラ (Dijkstra) 法&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;nw&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tsuda&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ac&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lec&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dijkstra&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ダイクストラ法のコア部分は多分できている&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;テスト中&lt;/span&gt;&lt;span class="err"&gt;）。&lt;/span&gt;&lt;span class="n"&gt;風呂入っている時に&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;アルファ符号取得の高速化は8bitパターンの結果を全てキャッシュしておけば良さそうだというのを思いつく&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nl"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;擬似コード&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;zero_runlength_table&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0xFF&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 0 -&amp;gt; 8 */&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* 1 -&amp;gt; 0 */&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* 2 -&amp;gt; 1 */&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;zero_runlength_table&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bitsbuf&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* もし8ならばまだ続いているので再度読み込む */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;25:30 やっつけでなんか動いているけど、結果はあまり良くない。等分割よりはすこし良くなった程度。しかし、一つ工夫を考えられた。探索範囲を広くとってその中で探索する。その時大事なのが最大ブロックサンプル数=探索範囲とせず、最大ブロックサンプル数&amp;lt;探索範囲とすること。こうすることで、より広い範囲の探索で最適な割り当てを探れるようになるはず。&lt;/p&gt;
&lt;p&gt;26:20 上記の修正を当てようとしてバグを踏んでる。エンコードコンフィグの最大ブロックサイズを探索範囲より小さくし、最大ブロックサンプル数&amp;lt;探索範囲としたときにバッファオーバーランしておかしなことになってる。探索範囲もコンフィグから指定できると良い。&lt;/p&gt;
&lt;h3&gt;2019.5.3&lt;/h3&gt;
&lt;p&gt;デバッグ作業。無音に近い時に推定符号長が負値になってダイクストラ法がうまく動かないバグがあった。&lt;/p&gt;
&lt;p&gt;とりあえず動いているようだけども結果は良くない。短い音声では良くなったが、長い音声で軒並み悪化。あがいてプリエンファシスをかけた音声に解析を行うけども結果は悪化。&lt;/p&gt;
&lt;p&gt;振幅が大きい音声では、どうも長めにブロックサイズを割り当てた方がサイズが減るようだ。（最低ブロックサイズを増やしたところ比較的性能向上）LMSがいい味出していて、収束して圧縮が効いてくるまでに長いブロックサイズを必要としているように見える。&lt;/p&gt;
&lt;p&gt;しっかし原理的にはその場で最短符号を探すよりも、広い範囲での最短符号を探したほうが絶対良いと思うのだが…実装ミスを疑う。&lt;/p&gt;
&lt;p&gt;あとは、探索範囲を広げてみる。→傾向は上と同じ…最低ブロックサイズに引っ張られている。原理的に減るはずなのに、おかしい…。&lt;/p&gt;
&lt;p&gt;推定コード長にブロックヘッダサイズを付加することで多少安定した。それでも傾向はほぼ同じ。もしかして原理的に減らないのかもしれない。グリーディな方法と選ばせるのが良いか？&lt;/p&gt;
&lt;p&gt;→最大ブロックサイズを16384から12288に変えたら、比較的結果が安定した。16384では長すぎる？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  39868406 May  4 18:54 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30161132 May  4 18:54 SPARKLE.sla
-rw-r--r--@  1 *  staff     50984 May  4 18:53 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff    772613 May  4 18:54 voice48a.sla
-rw-r--r--@  1 *  staff  23259269 May  4 18:55 Dream_goes_On.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;短くかつ振幅が小さい音源の性能が改善したが、振幅の大きい音声（特にSPAKLE）は悪化。&lt;/p&gt;
&lt;p&gt;いろいろあがいていたら20:30。終わりが見えてきている。ブロックヘッダサイズを大きくとったら全体的に性能が安定した。どうやら、パスを長くした時のペナルティを多くしたほうが性能が安定するようだ（実際、ブロックサイズを細かくしすぎると、ブロック先頭の残差増加や、LMSが収束しない等が発生してサイズが増加する）。ペナルティサイズを350byteにした時の結果は以下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  39761815 May  4 21:38 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30049221 May  4 21:38 SPARKLE.sla
-rw-r--r--@  1 *  staff     51077 May  4 21:39 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff    773953 May  4 21:39 voice48a.sla
-rw-r--r--@  1 *  staff  23297954 May  4 21:39 Dream_goes_On.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;全部下がったわけではないが、性能は安定しているようだし、これで一旦Fixとしようか。（グリーディな方法と比較したところ、自分の声シリーズで0.2%改善、アイカツ楽曲で0.1%悪化。今の状態でバランスが取れたし、また並列エンコードへの道が見えたからこれでFixとする。）&lt;/p&gt;
&lt;p&gt;→コードを整理してコミット。&lt;/p&gt;
&lt;p&gt;時間がかかるようになっているので、ネックになっているところを調べたら自己相関が馬鹿になっていなかった。自己相関を簡単に高速化した。&lt;/p&gt;
&lt;p&gt;```c:高速化前
  /&lt;em&gt; （標本）自己相関の計算 &lt;/em&gt;/
  for (delay_time = 0; delay_time &amp;lt; order; delay_time++) {
    auto_corr[delay_time] = 0.0f;
    /&lt;em&gt; 係数が0以上の時のみ和を取る &lt;/em&gt;/
    for (i_sample = delay_time; i_sample &amp;lt; num_sample; i_sample++) {
      auto_corr[delay_time] += data[i_sample] * data[i_sample - delay_time];
    }
  }&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;上記の計算だと積算で使用する項に重複が出る&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="n"&gt;重複を排除したのが以下の計算&lt;/span&gt;&lt;span class="err"&gt;（『&lt;/span&gt;&lt;span class="n"&gt;音声の線形予測&lt;/span&gt;&lt;span class="err"&gt;』&lt;/span&gt;&lt;span class="n"&gt;とFLACを参考にしている&lt;/span&gt;&lt;span class="err"&gt;）。&lt;/span&gt;&lt;span class="n"&gt;重複する項を&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;に受けて積和演算を行っている&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nl"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;高速化後&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* 係数初期化 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;order&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lag&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lag&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* 次数の代わりにデータ側のラグに注目した自己相関係数計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;order&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 同じラグを持ったデータ積和を取る */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;order&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lag&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lag&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;smpl + lag&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lag&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lag&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;smpl + lag&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根本的にはFFTを使うべき…。&lt;/p&gt;
&lt;h3&gt;2019.5.4&lt;/h3&gt;
&lt;p&gt;明日の帰りが早いこともあるので今日は大きな実装変更はしない予定。エンコード負荷が気になるので計測と可能ならば手直しを入れる。&lt;/p&gt;
&lt;p&gt;ロングタームの3,5,...対応はまだ後回し。&lt;/p&gt;
&lt;p&gt;負荷結果をざっと見ると、負荷が大きいのは自己相関計算に尽きる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最適分割探索の際の係数計算における自己相関&lt;/li&gt;
&lt;li&gt;ロングターム係数計算時のFFTによる自己相関&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SIMD, OpenMPで頑張るのはまだ先の話。（俺がやるべきでも無いと思う）&lt;/p&gt;
&lt;p&gt;LMSの更新量の重みを上げた（右シフト9から右シフト7に変えた）ところ性能が上がった…。（右シフト6では悪化に転じた。）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  39571790 May  5 16:31 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29824752 May  5 16:30 SPARKLE.sla
-rw-r--r--@  1 *  staff     50937 May  5 16:30 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff    770970 May  5 16:32 voice48a.sla
-rw-r--r--@  1 *  staff  23047704 May  5 16:34 Dream_goes_On.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;まだSign-Sign LMSには謎が多い。一回腰を据えて適応フィルタの理論を読むべきか。→日本語版が法外に高いので英語版を購入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://users.ics.forth.gr/tsakalid/UVEG09/Book/Haykin-AFT(3rd.Ed.)_Introduction.pdf"&gt;Adaptive Filter Theory 3rd（イントロのみ）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sign-Sign LMSの計算途中で、係数が32bitの範囲でオーバーフローしていることが分かった。係数を32bitにしたら圧縮性能が堕ちたので判明。FIRフィルターだから係数の範囲は予測できない…。どっかで制限をかける等できれば…。&lt;/p&gt;
&lt;h3&gt;2019.5.5&lt;/h3&gt;
&lt;p&gt;昨日の自己相関の計算が遅い件について、もう少し早いアルゴリズムが『音声のディジタル信号処理（上）』の172pあたりに書いてあったので実装中。&lt;/p&gt;
&lt;p&gt;→実装したが速度に納得できず、しかも複雑になっている。本に書いてある計算式は変形自己相関で、データのインデックスが飛び出ることを許す式になっている。（平均を常にNで割って行える式）なので自前で簡潔な実装にしようとしたところ、案の定ハマる。&lt;/p&gt;
&lt;p&gt;RL見なければいけないので一旦置く。。。&lt;/p&gt;
&lt;h3&gt;2019.5.7&lt;/h3&gt;
&lt;p&gt;5.6は実家から返りながら上の自己相関計算の高速化をやっていた。変形自己相関ではない方法で計算する実装は2019.5.7にできた。テストもOKで、2倍とは行かないまでもSPARKLEで自己相関計算負荷が44%が39.8%になっているのは確認した。有意に早くなっている。&lt;/p&gt;
&lt;h3&gt;2019.5.13&lt;/h3&gt;
&lt;p&gt;いよいよ手詰まりとなる。（ロングターム係数を増やすのはまだだが）&lt;/p&gt;
&lt;p&gt;TAKのデコーダ実装がffmpegに含まれていた：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/FFmpeg/FFmpeg/blob/a0ac49e38ee1d1011c394d7be67d0f08b2281526/libavcodec/takdec.c"&gt;libavcodec/takdec.c&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;といっても新しいバージョンではデコードできないとのこと。。。（パッチも当てられていない…）。読んでいるが、謎のテーブルを使用しているのが目につく。（TAKの公式ページではハフマンとライスを組み合わせたものと言っていた。だから、ライス符号パラメータをインデックスにした静的ハフマン符号ではないかと予測する。）&lt;/p&gt;
&lt;p&gt;ロングターム係数の次数を増やして、効果を見て区切りかな。
他に気付いている点は、格子型フィルタの前向き誤差は実はメモリに持たなくても実装できる点くらいだろうか…&lt;/p&gt;
&lt;h3&gt;2019.5.18&lt;/h3&gt;
&lt;p&gt;平日は時間あまり取れず。やっつけでLU分解のソースを移植したくらい。LU分解では処理中にワーク領域を必要としていたので、ハンドルをもたせた。また、計算時のユーティリティだから、SLAUtilityに置く。&lt;/p&gt;
&lt;p&gt;→15:20 LU分解によるソルバー追加完了。あとは解いて様子見。&lt;/p&gt;
&lt;p&gt;思いつきでPARCOR音声合成の僅かな高速化。実は合成時は前向き誤差を保存する必要はない。&lt;/p&gt;
&lt;p&gt;```c:変更前
    /&lt;em&gt; 誤差入力 &lt;/em&gt;/
    forward_residual[order] = (int64_t)residual[samp];
    for (ord = order; ord &amp;gt;= 1; ord--) {
      /&lt;em&gt; 前向き誤差計算 &lt;/em&gt;/
      mul_temp = SLAUTILITY_SHIFT_RIGHT_ARITHMETIC(parcor_coef[ord] * backward_residual[ord - 1] + half, 31);
      forward_residual[ord - 1] = forward_residual[ord] + mul_temp;
      /&lt;em&gt; 後ろ向き誤差計算 &lt;/em&gt;/
      mul_temp = SLAUTILITY_SHIFT_RIGHT_ARITHMETIC(parcor_coef[ord] * forward_residual[ord - 1] + half, 31);
      backward_residual[ord] = backward_residual[ord - 1] - mul_temp;
    }
    /&lt;em&gt; 合成信号 &lt;/em&gt;/
    assert((forward_residual[0] &amp;lt;= INT32_MAX) &amp;amp;&amp;amp; (forward_residual[0] &amp;gt;= INT32_MIN));
    output[samp] = (int32_t)(forward_residual[0]);
    /&lt;em&gt; 後ろ向き誤差計算部にデータ入力 &lt;/em&gt;/
    backward_residual[0] = forward_residual[0];&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nl"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;変更後&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 誤差入力 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;int64_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;forward_res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;residual&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;samp&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;order&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="cm"&gt;/* 前向き誤差計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SLAUTILITY_SHIFT_RIGHT_ARITHMETIC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parcor_coef&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord - 1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;half&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;forward_res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="cm"&gt;/* 後ろ向き誤差計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SLAUTILITY_SHIFT_RIGHT_ARITHMETIC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parcor_coef&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;forward_res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;half&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ord - 1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mul_temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 合成信号 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;forward_res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INT32_MAX&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forward_res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INT32_MIN&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;samp&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int32_t&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;forward_res&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 後ろ向き誤差計算部にデータ入力 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;backward_residual&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;forward_res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前向き誤差がキャッシュされるので当然早くなる。SPARKLEで100ms（全体で15.8%→10.7%）程の改善。遊んでないで、ロングタームに戻ろう。&lt;/p&gt;
&lt;p&gt;ロングターム実装OK。早速、タップ数を上げて試してみる。&lt;/p&gt;
&lt;p&gt;```sh:タップ数3
-rw-r--r--@  1 *  staff  39556836 May 18 16:57 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29836474 May 18 16:56 SPARKLE.sla
-rw-r--r--@  1 *  staff     50923 May 18 16:58 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff    770757 May 18 16:55 voice48a.sla
-rw-r--r--@  1 *  staff  23064285 May 18 16:58 Dream_goes_On.sla&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;```sh:タップ数5
-rw-r--r--@  1 *  staff  39568754 May 18 17:02 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29847311 May 18 17:03 SPARKLE.sla
-rw-r--r--@  1 *  staff     50930 May 18 17:01 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff    771036 May 18 17:01 voice48a.sla
-rw-r--r--@  1 *  staff  23064514 May 18 17:03 Dream_goes_On.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上げたら悪化（効果はあまり大きくない）。これはもしかしたらロングターム係数失敗回数が多くなっているのかもしれない。簡単に調べたところその通りで、SPARKLEでは、タップ数3で406回、タップ数5で742回失敗していた。係数が安定するまでタップ数を落とすのがいいかも。（とりあえず今は、係数が発散していたらタップ数を強制的に1にしている。）また、ロングタームを複数回適用するのも有りかも。（効果は薄そう…一番のピッチをロングタームで潰しても少ししか効果がなかったし…）&lt;/p&gt;
&lt;p&gt;実装をまとめた。これにてベータ版としたい。もう1MB減らすアイデアがあればTAKを倒せるが…。&lt;/p&gt;
&lt;h3&gt;2019.5.19&lt;/h3&gt;
&lt;p&gt;以下の論文を読んでいた：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pdfs.semanticscholar.org/ad7c/dc0865ff40fcac9bae02ccc77a24105a4e26.pdf"&gt;THE LOG?LOG LMS ALGORITHM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要は、LMSの計算の係数更新で、最も近い2の冪数に変えて演算するように変えたもの。今はSign-Sign LMSだが、筆者は論文の中で、それは非常に荒く量子化した状態と同じと言及していた（理論的には、絶対値誤差を最小にしているのだが…）&lt;/p&gt;
&lt;p&gt;そこで、Sign-Signをナイーブにやるのではなく、負荷は上がるけど誤差項のみlog2を取るように変えてみた（注：上の論文とは違う。論文では最も近い2の冪数にしていたが、こっちは単純にlogをとっている）ら、ほとんどの音源で性能が向上。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-rw-r--r--@  1 *  staff  39555825 May 19 18:45 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29780060 May 19 19:04 SPARKLE.sla
-rw-r--r--@  1 *  staff     50879 May 19 19:02 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  23082381 May 19 18:47 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    770037 May 19 18:53 voice48a.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（Dream goes onで性能悪化している。それ以外は向上。）&lt;/p&gt;
&lt;p&gt;どうするか。これ取り込んでFixとする？→取り込み、更新をテーブル引きにした。これで一旦beta版としよう。&lt;/p&gt;
&lt;h3&gt;2019.5.21&lt;/h3&gt;
&lt;p&gt;LMSの係数更新って毎サンプル行う必要はあるのだろうか。更新間隔を間引いてもいいのかも？&lt;/p&gt;
&lt;p&gt;VSで負荷計ったら、復号処理でアルファ符号を取得するところが遅いことが分かった。やはりバイトパターンテーブルからランレングスを取るのがいいかも。やってみる。&lt;/p&gt;
&lt;p&gt;他にも自己相関の加算対象はオート変数が良いかも。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wandbox.org/permlink/Fqtn0WIBvyGaPWYg"&gt;wandboxdで試作したラン長取得マスク&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.5.23&lt;/h3&gt;
&lt;p&gt;コマンドラインパーサを作りたい。業務が終わらんくてあんまり作業できてない。&lt;/p&gt;
&lt;p&gt;なんとかアルファ符号取得時にテーブルを使用するように変えて、速度向上。もう一度負荷計測したら、GetBitsとそのLog2Ceilで負荷がかかっていた：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* ライス符号の剰余部分取得 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SLABitStream_GetBits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SLAUtility_Log2Ceil&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rest&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;この引数で渡しているmは2の冪数だから、高速にlog2できないか？&lt;/p&gt;
&lt;h3&gt;2019.5.25&lt;/h3&gt;
&lt;p&gt;みなとみらい（ランドマークプラザ）のコメダ。
今日はlog2ceilの高速化をまずやってコマンドラインパーサの仕様を考える。log2ceilの高速化まあOK。要はテーブル引き。効果はわずかだが、確かに早くはなっている。&lt;/p&gt;
&lt;p&gt;コマンドラインパーサの仕様を考える。まず汎用に使いたいので名前は&lt;code&gt;command_parser.[ch]&lt;/code&gt;とする。ヘッダは、&lt;/p&gt;
&lt;p&gt;```c:command_parser.h&lt;/p&gt;
&lt;h1&gt;include &lt;stdint.h&gt;&lt;/h1&gt;
&lt;p&gt;/&lt;em&gt; 最大の文字列バッファサイズ &lt;/em&gt;/&lt;/p&gt;
&lt;h1&gt;define COMMAND_PARSER_MAX_STRING_BUFFER_SIZE   256&lt;/h1&gt;
&lt;p&gt;/&lt;em&gt; 取得結果 &lt;/em&gt;/
typedef enum CommandPaeserResultTag {
    COMMAND_PARSER_RESULT_OK,                             /&lt;em&gt; 正常終了 &lt;/em&gt;/
    COMMAND_PARSER_RESULT_INSUFFICIENT_FILE_BUFFER_SIZE,  /&lt;em&gt; ファイルバッファサイズが足らない &lt;/em&gt;/
    COMMAND_PARSER_RESULT_NOT_SPECIFY_OPTION_TO_ARGUMENT, /&lt;em&gt; 引数の指定が必須のオプションが指定されていない &lt;/em&gt;/
    COMMAND_PARSER_RESULT_NOT_SPECIFY_MANDATORY_OPTION,   /&lt;em&gt; 指定が必須のオプションが指定されていない &lt;/em&gt;/
    COMMAND_PARSER_RESULT_UNKOWN_OPTION,                  /&lt;em&gt; 定義にないオプションが指定された &lt;/em&gt;/
} CommandPaeserResult;&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 論理定数 &lt;/em&gt;/
typedef enum CommandParserBoolTag {
    COMMAND_PARSER_FALSE = 0,   /&lt;em&gt; 偽 &lt;/em&gt;/
    COMMAND_PARSER_TRUE,        /&lt;em&gt; 真 &lt;/em&gt;/
} CommandParserBool;&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; コマンドラインパーサ仕様 &lt;/em&gt;/
struct CommandParserSpecification {
    char                short_option;       /&lt;em&gt; [in] 短いオプション文字列 &lt;/em&gt;/
    const char&lt;em&gt;         long_option;        /&lt;/em&gt; [in] 長いオプション文字列 &lt;em&gt;/
    CommandParserBool   need_argument;      /&lt;/em&gt; [in] オプションに引数は必要か？ &lt;em&gt;/
    CommandParserBool   mandatory;          /&lt;/em&gt; [in] 引数の指定は必須か？ &lt;em&gt;/
    const char&lt;/em&gt;         description;        /&lt;em&gt; [in] 引数の説明 &lt;/em&gt;/
    char                argument_string[COMMAND_PARSER_MAX_STRING_BUFFER_SIZE]; /&lt;em&gt; [out] 得られた文字列 &lt;/em&gt;/
    CommandParserBool   is_acquired;        /&lt;em&gt; [out] オプションが指定されたか？ &lt;/em&gt;/
};&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 引数説明の印字 &lt;/em&gt;/
void CommandParser_PrintDescription(const CommandParserSpecification* cps);&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; 引数のパース &lt;/em&gt;/
CommandPaeserResult CommandPaser_ParseArguments(
    int32_t argc, const char&lt;strong&gt; argv,
    struct CommandParserSpecification* cps,
    char&lt;/strong&gt; filename_list, uint32_t filename_list_size);&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;コマンドラインパーサ仕様の定義例&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;CommandParserSpecification&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;arguments&lt;/span&gt;&lt;span class="cp"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c"&gt;/* 入力ファイル: ショートオプション&amp;#39;i&amp;#39;, ロングオプション&amp;quot;input&amp;quot;, 引数必須, 指定必須 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;#39;i&amp;#39;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;input&amp;quot;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;COMMAND_PARSER_TRUE,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;COMMAND_PARSER_TRUE,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;file&amp;quot;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c"&gt;/* 出力ファイル: ショートオプション&amp;#39;o&amp;#39;, ロングオプション&amp;quot;output&amp;quot;, 引数必須 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;#39;o&amp;#39;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;output&amp;quot;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;COMMAND_PARSER_TRUE,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;COMMAND_PARSER_FALSE,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;file&amp;quot;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c"&gt;/* 最適化オプション: ショートオプション&amp;#39;p&amp;#39;, ロングオプションなし, 引数必須 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;#39;p&amp;#39;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;NULL,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;COMMAND_PARSER_TRUE,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;COMMAND_PARSER_FALSE,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;optimization&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;level&amp;quot;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c"&gt;/* 情報表示: ショートオプション&amp;#39;v&amp;#39;, ロングオプション&amp;quot;verpose&amp;quot; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;#39;v&amp;#39;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;verpose&amp;quot;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;COMMAND_PARSER_FALSE,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;COMMAND_PARSER_FALSE,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;verpose&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;information&amp;quot;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c"&gt;/* サイレントモード: ショートオプション&amp;#39;s&amp;#39;, ロングオプション&amp;quot;silent&amp;quot; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;#39;s&amp;#39;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;silent&amp;quot;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;COMMAND_PARSER_FALSE,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;COMMAND_PARSER_FALSE,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;silent&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;mode&amp;quot;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;NULL&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c"&gt;/* 最後はNULLターミネート */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Log2Ceilの負荷が高い。LMSでLog2Ceilをサンプルごとに読んでいるがこれが大きな負荷になっている…（SPARKLEでは2.7秒の処理時間の内150ms使っている）。負荷を取るか、圧縮率を取るか…。&lt;/p&gt;
&lt;p&gt;2の冪に対するlog2呼び出しは明らかに一箇所からしか呼ばれないので、Utilityにある必要はないように見える。インライン関数展開されることを期待する意味も込めて、Coder側に移動して良いかも。→やったら最早負荷リストに乗らなくなった。&lt;/p&gt;
&lt;h3&gt;2019.5.26&lt;/h3&gt;
&lt;p&gt;コマンドラインパーサを作成する。&lt;/p&gt;
&lt;p&gt;一応仕様は見えたけど、いきなり大きく作ると混乱しそうだから、まずはショートオプション対応版をつくる。&lt;/p&gt;
&lt;p&gt;16:57 ロングオプション対応含めだいたいできた。エラー発生時にエラー出力するかどうかが迷いどころ。もう少し整理したらmain.cに取り込んでいく。&lt;/p&gt;
&lt;h3&gt;2019.5.28&lt;/h3&gt;
&lt;p&gt;コマンドラインパーサを追加。テストも追加。mandatoryは邪魔（&lt;code&gt;-o&lt;/code&gt;を必須にしていたが、それだと&lt;code&gt;-h&lt;/code&gt;だけでもエラーになってしまう。また、必須の判定はユーザがやればいい。）だし、-i, -o は指定必須だからオプションじゃなくていいかな。&lt;/p&gt;
&lt;h3&gt;2019.5.29&lt;/h3&gt;
&lt;p&gt;bonkなるフォーマットはPARCORを使っているようだ。ソースも短いので見てみる。→レビンソン-ダービン法をめちゃくちゃ改善しているようだった。読み解けない…&lt;/p&gt;
&lt;h3&gt;2019.6.1&lt;/h3&gt;
&lt;p&gt;6月は32bit演算対応を模索したい。最終的にSIMD化するときに、原理上ワード長で速度に差が出ると感じている。あと適応フィルタの本を読んで、LMSにさらなる改良を加えたい。&lt;/p&gt;
&lt;p&gt;bit幅の変動を観察していたら、まずPARCOR予測の入力がすでにbit幅が17bitになっていることが分かった。原因を見ていたらMS処理のところでsideが引き算になっていて、これによりbit幅が増加していた。（例えば、Lchが30000、Rchが-30000のとき、side = L - R = 30000 - (-30000) = 60000。60000は符号付き16bitで表現できない。）&lt;/p&gt;
&lt;p&gt;いろいろとbit幅増加要因がありそうなので、データ加工フローを見直してみる。以下の結果は符号ビットを含めている。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;入力データ：16bit&lt;/li&gt;
&lt;li&gt;MS処理のsideの引き算処理：17bit&lt;/li&gt;
&lt;li&gt;プレエンファシスフィルタの最大予測誤差を加味：18bit&lt;ul&gt;
&lt;li&gt;プリエンファシスにより大体の音声で絶対値は小さくなる、が、例外あり。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PARCOR&lt;/li&gt;
&lt;li&gt;ロングターム&lt;/li&gt;
&lt;li&gt;LMS&lt;/li&gt;
&lt;li&gt;エンコード&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;予測フィルタに入る前までに幅が18bitになっている。
予測は最大16bit幅で行うから、18bitで入ってきた場合は、2bitの切り捨てを入れないといけない。無条件に2bitの切り捨てを行うと、誤差は増える方向にしかいかない。&lt;/p&gt;
&lt;p&gt;おそらく必須になるのが、入力データをもれなく表現できる最小ビット幅の計測関数。やることはデータのABSの最大値を探してそのlog2ceilをとって+1する。（最後の+1は負値対応）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;入力データ：16bit&lt;/li&gt;
&lt;li&gt;MS処理のsideの引き算処理：17bit&lt;/li&gt;
&lt;li&gt;プレエンファシスフィルタの最大予測誤差を加味：18bit&lt;/li&gt;
&lt;li&gt;PARCOR：積和演算を&lt;strong&gt;15bit&lt;/strong&gt;幅で行い、予測時に元のデータのビット幅に合わせる：19bit？&lt;ul&gt;
&lt;li&gt;元のデータのビット幅をXbitとしたら、X&amp;gt;15ならばフィルタ入力時に(X-15)ビット算術右シフトする&lt;/li&gt;
&lt;li&gt;予測として得られた15bitデータを(X-15)ビット左シフトする。（(X-15)が負ならば(15-X)算術右シフト）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ロングターム：積和演算を&lt;strong&gt;15bit&lt;/strong&gt;幅で行い、予測時に元のデータのビット幅に合わせる：20bit？&lt;/li&gt;
&lt;li&gt;LMS：積和演算を&lt;strong&gt;15bit&lt;/strong&gt;幅で行い、予測時に元のデータのビット幅に合わせる：21bit？&lt;/li&gt;
&lt;li&gt;エンコード&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;別件で一点。ライス符号のパラメータが変化するところはあまりないのに、今はサンプル毎の更新処理を入れている。だから、パラメータが変化するところだけをマークして、パラメータが2倍になるのか1/2になるのかがわかれば原理的に早くなる。&lt;/p&gt;
&lt;h3&gt;2019.6.2&lt;/h3&gt;
&lt;p&gt;秋葉原製作所5hコース。今日は引き続き、積和演算の32bit化を検討する。&lt;/p&gt;
&lt;p&gt;重要なのは積の瞬間に32bitの表現範囲を超えてしまうこと。だから積の瞬間だけ後ろ向き・前向き誤差を16bitに丸めれば良い。&lt;/p&gt;
&lt;p&gt;問題は右シフト量をどうやってデコーダ側に渡すかという点。予測／合成関数の引数に右シフト量を追加するか？予測／合成を呼び出す側でシフト量を確定させてやれば良いのかも。&lt;/p&gt;
&lt;p&gt;エンコーダ側で、なんとなく32bit積算ができた（無論サイズ悪化）ので、まずはテストに合格することを目標にする。テストにビット幅計測を追加する必要がある。&lt;/p&gt;
&lt;p&gt;単体テストに追加してOKの様子。ミソは、入出力データには一切手を入れずに、乗算の精度だけを落とすということ。入出力データを右シフトすると復元できなくなる。ついでにUtilityにデータのビット幅計測関数を追加。&lt;/p&gt;
&lt;p&gt;データのビット幅が16bitを超えていたら、PARCOR係数側を右シフトするようにした。これにより、演算時の後ろ向き・前向き誤差の右シフトが不要になった。（ここで、PARCOR係数の非線形量子化が活きてくるんだなあ…と直感。）&lt;/p&gt;
&lt;p&gt;一旦小休止して、テストから本チャンへの移行を試みる。テストが通っているから、演算にはセーフなはずで、大事なのはエンコーダ・デコーダにビット幅を示すフィールドが追加されること。&lt;/p&gt;
&lt;p&gt;PARCOR係数さえ正しくシフトしていれば良いことが分かったので、もはや予測ルーチンでは右シフトを行う必要が無いのでは。エンコーダ側でビット幅を計測、係数を右シフトして関数実行する形にしてみる。改めてテストが通ったら本チャン組み込み。&lt;/p&gt;
&lt;p&gt;本チャン組み込みをした。テストは通っているし、手元の音源で元に戻るので一旦安心してしまって取り込む。なお、係数右シフト量を新規にブロックヘッダに追加している。そのため係数の精度悪化も合わせてサイズは増加している。&lt;/p&gt;
&lt;h3&gt;2019.6.3&lt;/h3&gt;
&lt;p&gt;暑さのせいか体力が持たない。LMSの32bit演算化を試みている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;24bit Wavを食わせたら落ちたので原因を見ていたらサイズオーバーしていた…。また、俺の声24bitでも圧縮率が非常に悪い（ちょっと調べたらmonkey's audioも悪かった。FLAC以下の性能）。最小値ぶん右シフトするなりの対処はいるかも。&lt;/li&gt;
&lt;li&gt;もしかしてと思って白色雑音を入れたら16bitでも例外発生。これは対処しないとだめだね。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.6.4&lt;/h3&gt;
&lt;p&gt;歯医者。力尽きて寝ていてあまり作業できず。&lt;/p&gt;
&lt;p&gt;サイズオーバー対策は、やはり確保するメモリを増やすしかない。また、EncodeBlock内でエラーチェックを強化する。&lt;/p&gt;
&lt;p&gt;白色雑音は、EncodeBlock内でPARCOR係数計算後、分散比を見て予測するか否かをチェックする。分散比が閾値以下になっていなかったら、圧縮不可能として、生データを書き出す。&lt;/p&gt;
&lt;p&gt;24bit対策は、まず原因調査しないと。そもそもあまり減っていないのがきになる。&lt;/p&gt;
&lt;p&gt;また、コマンドラインパーサで文字列デフォルト値は書き変わってしまうためやめよう。全てdescriptionで説明しよう。&lt;/p&gt;
&lt;h3&gt;2019.6.8&lt;/h3&gt;
&lt;p&gt;平日ろくに動けず。以下の作業をやっていく：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LMSはまず動いているか？16bitでオーバーフローなしで動くことを要確認。&lt;/li&gt;
&lt;li&gt;LMSのカスケードは廃止。&lt;/li&gt;
&lt;li&gt;mainの修正：文字列デフォルトを使わない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;32bitに対応すると、LMSはやはり16bit整数以上で乗算時にオーバーフローする。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;係数：無制限に上がる／下がってしまう&lt;/li&gt;
&lt;li&gt;入力信号：入力が16bitでない可能性がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PARCORでは入力のビット幅に合わせて係数を右シフトしてしまうことで問題なかったが、LMSではそうもいかない。係数はいくらでも増減する。また、右シフト量はLMSの事前に計算して、記録しておかないとだめ。係数の値を見て右シフトするのは負荷が高い。積和演算の途中で32bit範囲を超える可能性がある。&lt;/p&gt;
&lt;p&gt;上記の困難点が見えたので、LMSの32bit化は一旦断念する。&lt;/p&gt;
&lt;p&gt;コマンドラインパーサを整理。デフォルトを廃止。同時に、APIを呼ぶときにいちいちスペックとスペック数を渡しているのがめちゃくちゃ冗長。ハンドル化するか、スペック数をなくして仕様リストをNULLターミネートする形に持っていきたい。→OK。NULLターミネートに変えた。&lt;/p&gt;
&lt;p&gt;LMSのカスケードを廃止する…けど温情でもう少し観察してだめなことが分かったら廃止する。&lt;/p&gt;
&lt;p&gt;```sh:次数10/カスケード1
-rw-r--r--@  1 *  staff  39558053 Jun  8 20:13 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29781967 Jun  8 20:14 SPARKLE.sla
-rw-r--r--@  1 *  staff     50878 Jun  8 20:14 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  23078354 Jun  8 20:12 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    770097 Jun  8 20:14 voice48a.sla&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;```sh:次数5/カスケード2
-rw-r--r--@  1 *  staff  40076780 Jun  8 20:17 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30057429 Jun  8 20:16 SPARKLE.sla
-rw-r--r--@  1 *  staff     50889 Jun  8 20:15 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  22957174 Jun  8 20:18 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    770666 Jun  8 20:16 voice48a.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;```sh:次数20/カスケード1
-rw-r--r--@  1 *  staff  39573905 Jun  8 20:21 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29785000 Jun  8 20:20 SPARKLE.sla
-rw-r--r--@  1 *  staff     50780 Jun  8 20:22 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  22879755 Jun  8 20:22 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    768107 Jun  8 20:22 voice48a.sla&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;```sh:次数10/カスケード2
-rw-r--r--@  1 *  staff  39174228 Jun  8 20:09 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29607357 Jun  8 20:08 SPARKLE.sla
-rw-r--r--@  1 *  staff     50827 Jun  8 20:07 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  22656860 Jun  8 20:10 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    768789 Jun  8 20:10 voice48a.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;```sh:次数5/カスケード4
-rw-r--r--@  1 *  staff  40024904 Jun  8 20:26 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  30040884 Jun  8 20:25 SPARKLE.sla
-rw-r--r--@  1 *  staff     51036 Jun  8 20:27 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  34086796 Jun  3 00:42 DiamondSmile.sla
-rw-r--r--@  1 *  staff    772863 Jun  8 20:27 voice48a.sla&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;```sh:次数40/カスケード1
-rw-r--r--@  1 *  staff  39280231 Jun  8 20:30 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29776691 Jun  8 20:31 SPARKLE.sla
-rw-r--r--@  1 *  staff     51114 Jun  8 20:32 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  22631773 Jun  8 20:31 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    773745 Jun  8 20:32 voice48a.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;```sh:次数20/カスケード2
-rw-r--r--@  1 *  staff  39356907 Jun  8 20:35 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29691217 Jun  8 20:34 SPARKLE.sla
-rw-r--r--@  1 *  staff     50837 Jun  8 20:33 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  22479866 Jun  8 20:36 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    768416 Jun  8 20:33 voice48a.sla&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;```sh:次数10/カスケード4
-rw-r--r--@  1 *  staff  39280231 Jun  8 20:41 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29776691 Jun  8 20:42 SPARKLE.sla
-rw-r--r--@  1 *  staff     51114 Jun  8 20:43 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  22631773 Jun  8 20:38 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    773745 Jun  8 20:42 voice48a.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ん？次数10/カスケード2が良い？ごめんやっぱ廃止できない。プリセットを修正。&lt;/p&gt;
&lt;h3&gt;2019.6.9&lt;/h3&gt;
&lt;p&gt;日曜日のTODOは、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白色雑音対策&lt;/li&gt;
&lt;li&gt;分散比を観察（実際に白色雑音で高くなっているか？）&lt;/li&gt;
&lt;li&gt;圧縮しないモードを追加&lt;/li&gt;
&lt;li&gt;24bit対策&lt;/li&gt;
&lt;li&gt;最小値の算出機能追加&lt;/li&gt;
&lt;li&gt;一般の24bitデータ対策&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もしかしたら24bit対応で絶望して結局PARCORも64bitになるかもしれない。&lt;/p&gt;
&lt;p&gt;14:00に秋葉原製作所in。まずは白色雑音対策を打つ。6.8の夜の観察により、白色雑音では推定圧縮率（(1サンプルあたり推定符号長)/(元データのサンプルあたりビット数)）が0.98位になることを確認：&lt;/p&gt;
&lt;p&gt;```sh:1秒間の白色雑音をエンコードした際の推定圧縮率
0.980077
0.980992
0.980059
0.980983&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;他のデータでは0.90を超えることは稀であることを確認している。

![20190929123826p](./images/la_first_attempts/20190929123826.png)

雑に見積もって0.95以上ならば圧縮不可能と判定していいと考える。

→対策を行った。推定圧縮率が閾値以上ならば生データを書き出すように修正。これに伴ってブロックデータタイプを新しく導入。今の所、圧縮済みデータか、無音か、生データの3種類が存在する。

さて、いよいよ24bit対策に入る。

24bitデータを食わせると、以下のアサートを吐いて死んでしまう（少し気になって8bitも試したけど大丈夫だった。FLACよりよい結果が出ている。）：

```sh
Assertion failed: (init_param &amp;lt; (1UL &amp;lt;&amp;lt; 16)), function SLACoder_PutDataArray, file SLACoder.c, line 462.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;→これは初期パラメータのサイズ不足。24bitデータならば24bitレンジで初期値が出る。元データのビット幅を引数として渡し、そのビット数で符号化するように修正すれば良さそう。ひとまず24bit符号化して回避。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Assertion failed: &lt;span class="o"&gt;(&lt;/span&gt;encoder-&amp;gt;parcor_rshift&lt;span class="o"&gt;[&lt;/span&gt;ch&lt;span class="o"&gt;]&lt;/span&gt; &amp;lt; &lt;span class="o"&gt;(&lt;/span&gt;1UL &amp;lt;&amp;lt; &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;, &lt;span class="k"&gt;function&lt;/span&gt; SLAEncoder_EncodeBlock, file SLAEncoder.c, line &lt;span class="m"&gt;610&lt;/span&gt;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;→ビット幅が24のときに、右シフト量が24-16=8になる。8は3ビットで保存できない。と思ったらビット幅が25とか出てきた。これは明らかなバグ。ワン・ツー・スイーツでも17が出ている。→バグじゃなかった。プリエンファシスで16bit幅を超えてる！&lt;/p&gt;
&lt;p&gt;16bitwavを左シフトして作ったダイヤモンドスマイルの結果がかなり悪い。右シフト量が大きくて、PARCOR係数の精度がひどいことになっている。&lt;strong&gt;データ側のシフトに切り替えてみたが、状況はあまり変わらず悪化。&lt;/strong&gt;（係数を右シフトするよりは圧縮率はよかった。ただし実装が複雑化。関数引数に変化あり。速度は自明に低下。つらい。）&lt;/p&gt;
&lt;p&gt;FLAC, wavpackはおそらく最小値を見ていて、その分右シフト処理をしている。Monkey's Audio, ttaはそのまま圧縮しにいって減らせている（謎）。&lt;/p&gt;
&lt;p&gt;64bit演算にしてみて様子を見る。。。様子は変わらず。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;バグだった！&lt;/strong&gt;ライス符号パラメータがオーバーフローしていた！8bitの固定小数を使っていて、かつ119を掛ける時があって、24bitdデータを突っ込むと、確かに32bitだとオーバーフローする！直したら（パラメータを64bitにしたら）一気に減るようになった。&lt;/p&gt;
&lt;p&gt;しかしまだ最小値の対処が抜けている。これを対処することでFLAC, wavpackを倒せる予定。&lt;/p&gt;
&lt;p&gt;また、24bitエンコード時は高次係数も16bitを振った方が良さそうな印象。（また、右シフト量に応じた係数記録をすべき）&lt;/p&gt;
&lt;h3&gt;2019.6.11&lt;/h3&gt;
&lt;p&gt;最小値の対処を入れる。→やった。まだテスト実装だから、ビット幅計算関数を別途作成すべき。&lt;/p&gt;
&lt;p&gt;ダイヤモンドスマイルの圧縮率、wavpackにおいて負けとる。&lt;/p&gt;
&lt;p&gt;いろんな短い波形のエンコードデコードテストがやりたい…&lt;/p&gt;
&lt;h3&gt;2019.6.12&lt;/h3&gt;
&lt;p&gt;最小値対処を入れる。設計にはだいぶ迷った。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各ブロックで解析を行って、ブロックヘッダに書いておくのを考えていたが、それは明らかにもったいない気がした。&lt;/li&gt;
&lt;li&gt;なぜなら左シフトされて入っているデータはレアケースだと思うから。&lt;/li&gt;
&lt;li&gt;なのでヘッダに入れることにした。最初に全体を解析して、左シフト量を計測しておく。また、概念的に近いと考えてWaveFormatに左シフト量のメンバを追加。&lt;/li&gt;
&lt;li&gt;EncodeWhole時にしかヘッダに情報を入れない。&lt;/li&gt;
&lt;li&gt;EncodeBlockを個別に呼び出したときは効果なし。&lt;/li&gt;
&lt;li&gt;ユーザは左シフト量メンバをいじれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;24bitエンコード時は高次係数も16bitを振る。&lt;/li&gt;
&lt;li&gt;右シフト量に応じた係数記録をする&lt;/li&gt;
&lt;li&gt;係数量子化、最初にpow(2, 16)すべきでは？精度が落ちてる。この機会に整理。&lt;/li&gt;
&lt;li&gt;いろんなwavのエンコードデコードテストを追加&lt;/li&gt;
&lt;li&gt;とにかく一致確認を行う。ユニットテストとは分ける。&lt;/li&gt;
&lt;li&gt;無音、サイン波、雑音、定数、ナイキスト振幅などなど…&lt;/li&gt;
&lt;li&gt;8, 16, 24bit, 8bit&amp;lt;&amp;lt;16, 16bit&amp;lt;&amp;lt;8&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.6.13&lt;/h3&gt;
&lt;p&gt;何もできず。FLACのexe（実行可能形式）はGPLだけど、リンクしない限りは公開義務は発生しない。つまり、使うだけならOK。&lt;/p&gt;
&lt;h3&gt;2019.6.14&lt;/h3&gt;
&lt;p&gt;Adaptive filter theoryをパラパラ見ているけどSign Sign LMSの記述がどこにもない。やはりwebを見る。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://archive.org/details/bstj45-2-255/page/n1"&gt;Techniques for Adaptive Equalization of Digital Communication Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pdfs.semanticscholar.org/b26c/eda431a8b71e78298982ced440232266eb7b.pdf"&gt;LMS Adaptive Filters for Noise Cancellation: A Review&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あまりいい情報はない。&lt;/p&gt;
&lt;p&gt;高速化で気になっていたのは、係数更新時のバッファアクセス。毎回andは取りたくない…直線アクセスできんのかと思っていたら、あった&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://exp1gw.ec.t.kanazawa-u.ac.jp/DSP/Processor/delay.html"&gt;ディレイラインの実装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.6.15&lt;/h3&gt;
&lt;p&gt;ついでに久々に海ベローチェに来た。今日はここで作業して大井町寄って帰る。&lt;/p&gt;
&lt;p&gt;ビックサイト行く途中で、IIRも適応的にできたことをAdaptive filter theoryの本に思い出させてもらった。そういえば適応ノッチフィルタの応用例があった。&lt;/p&gt;
&lt;p&gt;適応IIRが先か、フィルタ処理高速化が先か…。圧縮率改善を先に頑張ったほうが良さそうだから、適応IIRを試してみよう。&lt;/p&gt;
&lt;p&gt;やっつけで実装してみた（更新式はsign-sign）けど、なかなか性能が良い。（バグあるかも）&lt;/p&gt;
&lt;p&gt;```sh:FIRのみ
-rw-r--r--@  1 *  staff  39558053 Jun  8 20:13 one_two_sweets_offvocal.sla
-rw-r--r--@  1 *  staff  29781967 Jun  8 20:14 SPARKLE.sla
-rw-r--r--@  1 *  staff     50878 Jun  8 20:14 kisaragi_chihaya.sla
-rw-r--r--@  1 *  staff  23078354 Jun  8 20:12 Dream_goes_On.sla
-rw-r--r--@  1 *  staff    770097 Jun  8 20:14 voice48a.sla&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;```sh:FIR+IIR（予測出力をIIRフィルタの入力とする）
-rw-r--r--@   1 *  staff   39417404 Jun 15 17:12 one_two_sweets_offvocal.sla
-rw-r--r--@   1 *  staff   29704724 Jun 15 17:13 SPARKLE.sla
-rw-r--r--@   1 *  staff      50819 Jun 15 17:13 kisaragi_chihaya.sla
-rw-r--r--@   1 *  staff   22925409 Jun 15 17:13 Dream_goes_On.sla
-rw-r--r--@   1 *  staff     769208 Jun 15 17:14 voice48a.sla
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;```sh:FIR+IIR（残差をIIRフィルタの入力とする）
-rw-r--r--@   1 *  staff   39339579 Jun 15 17:29 one_two_sweets_offvocal.sla
-rw-r--r--@   1 *  staff   29652750 Jun 15 17:28 SPARKLE.sla
-rw-r--r--@   1 *  staff      50818 Jun 15 17:30 kisaragi_chihaya.sla
-rw-r--r--@   1 *  staff   22852870 Jun 15 17:29 Dream_goes_On.sl
-rw-r--r--@   1 *  staff     769343 Jun 15 17:30 voice48a.sla&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;予測出力を入力するか、残差を入力とするかで実装が少し変わる。理論的なところでは、予測出力をIIRの入力とするものは出力誤差法（Output Error Method）と呼ばれるらしく（不安定、かつ局所最適に陥るそうだ。）、また、残差をIIRフィルタの入力とするものは該当する手法がない。何をしてるんだろう。。。

不安定さはステップサイズを小さくすることで防ぐしかないらしい（本によると）。

局所最適は等誤差法（Equation Error Method）で防げる。これは、希望出力をIIRの入力とするもの。この場合希望出力は無音になるな…

係数を64bitにしたら、残差IIR入力時に発散している（32bit整数を超える）ことがわかった。見たところ、定数予測のところで残差がいきなり発散していた。不安定なモードに入ったらしい…。発散するのは一般的によろしくないので、残差入力は取りやめる。

IIR対応により負荷が増えた。次数分のIIR計算を行うから2倍と言ってもいい。同等の計算負荷の次数を5にしてもFIR10より結果が悪い。昨日見たバッファアクセス高速化でどれだけ良くなるか…。後、log2演算の負荷がたかい。

ちょっと思ったこと：エンコードパラメータの再度精査。

### 2019.6.16

昨日バッファアクセス最適化を実装したけどバグがあるので、まずそれを直す。その後にエンコードデコードテストを行う。

6/8の結果に戻らずに苦戦していたが、6/8から6/16の間にフォーマット変更が入っているからもとに戻すのはだいぶ厳しそうなのでやめた。負荷の増減を見る。

OKで、インデックス参照は確かに早くなったが誤差レベル。
LMSの負荷が高すぎる…SPARKLE.wavのデコードで3秒のうち1秒がLMS...

LMSの高速化がどう考えてもキモだ。log2を諦めるか？

16:16 2時間半経った。高速化は一旦置いてテスト作成に入る。

19:13 ぐえー疲れた。テストはなんとか作った。しかし、左シフト量のオフセット計測の実装が怪しい感じ。

### 2019.6.17

テストを作り上げていく上でバグが2つ潰せた。

 1. 左シフト量の計算ミス
 2. 負の最大値(8bitでの-128)を符号なし化すると256になって8bitで符号化できない

### 2019.6.19

さらにバグつぶし。もっとテストケース増やそう。

 1. ステレオ白色雑音のデコードに失敗する
    - MS処理が働き、Mはガウス分布に近づくので圧縮、SはL-Rによりビット幅が増えて圧縮できず生データが入っていた。
    - 生データを係数領域に出力してしまい、デコード時にMチャンネルが残差と思ってデコードしてしまった。

### 2019.6.20

バグつぶし。チャープ信号追加で以下のバグがわかった。

 1. PARCOR係数がroundの結果正の最大値+1（=-1）になる場合がある。
    - クリップにより対処
 2. 推定符号長が負になる
    - パワーが極端に小さいときに起こる。1bit/1sampleで符号化できるとした。

### 2019.6.21

修正をまとめた。また、SLAUtility.cに機種依存文字が入っていたので消した。

### 2019.6.22

技術書典むけプロット：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;あらすじver.0.1.1&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;まえがき
ロスレス音声コーデックを作ってみませんか。
ロスレス音声コーデックと言えば、FLACがまず思い浮かべられると思いますが、実はFLACは
他のロスレス音声コーデックに比べて圧縮率が悪いという欠点があります。（展開速度は速いですが！）
本稿では "FLACを超える圧縮率を持つロスレス音声コーデック" の作成を目標として、
その基礎理論と実装を説明していきます。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;0-1. そもそもロスレス音声コーデックとは？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基礎理論編
ロスレス音声コーデックは大体以下の構成を持ちます。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;+----------+       +---------+       +----------------------+       +----------------+
|          |       |         |       |                      |       |                |
|①入力wav +---+--&amp;gt;+ ②予測  +---+--&amp;gt;+ ③エントロピー符号化 +---+--&amp;gt;+ ④出力バイナリ |
|          |   |   |         |   |   |                      |   |   |                |
+----------+   |   +---------+   |   +----------------------+   |   +----------------+
               |                 |                              |
               |                 |                              |
               +                 +                              +
            pcmデータ         残差信号                       ビット列&lt;/p&gt;
&lt;p&gt;①入力のwavを取得する。
　音声信号データはPCMで符号化されている
②入力の音声データパターンを解析して、音声の予測を行う。
　予測信号と元の信号の差を残差という。予測が正確ならば、残差は小さくなり、
　③のエントロピー符号化でより小さく圧縮することができる。
③残差信号をビット列に符号化（エンコード）する。
　"エントロピー符号化"は、入力データの"確率分布"に基づいて、出力ビット列が
　短くなるように符号化を行います。
④出力バイナリデータが得られます。&lt;/p&gt;
&lt;p&gt;復号（デコード）時は④→③→②→①の手順で処理を行い、元の入力wavを得ます。&lt;/p&gt;
&lt;p&gt;②、③の性能が個別に高ければ高いほど、より良い圧縮率を達成することができます。
本章では、②、③の基礎理論である予測とエントロピー符号化を紹介していきます。&lt;/p&gt;
&lt;p&gt;1-1. 予測
  1-1-1 予測とはどういうことか
  1-1-2 線形予測の理論と実装
　　　　（1サンプル間の予測から線形予測まで。頻度分布を見せる。）&lt;/p&gt;
&lt;p&gt;1-2. エントロピー符号化
  1-2-1 符号化とはどういうことか
  1-2-2 情報量とエントロピー
　　　　（エントロピー計測プログラムを載せる）
  1-2-3 エントロピー符号化の例
       - α、γ、σ符号とその確率分布
       - Golomb-Rice符号&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;実装編 -FLACを超える圧縮率を持つコーデックを作ってみる-
2-1. 固定小数演算PARCOR予測フィルタ
2-2. 残差符号化
  2-2-1 残差の確率分布分析
  2-2-2 ビットライタ、ビットリーダの実装
  2-2-3 負値の扱い
  2-2-4 ライス符号化パラメータの調整
2-3. wavファイルの読み込み&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Appendix. 失敗編
A-1. 他の予測手法
 A-1-1. Burg（共分散）法
 A-1-2. 1乗算型PARCOR格子フィルタ
A-2. 他のエントロピー符号
 A-2-1. ランレングス符号化
 A-2-2. ハフマン、適応的ハフマン
 A-2-3. LZ系
A-3. その他
 A-3-1. PARCOR係数の非線形量子化&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="s s-Atom"&gt;texの環境を整えてガリガリ書いていく。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;ボイスデータをevaluateしていたらエンコードエラーがじゃんじゃん出てくる。その対策中。&lt;/span&gt;&lt;span class="nv"&gt;LPC係数計算中に&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nf"&gt;fabs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;gamma&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="s s-Atom"&gt;f&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;になるケースがある&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="s s-Atom"&gt;確認したケースではサンプル数が少ない&amp;amp;パワーが小さいのが原因。&lt;/span&gt;

 &lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="s s-Atom"&gt;wavのfmtチャンクが拡張されている（サイズが16より大きい）ときにエラーを出していたが、スキップするようにした。（おそらく有効なデータは入っていない）&lt;/span&gt;

 &lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="s s-Atom"&gt;入力サンプルがPARCOR係数次数よりも少ないときは無音として扱うようにした。&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;入力サンプルが次数よりも大きく、自己相関が小さい場合は未対応。まだエンコードに失敗しうる。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;上記2点の修正を入れたところ、使用している評価データに対してはエンコードできるようになった。&lt;/span&gt;

&lt;span class="nv"&gt;TTAは読み込めないwavがある&lt;/span&gt;&lt;span class="s s-Atom"&gt;（おそらくfmtの拡張に対応していない）し、&lt;/span&gt;&lt;span class="nv"&gt;Monkey&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="s s-Atom"&gt;s&lt;/span&gt; &lt;span class="nv"&gt;Audioはクラッシュするwavがある&lt;/span&gt;&lt;span class="s s-Atom"&gt;…。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;今夜、&lt;/span&gt;&lt;span class="nv"&gt;FLAC&lt;/span&gt; &lt;span class="s s-Atom"&gt;vs&lt;/span&gt; &lt;span class="nv"&gt;WavPack&lt;/span&gt; &lt;span class="s s-Atom"&gt;vs&lt;/span&gt; &lt;span class="nv"&gt;SLA&lt;/span&gt; &lt;span class="s s-Atom"&gt;予定。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;手元の音源4091曲で圧縮率を比較：&lt;/span&gt;

&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;手法&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;圧縮率（圧縮後/圧縮前&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="s s-Atom"&gt;）&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="c1"&gt;%] | CPU負荷 [%] |&lt;/span&gt;
&lt;span class="p"&gt;|:-&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;|:-&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;|:-&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;FLAC&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;53.40&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;0.720&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; 
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;WavPack&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;hh&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;48.00&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;0.976&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="s s-Atom"&gt;sla&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;45.86&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;1.24&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2019.6.23&lt;/span&gt;

&lt;span class="s s-Atom"&gt;久々に何も進めない休日。直近のTODOがない。執筆に励むべきかも。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2019.6.25&lt;/span&gt;

&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;de&lt;/span&gt; &lt;span class="nv"&gt;Bruijn&lt;/span&gt; &lt;span class="s s-Atom"&gt;multiplication&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="nn"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="s s-Atom"&gt;supertech&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;csail&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;mit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;edu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;papers&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;debruijn&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;pdf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2019.6.27&lt;/span&gt;

&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;uint32_t&lt;/span&gt; &lt;span class="nv"&gt;SLAUtility_Log2CeilFor2PoweredValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;uint32_t&lt;/span&gt; &lt;span class="s s-Atom"&gt;val&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;が定義されていない。宣言だけあるので宣言を消す。→消した。&lt;/span&gt;

&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;wine&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;を使って、&lt;/span&gt;&lt;span class="nv"&gt;TAKとMP4ALSを評価に追加した&lt;/span&gt;&lt;span class="s s-Atom"&gt;。圧縮率はTAKが一番。しかし人間の声ではSLAが何故か一番良かった。無音区間をうまく捉えられている？また、&lt;/span&gt;&lt;span class="nv"&gt;MP4ALSと比べたところ&lt;/span&gt;&lt;span class="s s-Atom"&gt;、僅かにSLAが上回っている。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;小粒な修正。&lt;/span&gt;

 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;VSでビルドが通るように修正&lt;/span&gt;&lt;span class="s s-Atom"&gt;。&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;。*/&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;がエンコードでアウトだった。半角空けて&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;。&lt;/span&gt; &lt;span class="s s-Atom"&gt;*/&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;として対処。&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;バージョン文字列を文字列に変更。（フォーマットバージョンは整数。）&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;シグネチャを&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;SL&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;から&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;SL&lt;/span&gt;&lt;span class="s s-Atom"&gt;*\&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;に変更。（テキストファイルとして開いた時の事故を防ぐ目的）&lt;/span&gt;

&lt;span class="s s-Atom"&gt;プリセットを変更した。負荷として、&lt;/span&gt;&lt;span class="nv"&gt;LMSよりPARCORは負荷増加しにくいので&lt;/span&gt;&lt;span class="s s-Atom"&gt;、&lt;/span&gt;&lt;span class="nv"&gt;PARCORにより多くを割り振るように変更&lt;/span&gt;&lt;span class="s s-Atom"&gt;。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2019.6.29&lt;/span&gt;

&lt;span class="s s-Atom"&gt;アプリに組み込んだときに、負荷変動がやばい。&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;SLADecoder_DecodeBlock&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;はブロックサイズ単位でデコードするが、それが例えば16384サンプル単位だと、&lt;/span&gt;&lt;span class="mi"&gt;16384&lt;/span&gt;&lt;span class="s s-Atom"&gt;サンプル周期でスパイクが発生する。これでは実用に耐えないので、より小さなブロックサイズ、例えば512サンプル単位でデコードできるようにしたい。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;対応策を考えている。今有力なのは、&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;SLADecoder_DecodeSubBlock&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;という関数を新規に追加すること。&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;SLADecoder_DecodeSubBlock&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;の仕様は次の通り：&lt;/span&gt;

 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;ブロック先頭のときは、パラメータを読み取って指定サンプル分デコード。&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;ブロック途中のときは、継続して指定サンプル分デコード。その際に次のブロックに入ったら、改めてパラメータを読み取って指定サンプル分に達するまでデコード。&lt;/span&gt;
 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;今読み取っているブロックのサンプル数をカウントすればやれそう。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;負荷が変動するのは、ヘッダのパラメータの読み取り分（微小）と無音/生データデコード時（それなり）&lt;/span&gt;

&lt;span class="s s-Atom"&gt;おそらくこの関数はシークを実現するときも必要になるはず。&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;SLADecoder_DecodeSubBlock&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="s s-Atom"&gt;の名前はあんまり良くなさそう。任意位置から任意サンプル分だけデコードできるので、もっと別の名前が良い。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;同時に、ブロック途中で再度デコードを行っても問題なくデコードできるように下地を作る。&lt;/span&gt;

 &lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="s s-Atom"&gt;ライス符号の初期パラメータをブロックヘッダに持たせる&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;再帰的ライス符号のパラメータをコーディングモジュールの外から渡すように変える。&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;パラメータの初期化をPutDataArray&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;GetDataArrayで行わない&lt;/span&gt;&lt;span class="s s-Atom"&gt;。&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;→やった。ここで気付いたけど、**コーディングモジュールをハンドル化したほうがよい。**&lt;/span&gt;
 &lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="s s-Atom"&gt;予測モジュールのリセット関数を用意する。&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;各予測モジュールと、エンコーダ・デコーダに追加&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;予測/合成時に、リセットを行わないようにする&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;ブロックヘッダ先頭だけでリセットを行う&lt;/span&gt;
      &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;→試そうとしてきつい。予測/合成が始まるデータのインデックスに初回と2回目以降で差異がある。リセット関数でフラグを立てるか。&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;プリエンファシス・デエンファシスも状態を持たねばなるまい。モジュール化するし、&lt;/span&gt;&lt;span class="nv"&gt;Predictorに移動する&lt;/span&gt;&lt;span class="s s-Atom"&gt;。&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;合成予測ハンドルをチャンネル数分だけ持つように変える。&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;LMSカスケードを廃止&lt;/span&gt;&lt;span class="s s-Atom"&gt;。ハンドルが増えるし、何より圧縮に寄与しないから。&lt;/span&gt;
      &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;→やった。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2019.6.30&lt;/span&gt;

&lt;span class="s s-Atom"&gt;湿度のせいか、集中力が保たない。しかし大事なところなので頑張る。&lt;/span&gt;

 &lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="s s-Atom"&gt;ブロックヘッダのエンコード・デコードを行う内部関数を新規追加&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;エンコード側は難しいことがわかったのでデコード側のみ実装。（ブロックサイズ&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;CRC16がブロックエンコードが終わらない限り確定しないため&lt;/span&gt;&lt;span class="s s-Atom"&gt;）&lt;/span&gt;
 &lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="s s-Atom"&gt;先輩社員提案仕様を形にし始める&lt;/span&gt;

&lt;span class="mf"&gt;2.&lt;/span&gt;&lt;span class="s s-Atom"&gt;に取り掛かっているが、残差デコードで一点問題が。**残差はチャンネルインターリーブでエンコード／デコードしないとブロックの途中でデコードを中断できない。**→やった。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;予測ハンドルリセット時、フラグでなく入力サンプル数カウントを0にした方が素直かも。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2019.7.1&lt;/span&gt;

&lt;span class="s s-Atom"&gt;実装整理。とにかく、ストリーミングデコードが完成しない限りはだめだ。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2019.7.2&lt;/span&gt;

&lt;span class="s s-Atom"&gt;『ディジタル音声処理（古井貞）』に1乗算型の構成が書いてあった。。。。再度試してみたけど一致せず。うーん。諦めか？&lt;/span&gt;

&lt;span class="s s-Atom"&gt;戻ってストリーミングデコードへ向けて頑張る。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;###&lt;/span&gt; &lt;span class="mf"&gt;2019.7.3&lt;/span&gt;

&lt;span class="s s-Atom"&gt;データ追加・回収系のテストを追加。同時にLMSに関する良いリンクを見つける。&lt;/span&gt;

 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;再考・適応的アルゴリズム&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="nn"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="s s-Atom"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;jstage&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;jst&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;go&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;jp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;article&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;essfr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="mi"&gt;292&lt;/span&gt;&lt;span class="s s-Atom"&gt;/&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="s s-Atom"&gt;pdf/-char&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;ja&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;Computer&lt;/span&gt; &lt;span class="s s-Atom"&gt;exercise&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;Fixed&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;point&lt;/span&gt; &lt;span class="s s-Atom"&gt;implementation&lt;/span&gt; &lt;span class="s s-Atom"&gt;of&lt;/span&gt; &lt;span class="s s-Atom"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;LMS&lt;/span&gt; &lt;span class="s s-Atom"&gt;algorithm&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="nn"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="s s-Atom"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;eit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;lth&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;se&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;fileadmin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;eit&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;courses&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;ett042&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;CE&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;CE6e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;pdf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;Sign&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Signはやりすぎ&lt;/span&gt;&lt;span class="s s-Atom"&gt;…？入力信号のsignを取って、残差との乗算で更新してみる。→劇的にだめだった。とりやめ。&lt;/span&gt;

&lt;span class="s s-Atom"&gt;あと、ループアンローリング時は、和の変数も分けた方が良さそう。和の依存関係がなくなるからよい。&lt;/span&gt;

&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="nn"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s s-Atom"&gt;こんな感じ。&lt;/span&gt;
&lt;span class="s s-Atom"&gt;int&lt;/span&gt; &lt;span class="s s-Atom"&gt;sum1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;sum2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;sum3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;sum4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="nf"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;int&lt;/span&gt; &lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="s s-Atom"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="s s-Atom"&gt;nsmpl&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="s s-Atom"&gt;i++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="s s-Atom"&gt;sum1&lt;/span&gt; &lt;span class="s s-Atom"&gt;+=&lt;/span&gt; &lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="s s-Atom"&gt;sum2&lt;/span&gt; &lt;span class="s s-Atom"&gt;+=&lt;/span&gt; &lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="s s-Atom"&gt;sum3&lt;/span&gt; &lt;span class="s s-Atom"&gt;+=&lt;/span&gt; &lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="s s-Atom"&gt;sum4&lt;/span&gt; &lt;span class="s s-Atom"&gt;+=&lt;/span&gt; &lt;span class="s s-Atom"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="s s-Atom"&gt;int&lt;/span&gt; &lt;span class="s s-Atom"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s s-Atom"&gt;sum1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s s-Atom"&gt;sum2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s s-Atom"&gt;sum3&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s s-Atom"&gt;sum4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;シフト演算も劇的に速いわけではない。注意。Log2Ceilも割と重いと思う。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www001.upp.so-net.ne.jp/y_yutaka/labo/math_algo/calcbench.html"&gt;簡単な演算負荷比較&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.7.6&lt;/h3&gt;
&lt;p&gt;ストリーミングデコードのテスト追加して細々としたバグつぶし中。&lt;/p&gt;
&lt;h3&gt;2019.7.7&lt;/h3&gt;
&lt;p&gt;まだバグあり。波形依存でもとに戻らない。2時間がかかったが、ロングタームが悪さしていることがわかった。更に追いかける。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ロングタームとLMSが最初のバッファリング中のところでデコードが途切れるとバッファが不正になっていた&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必要バイトの最小値を最小ブロックヘッダ値に設定&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;だいたいバグは潰したけど、まだ構造的に未完成。データの受け渡しキューを綺麗にしたい。&lt;/p&gt;
&lt;h3&gt;2019.7.9&lt;/h3&gt;
&lt;p&gt;やはりデータコピー（&lt;code&gt;memmove&lt;/code&gt;）負荷が大きい。データパケットキュー構造を作っている。&lt;/p&gt;
&lt;h3&gt;2019.7.10&lt;/h3&gt;
&lt;p&gt;技術書典参加確定。
パケットキューを作った。&lt;code&gt;SLAUtility&lt;/code&gt;に追加。それに合わせてAPIを見直し。&lt;/p&gt;
&lt;h3&gt;2019.7.11&lt;/h3&gt;
&lt;p&gt;パケットキュー差し替え時のバグとり。とりあえず動いているようだが、ダブルバッファリングに変えたい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;シグネチャを&lt;code&gt;SLA*\0&lt;/code&gt;から&lt;code&gt;SLA*\1&lt;/code&gt;に変える。&lt;code&gt;\1&lt;/code&gt;はSOH(Start of Header)。&lt;code&gt;\0&lt;/code&gt;だとSL*の繋がるイメージに反するから。→やった。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.7.13&lt;/h3&gt;
&lt;p&gt;とどめの3連休としよう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最悪ビットレート値をヘッダに記録する→やった。&lt;/li&gt;
&lt;li&gt;Par （タイポ）→ Per→やった。&lt;/li&gt;
&lt;li&gt;連続バッファをダブルバッファリングに変える&lt;/li&gt;
&lt;li&gt;実は難しいことがわかっている。ブロックデコード終了直後にデータ追加が入ると、ブロックサイズが前のブロックのママになってしまう。&lt;/li&gt;
&lt;li&gt;制御が複雑になるので一旦ペンディングとする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2019.7.14&lt;/h3&gt;
&lt;p&gt;13:30起床。体が動かん。TODOなるべく早めにこなして、原稿執筆にはいる。&lt;/p&gt;
&lt;p&gt;TODO: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ストリーミングデコーダ作成直後にブロックサイズが不定になっている。&lt;/li&gt;
&lt;li&gt;フォーマット設定したかどうかのフラグをもたせる。&lt;/li&gt;
&lt;li&gt;フォーマット設定する前はサイズを最悪値で見積もっておく。&lt;/li&gt;
&lt;li&gt;→やった。が、デコード開始直後は最大ブロックサイズ分突っ込んでおかないと失敗するケースあり。データ不足が発生していると想像。&lt;/li&gt;
&lt;li&gt;異様に圧縮率がよい高崎データが元に戻っているのか精査&lt;/li&gt;
&lt;li&gt;→わかった。wavファイルの末尾に&lt;code&gt;bext&lt;/code&gt;チャンクが入っていた。そのチャンク情報を&lt;code&gt;sla&lt;/code&gt;は捨てていたため、小さくなっていた。他のコーデックは律儀に保存していた。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ja.wikipedia.org/wiki/Broadcast_Wave_Format"&gt;Broadcast Wave Format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;捨てた分のチャンクサイズを足すと、やはりTakを下回る。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tausoft.org/wiki/True_Audio_Codec_Algorithms"&gt;TTAの原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;残差でsignを取るのは負荷が高いから試していない。&lt;/li&gt;
&lt;li&gt;→うーん。微妙。減ったり増えたり。安定しないの取り下げ。TTAで気になるのはステップサイズを可変にしている記述があった。論文はロシア語で読めないのでソースを見てみる。&lt;/li&gt;
&lt;li&gt;全体的なコードリファクタ、テスト追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これはTODOではなくちら見でOK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.hpl.hp.com/techreports/1999/HPL-1999-144.pdf"&gt;Lossless Compression of Digital Audio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;今更なのに王道論文...いや、線形回帰ベースで古いな。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;永遠に上っ面の知識の吸収を続けるのか、それとも研究をしっかりやって将来的な発展に結びつけたいのか。かけた時間が時間なので、引くに引けない状況になってしまった。&lt;/p&gt;
&lt;p&gt;TTAのソース（フィルタ処理）を読んでいる。&lt;/p&gt;
&lt;p&gt;```c:TTAのfilter.hにコメントを入れてみる
static __inline void hybrid_filter_enc(TTA_fltst &lt;em&gt;fs, TTAint32 &lt;/em&gt;in) {
    register TTAint32 &lt;em&gt;pA = fs-&amp;gt;dl;     /&lt;/em&gt; pA: 入力バッファ &lt;em&gt;/
    register TTAint32 &lt;/em&gt;pB = fs-&amp;gt;qm;     /&lt;em&gt; pB: 乗算係数     &lt;/em&gt;/
    register TTAint32 &lt;em&gt;pM = fs-&amp;gt;dx;     /&lt;/em&gt; pM: 係数更新量   &lt;em&gt;/
    register TTAint32 sum = fs-&amp;gt;round;  /&lt;/em&gt; 丸め定数で初期化 */&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;/* 係数更新: 残差fs-&amp;gt;errorの符号で変える */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;fs-&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;error&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;fs-&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;error&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c"&gt;/* フィルタ出力計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;sum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pB&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c"&gt;/* 入力バッファ&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="nx"&gt;..3&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt;の更新 0が最も古いデータとなる */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c"&gt;/* 新しめの係数更新量&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="nx"&gt;..7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt;の更新 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;30&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c"&gt;/* sign(pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt;)（0のときは1）     */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;30&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c"&gt;/* 2 * sign(pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt;)（0のときは2） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;30&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c"&gt;/* 2 * sign(pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt;)（0のときは2） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;pM&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;30&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;4&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c"&gt;/* 4 * sign(pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt;)（0のときは4） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c"&gt;/* 元のソース&lt;/span&gt;
&lt;span class="c"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt; = -pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt;; pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt; = -pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt;;&lt;/span&gt;
&lt;span class="c"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt; = *in - pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt;; pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt; = *in;&lt;/span&gt;
&lt;span class="c"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt; += pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt;; pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt; += pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt;;&lt;/span&gt;
&lt;span class="c"&gt;*/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c"&gt;/* pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt; = -直前の3階の差分 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c"&gt;/* pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt; = -直前の2階の差分 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nt"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c"&gt;/* pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt; = 入力 - 直前の入力（1階の差分） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nt"&gt;in&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c"&gt;/* pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt; = 入力データ */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c"&gt;/* pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt; = 1階の差分 - 直前の2階の差分（2階の差分） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c"&gt;/* pA&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="c"&gt; = 2階の差分 - 直前の3階の差分（3階の差分） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c"&gt;/* 入力をインプレースで残差に差し替える */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nt"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;-&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;sum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;fs-&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;shift&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nt"&gt;fs-&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;error&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nt"&gt;in&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;} // hybrid_filter_enc
```&lt;/p&gt;
&lt;p&gt;いろんな工夫が見られる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入力信号バッファの先頭4つには&lt;strong&gt;差分値&lt;/strong&gt;が入っている&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pA[7]&lt;/code&gt;: 生の入力信号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pA[6]&lt;/code&gt;: 1階の差分（現在の入力 - 直前の入力）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pA[5]&lt;/code&gt;: 2階の差分（1階の差分 - 直前の1階の差分）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pA[4]&lt;/code&gt;: 3階の差分（2階の差分 - 直前の2階の差分）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pA[3]&lt;/code&gt;: 直前の&lt;code&gt;pA[4]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pA[2]&lt;/code&gt;: 直前の&lt;code&gt;pA[3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pA[1]&lt;/code&gt;: 直前の&lt;code&gt;pA[2]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pA[0]&lt;/code&gt;: 直前の&lt;code&gt;pA[1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;各係数の更新量&lt;code&gt;pM&lt;/code&gt;は次のように決まる。（ただし、&lt;code&gt;sign&lt;/code&gt;は符号関数。&lt;code&gt;sign(0) = 1&lt;/code&gt;）:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pM[7]&lt;/code&gt;: &lt;code&gt;4 * sign(pA[7]) = ((pA[7] &amp;gt;&amp;gt; 30) | 4) &amp;amp; ~3&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;pM[6]&lt;/code&gt;: &lt;code&gt;2 * sign(pA[6]) = ((pA[6] &amp;gt;&amp;gt; 30) | 2) &amp;amp; ~1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pM[5]&lt;/code&gt;: &lt;code&gt;2 * sign(pA[5]) = ((pA[5] &amp;gt;&amp;gt; 30) | 2) &amp;amp; ~1&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;pM[4]&lt;/code&gt;: &lt;code&gt;sign(pA[4])  = ((pA[4] &amp;gt;&amp;gt; 30) | 1)&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;pM[3]&lt;/code&gt;: 直前の&lt;code&gt;pM[4]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pM[2]&lt;/code&gt;: 直前の&lt;code&gt;pM[3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pM[1]&lt;/code&gt;: 直前の&lt;code&gt;pM[2]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pM[0]&lt;/code&gt;: 直前の&lt;code&gt;pM[1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今更ながら示唆がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;フィルタ係数と言うよりは、&lt;strong&gt;微係数&lt;/strong&gt;を適応的に変化させている&lt;/li&gt;
&lt;li&gt;予測も微係数を用いて行う。これは…何らかの補間手法では？&lt;/li&gt;
&lt;li&gt;入力は過去に行くほど影響度が小さくなっている&lt;/li&gt;
&lt;li&gt;係数更新量も過去に行くほど小さくなっている&lt;/li&gt;
&lt;li&gt;更新量は小さいように見えるが、TTAは1秒分のデータをブロックエンコードするので、十分に収束するものと想像&lt;/li&gt;
&lt;li&gt;係数更新が一番最初にきている&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここまで読めたのだから、取り込んでみた。が、性能が悪い。シフト量が鬼門で、どの値に設定すれば良いのかさっぱり。長尺データはそれなりの結果を出している（既存よりは低い）。&lt;strong&gt;係数更新が一番最初に行われるのもだいぶミソだ。予測後に更新したら性能が落ちた。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取り下げるけど、示唆が3点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;係数更新のタイミングを予測前にする&lt;ul&gt;
&lt;li&gt;やったら爆裂に悪化。定義からはずれたと思う。やめ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;古いバッファデータの更新量を小さくする&lt;/li&gt;
&lt;li&gt;係数シフトを乗算右シフトに含める&lt;ul&gt;
&lt;li&gt;これを参考にして、LMSの乗算時右シフトを10bitにしたら32bit整数で計算が完結した。&lt;/li&gt;
&lt;li&gt;圧縮率を犠牲に、32bit演算化の道が開けた感がある。&lt;/li&gt;
&lt;li&gt;しかし、24bit WAVを使用したとき、加算対象の変数を64bitにしたときと32bitnにしたときで差が出る…原因を追う。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;2019.7.15&lt;/h3&gt;
&lt;p&gt;秋葉原製作所8時間取った。ほぼ最後の追い込み。最後の課題はLMSの32bit化。&lt;/p&gt;
&lt;p&gt;変更前（64bit演算、重みシフト10bit）の結果をメモしておく：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;音源&lt;/th&gt;
&lt;th align="center"&gt;圧縮後サイズ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;A112b.wav&lt;/td&gt;
&lt;td align="center"&gt;156819&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;ワン・ツー・スゥイーツ&lt;/td&gt;
&lt;td align="center"&gt;39496924&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;SPARKLE&lt;/td&gt;
&lt;td align="center"&gt;29499550&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;俺の声&lt;/td&gt;
&lt;td align="center"&gt;50884&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;乗算時にオーバーフローは発生していない（テスト確認済み）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;32bitだとどうにも性能が悪い問題があった。これは、固定小数の精度が悪いのが原因（オーバーフロー以外で悪化する原因はこれしか考えられない）。64bit時は30bitも割り当てているから当然。&lt;/p&gt;
&lt;p&gt;係数の更新量テーブルを見直して、更新量を一律1bit右シフトしたら性能がそれなりに良化した。乗算時にオーバーフローしていないかチェックして、問題なければ...と思ったら、24bit音源で2%程の大幅悪化が見られた。&lt;/p&gt;
&lt;p&gt;どうするか…24bit対策するか…&lt;/p&gt;
&lt;p&gt;ひとまず今の更新量テーブル見直しの結果は以下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;音源&lt;/th&gt;
&lt;th align="center"&gt;圧縮後サイズ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;A112b.wav&lt;/td&gt;
&lt;td align="center"&gt;156667&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;ワン・ツー・スゥイーツ&lt;/td&gt;
&lt;td align="center"&gt;39441828&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;SPARKLE&lt;/td&gt;
&lt;td align="center"&gt;29468749&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;俺の声&lt;/td&gt;
&lt;td align="center"&gt;50985&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;アイカツ音源で0.3%の悪化。うーん。手元のデータに都合が良すぎるのか？&lt;/p&gt;
&lt;p&gt;設計上のジャッジを下さねばなるまい。...やはり、圧縮率は落ちるが、速度向上、より広い移植性を目指して32bitでやるべきでは？→やった。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;splint&lt;/code&gt;を全体的に行ってコード整理を行う。&lt;/p&gt;
&lt;p&gt;このタイミングでMP4ALSのソースを見つけてしまった…。一応追加。しかし、Hydrogen Audioでの扱いを信じることにする。&lt;/p&gt;
&lt;p&gt;帰った後でソースを見直していたらロングタームの予測変数が32bitになっていてオーバーフローで圧縮率を悪化させていた…。64bitに直したら、圧縮率を犠牲にしないで32bit化することができた。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="記事"></category><category term="Lossless audio codec"></category></entry><entry><title>フィルタ考察(3)</title><link href="/huirutakao-cha-3.html" rel="alternate"></link><published>2022-03-01T10:00:00+09:00</published><updated>2022-03-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-03-01:/huirutakao-cha-3.html</id><summary type="html">&lt;p&gt;あまり良い考察が得られていない。。構成による有意な差は見えないという結論になりそう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ntt-review.jp/archive/ntttechnical.php?contents=ntr200712sp3.html"&gt;MPEG-4 ALS: Performance, Applications, and Related Standardization Activities&lt;/a&gt; 早すぎ …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;あまり良い考察が得られていない。。構成による有意な差は見えないという結論になりそう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ntt-review.jp/archive/ntttechnical.php?contents=ntr200712sp3.html"&gt;MPEG-4 ALS: Performance, Applications, and Related Standardization Activities&lt;/a&gt; 早すぎでは…？それともFLACが遅くなっている…？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ieice.org/publications/conference-FIT-DVDs/FIT2004/pdf/M/M_016.pdf"&gt;チャンネル間相関を用いた多チャンネル信号の可逆圧縮符号化&lt;/a&gt; チャンネル間相関を使う研究&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=5157037"&gt;An efficient lossless compression of multichannel time-series signals by MPEG-4 ALS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=380001"&gt;IMPROVING JOINT STEREO AUDIO CODING BY ADAPTIVE INTER-CHANNEL PREDICTION&lt;/a&gt; MSから更に進んで片方のチャンネルからもう片方のチャンネルを線形予測する手法。効果があるらしい。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category></entry><entry><title>符号議論(5) とフィルタ考察(2)</title><link href="/fu-hao-yi-lun-5-tohuirutakao-cha-2.html" rel="alternate"></link><published>2022-02-21T10:00:00+09:00</published><updated>2022-02-21T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-02-21:/fu-hao-yi-lun-5-tohuirutakao-cha-2.html</id><summary type="html">&lt;p&gt;ワクチンでくたばる土日。21から再開。
くたばる前に実験していて、最小二乗誤差基準でフィルタを設計した方がより …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ワクチンでくたばる土日。21から再開。
くたばる前に実験していて、最小二乗誤差基準でフィルタを設計した方がより残差をフラットにできていて、
しかもL1ロスが低かった（！）寝てて思ったのが、やっぱLPCの量子化誤差の取り扱いでミスがあるのでは？ということ。&lt;/p&gt;
&lt;p&gt;早速量子化を疑う。flakeとFLACの量子化では量子化誤差を取り込んでいる処理があった。これが致命的とは思えなかったが、入れてみたら性能が向上した。。。（Jazzでは平均0.2%の向上…）&lt;/p&gt;
&lt;p&gt;量子化回りで観察していると、そういえば窓かけしてないことに気づく。でも、依然試したときは圧縮率が悪化していたから、End-to-Endじゃないとダメかと勝手に考えていた。しかし、今日再度突っ込んでみたら良くなる傾向が見られた…どうなっとんねん。&lt;/p&gt;
&lt;p&gt;窓かけにより、寝る前に仕掛けたら平均0.02%の改善が見られた…。とくに補助関数法ではない純粋なLPCで良く減ることが見えている。。。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category></entry><entry><title>符号議論(4) とフィルタ考察(1)</title><link href="/fu-hao-yi-lun-4-tohuirutakao-cha-1.html" rel="alternate"></link><published>2022-02-18T10:00:00+09:00</published><updated>2022-02-18T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-02-18:/fu-hao-yi-lun-4-tohuirutakao-cha-1.html</id><summary type="html">&lt;p&gt;Golomb-Rice符号の長さ解析で、エントロピーと比べたときの冗長度比較を追記しておきたい。冗長度の定義は&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ipnpr.jpl.nasa.gov/progress_report/42-159/159E.pdf"&gt;Selecting the Golomb Parameter in Rice Coding …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Golomb-Rice符号の長さ解析で、エントロピーと比べたときの冗長度比較を追記しておきたい。冗長度の定義は&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ipnpr.jpl.nasa.gov/progress_report/42-159/159E.pdf"&gt;Selecting the Golomb Parameter in Rice Coding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;による。エントロピー &lt;span class="math"&gt;\(H\)&lt;/span&gt; と符号長 &lt;span class="math"&gt;\(L\)&lt;/span&gt; に対して &lt;span class="math"&gt;\(H - L / H\)&lt;/span&gt; という定義。さっそく計測してみたら、平均が大きいところでRice符号よりも冗長度が高い…。これは正直に載せておこう。結果と考察を箇条書きすると、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;幾何分布の平均が1.5以上になるところで冗長度が高い。&lt;/li&gt;
&lt;li&gt;一様乱数に対しては常に良い。&lt;/li&gt;
&lt;li&gt;再帰的Golomb-Riceは、小さい符号語を一葉乱数とみなしているのが強みに思える。昨日の観察結果から、残差が0に近いところではほぼ一様乱数（減少傾向はあるけどエントロピーがほぼ一様乱数のそれ）になっていた。&lt;ul&gt;
&lt;li&gt;2段目のパラメータについては幾何分布の無記憶性が効く。残差を1段目のパラメータで引いてもその分布は近似的に幾何分布に従う。よってGolomb-Rice符号でよい（しかも、理論的には通常のRice符号での最適パラメータでよい）。実際には裾が重いので現実には当てはまらないが、近似にはなっている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;フィルタの考察にはいる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/sicejl1962/22/5/22_5_459/_pdf/-char/ja"&gt;スペクトル解析と最大エントロピー法&lt;/a&gt; ARモデルの次数決定法について、最終予測残差法について書いてある。読むべき。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.clear.rice.edu/elec532/PROJECTS00/vocode/lp.html"&gt;Linear prediction&lt;/a&gt; 音声信号でのLPCの次数をAICとMDLで決める取り組み。前も挙げたかも知れないけど、改めて。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ibisml.org/archive/ibis2014/Kameoka2014IBIS11ver3.pdf"&gt;音声音響信号処理のための確率モデルと学習アルゴリズム&lt;/a&gt; 33pあたりからLPCの確率的解釈について話題。&lt;ul&gt;
&lt;li&gt;「LPCはスペクトル包絡推定に相当」。&lt;/li&gt;
&lt;li&gt;音声のパワースペクトル密度をARの時間発展行列を使って書き直し、複素ガウス分布仮定のもとで最尤推定すると、板倉斎藤距離が出てくる。LPCは、観測したパワースペクトルとARの全極スペクトルを板倉斎藤距離で最小化している。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一番気にしているのはフィルタ次数。次数を高めれば2乗誤差は減るけど、過適合が良くないのではないかとずっと考えていた。flakeは最も符号長の短い次数を探しているから重要なことだと思っている。&lt;/p&gt;
&lt;p&gt;そこでPython実装版で試してみた。以下のようにしてパラメータ数についても最適化をかけた。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;search_optimal_layer_structure&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot; 最適なレイヤーあたりユニット数の探索・設定 &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;residual&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_num_params&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init_layer_structure&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;params_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;max_num_params&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_num_params&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;minnparams&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;num_params&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;params_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;minnorm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;float_info&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;
            &lt;span class="n"&gt;minnunits&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
            &lt;span class="n"&gt;minres&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
            &lt;span class="c1"&gt;# 最小の残差L1ノルムを達成する分割数をレイヤーに設定&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;nunits&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_params&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bit_length&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))]:&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;residual&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;nunits&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;tmplayer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LPCLayer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;num_params&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="n"&gt;nunits&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="n"&gt;tmpres&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmplayer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;forward_with_set_af_parameter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;residual&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="n"&gt;tmpres_norm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmpres&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;tmpres_norm&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;minnorm&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                        &lt;span class="n"&gt;minnorm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmpres_norm&lt;/span&gt;
                        &lt;span class="n"&gt;minnunits&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nunits&lt;/span&gt;
                        &lt;span class="n"&gt;minres&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmpres&lt;/span&gt;
                        &lt;span class="n"&gt;minnparams&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;num_params&lt;/span&gt;
        &lt;span class="c1"&gt;# パラメータとレイヤーを再設定&lt;/span&gt;
        &lt;span class="n"&gt;weight_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;W&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_num_params&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;minnparams&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;weight_name&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;minnparams&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;layers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;LPC&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LPCLayer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;weight_name&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;minnunits&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;residual&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;minres&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実験の結果、手元の音源では、常に最大のパラメータを使ったときにL1ノルムが最小になっていた。すなわち次数選択はあまり効いてきてないらしい。&lt;/p&gt;
&lt;p&gt;またスペクトルの平坦性について見ていたところ、補助関数法をL-Dに入れ替えたら様相が大きく変わった。L1ロスは小さくなるし、ネットワーク構成のパラメータ次数を1,2,4,8,...と設定するよりも、32,16,8,...とした方が平坦性が高かった。どういうこと？最適なユニット数検索を入れて検証したい。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category></entry><entry><title>符号議論(3) とフィルタ考察</title><link href="/fu-hao-yi-lun-3-tohuirutakao-cha.html" rel="alternate"></link><published>2022-02-17T10:00:00+09:00</published><updated>2022-02-17T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-02-17:/fu-hao-yi-lun-3-tohuirutakao-cha.html</id><summary type="html">&lt;p&gt;符号で他に思ったことは、Golomb符号の中でも商部が指数分布（ラプラス分布）に従っているはずで、それをハフマン符号化 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;符号で他に思ったことは、Golomb符号の中でも商部が指数分布（ラプラス分布）に従っているはずで、それをハフマン符号化するとよいのではと考えている。
商部はα符号を使っているが、それはp=1/2の幾何分布を仮定しているはず&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;分布を[0,m]で積分すればわかる&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\int_{0}^{m} p(x) dx = \int_{0}^{m} \frac{\log(2)}{2m} \exp \left( - \frac{\log(2)}{m} |x| \right) dx = \frac{1}{2}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\int_{m}^{2m} p(x) dx = \int_{m}^{2m} \frac{\log(2)}{2m} \exp \left( - \frac{\log(2)}{m} |x| \right) dx = \frac{1}{4}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\int_{(k-1)m}^{km} p(x) dx = \int_{(k-1)m}^{km} \frac{\log(2)}{2m} \exp \left( - \frac{\log(2)}{m} |x| \right) dx = 2^{-k-1}\)&lt;/span&gt; となるのでα符号が理論上最適。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;商だけで見ればそんな大きな値は取らないはず（大きすぎるものは可変長符号で）なので、ハフマン符号は有効に働きそうな気がする。&lt;/p&gt;
&lt;p&gt;これはまず商部の観察から始めるべきで、さっそく今のLINNEで商の分布をプロットした。&lt;/p&gt;
&lt;img alt="Quotient distribution" src="../images/quots.png" /&gt;
&lt;img alt="Quotient distribution (zoom)" src="../images/quots_zoom.png" /&gt;
&lt;p&gt;2枚目は横軸を制限しただけでデータは同様。やはり裾が広い。というか、残差を割ってるだけだから残差分布が出てるだけか。
もしα符号で最適ならば、 &lt;span class="math"&gt;\(\log_{2}\)&lt;/span&gt; の軸上で &lt;span class="math"&gt;\(-1-x\)&lt;/span&gt; となって直線になるがそうなっていない。 &lt;span class="math"&gt;\(x=10\)&lt;/span&gt; を超えたあたりで直線とのズレが出る。&lt;/p&gt;
&lt;p&gt;商が大きい場合はガンマなりデルタ符号を使うべしということになる。これは以前やってたな。商が大きい場合はガンマ符号に切り替える手法。そして試してみたけど1KB程度の改善に留まっている（SLAでもそんなんだった）。負荷とのトレードオフで考えると美味しくない。&lt;/p&gt;
&lt;p&gt;むしろ注目すべきは、商もまた幾何分布に近いというところだろう。早速商をRice符号化したが、悪化。そこまで裾は広くない。&lt;/p&gt;
&lt;p&gt;再帰的Golomb-Riceの1段目の符号に偏りがあるのでは？と思ってプロットしたらたしかに大きい数字は出にくい傾向があった。かなり急激に減少する分布であった（エントロピーは7.6）。&lt;/p&gt;
&lt;img alt="k1 value distribution" src="../images/k1val.png" /&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;k1の各パラメータごとの符号分布に注目するとエントロピーがほぼ割当bitと同じで（k1=4のとき3.99...、k1=7のとき6.99...とか）、ほぼ一様分布の様相。偏りは使えなそう。（一方で、ほぼ理想的であると言える）&lt;/li&gt;
&lt;li&gt;その一様分布が重なって上の分布ができている印象（k1が小さいと違うっぽく、一様に近い）。&lt;/li&gt;
&lt;li&gt;値が小さいとき（2^8=256あたり）はハフマンを使って符号化し、それを超えたらk1を使って2進数出力とか？&lt;ul&gt;
&lt;li&gt;もうちょっと理論詰めたほうがよさそう。実はもう理想的な可能性（現在の符号化で7.6達成済み）を考えている。&lt;ul&gt;
&lt;li&gt;k1の平均をとると6.24と言ってる。これすなわち平均符号長が6.24なので、エントロピーを超えていることになる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;うーん、符号については永遠に終わらん気がしてきたので、フィルタ考察に戻る。その前に、Golomb-Rice符号の長さ解析で、エントロピーと比べたときの冗長度比較を追記しておきたい。&lt;/p&gt;
&lt;p&gt;フィルタの考察も進めたい。flakeの観察から、次数をいじるべきではないかと感じてきている。必ずしもパラメータを全て使って予測するべきではないかもしれない（周波数領域でも激しく振動しており、過適合に見える）。分割をしないケースで考えれば良さそう。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category></entry><entry><title>符号議論(2)</title><link href="/fu-hao-yi-lun-2.html" rel="alternate"></link><published>2022-02-15T10:00:00+09:00</published><updated>2022-02-15T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-02-15:/fu-hao-yi-lun-2.html</id><summary type="html">&lt;p&gt;2日くらいかけて、Rice符号の改良を考えていた。基本となるアイディアは、TAKと同じで、パラメータmの冪以外ののとこ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;2日くらいかけて、Rice符号の改良を考えていた。基本となるアイディアは、TAKと同じで、パラメータmの冪以外ののところも使うというもの。しかし、上手くいってない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;パラメータを2の冪以外にすると、剰余部のbit数が剰余によって変わってくる。&lt;ul&gt;
&lt;li&gt;m=6では剰余として0,1,...,5が出てくるけど、それを3bit符号化してしまうのはあまりにも損。6,7の領域は無駄になる。&lt;ul&gt;
&lt;li&gt;真のGolomb符号では、上手く場合分けして無駄がないようにしている。けど場合分けのコストを入れたくない。&lt;/li&gt;
&lt;li&gt;m=4/3,8/3,16/3,...とか考えてみたけど状況は一緒で、むしろデコード時に3除算が出るので望ましくない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;グダグダ理屈をこねる前に、Golomb符号を使って効果を見るのが良いかもしれない。Golomb符号で良くなければ採用には入らない。&lt;ul&gt;
&lt;li&gt;やっつけでやってみたが、微妙に悪化した。最適なパラメータ設定がうまく動いていない予感。&lt;/li&gt;
&lt;li&gt;再帰的でもないGolombを使った場合でも微妙に悪化。&lt;/li&gt;
&lt;li&gt;パラメータの精密化は筋が悪いか？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;いやまて、TAKは剰余部の取得が先で、なんかうまいとこ場合分けしてたような気がする。まずlog2(m) bitぶんだけとって、次の1bitが立っているかどうかで処理を分けていたような（違うかも）。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category></entry><entry><title>符号議論(1)</title><link href="/fu-hao-yi-lun-1.html" rel="alternate"></link><published>2022-02-13T10:00:00+09:00</published><updated>2022-02-13T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-02-13:/fu-hao-yi-lun-1.html</id><content type="html">&lt;p&gt;Golomb-Rice符号の幾何分布仮定下における平均長さは&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ipnpr.jpl.nasa.gov/progress_report/42-159/159E.pdf"&gt;Selecting the Golomb Parameter in Rice Coding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;にもあった。要注目。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Golomb-Rice"></category></entry><entry><title>フィルタ解析(2)</title><link href="/huirutajie-xi-2.html" rel="alternate"></link><published>2022-02-12T10:00:00+09:00</published><updated>2022-02-12T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-02-12:/huirutajie-xi-2.html</id><summary type="html">&lt;p&gt;ソースの整理が済んで、早速周波数解析を始めている&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;階層ごとにピークを抑えている&lt;ul&gt;
&lt;li&gt;飛び出ている帯域を落とす感 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;ソースの整理が済んで、早速周波数解析を始めている&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;階層ごとにピークを抑えている&lt;ul&gt;
&lt;li&gt;飛び出ている帯域を落とす感じ。逆に、既に落ちている帯域は持ち上げるような特性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ネットワーク前段で高次フィルタを入れると、後段のフィルタがほぼフラットになる&lt;ul&gt;
&lt;li&gt;前段が低次の場合は、後段のフィルタはピークを捉える&lt;/li&gt;
&lt;li&gt;前段のフィルタは大まかな包絡、後段は詳細なピークを捉える感じ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という感じで当然の結果は見えるのだが、これ以上が見えてこない。構造を変えても同じような感じ。ロスもほぼおなじに見える。&lt;/p&gt;
&lt;p&gt;提案したモデルは、入力音声特徴をフラットにしていく過程だと思うが、それを評価する尺度として、spectral flatness (Wiener entropy) を使おうと思う。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;定義に揺れがあるが、 &lt;a class="reference external" href="https://dsp.stackexchange.com/questions/2045/how-do-you-calculate-spectral-flatness-from-an-fft"&gt;Stack Exchange&lt;/a&gt; によると振幅2乗値を使うのが信頼ある定義になる。&lt;ul&gt;
&lt;li&gt;音声特徴については &lt;a class="reference external" href="http://recherche.ircam.fr/equipes/analyse-synthese/peeters/ARTICLES/Peeters_2003_cuidadoaudiofeatures.pdf"&gt;こちら&lt;/a&gt; も参考になる。純音の場合は0, 白色雑音で1を取る尺度。&lt;/li&gt;
&lt;li&gt;AR(1), AR(2) のSpectral flatnessは代数計算できるとのこと&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://dsp.stackexchange.com/questions/42598/spectral-flatness-or-wiener-entropy-for-ar1-and-ar2"&gt;stack exchange&lt;/a&gt; スペクトル、まさに固有値だな…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;パワースペクトル密度を使った Spectrum Entropy （ &lt;a class="reference external" href="https://dsp.stackexchange.com/questions/23689/what-is-spectral-entropy"&gt;丁寧な定義&lt;/a&gt; ）と何が違うんだろう…&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://dsp.stackexchange.com/questions/30534/difference-b-w-spectral-entropy-and-flatness-measure"&gt;答えはstack exchage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Spectral Flatnessは一様分布の仮定が暗に入っている。&lt;/li&gt;
&lt;li&gt;信号自体の構造を入れるならば、Spectrum Entropyに軍配が上がる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そして早速Spectral flatnessとSpectrum entropyを測ってみる&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;後段になるにつれ次数を上げていく構成のほうがSpectral flatness大、かつSpectrum entropy大&lt;ul&gt;
&lt;li&gt;これ要考察。パワースペクトル密度が平坦になっているのは等化に成功していると思えるけど、符号化するのにエントロピー高くていいの？&lt;ul&gt;
&lt;li&gt;&amp;quot;等化に成功&amp;quot;はわかる。次数を上げていく構成の方がフィルタ特性が最後まで生きている（平坦ではない）から。&lt;/li&gt;
&lt;li&gt;最初に大雑把なスペクトラム包絡を削って、次第に細かい特徴を削っていく方式になっている。&lt;/li&gt;
&lt;li&gt;なんかウェーブレット的な考察できん？残差成分に対してスケールを変えたフィルタを適用しているよな。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;少なくとも変換符号化では良くない状態。&lt;/li&gt;
&lt;li&gt;周波数軸で見ているから、実際の符号化対象とは違うと思っていい？ホワイトノイズが0近傍で揺れていたらそれは良いことになる？？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="CNN"></category></entry><entry><title>フィルタ解析(1)</title><link href="/huirutajie-xi-1.html" rel="alternate"></link><published>2022-02-10T10:00:00+09:00</published><updated>2022-02-10T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-02-10:/huirutajie-xi-1.html</id><summary type="html">&lt;p&gt;TAKのソースはGolomb-Rice系であることが読み取れたが、それ以上が見えない。一旦置くべき。しかし、2の冪数以外のパラメータ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;TAKのソースはGolomb-Rice系であることが読み取れたが、それ以上が見えない。一旦置くべき。しかし、2の冪数以外のパラメータも抑えているのは良いアイデア。2の冪数以外のパラメータをテーブル引きで高速計算できればよい。パラメータの選択肢が増えるので圧縮率は上がる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ただし、線形補間しているのがなんかもったいない。 &lt;span class="math"&gt;\(2^3 = 8, 2^4 = 16\)&lt;/span&gt; だけど、 &lt;span class="math"&gt;\(2^{3.5} \approx 11.3137\)&lt;/span&gt; なので、補間値を12としてしまうのはわずかながらずれが出る。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さて、今日からは重要なフィルタ解析に入る。
Pythonでちょちょっとやりたかったが、今だいぶC言語実装と差が出てしまっている。どうするべきか。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;C言語実装成果をPythonに移植してから解析&lt;ul&gt;
&lt;li&gt;移植の手間&lt;/li&gt;
&lt;li&gt;解析のしやすさは1番&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C言語実装のままprintfで係数出力して解析&lt;ul&gt;
&lt;li&gt;手っ取り早さでは1番&lt;/li&gt;
&lt;li&gt;C言語実装が汚れる、デバッグコードが入るのがやだ&lt;/li&gt;
&lt;li&gt;出力形式を独自で定めなければいけん&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今後の結果まとめを考えても、Python移植したほうが良さそう。
というわけで実装整備を兼ねてPython版に着手。&lt;/p&gt;
&lt;p&gt;補助関数法にsin関数を入力すると、僅かな演算誤差（演算順序差）で全く違う解が出たり、行列が特異になったりする。。。実際条件数が高いので相当危険。&lt;/p&gt;
&lt;p&gt;ノイズに関しては問題なかったが、解析になったら困りそう。実際、実信号はノイズ成分が多すぎるのでなるべく簡単な信号から始めようとしている。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="CNN"></category></entry><entry><title>符号の検討(2) TAKソース読み</title><link href="/fu-hao-nojian-tao-2-taksosudu-mi.html" rel="alternate"></link><published>2022-02-08T10:00:00+09:00</published><updated>2022-02-08T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-02-08:/fu-hao-nojian-tao-2-taksosudu-mi.html</id><summary type="html">&lt;p&gt;やはりTAKの符号が気になる。
再帰的Golomb-Riceに近いだろうというのは読めるが、まだ理解しきれてない。&lt;/p&gt;
&lt;p&gt;ffmpegのソースにある、 &lt;a class="reference external" href="https://ffmpeg.org/doxygen/trunk/libavcodec_2takdec_8c_source.html#l00090"&gt;TAK …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;やはりTAKの符号が気になる。
再帰的Golomb-Riceに近いだろうというのは読めるが、まだ理解しきれてない。&lt;/p&gt;
&lt;p&gt;ffmpegのソースにある、 &lt;a class="reference external" href="https://ffmpeg.org/doxygen/trunk/libavcodec_2takdec_8c_source.html#l00090"&gt;TAKの残差デコード実装&lt;/a&gt; は以下。コメントを付す：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;CParam&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="cm"&gt;/* xの初期値のビット幅 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;escape&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="cm"&gt;/* おそらく、再帰的Golomb-Riceの1段目の閾値 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="cm"&gt;/* おそらく、Golomb-Riceの商部に乗じる係数 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;aescape&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* おそらく、再帰的Golomb-Riceの2段目の閾値 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bias&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;xcodes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: 略 */&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* aiki: 略 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;decode_segment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TAKDecContext&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;decoded&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;CParam&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;GetBitContext&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;gb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;gb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decoded&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;decoded&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FF_ARRAY_ELEMS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xcodes&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AVERROR_INVALIDDATA&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;xcodes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: xが最終結果 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: まずcode.initビット読み取った結果をセット（Golomb-Riceの剰余部を先に取得している？） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;get_bits_long&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;escape&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;get_bits1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gb&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: xがcode.escape以上で、続く1ビットが1ならば... （再帰的Golomb-Riceの1段目？） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: 最上位ビットに1をセット 最初の状態からすると x &amp;lt;- get_bits_long(gb, code.init + 1) となるはず */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="cm"&gt;/* TODO: get_bits1(gb) == 0だった場合はifを抜けるけど、これは何を意味する？ */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aescape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: xがcode.aescape以上ならば... （再帰的Golomb-Riceの2段目？） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: 商部scaleの取得に入る。まずはα符号の取得。9で止める */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;get_unary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: scaleが最大の9だったら、scaleの表現ビット数を3ビットで取得 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: 後でcode.biasを足し込む */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;scale_bits&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;get_bits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scale_bits&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scale_bits&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                            &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: scaleの表現ビットが最大の7の場合はさらに5ビット追加で取得 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                            &lt;/span&gt;&lt;span class="n"&gt;scale_bits&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;get_bits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                            &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: scaleが29ビットを超えることはない */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scale_bits&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;29&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AVERROR_INVALIDDATA&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: scaleの差し替え。1だけゲタが入っている */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;get_bits_long&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;scale_bits&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: 商部の加算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: code.biasの加算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bias&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: 商部の加算。scale &amp;lt; 9の場合はcode.escapeを減じる（TODO: なぜ引くのか？） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;escape&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: x &amp;gt; code.aescapeの場合はcode.escapeを減じる */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;escape&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: 符号なし整数から符号付き整数に変換 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;decoded&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;謎のテーブルxcodeの値をプロットしたのが以下：&lt;/p&gt;
&lt;img alt="xcodesのグラフ" src="../images/xcodes.png" /&gt;
&lt;p&gt;明らかに指数的なトレンドがある。コードの内容を10進数に直すと以下：&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;caption&gt;xcodes&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="17%" /&gt;
&lt;col width="17%" /&gt;
&lt;col width="17%" /&gt;
&lt;col width="17%" /&gt;
&lt;col width="17%" /&gt;
&lt;col width="17%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;index&lt;/th&gt;
&lt;th class="head"&gt;init&lt;/th&gt;
&lt;th class="head"&gt;escape&lt;/th&gt;
&lt;th class="head"&gt;scale&lt;/th&gt;
&lt;th class="head"&gt;aescape&lt;/th&gt;
&lt;th class="head"&gt;bias&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;48&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;56&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;52&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;44&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;112&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;104&lt;/td&gt;
&lt;td&gt;192&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;88&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;224&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;48&lt;/td&gt;
&lt;td&gt;48&lt;/td&gt;
&lt;td&gt;208&lt;/td&gt;
&lt;td&gt;384&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;176&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;448&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;416&lt;/td&gt;
&lt;td&gt;768&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;352&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;896&lt;/td&gt;
&lt;td&gt;800&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;192&lt;/td&gt;
&lt;td&gt;192&lt;/td&gt;
&lt;td&gt;832&lt;/td&gt;
&lt;td&gt;1536&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;704&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;td&gt;1792&lt;/td&gt;
&lt;td&gt;1600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;384&lt;/td&gt;
&lt;td&gt;384&lt;/td&gt;
&lt;td&gt;1664&lt;/td&gt;
&lt;td&gt;3072&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;1408&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;3584&lt;/td&gt;
&lt;td&gt;3200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;768&lt;/td&gt;
&lt;td&gt;768&lt;/td&gt;
&lt;td&gt;3328&lt;/td&gt;
&lt;td&gt;6144&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;2816&lt;/td&gt;
&lt;td&gt;1024&lt;/td&gt;
&lt;td&gt;7168&lt;/td&gt;
&lt;td&gt;6400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;1536&lt;/td&gt;
&lt;td&gt;1536&lt;/td&gt;
&lt;td&gt;6656&lt;/td&gt;
&lt;td&gt;12288&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;5632&lt;/td&gt;
&lt;td&gt;2048&lt;/td&gt;
&lt;td&gt;14336&lt;/td&gt;
&lt;td&gt;12800&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;3072&lt;/td&gt;
&lt;td&gt;3072&lt;/td&gt;
&lt;td&gt;13312&lt;/td&gt;
&lt;td&gt;24576&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;11264&lt;/td&gt;
&lt;td&gt;4096&lt;/td&gt;
&lt;td&gt;28672&lt;/td&gt;
&lt;td&gt;25600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;6144&lt;/td&gt;
&lt;td&gt;6144&lt;/td&gt;
&lt;td&gt;26624&lt;/td&gt;
&lt;td&gt;49152&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;22528&lt;/td&gt;
&lt;td&gt;8192&lt;/td&gt;
&lt;td&gt;57344&lt;/td&gt;
&lt;td&gt;51200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;12288&lt;/td&gt;
&lt;td&gt;12288&lt;/td&gt;
&lt;td&gt;53248&lt;/td&gt;
&lt;td&gt;98304&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;45056&lt;/td&gt;
&lt;td&gt;16384&lt;/td&gt;
&lt;td&gt;114688&lt;/td&gt;
&lt;td&gt;102400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;24576&lt;/td&gt;
&lt;td&gt;24576&lt;/td&gt;
&lt;td&gt;106496&lt;/td&gt;
&lt;td&gt;196608&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;90112&lt;/td&gt;
&lt;td&gt;32768&lt;/td&gt;
&lt;td&gt;229376&lt;/td&gt;
&lt;td&gt;204800&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;31&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;49152&lt;/td&gt;
&lt;td&gt;49152&lt;/td&gt;
&lt;td&gt;212992&lt;/td&gt;
&lt;td&gt;393216&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;180224&lt;/td&gt;
&lt;td&gt;65536&lt;/td&gt;
&lt;td&gt;458752&lt;/td&gt;
&lt;td&gt;409600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;33&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;98304&lt;/td&gt;
&lt;td&gt;98304&lt;/td&gt;
&lt;td&gt;425984&lt;/td&gt;
&lt;td&gt;786432&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;34&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;360448&lt;/td&gt;
&lt;td&gt;131072&lt;/td&gt;
&lt;td&gt;917504&lt;/td&gt;
&lt;td&gt;819200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;35&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;196608&lt;/td&gt;
&lt;td&gt;196608&lt;/td&gt;
&lt;td&gt;851968&lt;/td&gt;
&lt;td&gt;1572864&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;36&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;720896&lt;/td&gt;
&lt;td&gt;262144&lt;/td&gt;
&lt;td&gt;1835008&lt;/td&gt;
&lt;td&gt;1638400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;37&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;393216&lt;/td&gt;
&lt;td&gt;393216&lt;/td&gt;
&lt;td&gt;1703936&lt;/td&gt;
&lt;td&gt;3145728&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;38&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;1441792&lt;/td&gt;
&lt;td&gt;524288&lt;/td&gt;
&lt;td&gt;3670016&lt;/td&gt;
&lt;td&gt;3276800&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;39&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;786432&lt;/td&gt;
&lt;td&gt;786432&lt;/td&gt;
&lt;td&gt;3407872&lt;/td&gt;
&lt;td&gt;6291456&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;2883584&lt;/td&gt;
&lt;td&gt;1048576&lt;/td&gt;
&lt;td&gt;7340032&lt;/td&gt;
&lt;td&gt;6553600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;41&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;1572864&lt;/td&gt;
&lt;td&gt;1572864&lt;/td&gt;
&lt;td&gt;6815744&lt;/td&gt;
&lt;td&gt;12582912&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;42&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;5767168&lt;/td&gt;
&lt;td&gt;2097152&lt;/td&gt;
&lt;td&gt;14680064&lt;/td&gt;
&lt;td&gt;13107200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;43&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;3145728&lt;/td&gt;
&lt;td&gt;3145728&lt;/td&gt;
&lt;td&gt;13631488&lt;/td&gt;
&lt;td&gt;25165824&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;44&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;11534336&lt;/td&gt;
&lt;td&gt;4194304&lt;/td&gt;
&lt;td&gt;29360128&lt;/td&gt;
&lt;td&gt;26214400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;6291456&lt;/td&gt;
&lt;td&gt;6291456&lt;/td&gt;
&lt;td&gt;27262976&lt;/td&gt;
&lt;td&gt;50331648&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;46&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;23068672&lt;/td&gt;
&lt;td&gt;8388608&lt;/td&gt;
&lt;td&gt;58720256&lt;/td&gt;
&lt;td&gt;52428800&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;47&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;12582912&lt;/td&gt;
&lt;td&gt;12582912&lt;/td&gt;
&lt;td&gt;54525952&lt;/td&gt;
&lt;td&gt;100663296&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;48&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;46137344&lt;/td&gt;
&lt;td&gt;16777216&lt;/td&gt;
&lt;td&gt;117440512&lt;/td&gt;
&lt;td&gt;104857600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;49&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;25165824&lt;/td&gt;
&lt;td&gt;25165824&lt;/td&gt;
&lt;td&gt;109051904&lt;/td&gt;
&lt;td&gt;201326592&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;法則としては、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;偶数 &lt;code&gt;index&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;escape&lt;/code&gt; ： &lt;code&gt;init &amp;gt;= 4&lt;/code&gt; で &lt;code&gt;escape = 11 * 2^(init - 4)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scale&lt;/code&gt; ： &lt;code&gt;init &amp;gt;= 2&lt;/code&gt; で &lt;code&gt;escape = 2^(init - 2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aescape&lt;/code&gt; ： &lt;code&gt;init &amp;gt;= 2&lt;/code&gt; で &lt;code&gt;aescape = 7 * scale&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bias&lt;/code&gt; ： &lt;code&gt;init &amp;gt;= 4&lt;/code&gt; で &lt;code&gt;bias = 25 * 2^(init - 4)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;奇数 &lt;code&gt;index&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;escape&lt;/code&gt; ： &lt;code&gt;init &amp;gt;= 3&lt;/code&gt; で &lt;code&gt;escape = 6 * 2^(init - 3)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scale&lt;/code&gt; ： &lt;code&gt;init &amp;gt;= 3&lt;/code&gt; で &lt;code&gt;scale = 2^(init - 3) + 2^(init - 2)&lt;/code&gt; （偶数の間を線形補間）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aescape&lt;/code&gt; ： &lt;code&gt;init &amp;gt;= 3&lt;/code&gt; で &lt;code&gt;aescape = scale + 10 * 2^(init - 2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bias&lt;/code&gt; ： &lt;code&gt;init &amp;gt;= 3&lt;/code&gt; で &lt;code&gt;bias = 8 * scale&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;init &amp;lt;= 2&lt;/code&gt; の領域では法則がほぼ当てはまらないが、この領域は非常に振幅が小さいので指数分布になっておらず、おそらく手探りで決めたのだろう。それ以外での法則は見えたが、背景の理論が見えてこない。&lt;/p&gt;
&lt;p&gt;実質、 &lt;code&gt;init&lt;/code&gt; がRice符号、 &lt;code&gt;scale&lt;/code&gt; がGolomb符号のパラメータになっている。Rice符号だと2のべき乗だけになり、奇数 &lt;code&gt;index&lt;/code&gt; の要素は消えることになるが、ここでは補間してよりGolomb符号に近い挙動にしている？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;コードを見ると、初手 &lt;code&gt;init&lt;/code&gt; 分のビットを取得しているのが目につく。これは剰余部を先に取得している。&lt;ul&gt;
&lt;li&gt;剰余部はRice符号に近い形で実装している。または、再帰的Golomb-Rice符号の1段目を同時にやっている？&lt;/li&gt;
&lt;li&gt;剰余部は線形量子化するが、商部はこだわっているように思える。α符号は最大9で止めて、それより長ければビット幅+データで表現。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="TAK"></category><category term="Golomb-Rice"></category></entry><entry><title>符号の検討(1)</title><link href="/fu-hao-nojian-tao-1.html" rel="alternate"></link><published>2022-02-07T10:00:00+09:00</published><updated>2022-02-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2022-02-07:/fu-hao-nojian-tao-1.html</id><summary type="html">&lt;p&gt;忙しく、だいぶ間が空いてしまった。まだ忙しい状態は続くが、研究は地味にエンジンをかけていきたい。&lt;/p&gt;
&lt;p&gt;Macが故障して …&lt;/p&gt;</summary><content type="html">&lt;p&gt;忙しく、だいぶ間が空いてしまった。まだ忙しい状態は続くが、研究は地味にエンジンをかけていきたい。&lt;/p&gt;
&lt;p&gt;Macが故障してpelican環境が壊れたのでブログを刷新。&lt;/p&gt;
&lt;p&gt;これまでの動きをまとめる。まず12月下旬〜年明けは符号に突っ込んでいた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://scripties.uba.uva.nl/search?id=715287"&gt;例の卒論&lt;/a&gt; の結果から、再帰的Golomb-Rice符号の符号パラメータの最適化ができそうというところに目をつけて、できたのでコーデックに組み込んでいた。圧縮率はわずかに上がったし、何より、指数移動平均による更新処理がなくなりデコード速度が上がったのが大きい。&lt;/li&gt;
&lt;li&gt;Flake（FLACの最適化エンコーダ）（ &lt;a class="reference external" href="http://flake-enc.sourceforge.net"&gt;公式&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/justinruggles/flake"&gt;GitHub&lt;/a&gt; ）に割と衝撃を受けている。最大圧縮設定で当時のTAKに迫っている。やっていることはブロック単位で符号長さが最小になるようにGolomb-Rice符号のパラメータとLPC次数を定めている。&lt;ul&gt;
&lt;li&gt;次数が意外に重要な要因なのかも。多すぎて悪化要因になっている？&lt;/li&gt;
&lt;li&gt;Partitioned-Rice（ブロックを分けてその範囲でパラメータを設定するアイデア）はいままで懐疑の目で見ていたけど、性能の良さから採用に傾いた。&lt;/li&gt;
&lt;li&gt;また、 &lt;strong&gt;32bitのbitioもここに実装がある。&lt;/strong&gt; 参考にすべき。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;その後1月下旬は研究会があったのでその準備。そのあたりで並行してRustのお勉強、とても素晴らしい言語。商業的にも意味があると思うし、是非ともマスターしたい。&lt;/p&gt;
&lt;p&gt;引き続き符号に着手。まずは近いと指摘があったblock Gilbert-Mooreの詳細を見ていく。記憶上ではレンジコーダの一種だと思ったが…？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;まずGilbert-Mooreはレンジコーダと思ってもらっていいはず。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.eit.lth.se/fileadmin/eit/courses/eitf01/2008/semin_arif.pdf"&gt;Arithmetic coding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.438.232&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;CODING OF PREDICTION RESIDUAL IN MPEG-4 STANDARD FOR LOSSLESS AUDIO CODING (MPEG-4 ALS)&lt;/a&gt; 再帰的Golomb-Riceに似ている。小さい残差ではblock Gilbert-Moore、大きければ普通のGolomb-Rice。&lt;ul&gt;
&lt;li&gt;これをBGMC(Block Gilbert-Moore Codes)と呼ぶらしい（Data Compresssion - The complete reference本より）&lt;/li&gt;
&lt;li&gt;論文では、LSB部分を直接送ることもしている。&lt;/li&gt;
&lt;li&gt;MPEG4-ALSの実装も多分この論文のとおりになっている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公開されているコードを見ると、やはりレンジコーダに見える。
LSB部分を直接送ることで、頻度テーブル &lt;cite&gt;s_freq&lt;/cite&gt; が大きくなりすぎないようにしている。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Encode a symbol using Gilbert-Moore code.&lt;/span&gt;
&lt;span class="cm"&gt; * delta -- step size in the s_freq[] distribution.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;bgmc_encode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delta&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;short&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s_freq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BITIO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;register&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;range&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* get current range: */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;range&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* narrow the code region to that allotted to this symbol: */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* aiki: ここがまさにレンジコーダ. 下限と上限をテーブル引きで高速に計算できるようにしている */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;range&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s_freq&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delta&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FREQ_BITS&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FREQ_BITS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;range&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s_freq&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delta&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FREQ_BITS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* renormalize interval: */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;HALF&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;put_bit_plus_follow&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* output 0 if in low half  */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;HALF&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="cm"&gt;/* output 1 if in high half */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;put_bit_plus_follow&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;HALF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;HALF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="cm"&gt;/* move down by half        */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FIRST_QTR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;THIRD_QTR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* middle  */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bits_to_follow&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="cm"&gt;/* output an opposite bit   */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FIRST_QTR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="cm"&gt;/* move down by a quarter   */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FIRST_QTR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="cm"&gt;/* otherwise exit the loop  */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* scale interval up: */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* update encoder&amp;#39;s state: */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;cite&gt;s_freq&lt;/cite&gt; を眺めていると、指数的に減少していく頻度テーブルで（おそらく幾何分布orラプラス分布から来ている）、TAKの &lt;cite&gt;xcodes&lt;/cite&gt; に似ているなと思う。TAKはレンジコーダを使っていたのか？？&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="TAK"></category><category term="Golomb-Rice"></category></entry><entry><title>LPCの多段構成執筆(20)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-20.html" rel="alternate"></link><published>2021-12-13T10:00:00+09:00</published><updated>2021-12-13T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-12-13:/lpcnoduo-duan-gou-cheng-zhi-bi-20.html</id><summary type="html">&lt;p&gt;最適化に突っ込んでた。よくない。でも、畳み込み演算でインデックスの走査方向が異なるのは良くないことに気づけ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;最適化に突っ込んでた。よくない。でも、畳み込み演算でインデックスの走査方向が異なるのは良くないことに気づけたのは良かった。&lt;/p&gt;
&lt;p&gt;ブロックサイズが大きいので8192に変える→圧縮率・デコード速度悪化。当然か。圧縮率については8192に合った設定があるだろうし、デコード速度についてはブロックサイズが減るので畳み込み演算の効率が落ちる。&lt;/p&gt;
&lt;p&gt;高速化の絡み。絶対値残差計算が重いので、分割設定にAICかMDLを使えないか考えている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.orsj.or.jp/~archive/pdf/bul/Vol.41_07_375.pdf"&gt;AICとMDLとBIC&lt;/a&gt; 赤池先生の解説。AICの明確な導出もある。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.clear.rice.edu/elec532/PROJECTS00/vocode/lp.html"&gt;Linear prediction&lt;/a&gt; 線形予測でのAICとMDLの比較。MDLの方がLPCとBurgの両方で明確な谷を示していた。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1046.6692&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;CHOICE OF FILTER ORDER IN LPC ANALYSIS OF VOWELS&lt;/a&gt; 母音推定のときのLPCの次数決定にAIC, MDLを使う&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;しかし、LPCに対する基準には結局分散（2乗残差）が出ている。絶対値残差最小化の意味でやれないか？？と思うんだけど、ラプラス分布の最尤推定値は絶対値残差だ。&lt;/p&gt;
&lt;p&gt;となると、次は平均絶対値残差の推定がしたくなってくる。でもそんな手法は無いように見える…&lt;/p&gt;
&lt;p&gt;補助関数法自体の高速化に命かけたほうがいいんじゃないかと思えてきた。圧縮率にも関係してくるし。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>とあるCのプログラミングパターン</title><link href="/toarucnopuroguramingupatan.html" rel="alternate"></link><published>2021-12-05T00:00:00+09:00</published><updated>2021-12-05T00:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-12-05:/toarucnopuroguramingupatan.html</id><summary type="html">&lt;p&gt;C言語のプログラミングパターン&lt;/p&gt;</summary><content type="html">&lt;h3&gt;注意&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;原理的にCではオブジェクト指向プログラミングはできない。ここで述べるのはオブジェクト指向 &lt;strong&gt;チック&lt;/strong&gt; であることに注意。C言語を使わざるを得ない環境で使うと良い。（例：コンパイラがCしかない、ランタイムが貧弱）&lt;/li&gt;
&lt;li&gt;あくまで例であり、すべての問題はこのスタイルでは解決できない。プログラミングする対象に合わせて、柔軟にスタイルを切り替えるべし。&lt;/li&gt;
&lt;li&gt;この例をコピペして使わないこと。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;例1：Fooモジュールの実装&lt;/h2&gt;
&lt;p&gt;例として、&lt;code&gt;Foo&lt;/code&gt; というモジュールの実装を示す。&lt;/p&gt;
&lt;h3&gt;ヘッダファイル foo.h&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cm"&gt;/* ヘッダの多重インクルード防止（ヘッダインクルードガード） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef FOO_H_INCLUDED&lt;/span&gt;
&lt;span class="cp"&gt;#define FOO_H_INCLUDED&lt;/span&gt;

&lt;span class="cm"&gt;/* このモジュールが使用する型定義を含むヘッダ(C99) */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdint.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* 構造体定義は隠して宣言のみを行う（前方宣言） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;FooTag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;FooHn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* インスタンスを作成するためのコンフィグ構造体 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;FooConfigTag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="cm"&gt;/* パラメータ数 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FooConfig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* APIの成否を示す型 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FooApiResultTag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;FOO_APIRESULT_OK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="cm"&gt;/* 成功 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;FOO_APIRESULT_NG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="cm"&gt;/* 分類不能な失敗 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;FOO_APIRESULT_INVALID_ARGUMENT&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* 引数が不正 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FooApiResult&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Cリンケージで関数宣言（補遺にて解説） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#ifdef __cplusplus&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* __cplusplus */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fooモジュールの初期化 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* 必要に応じてリソースの初期化などを行う */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Foo_Initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fooモジュールの終了 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* Initializeで初期化した内容を片付ける */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Foo_Finalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fooインスタンス作成に必要なワークサイズの計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* 失敗した場合は負値を返す */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Foo_CalculateWorkSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FooConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fooインスタンスの作成 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* 失敗した場合はNULLを返す */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;FooHn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Foo_Create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FooConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* パラメータ数の取得 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;FooApiResult&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Foo_GetNumParameters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FooHn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fooインスタンスの破棄 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Foo_Destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FooHn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#ifdef __cplusplus&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* __cplusplus */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* FOO_H_INCLUDED */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Foo&lt;/code&gt; というモジュールがあった場合、そのクラスインスタンスを扱う実体（&lt;strong&gt;ハンドル&lt;/strong&gt;）は &lt;code&gt;FooHn&lt;/code&gt;、関数は &lt;code&gt;Foo_HogePiyo&lt;/code&gt; という命名規則をつける（命名規則は各プロダクトのコーディングスタイルによって揺らぐので、この規則は絶対ではない）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Foo_Create&lt;/code&gt;によってクラスインスタンスが作られる（クラスのコンストラクタに該当）。&lt;code&gt;Foo_Create&lt;/code&gt;の前に &lt;code&gt;Foo_CalculateWorkSize&lt;/code&gt; によって必要なワークサイズ（メモリ領域サイズ）を計算する必要があることに注意。&lt;code&gt;Foo_Create&lt;/code&gt;では &lt;code&gt;work&lt;/code&gt; に任意のアドレスを指定する事ができる（C++の配置newに該当）。&lt;/li&gt;
&lt;li&gt;インスタンスに対して何かを実行する際には、&lt;code&gt;Foo_GetNumParameters&lt;/code&gt; の様に、必ずハンドルを介して行う（Pythonの&lt;code&gt;self&lt;/code&gt;等に該当）。&lt;/li&gt;
&lt;li&gt;インスタンスを破棄するときには &lt;code&gt;Foo_Destroy&lt;/code&gt; を使用する（クラスのデストラクタに該当）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;実装ファイル foo.c&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;foo.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* このモジュールが保証するアラインメント */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* アラインメントについては別途説明する */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define FOO_ALIGNMENT 16&lt;/span&gt;

&lt;span class="cm"&gt;/* アドレスをアラインメント境界に揃えるマクロ */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define FOO_ALIGN_NBYTE(ptr, alignment) ((((ptr) + ((alignment) - 1)) / (alignment)) * (alignment))&lt;/span&gt;

&lt;span class="cm"&gt;/* メモリの無効値を示す値 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define FOO_INVALID_BYTE_PATTERN 0xCD&lt;/span&gt;

&lt;span class="cm"&gt;/* Fooオブジェクトの構造体定義 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;FooTag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="cm"&gt;/* パラメータ領域 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* パラメータ数 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="cm"&gt;/* ワーク領域先頭アドレス */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="cm"&gt;/* ワークサイズ */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* ローカル変数宣言 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* モジュール初期化フラグ */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;st_foo_is_initialized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fooモジュールの初期化 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Foo_Initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 多重初期化防止 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st_foo_is_initialized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 必要に応じてリソースの初期化・確保 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 初期化フラグを立てる */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;st_foo_is_initialized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fooモジュールの終了 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Foo_Finalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 初期化前では実行不可能 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st_foo_is_initialized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 必要に応じてリソースの破棄 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 初期化フラグをクリア */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;st_foo_is_initialized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fooインスタンス作成に必要なワークサイズの計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Foo_CalculateWorkSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FooConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 引数チェック */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* コンフィグチェック */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 構造体分のサイズ */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;FooTag&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* パラメータ領域分のサイズ */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* アラインメント分加算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FOO_ALIGNMENT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fooインスタンスの作成 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;FooHn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Foo_Create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FooConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;FooHn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 引数チェック */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* コンフィグチェック */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 未初期化メモリ領域のアクセス防止（メモリを無効値で埋める） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FOO_INVALID_BYTE_PATTERN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* アラインメント境界に揃える */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;work_ptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;FOO_ALIGN_NBYTE&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;uintptr_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FOO_ALIGNMENT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 構造体の配置 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FooHn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;work_ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;work_ptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;FooTag&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* メンバに値を設定 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* パラメータ領域の配置 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;work_ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;work_ptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* バッファオーバーラン検知 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;work_ptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 領域先頭アドレスとワークサイズを記録 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* 何らかの処理の実行 例: パラメータ数の取得 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;FooApiResult&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Foo_GetNumParameters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FooHn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 引数チェック */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FOO_APIRESULT_INVALID_ARGUMENT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 結果をセット */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 成功終了 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FOO_APIRESULT_OK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fooインスタンスの破棄 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Foo_Destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FooHn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* メモリが無効な場合は何もしない */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* メモリを無効値で埋める */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;memset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FOO_INVALID_BYTE_PATTERN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;メインエントリ main.c&lt;/h3&gt;
&lt;p&gt;ライブラリ使用者たるユーザが書くコードは次のようになる。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cm"&gt;/* 依存ヘッダインクルード */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;foo.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* メインエントリ */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;FooHn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;FooConfig&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* コンフィグの設定 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;num_parameters&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* インスタンス生成に必要なワークサイズ計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Foo_CalculateWorkSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* メモリ領域確保 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* インスタンス生成 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Foo_Create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* 確保済み領域は開放 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* やりたいことをする */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_params&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Foo_GetNumParameters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;num_params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FOO_APIRESULT_OK&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Number of parameters: %d &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_params&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* インスタンス破棄 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Foo_Destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;例2：インターフェース&lt;/h2&gt;
&lt;p&gt;多相性（ポリモーフィズム）を実現する例を示す。多相性とは、関数呼び出しは同じだけども振る舞いが変わるようなことを指す。例えば、犬とか猫は共通の「鳴く」という動作（関数）を持つが、実際に実行すると全く違った鳴き声が得られるといったことを指す。&lt;/p&gt;
&lt;p&gt;うまくインターフェースが定義できると、モジュール間の情報のやり取りが非常に楽になる。例えば、画像に対してフィルタを適用することを考えてみる。インターフェースを使う側から考えると、フィルタに画像入力を与えて処理済みの出力さえ得られればよいので、その中身の実装を気にする必要がなくなる。もし出力がおかしければ、フィルタ側の不具合を疑って修正していけばよいのでデバッグ効率も高まる。&lt;/p&gt;
&lt;h3&gt;インターフェースの定義ヘッダ  animal.h&lt;/h3&gt;
&lt;p&gt;C言語でインターフェースを実現するには、 &lt;strong&gt;関数ポインタの構造体&lt;/strong&gt; を使うのが普通である。インターフェースの定義をまとめたヘッダを以下に示す。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#ifndef ANIMAL_H_INCLUDED&lt;/span&gt;
&lt;span class="cp"&gt;#define ANIMAL_H_INCLUDED&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdint.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* インスタンス生成用のコンフィグ */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;AnimalConfig&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalConfig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* インターフェース定義 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;AnimalInterfaceTag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* ワークサイズ計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;CalculateWorkSize&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* インスタンス生成 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;Create&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 鳴かせる */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;MakeSound&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* インスタンス破棄 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;Destroy&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalInterface&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* ANIMAL_H_INCLUDED */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;インターフェースの実装例1（Piyo）&lt;/h3&gt;
&lt;h4&gt;Piyoのヘッダ piyo.h&lt;/h4&gt;
&lt;p&gt;インターフェースを実装したPiyoは、インターフェースの取得関数 &lt;code&gt;Piyo_GetInterface&lt;/code&gt; のみを公開する。こうすることで使用者側に実装の内容を隠蔽でき、インターフェースのみを介して操作するようにできる。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#ifndef PIYO_H_INCLUDED&lt;/span&gt;
&lt;span class="cp"&gt;#define PIYO_H_INCLUDED&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;animal.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#ifdef __cplusplus&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* __cplusplus */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Piyoインターフェースの取得 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalInterface&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Piyo_GetInterface&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#ifdef __cplusplus&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* __cplusplus */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* PIYO_H_INCLUDED */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;Piyoの実装  piyo.c&lt;/h4&gt;
&lt;p&gt;インターフェースの実装はソースファイル(.c)に行う。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;piyo.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Piyoオブジェクト定義 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;PiyoTag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;PiyoHn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* ワークサイズ計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Piyo_CalculateWorkSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* Piyoインスタンス生成 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Piyo_Create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* Piyoを鳴かせる */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Piyo_MakeSound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* Piyoインスタンス破棄 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Piyo_Destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Piyoインターフェース定義 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalInterface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;st_piyo_interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Piyo_CalculateWorkSize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Piyo_Create&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Piyo_MakeSound&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Piyo_Destroy&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Piyoインターフェースの取得 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalInterface&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Piyo_GetInterface&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;st_piyo_interface&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* ワークサイズ計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Piyo_CalculateWorkSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 引数チェック */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 自分でメモリ領域を確保するため要求サイズは0 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Piyoインスタンス生成 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Piyo_Create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;PiyoHn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;piyo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 引数チェック */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* Piyoハンドルの作成 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;piyo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PiyoHn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;PiyoTag&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* コンフィグ値をセット */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;piyo&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;piyo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Piyoを鳴かせる */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Piyo_MakeSound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;PiyoHn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;piyo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 引数チェック */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;piyo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PiyoHn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 鳴く */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I&amp;#39;m Piyo. Age: %d &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;piyo&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Piyoインスタンス破棄 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Piyo_Destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;インターフェースの実装例2（Fuga）&lt;/h3&gt;
&lt;p&gt;同一インターフェースだが、Piyoと異なる振る舞いを示すモジュールFugaのヘッダと実装を示す。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#ifndef FUGA_H_INCLUDED&lt;/span&gt;
&lt;span class="cp"&gt;#define FUGA_H_INCLUDED&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;animal.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#ifdef __cplusplus&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* __cplusplus */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fugaインターフェースの取得 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalInterface&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Fuga_GetInterface&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#ifdef __cplusplus&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* __cplusplus */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* FUGA_H_INCLUDED */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;fuga.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fugaオブジェクト定義 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;FugaTag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;FugaHn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* ワークサイズ計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Fuga_CalculateWorkSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* Fugaインスタンス生成 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Fuga_Create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* Fugaを鳴かせる */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Fuga_MakeSound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* Fugaインスタンス破棄 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Fuga_Destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fugaインターフェース定義 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalInterface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;st_fuga_interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Fuga_CalculateWorkSize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Fuga_Create&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Fuga_MakeSound&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Fuga_Destroy&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fugaインターフェースの取得 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalInterface&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Fuga_GetInterface&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;st_fuga_interface&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* ワークサイズ計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Fuga_CalculateWorkSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 引数チェック */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 自分でメモリ領域を確保するため要求サイズは0 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fugaインスタンス生成 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Fuga_Create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalConfig&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;FugaHn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fuga&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 引数チェック */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* Fugaハンドルの作成 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;fuga&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FugaHn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;FugaTag&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* コンフィグ値をセット */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;fuga&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fuga&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fugaを鳴かせる */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Fuga_MakeSound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;FugaHn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fuga&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 引数チェック */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;fuga&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FugaHn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 鳴く */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I&amp;#39;m Fuga. Age: %d &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fuga&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Fugaインスタンス破棄 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Fuga_Destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;メインエントリ main.c&lt;/h3&gt;
&lt;p&gt;PiyoとFugaを使用するソースコード例は以下になる。インターフェースを利用する側としては、内部の実装を知らずにインスタンスの操作を行うことができる。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cm"&gt;/* 依存ヘッダインクルード */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;piyo.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;fuga.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdint.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* メインエントリ */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;animal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;animal_work&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;AnimalConfig&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalInterface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;interface_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 処理対象のインターフェースを取得 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;interface_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Piyo_GetInterface&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;interface_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Fuga_GetInterface&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* リスト内のインターフェースに対して共通の処理 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AnimalInterface&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;animal_if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;interface_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* コンフィグの設定 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* インスタンス生成に必要なワークサイズ計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;animal_if&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;CalculateWorkSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* メモリ領域確保 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;animal_work&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;animal_work&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* インスタンス生成 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;animal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;animal_if&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;animal_work&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;work_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;animal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="cm"&gt;/* 確保済み領域は開放 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;animal_work&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* 鳴かせる */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;animal_if&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;MakeSound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;animal&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* インスタンス破棄 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;animal_if&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;animal&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;animal_work&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1&gt;補遺&lt;/h1&gt;
&lt;h2&gt;C言語で書かれたライブラリの提供形態&lt;/h2&gt;
&lt;p&gt;C言語で開発したライブラリを商業に展開するときは、以下の2つをユーザに提供することが多い。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ヘッダファイル(.h)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ライブラリを使用するために必要な型、構造体、列挙型、関数宣言等が含まれる。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ライブラリファイル(.a, .so, .lib)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;多数のソースファイル(.c, .h)をコンパイルしてアーカイブした（取りまとめた）もの。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例ではソースファイル(.c)を載せているが、関数の実装は隠蔽するためにソースファイルは原則公開しない。&lt;/p&gt;
&lt;h2&gt;extern "C" について&lt;/h2&gt;
&lt;p&gt;Cの関数（変数）をヘッダで宣言するときは、以下のように&lt;code&gt;extern "C"&lt;/code&gt;で括った方が良い。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#ifndef BAR_H_INCLUDED&lt;/span&gt;
&lt;span class="cp"&gt;#define BAR_H_INCLUDED&lt;/span&gt;

&lt;span class="cp"&gt;#ifdef __cplusplus&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* __cplusplus */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#ifdef __cplusplus&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* __cplusplus */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#endif &lt;/span&gt;&lt;span class="cm"&gt;/* BAR_H_INCLUDED */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;単一の関数（変数）ならば、以下のように書いても良い。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;これはCとC++との相互運用の際に必要になってくる。C++の言語仕様には名前空間があり、関数（変数）は名前空間に応じた名前（シンボル）を持って（マングルされて）オブジェクトファイル(.obj, .o)に出力される。一方、Cの関数は（&lt;code&gt;static&lt;/code&gt;でない限り）全てグローバルなシンボルを持つ。&lt;/p&gt;
&lt;p&gt;何も対策を行わない場合、C++コンパイラとCコンパイラで異なる名前（シンボル）を持つようになってしまい、相互に参照できなくなりリンクエラーが生じてしまう。そこで、&lt;code&gt;extern "C"&lt;/code&gt;が必要になってくる。&lt;code&gt;extern "C"&lt;/code&gt;で括られた関数はC言語と同様の宣言を行うことを強制するため、上記の問題を回避できる。&lt;/p&gt;
&lt;h2&gt;アラインメント&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;メモリに関して気にしたければ読んでください。&lt;/strong&gt;
CPUはある特定のバイト境界に合わせてメモリをアクセスしている。この境界を（メモリ）&lt;strong&gt;アラインメント&lt;/strong&gt;という。例えば、16バイトアラインメントでアクセスする場合、変数や配列の先頭アドレスは必ず16の倍数に配置されていなければならない。配置されていない場合は&lt;a href="https://ja.wikipedia.org/wiki/%E3%83%90%E3%82%B9%E3%82%A8%E3%83%A9%E3%83%BC"&gt;バスエラー&lt;/a&gt;が発生する。（実行時に補正を行うことでエラーが起きない場合もあるが、補正によるオーバーヘッドがかかる）&lt;/p&gt;
&lt;p&gt;上記のプログラム例では、メモリ上に直接構造体の内容を書き込んでいるため、アラインメントを意識しなければならない。&lt;/p&gt;
&lt;p&gt;使用するCPUによってアラインメントは異なり、もっと言うと特定の機械語命令がアラインメントを要求するときがある。例えば、IntelのSSE命令（1命令で複数数値の数値演算を行う命令）では、命令に渡すアドレスに16バイトアラインメントを要求する。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href="http://www5d.biglobe.ne.jp/~noocyte/Programming/Alignment.html"&gt;データ型のアラインメントとは何か，なぜ必要なのか？&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;マルチスレッド&lt;/h2&gt;
&lt;p&gt;上記の例ではマルチスレッド環境のことは全く考えずに実装している。排他はユーザ側が行う必要がある。&lt;/p&gt;
&lt;p&gt;実装者がマルチスレッドセーフにモジュールを作るのは難しい。上記の例でも、例えば、&lt;code&gt;Foo_Destroy&lt;/code&gt; が呼ばれた直後に別のスレッドから &lt;code&gt;Foo_GetNumParameters&lt;/code&gt; が呼ばれるかもしれない。そうなるとどうなるか分からない。すぐクラッシュすれば運が良いが、ひどい場合は何も起こらずに、開放したメモリ領域を再利用した他のモジュールのメモリ領域を破壊して実行し続けるかもしれない。いずれにせよ、追跡の難しい不具合を生むことになる。&lt;/p&gt;
&lt;p&gt;マルチスレッドセーフに作る仕組みとしては例えばロックやセマフォがある。しかし、次はデットロック（ライブロック）、排他待ちによる性能悪化に対応する必要がある。&lt;/p&gt;
&lt;p&gt;一般にC言語でマルチスレッド実装を安全に実現するのは難しい。&lt;/p&gt;
&lt;h2&gt;コンフィグのメンバにポインタを使う時&lt;/h2&gt;
&lt;p&gt;文字列を始め、配列をコンフィグに渡すならばポインタを使うことになる。&lt;/p&gt;
&lt;p&gt;そのポインタが指す内容の生存期間を仕様として明らかにし、実装者とユーザ両方で約束として守らせる。
- インスタンスにアドレスだけコピーされるのか？
- ポインタが指す内容ごとコピーされるのか？&lt;/p&gt;
&lt;p&gt;さもなくばメモリの不定領域にアクセスして奇妙な振る舞いを示すようになる。設計の際に注意する。&lt;/p&gt;
&lt;h2&gt;内部モジュールとして使う時&lt;/h2&gt;
&lt;p&gt;ユーザに公開することのない内部モジュールで実装するならば、プログラミングミスを防いだり、デバッグ効率を高めるために、チェックを厳しくしたほうがよい。具体的には &lt;code&gt;assert&lt;/code&gt;（C標準の &lt;code&gt;assert.h&lt;/code&gt; にマクロ定義がある） を使う。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cm"&gt;/* Fooモジュールの初期化 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Foo_Initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 多重初期化防止 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st_foo_is_initialized&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;補足：&lt;code&gt;assert&lt;/code&gt; は引数の条件が成立しないときにプログラムを強制停止（アボート）させる。その際、（ランタイムにより多少の差はあるが）条件チェックに失敗した行などの診断メッセージを出せる。（補足の補足：デバッグ向けにコンパイルしていないと &lt;code&gt;assert&lt;/code&gt; が有効にならない場合がある。&lt;code&gt;gcc&lt;/code&gt;では&lt;code&gt;-DDEBUG&lt;/code&gt;フラグを指定する必要がある。）&lt;/p&gt;</content><category term="記事"></category><category term="C89"></category></entry><entry><title>LPCの多段構成執筆(19)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-19.html" rel="alternate"></link><published>2021-12-04T10:00:00+09:00</published><updated>2021-12-04T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-12-04:/lpcnoduo-duan-gou-cheng-zhi-bi-19.html</id><summary type="html">&lt;p&gt;パラメータ調節以外の残りのTODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;音声データを10秒単位で切り刻む&lt;ul&gt;
&lt;li&gt;Rubyでパパパっとやって、オワリッ！やる気の問題。&lt;/li&gt;
&lt;li&gt;Ruby …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;パラメータ調節以外の残りのTODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;音声データを10秒単位で切り刻む&lt;ul&gt;
&lt;li&gt;Rubyでパパパっとやって、オワリッ！やる気の問題。&lt;/li&gt;
&lt;li&gt;Rubyのwav-fileは波形データが本質的にバイナリだから切り出しを考えるのがだるかった。&lt;/li&gt;
&lt;li&gt;Pythonのに乗り換えた。scipy.io.wavfileが圧倒的に使いやすい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;窓掛けをまだやってない&lt;ul&gt;
&lt;li&gt;サイン窓で試したが、微妙。圧縮率が上がったり下がったり。パラメータ数を増やすと少しマシ&lt;/li&gt;
&lt;li&gt;ハン窓はもっと悪い傾向。&lt;/li&gt;
&lt;li&gt;納得いってない。バグを疑っているが、単純なので失敗しようがない。。&lt;/li&gt;
&lt;li&gt;End-to-endでやるにあたり解析信号をいじるのは良くないこと？&lt;/li&gt;
&lt;li&gt;長区間で窓をかけてしまうのは良くない？とおもって分割サンプル数で場合分けしたが、やはり微妙。窓掛けしない場合に漸近しているように見える。&lt;/li&gt;
&lt;li&gt;窓掛けは取り下げ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Burg法の性能が悪い原因の調査&lt;ul&gt;
&lt;li&gt;やはり微妙。ピアノだけのような特性がはっきりした音源は少し良い傾向。&lt;/li&gt;
&lt;li&gt;共分散を使うのをやめて、定義式どおり（Burg Recursion）にやってみる&lt;/li&gt;
&lt;li&gt;同様の傾向（微妙に上がったり下がったりするだけ）。また、Burg Recursionの方が早い。なぜなら自己共分散の計算無しでやれるから。（前向き残差と後ろ向き残差を持たなければならないのでメモリ効率は悪い）&lt;/li&gt;
&lt;li&gt;理由がわからない。自分の前向き・後ろ向き絶対値残差も良くないことを踏まえると、ネットワークが前向き残差を伝播していくのが効いている？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;逆誤差伝播学習をやるかどうかはエンコードパラメータに入れ、コマンドラインから選ぶようにする&lt;ul&gt;
&lt;li&gt;やった。OK。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(18)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-18.html" rel="alternate"></link><published>2021-12-03T10:00:00+09:00</published><updated>2021-12-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-12-03:/lpcnoduo-duan-gou-cheng-zhi-bi-18.html</id><summary type="html">&lt;p&gt;パラメータ調節以外の残りのTODOを考えていた。あんまり大きなことではないのでスキマ時間でやっていきたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;音声 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;パラメータ調節以外の残りのTODOを考えていた。あんまり大きなことではないのでスキマ時間でやっていきたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;音声データを10秒単位で切り刻む&lt;/li&gt;
&lt;li&gt;窓掛けをまだやってない&lt;/li&gt;
&lt;li&gt;Burg法の性能が悪い原因の調査&lt;/li&gt;
&lt;li&gt;逆誤差伝播学習をやるかどうかはエンコードパラメータに入れ、コマンドラインから選ぶようにする&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(17)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-17.html" rel="alternate"></link><published>2021-12-01T10:00:00+09:00</published><updated>2021-12-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-12-01:/lpcnoduo-duan-gou-cheng-zhi-bi-17.html</id><summary type="html">&lt;p&gt;提案手法（絶対値残差Burg）はやはり性能微悪化。
分割の探索でロスが上がったら打ち切るのはだめだった。値をダンプし …&lt;/p&gt;</summary><content type="html">&lt;p&gt;提案手法（絶対値残差Burg）はやはり性能微悪化。
分割の探索でロスが上がったら打ち切るのはだめだった。値をダンプしてみても、凸関数的ではなく、上がったり下がったりしている。&lt;/p&gt;
&lt;p&gt;ブロックサイズを増やせば、まだパラメータ増加に従って性能改善していくのが見えている。しかしレイテンシが気になっている。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(16)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-16.html" rel="alternate"></link><published>2021-11-30T10:00:00+09:00</published><updated>2021-11-30T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-11-30:/lpcnoduo-duan-gou-cheng-zhi-bi-16.html</id><summary type="html">&lt;p&gt;提案手法（絶対値残差Burg）は実験回しておきたい、また、分割の探索はロスが上がり始めたら打ち切ってもいいと思う。観 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;提案手法（絶対値残差Burg）は実験回しておきたい、また、分割の探索はロスが上がり始めたら打ち切ってもいいと思う。観察は必須。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(15)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-15.html" rel="alternate"></link><published>2021-11-28T10:00:00+09:00</published><updated>2021-11-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-11-28:/lpcnoduo-duan-gou-cheng-zhi-bi-15.html</id><summary type="html">&lt;p&gt;Burg法の方が圧縮率が高いはず（亀岡さんの文献と例の卒論から）なので、今の状況が納得できず、Burg法のデバッグ中。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;共分 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Burg法の方が圧縮率が高いはず（亀岡さんの文献と例の卒論から）なので、今の状況が納得できず、Burg法のデバッグ中。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;共分散行列をナイーブ計算しても結果変わらず。バグではなさそう。&lt;/li&gt;
&lt;li&gt;はっきり言ってL-D法との差が見当たらない。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分割数の観察をすると、Python版でも見ていたけど、1層目は1分割で、2層目以降でたかだか32とか16分割といった感じ。分割しすぎても性能が伸びないのは明らかだから、分割数を記録するビット幅を減らそうかと考えている。&lt;/p&gt;
&lt;p&gt;しかし、ビット幅を3から2に減らしても悪化の傾向。ビット幅3と2では大きな差がある。3では7、つまり128パラメータまで対応できるが、2では8までしか対応できない。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(14)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-14.html" rel="alternate"></link><published>2021-11-25T10:00:00+09:00</published><updated>2021-11-25T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-11-25:/lpcnoduo-duan-gou-cheng-zhi-bi-14.html</id><summary type="html">&lt;p&gt;メモリ破壊バグが原因で32より大きいパラメータで圧縮率が極端に低下していた。これまでパラメータの増やし過 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;メモリ破壊バグが原因で32より大きいパラメータで圧縮率が極端に低下していた。これまでパラメータの増やし過ぎは良くないと思っていたが、原因はくだらない不具合だった。また、Releaseビルドでずっと試していて、assertに気付かなかったのも大きい。&lt;/p&gt;
&lt;p&gt;そしてパラメータを増やしていくと、圧縮率がどんどん良くなっていく。WavPack(-hh)は確実に倒した。1層あたり128まで増やしておく。&lt;/p&gt;
&lt;p&gt;Burg法を実装して、L-D法を入れ替える形で組み込んでみた。しかしALAで見たようにトイデータでL-D方よりも小さいRMSを出しているが、実データで微妙。&lt;/p&gt;
&lt;p&gt;気になってるのは自分の実装は共分散行列を使った実装をしている。例の簡易再帰実装の方がトイデータでRMSが良いが、係数を除くと5.0, -4.0とか出しててなにか危ないものを感じる。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(13)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-13.html" rel="alternate"></link><published>2021-11-21T10:00:00+09:00</published><updated>2021-11-21T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-11-21:/lpcnoduo-duan-gou-cheng-zhi-bi-13.html</id><summary type="html">&lt;p&gt;後ろ向き残差を含めた定式化、試しているが微妙。
音量が小さい音源で改善が見られたが、POPSなど音圧の大きい音源で …&lt;/p&gt;</summary><content type="html">&lt;p&gt;後ろ向き残差を含めた定式化、試しているが微妙。
音量が小さい音源で改善が見られたが、POPSなど音圧の大きい音源で悪化の傾向。実際に大きなデータセットで試してみないことには結論が出せないので、やるに限る。この結果を見て執筆の大枠を詰めていく。&lt;/p&gt;
&lt;p&gt;負荷が大きいのは、やはり補助関数法を連打しているのが大きい。。。分割決定時にも実行しているので尚更という感じ。&lt;/p&gt;
&lt;p&gt;そしてまたPARCOR符号化の符号長の議論を思い出す。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/ast/34/2/34_E1250/_pdf/-char/ja"&gt;Low-complexity PARCOR coefficient quantization and prediction order estimation designed for entropy coding of prediction residuals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分割探索時には、LPCの誤差分散をつかってやってみると、圧縮率は（二乗誤差だから）当然落ちているが、早くなっている。アイデアとしてはあり。&lt;/p&gt;
&lt;p&gt;他、補助関数の評価関数値で比較するのもやってみた（その場での予測がいらなくなる）が、僅かに性能悪化。これは、後ろ向き残差項も追加で考えてしまっているからと考える。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.kecl.ntt.co.jp/people/kameoka.hirokazu/publications/Kameoka2008IEICEPaper.pdf"&gt;予測誤差のGolomb-Rice符号量を最小にする線形予測分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;を見ると、初期値をLD法やBurg法で定めている。あれ？と思った。前日にゼロ初期化よりも性能悪化を確認したんだが。
改めて初期値をLDで定めてみたら速度、圧縮率共に改善の傾向。前日に見た結果と食い違っとる。。。今日、構造決定とパラメータ決定で補助関数法の繰り返し回数を揃えたのが効いているのだろうか。。。（前は構造決定で5回、パラメータ決定で20回だった。）&lt;/p&gt;
&lt;p&gt;初期値はBurg法の方が良いというのも気になっている。実装するか。
今まで試行してた実装があったのでそれで試したが、LDとどっこいどっこいに見える。LDでも十分に見えるので、一旦取り下げ。&lt;/p&gt;
&lt;p&gt;エンコード遅い問題はなんとかしたい。補助関数法の呼び出し回数が減らせればいい感じなんだが。。。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(12)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-12.html" rel="alternate"></link><published>2021-11-20T10:00:00+09:00</published><updated>2021-11-20T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-11-20:/lpcnoduo-duan-gou-cheng-zhi-bi-12.html</id><summary type="html">&lt;p&gt;論文紹介で1週間ほど止まる。あと就活も。。&lt;/p&gt;
&lt;p&gt;補助関数法の初期値をLD法で決めた方が収束早まるだろうと思ったら、全 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;論文紹介で1週間ほど止まる。あと就活も。。&lt;/p&gt;
&lt;p&gt;補助関数法の初期値をLD法で決めた方が収束早まるだろうと思ったら、全然そうではなかった。LD法を初期値に使ったとき、LD法の呼び出しを含め負荷が上がった。ユニット数を多めに選ぶ傾向があり、結果負荷上昇していると見る。圧縮率も悪化。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(11)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-11.html" rel="alternate"></link><published>2021-11-15T10:00:00+09:00</published><updated>2021-11-15T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-11-15:/lpcnoduo-duan-gou-cheng-zhi-bi-11.html</id><summary type="html">&lt;p&gt;プリエンファシスの修正に取り掛かっている。先頭サンプルをスキップして処理するようにしたら、（前も見たけど）結 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;プリエンファシスの修正に取り掛かっている。先頭サンプルをスキップして処理するようにしたら、（前も見たけど）結構悪化する。。。ストリーミングエンコードができないのはきっとツライ。どこかでケリを付けたい。&lt;/p&gt;
&lt;p&gt;Rice符号のパラメータも影響を受けているのは確認したが、そしたら初期値パラメータ設定が良くないんじゃないと再び思ってしまった。そして論文探しへ…&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://scripties.uba.uva.nl/search?id=715287;setlang=en"&gt;Linear predictive coding and Golomb-Rice codes in the FLAC lossless audio compression codec&lt;/a&gt; ロスレスについての素晴らしい文献（卒論？）。FLAC中心だけど、Golomb-Riceの詳細な考察がある。エントロピー+0.6の上限があることを初めて知った。また、 &lt;strong&gt;自己相関を計算することで前向き誤差と後ろ向き誤差を高速計算できることを言っている（Algorithm 2.29の上）。これも知らんかった。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最適なRiceパラメータ設定についてもまだ議論の余地がある。&lt;/p&gt;
&lt;p&gt;また上記文献を見ていたらBurgアルゴリズムがあるのを思い出した。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.emptyloop.com/technotes/A%20tutorial%20on%20Burg's%20method,%20algorithm%20and%20recursion.pdf"&gt;Burg’s Method, Algorithm and Recursion&lt;/a&gt; リンクがまだ生きてた。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://stat.wharton.upenn.edu/~steele/Courses/956/Resource/YWSourceFiles/WhyNotToUseYW.pdf"&gt;WHY YULE-WALKER SHOULD NOT BE USED FOR AUTOREGRESSIVE MODELLING&lt;/a&gt; Yule-Walker法が不安定な解を導くことを言っている。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大分脱線したが、Burg法に補助関数突っ込めばL1基準で最適化できるんじゃねと思ってやってみたら意外に導出が進んで、若干汚いが再帰式が出た。脱線甚だしいがまとめてみるか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(10)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-10.html" rel="alternate"></link><published>2021-11-14T10:00:00+09:00</published><updated>2021-11-14T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-11-14:/lpcnoduo-duan-gou-cheng-zhi-bi-10.html</id><summary type="html">&lt;p&gt;イベなどをこなす。同時にゼミ準備。&lt;/p&gt;
&lt;p&gt;コーデックで気になっているのはプリエンファシス。前フレームが終わらないと …&lt;/p&gt;</summary><content type="html">&lt;p&gt;イベなどをこなす。同時にゼミ準備。&lt;/p&gt;
&lt;p&gt;コーデックで気になっているのはプリエンファシス。前フレームが終わらないと先に進めないのは将来的に絶対苦しむので、今のうちにブロックエンコードができるようにしておきたい。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(9)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-9.html" rel="alternate"></link><published>2021-11-13T10:00:00+09:00</published><updated>2021-11-13T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-11-13:/lpcnoduo-duan-gou-cheng-zhi-bi-9.html</id><summary type="html">&lt;p&gt;パラメータ（層数＋層ごとの係数次数）調節を進めた。なんとかFLAC(-8)を超える圧縮率が出たところ。しかしやっぱりWavPack(-hh)は …&lt;/p&gt;</summary><content type="html">&lt;p&gt;パラメータ（層数＋層ごとの係数次数）調節を進めた。なんとかFLAC(-8)を超える圧縮率が出たところ。しかしやっぱりWavPack(-hh)は越えておきたい…&lt;/p&gt;
&lt;p&gt;パラメータ調節でのメモ：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;フレームサイズは大きく取る。フレームサイズを4096から8192, 2048*5に増やしたところ、パラメータ増加に対して性能悪化しなくなった。&lt;ul&gt;
&lt;li&gt;フレームサイズが小さいとパラメータを増やしたときにすぐに頭打ちになる。プリエンファシスの精度低下も効いてきていると思う。&lt;/li&gt;
&lt;li&gt;しかしレイテンシが気になってくる。TAKはたしか250msのブロックと言っていたので、おそらく2048*5だろう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;パラメータ個数は、先頭は少なく（4とか）、次に最大（32など）、その後は少しずつ減らしていくといい感じの圧縮率だった。&lt;ul&gt;
&lt;li&gt;これは経験的なのであんまり信憑性がない。。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;学習を切るとAFはなかなか良い性能を出す。（つまり学習が逆効果になっている？）&lt;ul&gt;
&lt;li&gt;AF単体で負荷がかなり大きい。ボトルネックは何かをちゃんと見るべき。繰り返し回数を見直すなど。&lt;ul&gt;
&lt;li&gt;たとえば構造決定のときは2回くらいの繰り返しにして、本チャンのパラメータ設定では10回程度繰り返す。&lt;/li&gt;
&lt;li&gt;これは試してみたい。繰り返し回数を指定できるようにAPIを変える。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AFのみ（学習しない）場合の結果も見たい。&lt;/li&gt;
&lt;li&gt;もしかしてと思ってAFの行列の平均操作をやめたら性能が向上した。とくに音量の小さい音源で。ラグ込みで正しい平均を取れていないから平均はむしろ悪影響になっていた。これは直す。&lt;/li&gt;
&lt;li&gt;いよいよ学習抜きで試すときがきたかも。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ユニット数の記録bit幅が3(=2の7乗=128)になっていて大きいのでは…&lt;ul&gt;
&lt;li&gt;bit幅を2(=2の3乗=8)にした。効果は微妙なので取り下げる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(8)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-8.html" rel="alternate"></link><published>2021-11-09T10:00:00+09:00</published><updated>2021-11-09T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-11-09:/lpcnoduo-duan-gou-cheng-zhi-bi-8.html</id><summary type="html">&lt;ul class="simple"&gt;
&lt;li&gt;AdaGradは既に勾配を適用した要素を潰しているので、OMPに近いというか、やっている最適化は貪欲法に近い可能性がある …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;AdaGradは既に勾配を適用した要素を潰しているので、OMPに近いというか、やっている最適化は貪欲法に近い可能性がある。&lt;/li&gt;
&lt;li&gt;結果の分析が重要。ジャンルごとの結果をまとめるべき。原因追求。&lt;/li&gt;
&lt;li&gt;フレーム間予測は重要。特徴にはフレーム間で相関があるので係数の使い回しは有効。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(7)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-7.html" rel="alternate"></link><published>2021-11-08T10:00:00+09:00</published><updated>2021-11-08T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-11-08:/lpcnoduo-duan-gou-cheng-zhi-bi-7.html</id><summary type="html">&lt;p&gt;RWCデータセットに対して性能が壊滅的に悪い。発表を戸惑うレベル。しかし発表申し込みはしてしまった。。。
手元のアニ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;RWCデータセットに対して性能が壊滅的に悪い。発表を戸惑うレベル。しかし発表申し込みはしてしまった。。。
手元のアニソン数種類でWavPack(-hh)を越えていた(4, 8, 8)の構成で、RWCデータセットに対してはFLAC(-8)と同等の圧縮率。&lt;/p&gt;
&lt;p&gt;11/3から、焦りも感じながらパラメータ調整に着手。以下を試したがいずれも悪化の傾向&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;補助関数法に切り替え&lt;ul&gt;
&lt;li&gt;この結果がかなりショック。手元では良くなったのに、何かのバグを疑っている。。。冷静にクラシック音源で確かめるとたしかに悪化している。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;パラメータ数を2倍（(8, 16, 16)）にして係数ビット数を半分の4に&lt;/li&gt;
&lt;li&gt;学習率を0.001かつ学習イプシロンを1e-8に&lt;ul&gt;
&lt;li&gt;手元のクラシックでは改善したが、RWCでの全体平均がだめ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;フレームサイズを増やす&lt;ul&gt;
&lt;li&gt;16384を選んだ。これ以上はエンコード遅延がキツイか。。&lt;/li&gt;
&lt;li&gt;クラシック音源では良いが、平均的な挙動が悪い。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下は改善の傾向&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LPC予測/合成を先頭部分でも行う&lt;ul&gt;
&lt;li&gt;これは手抜きだった。処理追加で改善確認。無条件で取り込む予定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;残差波形を見ていると、ブロック周期で大きな残差が出ているのが気になる。先頭は予測できないから仕方ないのだが。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(6)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-6.html" rel="alternate"></link><published>2021-11-02T10:00:00+09:00</published><updated>2021-11-02T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-11-02:/lpcnoduo-duan-gou-cheng-zhi-bi-6.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;予稿を書きつつある。同時にWavenetを読み込んでいる。
今日思ったのが、プリエンファシスも …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;予稿を書きつつある。同時にWavenetを読み込んでいる。
今日思ったのが、プリエンファシスもAuxiliary FunctionでL1スパース解が求まるのでは無いかという想像。式導出だけでもできるはずなのでやってみたい。&lt;/p&gt;
&lt;p&gt;試しにやってみたが、圧縮率が微妙に悪化。
値の範囲チェックが悪かったりするかもしれない。コメントアウトで残すには汚いので、ここに供養する。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* 残差絶対値平均を最小にするプリエンファシスフィルタ係数計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;LINNEPreemphasisFilter_CalculateLADCoefficient&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;LINNEPreemphasisFilter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;preem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;coef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;obj_value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;prev_obj_value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;LINNE_ASSERT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;preem&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;LINNE_ASSERT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#if 0&lt;/span&gt;&lt;span class="c"&gt;&lt;/span&gt;
&lt;span class="c"&gt;    /* 係数の初期値を最小二乗法で定める */&lt;/span&gt;
&lt;span class="c"&gt;    {&lt;/span&gt;
&lt;span class="c"&gt;        double corr[2];&lt;/span&gt;
&lt;span class="c"&gt;        curr = buffer[0] * pow(2.0f, -15);&lt;/span&gt;
&lt;span class="c"&gt;        for (smpl = 0; smpl &amp;lt; num_samples - 1; smpl++) {&lt;/span&gt;
&lt;span class="c"&gt;            const double succ = buffer[smpl + 1] * pow(2.0f, -15);&lt;/span&gt;
&lt;span class="c"&gt;            corr[0] += curr * curr;&lt;/span&gt;
&lt;span class="c"&gt;            corr[1] += curr * succ;&lt;/span&gt;
&lt;span class="c"&gt;            curr = succ;&lt;/span&gt;
&lt;span class="c"&gt;        }&lt;/span&gt;
&lt;span class="c"&gt;        coef = (corr[0] &amp;lt;= 1e-6) ? 0.0f : (corr[1] / corr[0]);&lt;/span&gt;
&lt;span class="c"&gt;    }&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;prev_obj_value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FLT_MAX&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;r01&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;r11&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* 方程式の係数計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;obj_value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-15&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inv_res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;succ&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-15&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="cm"&gt;/* 絶対値残差計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fabs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;succ&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;coef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;obj_value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="cm"&gt;/* 正則化 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1e-8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1e-8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;inv_res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;r01&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;succ&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inv_res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;r11&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inv_res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;succ&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;obj_value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* 係数更新 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;coef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;r01&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;r11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cm"&gt;/* 収束判定 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fabs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;prev_obj_value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;obj_value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1e-8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 係数設定 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;preem&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;coef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;LINNEUtility_Round&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LINNE_PREEMPHASIS_COEF_SHIFT&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* 丸め込み */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;preem&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;coef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LINNE_PREEMPHASIS_COEF_SHIFT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;preem&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;coef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LINNE_PREEMPHASIS_COEF_SHIFT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1次線形近似で平均絶対値が最小になるのは中央値 &lt;span class="math"&gt;\(m\)&lt;/span&gt; のときだから、 &lt;span class="math"&gt;\(\mean{}{|x_{n} - a x_{n-1}|}\)&lt;/span&gt; を最小化すると考えると、 &lt;span class="math"&gt;\(a x_{n-1} = m\)&lt;/span&gt; となるようにすれば良くて、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mean{}{|x_{n} - a x_{n-1}|}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（うまく行かなそうなのでやめた。備忘としては残す。）&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(5)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-5.html" rel="alternate"></link><published>2021-10-31T10:00:00+09:00</published><updated>2021-10-31T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-10-31:/lpcnoduo-duan-gou-cheng-zhi-bi-5.html</id><summary type="html">&lt;p&gt;土曜日はkolme&amp;#64;西川口。とくにStep by stepがよい。Youtubeと比べると進歩が歴然。
移動中SoundStream読んでた。新しいのは残差のVQのやり方に …&lt;/p&gt;</summary><content type="html">&lt;p&gt;土曜日はkolme&amp;#64;西川口。とくにStep by stepがよい。Youtubeと比べると進歩が歴然。
移動中SoundStream読んでた。新しいのは残差のVQのやり方に尽きるかも？でも面白くはあるから紹介する。&lt;/p&gt;
&lt;p&gt;日曜日の今日は、補助関数法をコーデックに移植して試している。
結果、手元の音源でわずかに圧縮率が改善している。（まだ不具合があるかも）&lt;/p&gt;
&lt;p&gt;繰り返しの過程を見ている。目的関数値（残差L1ノルム）は単調減少しているが、係数が安定しない印象を受ける。これは少なくともPythonで簡単な信号を処理するときには見られなかった。
また、繰り返し回数や収束判定でもだいぶ圧縮率に差が出る（0.1%オーダー）。これはアルゴリズムバグを疑っている。&lt;/p&gt;
&lt;p&gt;そして学習をスキップできるかと思ったら、そうでもなくて学習したほうが減る。。
学習にあたっては、1回だけ補助関数法を実行→次の層の残差計算 というやり方が考えられるけどどうだろう。試してみたい欲はあるが、理論がまったくない。
うーん、やはりBPは有効なのかも。なぜなら、最終的な残差を最小にするように層全体に対して学習が動くから。LPCと補助関数法は1層間に対してしか最適化しない。&lt;/p&gt;
&lt;p&gt;残差イプシロン、目的関数イプシロンを変えてもだいぶ結果に差が出るのは怪しい。引き続きデバッグする。Python実装と比べても何も思い浮かばないから、もはやテストコード書いたほうがいいかも？&lt;/p&gt;
&lt;p&gt;補助関数法の途中の補助変数の絶対値逆数が0割りの可能性があるので、そのイプシロンを設けたところイプシロンの値によってだいぶ結果が変わってくる。補助関数をもっと良いものを構成できないか、原論文を漁った。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.kecl.ntt.co.jp/people/kameoka.hirokazu/publications/Kameoka2008IEICEPaper.pdf"&gt;予測誤差の Golomb-Rice 符号量を最小化する線形予測分析&lt;/a&gt; 原論文。&lt;ul&gt;
&lt;li&gt;Golomb-Rice符号の最短符号の範囲は広いから、絶対値関数の原点付近は単に0に近づけるより遊びをもたせるのが良いとの記述。それで別の補助関数を作成。その適用法はまだ読み込めてない。&lt;/li&gt;
&lt;li&gt;最適解の1つを出力するが、大域最適解は一意とは限らない。まじかあ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プリセットをもう少し真面目に設定し直した。圧縮率とデコード速度でwavpack(-hh)は越えてる想定。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ibisml.org/archive/ibis2014/Kameoka2014IBIS11ver3.pdf"&gt;音声音響信号処理のための 確率モデルと学習アルゴリズム&lt;/a&gt; これの後ろの方に補助関数設計クックブックがある。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(4)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-4.html" rel="alternate"></link><published>2021-10-29T10:00:00+09:00</published><updated>2021-10-29T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-10-29:/lpcnoduo-duan-gou-cheng-zhi-bi-4.html</id><summary type="html">&lt;p&gt;昨日の続きで、もう少しPython実装で補助変数法が有効か確かめてみた。
どうも単純な線形関数に対してはLevinson-Durbinの方がL1ロ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;昨日の続きで、もう少しPython実装で補助変数法が有効か確かめてみた。
どうも単純な線形関数に対してはLevinson-Durbinの方がL1ロスでも良い傾向がある。
また、単純な入力では学習によってロスが振動するか、のんびり悪化していく。
怪しくなってもう一度Notebookで試してみたが、実信号の方では補助関数法のほうがよい。
また、学習によってロスが減少していくことも見ている。この差は一体なんだろう。&lt;/p&gt;
&lt;p&gt;C組み込みに着手してよいのだろうか。。。迷いどころ。
結構内部実装に手を入れそうだから、ブランチを切ろう。&lt;/p&gt;
&lt;p&gt;初手LU分解でいいはず。と思ったらNumerical recipies in Cで超簡易実装が（日本語訳されてない）&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://kfes-16.karlov.mff.cuni.cz/~standa/nc/www.library.cornell.edu/nr/bookcpdf/c2-9.pdf"&gt;2.9 Cholesky Decomposition&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これを実装しない手はない。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(3)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-3.html" rel="alternate"></link><published>2021-10-28T10:00:00+09:00</published><updated>2021-10-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-10-28:/lpcnoduo-duan-gou-cheng-zhi-bi-3.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;論文書きが一旦落ち着きそうなのを見て、学習の高速化 …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;論文書きが一旦落ち着きそうなのを見て、学習の高速化を考えている。ダイレクトに微分を計算して解くのは、やはり解析的でないこともありいい方向じゃない。&lt;/p&gt;
&lt;p&gt;L1ロスの最適化（しかもARモデルで）を調べていたら、亀岡さんの補助関数法を思い出した（ &lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jasj/71/11/71_KJ00010109335/_pdf"&gt;スパース表現に基づく音声音響符号化&lt;/a&gt; ）。これ、ずっと気になっていたがLPCだし気にしていなかった。結果としてはかなり有用そうで、試してみたい。最急勾配よりはよい性質がある（目的関数値が単調減少する。目的関数は凸だから大域最適値への収束が保証）。&lt;/p&gt;
&lt;p&gt;以下に概要をまとめよう。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;定義（補助関数）&lt;/dt&gt;
&lt;dd&gt;&lt;span class="math"&gt;\(\ve{\theta}\)&lt;/span&gt; をパラメータとする目的関数 &lt;span class="math"&gt;\(D(\ve{\theta})\)&lt;/span&gt; に対し &lt;span class="math"&gt;\(D(\ve{\theta}) = \min_{\ve{\alpha}} G(\ve{\theta}, \ve{\alpha})\)&lt;/span&gt; が成り立つとき、 &lt;span class="math"&gt;\(G(\ve{\theta}, \ve{\alpha})\)&lt;/span&gt; を &lt;span class="math"&gt;\(D(\ve{\theta})\)&lt;/span&gt; の補助関数(Auxiliary Function)、 &lt;span class="math"&gt;\(\ve{\alpha}\)&lt;/span&gt; を補助変数と呼ぶ。&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;補助関数の基本的かつ重要な定理が以下。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;定理&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;補助関数 &lt;span class="math"&gt;\(G(\ve{\theta}, \ve{\alpha})\)&lt;/span&gt; に対し、以下の手続き&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{\alpha} &amp;amp;\leftarrow \underset{\ve{\alpha}}{\mathrm{argmin}} \ G(\ve{\theta}, \ve{\alpha}) \tag{1} \\
\ve{\theta} &amp;amp;\leftarrow \underset{\ve{\theta}}{\mathrm{argmin}} \ G(\ve{\theta}, \ve{\alpha}) \tag{2}
\end{align*}
&lt;/div&gt;
&lt;p&gt;を繰り返すと、目的関数の値は単調減少する。&lt;/p&gt;
&lt;p&gt;（証明） &lt;span class="math"&gt;\((\ve{\theta}^{(l)}, \ve{\alpha}^{(l)})\)&lt;/span&gt; から &lt;span class="math"&gt;\((\ve{\theta}^{(l+1)}, \ve{\alpha}^{(l+1)})\)&lt;/span&gt; と更新したときに、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
D(\ve{\theta}^{(l)}) &amp;amp;:= \min_{\ve{\alpha}} G(\ve{\theta}^{(l)}, \ve{\alpha}) \\
&amp;amp;= G(\ve{\theta}^{(l)}, \ve{\alpha}^{(l+1)}) \quad (\because (1)) \\
&amp;amp;\geq G(\ve{\theta}^{(l+1)}, \ve{\alpha}^{(l+1)}) \quad (\because (2)) \\
&amp;amp;\geq D(\ve{\theta}^{(l+1)}) \quad (\because 補助関数の定義)
\end{align*}
&lt;/div&gt;
&lt;p class="last"&gt;（証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;これをARモデルの絶対値誤差問題&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
J(\ve{a}) = \mean{}{\left| s_{t} - \sum_{i = 1}^{L} a_{i} s_{t-i} \right|}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;に適用することを考える。今、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|x| \leq \frac{x^{2}}{2 |w|} + \frac{|w|}{2}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;だから（ &lt;span class="math"&gt;\(\because \frac{x^{2}}{2 |w|} + \frac{|w|}{2} - |x| = \frac{1}{2 |w|}(x^{2} + |w|^{2} - 2|w|x) = (x - |w|)^{2} \geq 0\)&lt;/span&gt; 、 &lt;span class="math"&gt;\(x = w\)&lt;/span&gt; のとき等号成立）、補助変数 &lt;span class="math"&gt;\(w_{t}\)&lt;/span&gt; を導入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
J(\ve{a}) &amp;amp;= \mean{}{\left| s_{t} - \sum_{i = 1}^{L} a_{i} s_{t-i} \right|} \\
&amp;amp;\leq \mean{}{\frac{1}{2|w_{t}|} \left( s_{t} - \sum_{i = 1}^{L} a_{i} s_{t-i} \right)^{2} + \frac{|w_{t}|}{2}} = \mean{}{\frac{1}{2|w_{t}|} \left( s_{t} - \sum_{i = 1}^{L} a_{i} s_{t-i} \right)^{2}} + \frac{1}{2} \mean{}{|w_{t}|}
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。そこで補助関数 &lt;span class="math"&gt;\(I(\ve{a}, \ve{w})\)&lt;/span&gt; を&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
I(\ve{a}, \ve{w}) := \mean{}{\frac{1}{2|w_{t}|} \left( s_{t} - \sum_{i = 1}^{L} a_{i} s_{t-i} \right)^{2}} + \frac{1}{2} \mean{}{|w_{t}|}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と定義する。 &lt;span class="math"&gt;\(w_{t} = s_{t} - \sum_{i = 1}^{L} a_{i} s_{t-i}\)&lt;/span&gt; とすれば、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
I(\ve{a}, \ve{w}) = \mean{}{\frac{1}{2|w_{t}|} w_{t}^{2}} + \frac{1}{2} \mean{}{|w_{t}|} = \mean{}{|w_{t}|} = J(\ve{a})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;だから、この &lt;span class="math"&gt;\(w_{t}\)&lt;/span&gt; は &lt;span class="math"&gt;\(\underset{\ve{w}}{\mathrm{argmin}} \ I(\ve{a}, \ve{w})\)&lt;/span&gt; を満たしている。一方、 &lt;span class="math"&gt;\(\ve{w}\)&lt;/span&gt; を固定したとき、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\parfrac{}{a_{j}} I(\ve{a}, \ve{w}) &amp;amp;= \mean{}{\frac{1}{2|w_{t}|} 2 \left( s_{t} - \sum_{i = 1}^{L} a_{i} s_{t-i} \right)(-s_{t-j})} \\
&amp;amp;= \mean{}{\frac{1}{|w_{t}|} \left( \sum_{i = 1}^{L} a_{i} s_{t-i} s_{t-j} - s_{t} s_{t-j} \right)} \\
&amp;amp;= \sum_{i = 1}^{L} a_{i} \mean{}{\frac{1}{|w_{t}|} s_{t-i} s_{t-j}} - \mean{}{\frac{1}{|w_{t}|} s_{t} s_{t-j}} \\
&amp;amp;= \sum_{i = 1}^{L} a_{i} r_{ij} - r_{0j}
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで &lt;span class="math"&gt;\(r_{ij} := \mean{}{\frac{1}{|w_{t}|} s_{t-i} s_{t-j}}\)&lt;/span&gt; とおいている。さて、 &lt;span class="math"&gt;\(\parfrac{}{a_{j}} I(\ve{a}, \ve{w}) = 0\ (j = 1,...,L)\)&lt;/span&gt; とおいて &lt;span class="math"&gt;\(\ve{a}\)&lt;/span&gt; について解くと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left[
\begin{array}{ccc}
  r_{11} &amp;amp; ...    &amp;amp; r_{1L} \\
  \vdots &amp;amp; \ddots &amp;amp; \vdots \\
  r_{L1} &amp;amp; ...    &amp;amp; r_{LL} \\
\end{array}
\right]
\left[
\begin{array}{c}
  a_{1} \\
  \vdots \\
  a_{L} \\
\end{array}
\right]
=
\left[
\begin{array}{c}
  r_{01} \\
  \vdots \\
  r_{0L} \\
\end{array}
\right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;だから、上記の方程式を満たす &lt;span class="math"&gt;\(\ve{a}\)&lt;/span&gt; が &lt;span class="math"&gt;\(I(\ve{a}, \ve{w})\)&lt;/span&gt; を最小にする。なお、 &lt;span class="math"&gt;\((\ve{R})_{ij} = r_{ij}\)&lt;/span&gt; なる行列をおくと、 &lt;span class="math"&gt;\(r_{ij} = r_{ji}\)&lt;/span&gt; だから &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; は対称で、任意の &lt;span class="math"&gt;\(\ve{x} \neq \ve{0}\)&lt;/span&gt; に対し、 &lt;span class="math"&gt;\(\ve{s}_{t} := [ s_{t-1} ... s_{t-L} ]^{\mathsf{T}}\)&lt;/span&gt; とおくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{x}^{\mathsf{T}} \ve{R} \ve{x} = \ve{x}^{\mathsf{T}} \mean{}{\frac{1}{|w_{t}|} \ve{s}_{t} \ve{s}_{t}^{\mathsf{T}}} \ve{x} = \mean{}{\frac{1}{|w_{t}|} (\ve{x}^{\mathsf{T}} \ve{s}_{t})^{2}} \geq 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;だから &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; は半正定値なので、コレスキー分解などで高速に解ける（注： &lt;span class="math"&gt;\(r_{00} = \mean{}{\frac{1}{|w_{t}|} s_{t}^{2}} \neq r_{11} = \mean{}{\frac{1}{|w_{t}|} s_{t-1}^{2}}\)&lt;/span&gt; なのでPersymmetric行列でなく、Levinson-Durbinは使えない）。&lt;/p&gt;
&lt;p&gt;よって、次のアルゴリズムにより &lt;span class="math"&gt;\(J(\ve{a})\)&lt;/span&gt; を単調減少させられる。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\ve{a}\)&lt;/span&gt; を初期値に設定（Lebinson-Durbinとかで決める？）&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(w_{t} \leftarrow s_{t} - \sum_{i=1}^{L} a_{i} s_{t-i}\)&lt;/span&gt; （予測）&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(r_{ij} \leftarrow \mean{}{\frac{1}{|w_{t}|} s_{t-i} s_{t-j}}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\ve{a} \leftarrow \left[ \begin{array}{ccc} r_{11} &amp;amp; ...    &amp;amp; r_{1L} \\ \vdots &amp;amp; \ddots &amp;amp; \vdots \\ r_{L1} &amp;amp; ...    &amp;amp; r_{LL} \\ \end{array} \right]^{-1} \left[ \begin{array}{c} r_{01} \\ \vdots \\ r_{0L} \\ \end{array} \right]\)&lt;/span&gt; （コレスキー分解などで解く）&lt;/li&gt;
&lt;li&gt;2.に戻る&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class="math"&gt;\(J(\ve{a})\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{a}\)&lt;/span&gt; に関して凸なので、この問題に関しては上記アルゴリズムは大域最適解に収束する。&lt;/p&gt;
&lt;p&gt;例えば、提案するモデルにおいて順行方向か逆方向に2, 3, 4を実行するのは、BPの代替手段としてあり。&lt;/p&gt;
&lt;p&gt;ちょっと試している。初期値についてはゼロでもLevinson-Durbinでもあんまり最終的な結果に差は出てこない。また、論文では平均ではなく和で計算しているが、和では安定しない（係数行列の要素が大きくなる+解が収束しない）傾向。
LPCNet（仮。名称変更予定）でLevinson-Durbinを入れ替えてみた（NNの構造選択と初期値設定で上記手法を使った）ら、割と劇的な平均絶対値残差減少が見られた。ひとまず機能追加。&lt;/p&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;補助関数の文献&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jasj/68/11/68_KJ00008328911/_article/-char/ja/"&gt;補助関数法による最適化アルゴリズムとその音響信号処理への応用(&amp;lt;小特集&amp;gt;近年の音響信号処理における数理科学の進展)&lt;/a&gt; MM(majorization minimization)法とも言うらしい。&lt;ul&gt;
&lt;li&gt;補助関数設計のコツは、よく知られた不等式を使うことにある。確かに。&lt;/li&gt;
&lt;li&gt;Jensenの不等式、コーシーシュワルツの不等式、凸関数の接平面が満たす不等式、凸関数の定義不等式などなど&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\log(\cosh(x))\)&lt;/span&gt; が &lt;span class="math"&gt;\(|x|\)&lt;/span&gt; に近い挙動をするのも参考になる。 &lt;span class="math"&gt;\(\log(\cosh(x)) + \log(2)\)&lt;/span&gt; は &lt;span class="math"&gt;\(x \to \pm \infty\)&lt;/span&gt; で &lt;span class="math"&gt;\(|x|\)&lt;/span&gt; に上から漸近する。なにかに使えないか少しだけ考えたが、補助関数はキツイか。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category><category term="Auxiliary Function"></category></entry><entry><title>LPCの多段構成執筆(2)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-2.html" rel="alternate"></link><published>2021-10-22T10:00:00+09:00</published><updated>2021-10-22T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-10-22:/lpcnoduo-duan-gou-cheng-zhi-bi-2.html</id><content type="html">&lt;p&gt;改めてお話づくりが必要だと思っている。→土日月マジミラやりながらお話づくり。論文も修正。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成執筆(1)</title><link href="/lpcnoduo-duan-gou-cheng-zhi-bi-1.html" rel="alternate"></link><published>2021-10-21T10:00:00+09:00</published><updated>2021-10-21T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-10-21:/lpcnoduo-duan-gou-cheng-zhi-bi-1.html</id><summary type="html">&lt;p&gt;合宿で9月末から今週頭まで全く動けず。進捗報告を行ったところ以下のコメント。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LPCを多段構成するとき、解像度の …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;合宿で9月末から今週頭まで全く動けず。進捗報告を行ったところ以下のコメント。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LPCを多段構成するとき、解像度の低い方から処理していくのはやはり特殊&lt;ul&gt;
&lt;li&gt;画像向きのResNetやロッシーコーデックでは解像度が高い（細かい領域）から処理していく。ロスレスに特有の現象か。&lt;/li&gt;
&lt;li&gt;これは周波数空間でいつもの処理をしているのでは？（次元が逆になっているから）←これとても興味深い&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ResNet, VGG, DNNでも、係数を量子化することによる影響は少ないという実験的結果がある。すなわち係数のビット幅は小さくして良さそう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(21) 一旦中断</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-21-yi-dan-zhong-duan.html" rel="alternate"></link><published>2021-09-15T10:00:00+09:00</published><updated>2021-09-15T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-09-15:/lpcnoduo-duan-gou-cheng-jian-zheng-21-yi-dan-zhong-duan.html</id><summary type="html">&lt;p&gt;論文執筆に戻らないといけないことが分かった。&lt;/p&gt;
&lt;p&gt;解析的最適化を行いたいのはもちろんだが、後回しになりそう。
今日 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;論文執筆に戻らないといけないことが分かった。&lt;/p&gt;
&lt;p&gt;解析的最適化を行いたいのはもちろんだが、後回しになりそう。
今日で一旦実装に整理をつけておく。明日以降論文のプロットを打つ。&lt;/p&gt;
&lt;p&gt;今日試したいのは勾配を直線探索する試み。理由は2点&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;最急降下法で直線的に降下しているところを見ると、もしかしたら誤差平面は単純な凸に近いのかもしれない&lt;ul&gt;
&lt;li&gt;これは嘘っぽい。最急降下法でも勾配を毎回計算しているから、方向は逐次変わっている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;勾配計算（とくに逆誤差伝播）の負荷が大きすぎるでなるべく勾配計算回数を減らしたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;試してみた。確かに収束は早いが、圧縮率が悪化した。また、原因は詳しく終えてないが別音源で無限ループ。
全体的に性能が良くないため直線探索は採用しない。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(20)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-20.html" rel="alternate"></link><published>2021-09-14T10:00:00+09:00</published><updated>2021-09-14T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-09-14:/lpcnoduo-duan-gou-cheng-jian-zheng-20.html</id><summary type="html">&lt;p&gt;実装をまとめていったんGitHubにあげた（まだprivate）。
まだテストや評価が残っている。また、色々圧縮してみるがエンコード負荷 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;実装をまとめていったんGitHubにあげた（まだprivate）。
まだテストや評価が残っている。また、色々圧縮してみるがエンコード負荷が高すぎる。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(19)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-19.html" rel="alternate"></link><published>2021-09-13T10:00:00+09:00</published><updated>2021-09-13T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-09-13:/lpcnoduo-duan-gou-cheng-jian-zheng-19.html</id><summary type="html">&lt;p&gt;9/11, 9/12 はAIR聖地巡り。美しい。聖地以外も。そして飯がうまい。日高のクエ鍋は冬料理（10〜3月）だが、いつかきっと食べに …&lt;/p&gt;</summary><content type="html">&lt;p&gt;9/11, 9/12 はAIR聖地巡り。美しい。聖地以外も。そして飯がうまい。日高のクエ鍋は冬料理（10〜3月）だが、いつかきっと食べに行こう。&lt;/p&gt;
&lt;p&gt;コーデックの実装に戻る。ここからが勝負になると思っている。今日は帰りの新幹線のぞみで、Adamを試してみたい。
実装してみたがすごい不安定。デフォルトの推奨値（学習率:0.001、beta1:0.9、beta2:0.999、イプシロン1e-8）でないと実用的とは思えない。
上パラメータは &lt;a class="reference external" href="https://machinelearningmastery.com/adam-optimization-algorithm-for-deep-learning/"&gt;ここ&lt;/a&gt; を参照した。&lt;/p&gt;
&lt;p&gt;薄紅10secの末尾をエンコードしたところ、モーメンタムが120223byte, AdaGradが120115byte, Adamが120192byteでAdaGradに軍配が上がっている。
もうすこし本格的に調査すべきかもしれないが、学習曲線の安定性から見てもAdaGradを選ぶことになりそう。&lt;/p&gt;
&lt;p&gt;学習の良し悪しが圧縮率に影響しているので面白くもあり同時に恐ろしくもある。とりあえず今は収束速度重視で考えたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ai-gakkai.or.jp/jsai2006/program/pdf/100171.pdf"&gt;部分時系列クラスタリングの理論的基礎&lt;/a&gt; 時系列データの窓をランダムに切り出してk-means法を適用すると、セントロイドに正弦波しか表れないということを理論的に示している。すごいが、フーリエ変換し始めたあたりでたしかにそうだよなあと思った。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;帰っている途中で、AdaGradの実装が間違っていることに気付いた。全ての次元で2乗和をとっていた。
直したが、学習率は低く取らないと発散しがち。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(18)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-18.html" rel="alternate"></link><published>2021-09-10T10:00:00+09:00</published><updated>2021-09-10T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-09-10:/lpcnoduo-duan-gou-cheng-jian-zheng-18.html</id><summary type="html">&lt;p&gt;9/8,9,10 とエンコーダ・デコーダの実装をしていた。
フルスクラッチではなく構造としてはほぼNARUと同じだから早 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;9/8,9,10 とエンコーダ・デコーダの実装をしていた。
フルスクラッチではなく構造としてはほぼNARUと同じだから早い。今日にはとりあえずロスレスで戻るものを確認している。
やはりデコード時間が早い。&lt;/p&gt;
&lt;p&gt;テストを固めながら、プリセットの選定を行っていきたい。&lt;/p&gt;
&lt;p&gt;今の所気になっている項目は、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;末尾が2の冪数になっていないと問題が起こりそう&lt;ul&gt;
&lt;li&gt;しかし切り上げとかするとデコード時に追加の領域が必要になりそう&lt;/li&gt;
&lt;li&gt;2の冪数が問題になるのは分析学習時のときだった。予測のときは剰余サンプルは無視しても問題ない（合成のときも同様に無視されるから）&lt;/li&gt;
&lt;li&gt;おそらく対応できたはず。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BPが遅い。微分を直接計算することで高速化できないか？微分すると結局BPに帰着するかもしれないが追うだけ追ってみたい&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jasj/71/11/71_KJ00010109335/_pdf"&gt;亀岡さんの研究&lt;/a&gt; のように補助関数を使う。初期値設定をこれに従うのがいいのか？&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://retrofocus28.blogspot.com/2015/09/iteratively-reweighted-least-squares.html?m=1"&gt;IRLS&lt;/a&gt; もあり得るのでは&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;手っ取り早いところではAdamを試すとか。&lt;ul&gt;
&lt;li&gt;AdaGradが案外良いと言うのを見ている。振動しない。（逆に言うとMomentumが振動しがち）&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.anarchive-beta.com/entry/2020/08/13/180000"&gt;6.1.6：Adam【ゼロつく1のノート(実装)】&lt;/a&gt; わりと沼だと思うんだな...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(17)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-17.html" rel="alternate"></link><published>2021-09-07T10:00:00+09:00</published><updated>2021-09-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-09-07:/lpcnoduo-duan-gou-cheng-jian-zheng-17.html</id><summary type="html">&lt;p&gt;バイト後疲れてくたばってしまった。なんとか手を動かして骨格は作れたつもり。
順次エンコーダ・デコーダの実装 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;バイト後疲れてくたばってしまった。なんとか手を動かして骨格は作れたつもり。
順次エンコーダ・デコーダの実装に入る。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(16)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-16.html" rel="alternate"></link><published>2021-09-06T10:00:00+09:00</published><updated>2021-09-06T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-09-06:/lpcnoduo-duan-gou-cheng-jian-zheng-16.html</id><summary type="html">&lt;p&gt;昨日の移動中にモックを仕上げた。が、ワンツーの末尾のほぼ無音になっているところでアサートして落ちていた。
原 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;昨日の移動中にモックを仕上げた。が、ワンツーの末尾のほぼ無音になっているところでアサートして落ちていた。
原因を見たら係数が非常に小さくなっているところの整数量子化で、右シフト量が大きくなりすぎていた(26とか。16bit深度を超えてる)。
普通にLPCで計算すると発生せず（むしろ、LPCではゼロに設定していたが）、学習によって小さいながらも非ゼロの係数が得られていた。
その小さい係数に対して律儀に右シフト量を計算してしまっていた。係数がビット表現精度未満の場合は0に丸め込むようにした。&lt;/p&gt;
&lt;p&gt;ひとまずモックまではできた感じ。ソース全体を見て、削れるところを削った上で、CMakeプロジェクトを作っていきたい。
今日はソースを見て使っていない関数を削る。ついでにCMakeの骨格も作ってしまおう。
コーデック名は LInear-predictive Neural Net Encoder, LINNE とする。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(15)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-15.html" rel="alternate"></link><published>2021-09-04T10:00:00+09:00</published><updated>2021-09-04T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-09-04:/lpcnoduo-duan-gou-cheng-jian-zheng-15.html</id><summary type="html">&lt;p&gt;LPCネットワークを使ったコーデックのモックを作成中。
パラメータ領域を含めてエンコードしておるが、なんか性能 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;LPCネットワークを使ったコーデックのモックを作成中。
パラメータ領域を含めてエンコードしておるが、なんか性能が渋くなってきた印象。
文句行ってないで早くビットパーフェクトに戻るものを作ろう。&lt;/p&gt;
&lt;p&gt;明日出発するので今日はここまでとする。
予測側で係数計算と符号化が分けられてないのがだいぶ苦しみの元になっている（プリエンファシスとか）。
明日帰省しながら直す。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(14)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-14.html" rel="alternate"></link><published>2021-09-03T10:00:00+09:00</published><updated>2021-09-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-09-03:/lpcnoduo-duan-gou-cheng-jian-zheng-14.html</id><summary type="html">&lt;p&gt;LPCネットワークの検証に戻る。(i)1層あたりのパラメータを増やす, (ii)層数を増やす の2軸で様子見。
構成は全部LD法 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;LPCネットワークの検証に戻る。(i)1層あたりのパラメータを増やす, (ii)層数を増やす の2軸で様子見。
構成は全部LD法初期値から学習するものとする。（前回と(8, 8)の結果が違うのはモーメンタムに修正が入ったから）&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;caption&gt;パラメータ数/層数を変えたときの圧縮率&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;col width="7%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;音源 \ 手法&lt;/td&gt;
&lt;td&gt;(  8)&lt;/td&gt;
&lt;td&gt;( 16)&lt;/td&gt;
&lt;td&gt;( 32)&lt;/td&gt;
&lt;td&gt;( 64)&lt;/td&gt;
&lt;td&gt;(  8,  8)&lt;/td&gt;
&lt;td&gt;( 16, 16)&lt;/td&gt;
&lt;td&gt;( 32, 32)&lt;/td&gt;
&lt;td&gt;(  8,  8,  8)&lt;/td&gt;
&lt;td&gt;( 16, 16, 16)&lt;/td&gt;
&lt;td&gt;( 32, 32, 32)&lt;/td&gt;
&lt;td&gt;(  8,  8,  8,  8)&lt;/td&gt;
&lt;td&gt;( 16, 16, 16, 16)&lt;/td&gt;
&lt;td&gt;( 32, 32, 32, 32)&lt;/td&gt;
&lt;td&gt;FLAC(-8)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;薄紅先頭10sec&lt;/td&gt;
&lt;td&gt;64.78&lt;/td&gt;
&lt;td&gt;63.84&lt;/td&gt;
&lt;td&gt;63.16&lt;/td&gt;
&lt;td&gt;62.33&lt;/td&gt;
&lt;td&gt;63.80&lt;/td&gt;
&lt;td&gt;63.08&lt;/td&gt;
&lt;td&gt;62.25&lt;/td&gt;
&lt;td&gt;63.43&lt;/td&gt;
&lt;td&gt;62.64&lt;/td&gt;
&lt;td&gt;61.91&lt;/td&gt;
&lt;td&gt;63.20&lt;/td&gt;
&lt;td&gt;62.45&lt;/td&gt;
&lt;td&gt;61.61&lt;/td&gt;
&lt;td&gt;64.94&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サマーマジック先頭10sec&lt;/td&gt;
&lt;td&gt;58.75&lt;/td&gt;
&lt;td&gt;57.73&lt;/td&gt;
&lt;td&gt;56.94&lt;/td&gt;
&lt;td&gt;56.44&lt;/td&gt;
&lt;td&gt;57.74&lt;/td&gt;
&lt;td&gt;56.87&lt;/td&gt;
&lt;td&gt;56.19&lt;/td&gt;
&lt;td&gt;57.33&lt;/td&gt;
&lt;td&gt;56.53&lt;/td&gt;
&lt;td&gt;55.90&lt;/td&gt;
&lt;td&gt;57.10&lt;/td&gt;
&lt;td&gt;56.34&lt;/td&gt;
&lt;td&gt;55.67&lt;/td&gt;
&lt;td&gt;57.72&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;パラメータ/層を増やせば増やすほど圧縮率は改善していく（注意：パラメータ領域は記録していない）。
Pythonで観察したように、全体の総パラメータ数が同一ならば、2層構成が一番良い。&lt;/p&gt;
&lt;p&gt;じゃあ、具体的にコーデックに仕立てようか。プリエンファシス含め前段に何が良いのかを確定させる。LPCNetは(8,8)で固定、Pは固定プリエンファシス、OPは最適プリエンファシスとしてチェック。&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;caption&gt;前処理構成を変えたときの圧縮率&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="13%" /&gt;
&lt;col width="13%" /&gt;
&lt;col width="13%" /&gt;
&lt;col width="13%" /&gt;
&lt;col width="13%" /&gt;
&lt;col width="13%" /&gt;
&lt;col width="13%" /&gt;
&lt;col width="13%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;音源 \ 手法&lt;/td&gt;
&lt;td&gt;(  P,  P)&lt;/td&gt;
&lt;td&gt;(  P, OP)&lt;/td&gt;
&lt;td&gt;( OP,  P)&lt;/td&gt;
&lt;td&gt;( OP, OP)&lt;/td&gt;
&lt;td&gt;( OP, OP, OP)&lt;/td&gt;
&lt;td&gt;(  P, OP, OP)&lt;/td&gt;
&lt;td&gt;( OP, OP,  P)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;薄紅先頭10sec&lt;/td&gt;
&lt;td&gt;64.78&lt;/td&gt;
&lt;td&gt;64.49&lt;/td&gt;
&lt;td&gt;63.99&lt;/td&gt;
&lt;td&gt;63.80&lt;/td&gt;
&lt;td&gt;63.80&lt;/td&gt;
&lt;td&gt;64.46&lt;/td&gt;
&lt;td&gt;63.95&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サマーマジック先頭10sec&lt;/td&gt;
&lt;td&gt;58.52&lt;/td&gt;
&lt;td&gt;58.18&lt;/td&gt;
&lt;td&gt;57.96&lt;/td&gt;
&lt;td&gt;57.74&lt;/td&gt;
&lt;td&gt;57.79&lt;/td&gt;
&lt;td&gt;58.21&lt;/td&gt;
&lt;td&gt;58.11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;これは、間違いなく最適プリエンファシス2段で確定かな。他にも、(OP, OP)で固定してさらにLPCNetの前にLPCを入れると性能が良くなることを見ている。その次数はいくつがいいか？見てみよう。&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;caption&gt;LPCNetの前に入れるLPCの次数による圧縮率&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="17%" /&gt;
&lt;col width="17%" /&gt;
&lt;col width="17%" /&gt;
&lt;col width="17%" /&gt;
&lt;col width="17%" /&gt;
&lt;col width="17%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;音源 \ 手法&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;薄紅先頭10sec&lt;/td&gt;
&lt;td&gt;63.65&lt;/td&gt;
&lt;td&gt;63.64&lt;/td&gt;
&lt;td&gt;63.65&lt;/td&gt;
&lt;td&gt;63.21&lt;/td&gt;
&lt;td&gt;62.70&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サマーマジック先頭10sec&lt;/td&gt;
&lt;td&gt;57.67&lt;/td&gt;
&lt;td&gt;57.54&lt;/td&gt;
&lt;td&gt;57.51&lt;/td&gt;
&lt;td&gt;57.20&lt;/td&gt;
&lt;td&gt;56.88&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;次数を上げれば上げるほどよい。8であんまり改善しないのは、後段のLPCNetの1層目が1分割になることが多く、結果次数8が2連結になってしまい性能が上がりにくくなっていると考えられる。&lt;/p&gt;
&lt;p&gt;LPCNetの前に入れるLPCもNetに取り込むべきではないかと考える。すると、層ごとのパラメータ数を変えるべきという発想に至る。
各層でパラメータ可変になるように対応した。2層がベストという観察だけど、LPCNet前のLPCも取り入れて3層で勝負してみる。つまり、プリエンファシス2段+LPCNet。悪ければ変える。&lt;/p&gt;
&lt;p&gt;よし、汚くてもいいからコーデックに仕上げてみよう。出来上がり次第、CMakeでプロジェクトを作ってきれいに実装し、評価フェーズに入る。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>Monkey's Audio (version. 6.61) 実装を見やる(1)</title><link href="/monkeys-audio-version-661-shi-zhuang-wojian-yaru1.html" rel="alternate"></link><published>2021-09-02T10:00:00+09:00</published><updated>2021-09-02T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-09-02:/monkeys-audio-version-661-shi-zhuang-wojian-yaru1.html</id><summary type="html">&lt;p&gt;自分のやってることに近いことが分かっているのでMonkey's Audioの実装を見てみよう。まず、NewPredictor.cppの予測処理。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// aiki: サンプルnA, nB …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;自分のやってることに近いことが分かっているのでMonkey's Audioの実装を見てみよう。まず、NewPredictor.cppの予測処理。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// aiki: サンプルnA, nBを圧縮。ステレオ信号ならnA, nB両方にデータが入る&lt;/span&gt;
&lt;span class="c1"&gt;// aiki: 片方のチャンネルが無音の場合はnBは0になる。&lt;/span&gt;
&lt;span class="c1"&gt;// aiki: nA, nBの呼び分けは CAPECompressCore::EncodeFrame にて行われる&lt;/span&gt;
&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;CPredictorCompressNormal::CompressValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nB&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// roll the buffers if necessary&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_nCurrentIndex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WINDOW_BLOCKS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Roll&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_rbAdapt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Roll&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_nCurrentIndex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// stage 1: simple, non-adaptive order 1 prediction&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 固定係数フィルタによる予測。これはTTAと全く同じ（！）プリエンファシスフィルタ&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;nA&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_Stage1FilterA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Compress&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nA&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;nB&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_Stage1FilterB&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Compress&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nB&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// stage 2: adaptive offset filter(s)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 適応フィルタによる予測。コードを見る限り4係数&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nA&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-6&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;paryM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_aryM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nPredictionA&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;paryM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;paryM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;paryM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;paryM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-3&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nPredictionB&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;paryM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-4&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;paryM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-7&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;paryM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-6&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;paryM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-7&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-9&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;paryM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-8&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nA&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;nPredictionA&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nPredictionB&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// adapt&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 出力の符号を取る&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: ((x &amp;gt;&amp;gt; 30) &amp;amp; 2) - 1 は符号関数の符号を反転したもの&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: (x &amp;gt;&amp;gt; 30)で0(&amp;gt;0), -1(&amp;lt;0)となり, (x &amp;gt;&amp;gt; 30) &amp;amp; 2で0(&amp;gt;0), 2(&amp;lt;0),&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: ((x &amp;gt;&amp;gt; 30) &amp;amp; 2) - 1 によって-1(&amp;gt;0), 1(&amp;lt;0)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;m_rbAdapt&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;m_rbAdapt&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;m_rbAdapt&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;m_rbAdapt&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-6&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 係数の更新。残差符号によって更新符号が変わる。&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: すなわちSign-Algorithmで出力フィードバックしている。&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;paryM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pAdapt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_rbAdapt&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;EXPAND_9_TIMES&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pM&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pAdapt&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;paryM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pAdapt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_rbAdapt&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;EXPAND_9_TIMES&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pM&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pAdapt&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// stage 3: NNFilters&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: CNNフィルタによる予測。圧縮オプションにより使うフィルタ段数が異なる&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Compress&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Compress&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter2&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Compress&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;m_rbPrediction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IncrementFast&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_rbAdapt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IncrementFast&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;m_nCurrentIndex&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注目のCNNの圧縮（予測）処理は以下。NNFilter.cpp にある&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;CNNFilter::Compress&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nInput&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_nBitdepth&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// convert the input to a short and store it&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// aiki: short(たぶん16bit)幅に丸め込む。範囲外の値は0x7FFF(&amp;gt;0), 0x8000(&amp;lt;0)に飽和する (NNFilter.h)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_rbInput16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GetSaturatedShortFromInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nInput&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// figure a dot product&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 内積実行（指定された次数のフィルタを畳み込む）。&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nDotProduct&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cp"&gt;#ifdef ENABLE_AVX_ASSEMBLY&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;useAVX2&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;nDotProduct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CalculateDotProductAVXx16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_rbInput16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m_nOrder&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_paryM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_nOrder&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cp"&gt;#ifdef ENABLE_SSE_ASSEMBLY&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;useSSE2&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="n"&gt;nDotProduct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CalculateDotProductSSEx16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_rbInput16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m_nOrder&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_paryM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_nOrder&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;nDotProduct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CalculateDotProductx16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_rbInput16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m_nOrder&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_paryM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_nOrder&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// calculate the output&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 残差計算。シフト量 m_nShift はコンストラクタで指定&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nInput&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nDotProduct&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_nShift&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_nShift&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// adapt&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 適応。nOutputの符号を見て更新方向を決め、m_rbDeltaM16だけ増減する。Sign-Algorithmやな。&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cp"&gt;#ifdef ENABLE_AVX_ASSEMBLY&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;useAVX2&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;AdaptAVXx16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_paryM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_rbDeltaM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m_nOrder&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_nOrder&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cp"&gt;#ifdef ENABLE_SSE_ASSEMBLY&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;useSSE2&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;AdaptSSEx16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_paryM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_rbDeltaM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m_nOrder&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_nOrder&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;Adaptx16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_paryM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;m_rbDeltaM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m_nOrder&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_nOrder&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;int64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nTempABS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;llabs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nInput&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 入力の絶対値に応じて更新量の更新。入力を量子化。Sign-Algorithmだけど入力を荒くしている。&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nTempABS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_nRunningAverage&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;m_rbDeltaM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;nInput&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nTempABS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m_nRunningAverage&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;m_rbDeltaM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;nInput&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nTempABS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;m_rbDeltaM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;nInput&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;27&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;m_rbDeltaM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 入力の絶対値の移動平均値の更新。&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_nRunningAverage&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nTempABS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m_nRunningAverage&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_rbDeltaM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_rbDeltaM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_rbDeltaM16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;-8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// increment and roll if necessary&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_rbInput16&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IncrementSafe&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_rbDeltaM16&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IncrementSafe&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nOutput&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// m_nBitdepth == 32&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// aiki: (snip) ビット幅32の場合の処理。&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大雑把に見ると、層ごとにサンプルごとに適応している。たしかにこれなら圧縮率は高いだろう。&lt;/p&gt;
&lt;p&gt;CNNの設定は以下で決まる。これも NewPredictor.cpp にある。CNNFilterのコンストラクタの第一引数は次数。第二引数はシフト量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;CPredictorCompressNormal&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;CPredictorCompressNormal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;intn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nCompressionLevel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;intn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nBitsPerSample&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IPredictorCompress&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nCompressionLevel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nCompressionLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_COMPRESSION_LEVEL_FAST&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nCompressionLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_COMPRESSION_LEVEL_NORMAL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CNNFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_FILE_VERSION_NUMBER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nBitsPerSample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nCompressionLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_COMPRESSION_LEVEL_HIGH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CNNFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_FILE_VERSION_NUMBER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nBitsPerSample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nCompressionLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_COMPRESSION_LEVEL_EXTRA_HIGH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CNNFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_FILE_VERSION_NUMBER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nBitsPerSample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CNNFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_FILE_VERSION_NUMBER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nBitsPerSample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nCompressionLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_COMPRESSION_LEVEL_INSANE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CNNFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_FILE_VERSION_NUMBER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nBitsPerSample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CNNFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_FILE_VERSION_NUMBER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nBitsPerSample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;m_pNNFilter2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CNNFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_FILE_VERSION_NUMBER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nBitsPerSample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Extra High以上では多層構成になっている。
Extra Highでは一段目は256次数、二段目は32次数。二段目の方により弱いフィルタを噛ましている。INSANE頭おかしい…（小声）
層を増やすたびに次数が急激に減り過ぎでは、という印象。
他にも圧縮オプションに応じてフレームサイズが変わっていた。(CAPECompressCreate::Start 関数)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// initialize (creates the base classes)&lt;/span&gt;
&lt;span class="n"&gt;m_nSamplesPerFrame&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;73728&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nCompressionLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_COMPRESSION_LEVEL_EXTRA_HIGH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;m_nSamplesPerFrame&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nCompressionLevel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAC_COMPRESSION_LEVEL_INSANE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;m_nSamplesPerFrame&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;クソデカフレームサイズだな。&lt;/p&gt;
&lt;p&gt;だいたい理解したと思いこんでいる。不足があればもっと読み込んでみる。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Monkey's Audio"></category><category term="CNN"></category></entry><entry><title>LPCの多段構成検証(13)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-13.html" rel="alternate"></link><published>2021-09-01T10:00:00+09:00</published><updated>2021-09-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-09-01:/lpcnoduo-duan-gou-cheng-jian-zheng-13.html</id><summary type="html">&lt;p&gt;今日からはLPCネットの性能評価メインで。まずは簡単な音源で色々動かしてみよう。&lt;/p&gt;
&lt;p&gt;簡単な音源として薄紅先頭10secとサ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;今日からはLPCネットの性能評価メインで。まずは簡単な音源で色々動かしてみよう。&lt;/p&gt;
&lt;p&gt;簡単な音源として薄紅先頭10secとサマーマジック先頭10secを用意した。
ネットワーク構成はとりあえずレイヤー数2, レイヤーあたりパラメータ数8, ブロックサイズ8192, 学習率0.9&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;caption&gt;LPCNetの学習による圧縮率寄与&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;音源 \ 手法&lt;/td&gt;
&lt;td&gt;レイヤー数1, パラメータ数8でLD法で設定&lt;/td&gt;
&lt;td&gt;LD法で設定&lt;/td&gt;
&lt;td&gt;ゼロから学習&lt;/td&gt;
&lt;td&gt;LD法初期値から学習&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;薄紅先頭10sec&lt;/td&gt;
&lt;td&gt;65.16&lt;/td&gt;
&lt;td&gt;64.33&lt;/td&gt;
&lt;td&gt;64.07&lt;/td&gt;
&lt;td&gt;63.81&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サマーマジック先頭10sec&lt;/td&gt;
&lt;td&gt;59.08&lt;/td&gt;
&lt;td&gt;58.35&lt;/td&gt;
&lt;td&gt;57.87&lt;/td&gt;
&lt;td&gt;57.75&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Python版でも見ていたが、LD(Levinson-Durbin)で初期値設定して学習すると、（ロスがより下がり）圧縮率がよくなっている。LD初期値から学習すると、LD初期値と比べ学習により0.5%ほどの改善が見受けられる。案外高い。
試しにゼロから（パラメータ全部0）から学習してみたら、LD法を設定するだけよりは良いがLD法+学習には敵わない感じ。観察したこと：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;学習時間: 10秒のファイルに30秒かかる。&lt;/li&gt;
&lt;li&gt;学習: 学習率を高めにとったほうがより小さくなっているが、たまに谷を乗り越えてしまって悪化している。&lt;ul&gt;
&lt;li&gt;SGDよりMomentumのほうが断然早い。しかし慣性項を大きくしてしまうとやはり谷を乗り上げるケースがたまに見受けられる。&lt;/li&gt;
&lt;li&gt;AdaGradもSGDより早い。全体的に安定している。しかし学習率高めのMomentumよりは遅い。&lt;/li&gt;
&lt;li&gt;学習終了を判断する閾値は &lt;cite&gt;1e-8&lt;/cite&gt; 程度でまあOKか。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他に思ったことは、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;構成がまだ2層のみ。もっと深くする&lt;ul&gt;
&lt;li&gt;Pythonでは2層が平均的に良いという結果だったが、実際に圧縮するとどうか？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ロス変えるとどうなるか気になる。まずL2。他にはエントロピーロス。&lt;ul&gt;
&lt;li&gt;これも前試したかもしれないけど、L2よりL1ロスのほうが圧縮率が高い。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Monkey's AudioがそういえばCNNだった。実装調査必須&lt;ul&gt;
&lt;li&gt;エンコードがやけに早いので全く同じことはないと思っているが、、、今こそ見るべきか。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(12)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-12.html" rel="alternate"></link><published>2021-08-31T10:00:00+09:00</published><updated>2021-08-31T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-31:/lpcnoduo-duan-gou-cheng-jian-zheng-12.html</id><summary type="html">&lt;ul class="simple"&gt;
&lt;li&gt;Lebinson-Durvinによる適応的分割数決定: 済&lt;/li&gt;
&lt;li&gt;演算結果の取得API追加: 済&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なんとか8月に間に合った。早速コーデックに入れてみる…が …&lt;/p&gt;</summary><content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;Lebinson-Durvinによる適応的分割数決定: 済&lt;/li&gt;
&lt;li&gt;演算結果の取得API追加: 済&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なんとか8月に間に合った。早速コーデックに入れてみる…が、やっぱり渋い。あんまり減っていかない。
いろいろ試していると、Levinson-Durbinで初期値設定するより、オールゼロで始めたほうが圧縮率がいい結果が出ている。
要観察か。&lt;/p&gt;
&lt;p&gt;いままでの固定構成と比べてどうよ？というところもしっかり見るべし。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(11)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-11.html" rel="alternate"></link><published>2021-08-30T10:00:00+09:00</published><updated>2021-08-30T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-30:/lpcnoduo-duan-gou-cheng-jian-zheng-11.html</id><summary type="html">&lt;p&gt;イベ中に地味に進めた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Lebinson-Durvinによる適応的分割数決定: 済&lt;/li&gt;
&lt;li&gt;演算結果の取得API追加: まだ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;L1ロスの平均操作必須だった。サン …&lt;/p&gt;</summary><content type="html">&lt;p&gt;イベ中に地味に進めた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Lebinson-Durvinによる適応的分割数決定: 済&lt;/li&gt;
&lt;li&gt;演算結果の取得API追加: まだ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;L1ロスの平均操作必須だった。サンプル数増やすと安定しない。
また、純音とか突っ込むと学習全然安定しない。うーん実データは問題なかったんやが。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(10)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-10.html" rel="alternate"></link><published>2021-08-27T10:00:00+09:00</published><updated>2021-08-27T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-27:/lpcnoduo-duan-gou-cheng-jian-zheng-10.html</id><summary type="html">&lt;p&gt;もうすこしテスト追加して学習結果がPython版とおなじになるように。
手元で確認した限りではOK。しっかし演算精度で …&lt;/p&gt;</summary><content type="html">&lt;p&gt;もうすこしテスト追加して学習結果がPython版とおなじになるように。
手元で確認した限りではOK。しっかし演算精度で差が出たのでfloatからdoubleに変えた。いつもどおり速度が問題になったらfloatにすれば良い。&lt;/p&gt;
&lt;p&gt;ネットワークモジュールとトレーナーを追加した。
あとは&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Lebinson-Durvinによる適応的分割数決定&lt;/li&gt;
&lt;li&gt;演算結果の取得API追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;やな。ここまでいけば圧縮試せそう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(9)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-9.html" rel="alternate"></link><published>2021-08-26T10:00:00+09:00</published><updated>2021-08-26T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-26:/lpcnoduo-duan-gou-cheng-jian-zheng-9.html</id><summary type="html">&lt;p&gt;今日もデバッグを優先。8月中にはPython版と同様の状態に持っていきたい。
分割時の挙動もしっかり合わせる必要があ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;今日もデバッグを優先。8月中にはPython版と同様の状態に持っていきたい。
分割時の挙動もしっかり合わせる必要がある。&lt;/p&gt;
&lt;p&gt;かなりバグが有った。インデックス端点とか。Python側にもcol2im(cmat2frame)にバグがあったりした。他にもL1ロスでの誤差逆伝播で入力サイズで割ってたのを見つけた。バッチサイズで割るべきで、除算は不要だった。学習がだいぶ遅くなっていたはず。
ひとまず動くように見えるけどやっつけ感ある。明日テストケースを増やして確認。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(8)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-8.html" rel="alternate"></link><published>2021-08-25T10:00:00+09:00</published><updated>2021-08-25T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-25:/lpcnoduo-duan-gou-cheng-jian-zheng-8.html</id><summary type="html">&lt;p&gt;学会Done。英語力の低さがやはり響く。&lt;/p&gt;
&lt;p&gt;学習のC言語版実装を進めている。なんとなく動いているが、まだPython版と学習曲線 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;学会Done。英語力の低さがやはり響く。&lt;/p&gt;
&lt;p&gt;学習のC言語版実装を進めている。なんとなく動いているが、まだPython版と学習曲線が一致していない。一致するまでデバッグ。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(7)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-7.html" rel="alternate"></link><published>2021-08-24T10:00:00+09:00</published><updated>2021-08-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-24:/lpcnoduo-duan-gou-cheng-jian-zheng-7.html</id><summary type="html">&lt;p&gt;22はイベ。疲労か23は全く動けなかった。全く動けないのは問題。&lt;/p&gt;
&lt;p&gt;今日からC言語実装を試していく。まずは2層で様子 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;22はイベ。疲労か23は全く動けなかった。全く動けないのは問題。&lt;/p&gt;
&lt;p&gt;今日からC言語実装を試していく。まずは2層で様子見。分割の探索も試す。
8月以内にはバックプロパゲーション学習も実装したい。&lt;/p&gt;
&lt;p&gt;分割の探索を導入したところ、当然というか、固定分割よりも向上（4分割固定だったのを可変にしたら0.8%向上。明らかによいので導入）&lt;/p&gt;
&lt;p&gt;1層目も可変分割にしたら僅かであるが確かに減る。というわけで全ての層で可変分割を入れる。&lt;/p&gt;
&lt;p&gt;層を重ねると予想外に減っていくことに気づく。メモしていく。&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;caption&gt;1層のパラメータが16のとき&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;層数 \ 音源&lt;/td&gt;
&lt;td&gt;ワンツー&lt;/td&gt;
&lt;td&gt;SPARKLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0(なし)&lt;/td&gt;
&lt;td&gt;80.85&lt;/td&gt;
&lt;td&gt;69.49&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;73.03&lt;/td&gt;
&lt;td&gt;61.49&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;71.51&lt;/td&gt;
&lt;td&gt;60.05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;71.20&lt;/td&gt;
&lt;td&gt;59.68&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;71.04&lt;/td&gt;
&lt;td&gt;59.53&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;70.79&lt;/td&gt;
&lt;td&gt;59.38&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table border="1" class="docutils"&gt;
&lt;caption&gt;1層のパラメータが32のとき&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;層数 \ 音源&lt;/td&gt;
&lt;td&gt;ワンツー&lt;/td&gt;
&lt;td&gt;SPARKLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;0(なし)&lt;/td&gt;
&lt;td&gt;80.85&lt;/td&gt;
&lt;td&gt;69.49&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;72.68&lt;/td&gt;
&lt;td&gt;61.15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;71.00&lt;/td&gt;
&lt;td&gt;59.65&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;70.69&lt;/td&gt;
&lt;td&gt;59.29&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;70.53&lt;/td&gt;
&lt;td&gt;59.15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;70.20&lt;/td&gt;
&lt;td&gt;59.01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;層を増やしても圧縮率は単調減少。&lt;ul&gt;
&lt;li&gt;直感的にも層ごとに二乗誤差最小化しているので増えることは無いのは分かる。&lt;/li&gt;
&lt;li&gt;減り方は頭打ち。1層-&amp;gt;2層が最も意義があり、1.5%改善する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;層構造の前に次数低め(4, 8)のLPC予測を分割せず突っ込むと0.2%~0.3%ほど改善&lt;ul&gt;
&lt;li&gt;擬似的に分割のない1層目が実現できているからと思われる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あとはパラメータをこねくり回すだけになるので、引き続き学習を実装しよう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(6)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-6.html" rel="alternate"></link><published>2021-08-21T10:00:00+09:00</published><updated>2021-08-21T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-21:/lpcnoduo-duan-gou-cheng-jian-zheng-6.html</id><summary type="html">&lt;p&gt;これまでの結果をまとめることを試みる。いい加減グダグダ実験するのはやめ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;パラメータ（LPC係数）は多いほうが低い …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;これまでの結果をまとめることを試みる。いい加減グダグダ実験するのはやめ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;パラメータ（LPC係数）は多いほうが低いロスを達成する&lt;ul&gt;
&lt;li&gt;ロスの減少は頭打ちになるが、実用的な範囲（8192サンプルフレームに256パラメータまで）は下がり続ける&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2層構成が最も低いロスを達成することが多かった&lt;ul&gt;
&lt;li&gt;ただし、パラメータを各層に等しく振り分けた場合。&lt;/li&gt;
&lt;li&gt;パラメータを各層で変えた場合は、3層でよりよい構成が見つかる場合が多数あった。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1層目は分割しないほうがロスが小さい&lt;ul&gt;
&lt;li&gt;はっきりとした傾向として出ている。&lt;/li&gt;
&lt;li&gt;これが何故良いのかはっきりと説明できない。以下に仮説を述べる。&lt;ol class="arabic"&gt;
&lt;li&gt;プリエンファシスで見たように相関を消せるから。またその相関を消すには長い区間で分析すべきだから。（正確な統計量を計算すべきだから）&lt;/li&gt;
&lt;li&gt;マルチスケールで分析できているから。分割しないで計算すると長区間の傾向を捉えることができる&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2層目以降の分割は法則が見えない&lt;ul&gt;
&lt;li&gt;分割時に見る波形に依存してパフォーマンスがブレるから&lt;/li&gt;
&lt;li&gt;これは適応的に定めるべきかと。分割数を変えて最も低いロスを出す構成を探すのが良い&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;学習はいつでも有効。学習率を上げすぎると発散する&lt;ul&gt;
&lt;li&gt;Momentumで加速する。プラトーにもあんまりはまらない。単調に減っていく。&lt;/li&gt;
&lt;li&gt;初期値をLebinson-Durbin法で設定すると良い。ランダム初期値/ゼロ初期値よりも低いロスを達成していた。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;で、コーデックにどう還元していくか。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2層をベースに、2層目の適応分割をおこなって性能を見る。&lt;/li&gt;
&lt;li&gt;学習実装&lt;ul&gt;
&lt;li&gt;学習による改善は少ないように思える。絶対値にして2~3の改善はどれくらい圧縮に効いてくるか不明…&lt;/li&gt;
&lt;li&gt;しかしLebinson-Durbin法によって設定するより確実によい係数が見つかっている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(5)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-5.html" rel="alternate"></link><published>2021-08-20T10:00:00+09:00</published><updated>2021-08-20T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-20:/lpcnoduo-duan-gou-cheng-jian-zheng-5.html</id><summary type="html">&lt;p&gt;だいぶ副反応は楽になった。&lt;/p&gt;
&lt;p&gt;バラバラと実験している。。音源も少ないので客観的な結果が出てないかもしれないのが …&lt;/p&gt;</summary><content type="html">&lt;p&gt;だいぶ副反応は楽になった。&lt;/p&gt;
&lt;p&gt;バラバラと実験している。。音源も少ないので客観的な結果が出てないかもしれないのがとても怖い。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(4)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-4.html" rel="alternate"></link><published>2021-08-19T10:00:00+09:00</published><updated>2021-08-19T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-19:/lpcnoduo-duan-gou-cheng-jian-zheng-4.html</id><summary type="html">&lt;p&gt;大体の傾向はつかめた。しかし実践で網羅探索するのはつらい。
そこで、前から思っていた手法を試してみたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;浅い層 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;大体の傾向はつかめた。しかし実践で網羅探索するのはつらい。
そこで、前から思っていた手法を試してみたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;浅い層から深い層に向けて分割数を変えてLevinson-Durbin法を実行して、誤差分散最小の分割数を選ぶ&lt;/li&gt;
&lt;li&gt;実装も楽にできるはず。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ワクチン2回目打って体調が悪い！寒気が止まらん！&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(3)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-3.html" rel="alternate"></link><published>2021-08-18T10:00:00+09:00</published><updated>2021-08-18T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-18:/lpcnoduo-duan-gou-cheng-jian-zheng-3.html</id><summary type="html">&lt;p&gt;調査してみたら、やはり前日と同じ傾向。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;16&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;('[(8, 1), (8, 2)]', 0.004464827723304184)
('[(8, 1), (8, 1)]', 0.004511942895091376)
('[(8, 1), (8, 4)]', 0.004585848876812132)
('[(8, 1), (8, 8)]', 0.004621162135462672)
('[(8, 2), (8, 1)]', 0.00474587468751301)
('[(16, 1 …&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;調査してみたら、やはり前日と同じ傾向。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;16&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;('[(8, 1), (8, 2)]', 0.004464827723304184)
('[(8, 1), (8, 1)]', 0.004511942895091376)
('[(8, 1), (8, 4)]', 0.004585848876812132)
('[(8, 1), (8, 8)]', 0.004621162135462672)
('[(8, 2), (8, 1)]', 0.00474587468751301)
('[(16, 1)]', 0.004797777841798966)
('[(8, 2), (8, 2)]', 0.005024862442518435)
('[(16, 2)]', 0.0051091371014737865)
('[(8, 2), (8, 4)]', 0.005357035338875968)
('[(8, 4), (8, 1)]', 0.005369198865788604)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;32&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;('[(8, 1), (16, 4), (8, 1)]', 0.004193440403001765)
('[(8, 1), (16, 8), (8, 1)]', 0.004198748182943823)
('[(8, 1), (16, 2), (8, 8)]', 0.0042179607825672824)
('[(8, 1), (8, 4), (16, 2)]', 0.004219042849385237)
('[(8, 1), (16, 8), (8, 2)]', 0.0042271081205968635)
('[(8, 1), (8, 8), (16, 4)]', 0.004227474822867072)
('[(8, 1), (8, 1), (16, 4)]', 0.004232727332568911)
('[(8, 1), (8, 4), (8, 8), (8, 1)]', 0.004238654463289194)
('[(16, 1), (16, 4)]', 0.004239532857106851)
('[(8, 1), (8, 4), (8, 2), (8, 1)]', 0.004241416904835525)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;64&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;('[(32, 1), (16, 8), (16, 2)]', 0.003914014978180023)
('[(32, 1), (32, 4)]', 0.003916940916529179)
('[(32, 1), (8, 8), (16, 4), (8, 1)]', 0.003927724967759615)
('[(32, 1), (16, 8), (8, 2), (8, 1)]', 0.003929616594921038)
('[(32, 1), (16, 8), (8, 1), (8, 2)]', 0.003941842588266561)
('[(32, 1), (16, 4), (8, 8), (8, 1)]', 0.003942065244126739)
('[(32, 1), (16, 4), (8, 1), (8, 8)]', 0.003942362549652674)
('[(32, 1), (8, 2), (16, 8), (8, 1)]', 0.003947254766650566)
('[(32, 1), (8, 4), (16, 2), (8, 8)]', 0.003954088359130106)
('[(32, 1), (16, 4), (16, 2)]', 0.0039544232569613084)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;96&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;('[(64, 1), (32, 4)]', 0.0036990251119209)
('[(64, 1), (16, 8), (16, 2)]', 0.0037016600715085324)
('[(64, 1), (16, 8), (8, 2), (8, 1)]', 0.0037156882096881583)
('[(64, 1), (8, 8), (16, 4), (8, 1)]', 0.003717281269845087)
('[(8, 1), (8, 8), (16, 4), (64, 1)]', 0.0037240095186138623)
('[(64, 1), (16, 8), (8, 1), (8, 2)]', 0.0037245477708627195)
('[(8, 1), (16, 8), (64, 1), (8, 2)]', 0.003727027030949939)
('[(8, 1), (16, 8), (8, 2), (64, 1)]', 0.003727921779451059)
('[(64, 1), (16, 4), (8, 1), (8, 8)]', 0.0037290389284781963)
('[(8, 1), (16, 4), (64, 1), (8, 8)]', 0.0037291228854336414)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;128&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;('[(64, 1), (64, 8)]', 0.0035595342792548975)
('[(64, 1), (32, 8), (32, 4)]', 0.0035857287584252565)
('[(64, 1), (32, 4), (32, 8)]', 0.0035918334574457068)
('[(64, 1), (16, 8), (32, 8), (16, 2)]', 0.0036013132060243092)
('[(64, 1), (16, 8), (32, 4), (16, 1)]', 0.003604358199604862)
('[(16, 1), (16, 8), (64, 1), (32, 4)]', 0.0036052681630675773)
('[(16, 1), (64, 1), (16, 8), (32, 4)]', 0.0036059253610609423)
('[(64, 1), (16, 8), (16, 1), (32, 4)]', 0.003606505587211954)
('[(64, 1), (16, 1), (16, 8), (32, 4)]', 0.0036074719356301247)
('[(64, 1), (16, 8), (16, 8), (32, 4)]', 0.003609187475720838)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般的に言えそうなことは&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;4層構成で有効な構成はなかった
- かといって1層構成は上位に表れない。多層にする意味はある。&lt;/li&gt;
&lt;li&gt;やはり1段目は1分割&lt;/li&gt;
&lt;li&gt;2段目は分割数多めに&lt;/li&gt;
&lt;li&gt;3段目以降は少なく&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(2)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-2.html" rel="alternate"></link><published>2021-08-17T10:00:00+09:00</published><updated>2021-08-17T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-17:/lpcnoduo-duan-gou-cheng-jian-zheng-2.html</id><summary type="html">&lt;p&gt;実装に没頭してしまい、記録が疎かになっていた。8/13,14は実装していた。ほぼカサゴ本を参考に。
しかし日〜月はライブ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;実装に没頭してしまい、記録が疎かになっていた。8/13,14は実装していた。ほぼカサゴ本を参考に。
しかし日〜月はライブとその後で放心状態になっていた。これからイベントラッシュなのでこの傾向は良くない。&lt;/p&gt;
&lt;p&gt;見えてきたことといえば、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;同一のパラメータ数では、分割しないほうがロス（L1ノルム）が低い&lt;/li&gt;
&lt;li&gt;次数を入力直後は大きくし、末尾に行くに従って小さくすると最もロスが低い&lt;ul&gt;
&lt;li&gt;しかし学習が不安定になりやすい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Levinson-Durbinで学習した状態から6くらいいロスが減る。平均絶対値でこれくらい減ってるから有益かも？でも負荷が気になる。&lt;/li&gt;
&lt;li&gt;オールゼロを初期値とするとLPCのロスまでたどり着かない&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Levinson-Durbinが大域最適値ではないことは見えてきたが、一方、初期値としては妥当っぽいので構成の評価には使える。&lt;/p&gt;
&lt;p&gt;今日は、どんな構成が一番良いのか評価したい。&lt;/p&gt;
&lt;p&gt;どうも以下の傾向があるようだ&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;1段目は分割しない&lt;/li&gt;
&lt;li&gt;2段目は分割数を多くする&lt;/li&gt;
&lt;li&gt;それ以降はあまり法則見えず&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;気になるのは次数を増やすのがよいか、層を深くするのが良いかという点。
合計32次数でFixして調査すべきか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>LPCの多段構成検証(1)</title><link href="/lpcnoduo-duan-gou-cheng-jian-zheng-1.html" rel="alternate"></link><published>2021-08-11T10:00:00+09:00</published><updated>2021-08-11T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-11:/lpcnoduo-duan-gou-cheng-jian-zheng-1.html</id><summary type="html">&lt;p&gt;迷ったけど性能が高いし研究室のテーマに合致するのでテーマを変えるのがいいと思った。&lt;/p&gt;
&lt;p&gt;今やっているLPCの多段 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;迷ったけど性能が高いし研究室のテーマに合致するのでテーマを変えるのがいいと思った。&lt;/p&gt;
&lt;p&gt;今やっているLPCの多段構成はResNetとの類似が指摘できる。F(x)がLPCの予測（に負号をとったもの）で、xと足すと残差が出力される。そして見ている区間を変えるのはストライド付きの畳み込みだ。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="白板に書いたイメージ図" src="./images/LPC_NN.jpg" /&gt;
&lt;/div&gt;
&lt;p&gt;これがすごいのが学習できるということ。最終層でL1ノルムとかエントロピーを損失に設定して微分してバックプロパゲーション学習する。何なら最小二乗誤差で学習してもいい。LPCは層ごとに学習している（制約ボルツマシンの単層学習に相当？）からより良い解が見つかる可能性がある。&lt;/p&gt;
&lt;p&gt;この構成は単純なLPCの組み合わせに過ぎないが性能がよい。時間がかかるのは学習（エンコード）のときだけだ。
しかし、まだ整理できてないし既存研究があるかどうかも不定。学習は詰めて定式化しなければなるまい。&lt;/p&gt;
&lt;p&gt;ひとまず試すべきなのは、細かい分割から始めて荒くしていく方針はどうかというところ。以前試したが圧縮性能は良くなかった。今一度試してみる。&lt;/p&gt;
&lt;p&gt;最小分割単位を2048, 最大ブロックサイズを(2048*8)として、LPCの次数はすべて4とする。&lt;/p&gt;
&lt;p&gt;ワン・ツー・スゥイーツでは、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;(2048*8, 2048*4, 2048*2, 2048) の構成: 74.83% 係数全部8で71.89% (1024にしてもほぼ変わらず)&lt;/li&gt;
&lt;li&gt;(2048, 2048*2, 2048*4, 2048*8) の構成: 75.13% 係数全部8で74.50%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SPARKLEでは、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;(2048*8, 2048*4, 2048*2, 2048): 62.60% 係数次数全部8で60.15% (1024にしてもほぼ変わらず)&lt;/li&gt;
&lt;li&gt;(2048, 2048*2, 2048*4, 2048*8): 63.74% 係数次数全部8で63.54%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;荒い方から始めて順に細かくしていった方が明らかに良い。&lt;/p&gt;
&lt;p&gt;ソースを切り出して、学習則を具体的に導くことを考える。&lt;/p&gt;
&lt;div class="section" id="todo"&gt;
&lt;h2&gt;TODO&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;学習則（バックプロパゲーション）の検討・導出&lt;/li&gt;
&lt;li&gt;Sign-Signアルゴリズムの自然勾配考察&lt;/li&gt;
&lt;li&gt;NGSA突っ込んでみる&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;所感&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;.cal(lossless audio codecの逆) いいな。カレンダーガールに掛けて&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="LPC"></category><category term="ResNet"></category></entry><entry><title>リフティングの組み込み検証(12)</title><link href="/rihuteingunozu-miip-mijian-zheng-12.html" rel="alternate"></link><published>2021-08-10T10:00:00+09:00</published><updated>2021-08-10T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-10:/rihuteingunozu-miip-mijian-zheng-12.html</id><summary type="html">&lt;p&gt;CDF22の性能が良いことをうけて、CDF22の端点対応をする。
うーん、端点0次ホールドしたほうが圧縮率がほんの僅かに悪い …&lt;/p&gt;</summary><content type="html">&lt;p&gt;CDF22の性能が良いことをうけて、CDF22の端点対応をする。
うーん、端点0次ホールドしたほうが圧縮率がほんの僅かに悪い。実装間違いを疑いつつコミット。&lt;/p&gt;
&lt;p&gt;再び残差に注目した。まだ残差波形に対してflacをかけるとかなり小さくなる。これはやはりまだパス数を増やすべきという示唆だと思っている。&lt;/p&gt;
&lt;p&gt;そして次は3パス（サブブロックのサイズを2倍, 4倍, ...と変える）を試してみた。するとまた劇的な減少が見られた。。。。LPCを連結するのではなく、ブロックサイズを変えて適用していくとかなりの効果が見られている。。。&lt;/p&gt;
&lt;p&gt;さらにブロック内での分割数を増やしていくと、どんどん圧縮率が上がっていく。今まで見たような、連結や次数上げによる圧縮率上昇とは違ったレベルで、次数の影響を受けずに上がっていく。。。少なくとも、ワン・ツー・スゥイーツではtakのp4を超えたかもしれない。残差をflac(-8)で圧縮してももう小さくならない。&lt;/p&gt;
&lt;p&gt;冷静になって見たいが、何故これが起きてるのか説明できない。スケールを変えることがなにか本質的に効いている？&lt;/p&gt;
&lt;p&gt;もはや、リフティングによる分割+SSによる帯域別適応が可愛く見えるレベルで効いているように見受けられる。→そのとおりで、リフティング+SSは0.1%程度のゲインでしか無い…。&lt;/p&gt;
&lt;p&gt;どうしよう。もうウェーブレットとか関係なくて、LPCの連打で高圧縮率を達成してしまっている。しかもLPCだから逆も早いのが分かっている。段階的に残差分散を減らすのがかなり効いているが、なぜうまくいっているか。裏付けが取れないのがすごい厳しい。&lt;/p&gt;
&lt;p&gt;気になるのは係数記録サイズ。ネストするとそのノード数だけ係数を用意しなければならない。特に一番下段では次数を上げると圧縮率の向上度合いが良いが、大量の係数が必要になる。。嬉しいことには、LPC係数のビット幅を6bitとかに設定しても &lt;strong&gt;あまり圧縮性能が悪化しない&lt;/strong&gt; ことを確認している。困ったら昔手を付けたPARCOR係数の量子化が効く可能性を考えている。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティングの組み込み検証(11)</title><link href="/rihuteingunozu-miip-mijian-zheng-11.html" rel="alternate"></link><published>2021-08-09T10:00:00+09:00</published><updated>2021-08-09T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-09:/rihuteingunozu-miip-mijian-zheng-11.html</id><summary type="html">&lt;p&gt;プリエンファシスの評価をする。1次相関除去がよいのか、分散除去がよいのか、それとも組み合わせが良いのか？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;プリエンファシスの評価をする。1次相関除去がよいのか、分散除去がよいのか、それとも組み合わせが良いのか？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシスx2 + LPC(4), サブブロックでLPC(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;のモデルで、最適プリエンファシスの次数を(1回目, 2回目)として調べる。&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;caption&gt;最適プリエンファシスの組み合わせと圧縮率&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="14%" /&gt;
&lt;col width="14%" /&gt;
&lt;col width="14%" /&gt;
&lt;col width="14%" /&gt;
&lt;col width="14%" /&gt;
&lt;col width="14%" /&gt;
&lt;col width="14%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;楽曲 \ 手法&lt;/td&gt;
&lt;td&gt;(0, 0)&lt;/td&gt;
&lt;td&gt;(0, 1)&lt;/td&gt;
&lt;td&gt;(1, 0)&lt;/td&gt;
&lt;td&gt;(1, 1)&lt;/td&gt;
&lt;td&gt;(0, -)&lt;/td&gt;
&lt;td&gt;何もしない&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;kanonop&lt;/td&gt;
&lt;td&gt;55.01&lt;/td&gt;
&lt;td&gt;54.98&lt;/td&gt;
&lt;td&gt;54.94&lt;/td&gt;
&lt;td&gt;54.91&lt;/td&gt;
&lt;td&gt;55.14&lt;/td&gt;
&lt;td&gt;55.44&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ワン・ツー・スゥイーツ&lt;/td&gt;
&lt;td&gt;73.43&lt;/td&gt;
&lt;td&gt;73.43&lt;/td&gt;
&lt;td&gt;73.45&lt;/td&gt;
&lt;td&gt;73.46&lt;/td&gt;
&lt;td&gt;73.56&lt;/td&gt;
&lt;td&gt;73.85&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;SPARKLE&lt;/td&gt;
&lt;td&gt;61.22&lt;/td&gt;
&lt;td&gt;61.37&lt;/td&gt;
&lt;td&gt;61.24&lt;/td&gt;
&lt;td&gt;61.33&lt;/td&gt;
&lt;td&gt;61.22&lt;/td&gt;
&lt;td&gt;61.47&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;クラシック(RWC先頭)&lt;/td&gt;
&lt;td&gt;42.46&lt;/td&gt;
&lt;td&gt;42.60&lt;/td&gt;
&lt;td&gt;42.46&lt;/td&gt;
&lt;td&gt;42.61&lt;/td&gt;
&lt;td&gt;42.28&lt;/td&gt;
&lt;td&gt;42.40&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ちゃんとしたCD音源（ロスのない音源）で分散減らしが有効である示唆。そして2連続も怪しいことが分かってきた。1次相関の除去はkanon音源だけで有効だったということで、これからは分散減らしをメインに据えていく。&lt;/p&gt;
&lt;p&gt;クラシック音源に対してLPCの次数上げがあんまり効いてないことを確認したあたりで、急に集中力がきれてくたばってしまった。&lt;/p&gt;
&lt;p&gt;残りは構成再検討くらいしか無いと思っている。&lt;/p&gt;
&lt;p&gt;CDF42をCDF22に入れ替えたらkanonop &lt;strong&gt;以外&lt;/strong&gt; が軒並み0.4%くらい改善したので、リフティングも含めて検討すべきだし、CDF22の端点も丁寧にしておきたい。残差を見ると、CDF42はCDF22に比べ低域の分散は小さいが、高域がかなり暴れている印象。帯域ロスなくフルに入っている音源は高域成分が残ってしまうということか。CDFは高域の成分が低域に漏れ出ているのであまりひどいことになっていないのかという想像。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティングの組み込み検証(10)</title><link href="/rihuteingunozu-miip-mijian-zheng-10.html" rel="alternate"></link><published>2021-08-08T10:00:00+09:00</published><updated>2021-08-08T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-08:/rihuteingunozu-miip-mijian-zheng-10.html</id><summary type="html">&lt;p&gt;最近はプリエンファシスばっかやってる。&lt;/p&gt;
&lt;p&gt;昨日の議論の一般化をしようとして、まず2次フィルタを使って1次の相 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近はプリエンファシスばっかやってる。&lt;/p&gt;
&lt;p&gt;昨日の議論の一般化をしようとして、まず2次フィルタを使って1次の相関を消す場合を考えて導いたが、以下の難点があるのでスルー。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;解が複雑になる&lt;/li&gt;
&lt;li&gt;今のプリエンファシスを置き換えられない&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代わりに &lt;span class="math"&gt;\(k\)&lt;/span&gt; 次相関を消す1次のフィルタはまとまった。フィルタ係数を &lt;span class="math"&gt;\(a\)&lt;/span&gt; と書き、分散で正規化した &lt;span class="math"&gt;\(k\)&lt;/span&gt; 次相関を &lt;span class="math"&gt;\(\rho_{k}\)&lt;/span&gt; と書く（&lt;span class="math"&gt;\(\rho_{0} = 1, \rho_{-k} = \rho_{k}\)&lt;/span&gt; ）&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
E[(x_{n} - ax_{n-1})(x_{n-k} - ax_{n-k-1})] &amp;amp;= E[x_{n}x_{n-k} - ax_{n}x_{n-k-1} - ax_{n-1}x_{n-k} + a^{2}x_{n-1}x_{n-k-1}] \\
&amp;amp;= \sigma^{2} (\rho_{k} - a \rho_{k+1} - a \rho_{k-1} + a^{2} \rho_{k}) \\
&amp;amp;= \sigma^{2} \left\{ a^{2} \rho_{k} - (\rho_{k+1} + \rho_{k-1}) a + \rho_{k} \right\} \\
&amp;amp;= \sigma^{2} \left[ \rho_{k} \left\{ a^{2} - \frac{\rho_{k+1} + \rho_{k-1}}{\rho_{k}} a \right\} + \rho_{k} \right\} \\
&amp;amp;= \sigma^{2} \left[ \rho_{k} \left( a - \frac{\rho_{k+1} + \rho_{k-1}}{2\rho_{k}} \right)^{2} + \rho_{k} - \frac{(\rho_{k+1} + \rho_{k-1})^{2}}{4\rho_{k}} \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって、 &lt;span class="math"&gt;\(\rho_{k} &amp;gt; 0 (&amp;lt; 0)\)&lt;/span&gt; のとき最小（大）値は &lt;span class="math"&gt;\(\rho_{k} - \frac{(\rho_{k+1} + \rho_{k-1})^{2}}{4\rho_{k}}\ (a = \frac{\rho_{k+1} + \rho_{k-1}}{2\rho_{k}})\)&lt;/span&gt; となる。解（&lt;span class="math"&gt;\(k\)&lt;/span&gt; 次相関が0になる点）は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
a &amp;amp;= \frac{(\rho_{k+1} + \rho_{k-1}) \pm \sqrt{(\rho_{k+1} + \rho_{k-1})^{2} - 4\rho_{k}^{2}}}{2\rho_{k}} \\
&amp;amp;= \frac{\rho_{k+1} + \rho_{k-1}}{2\rho_{k}} \pm \sqrt{\left( \frac{\rho_{k+1} + \rho_{k-1}}{2\rho_{k}} \right)^{2} - 1}
\end{align*}
&lt;/div&gt;
&lt;p&gt;で、 &lt;span class="math"&gt;\(\left| \frac{\rho_{k+1} + \rho_{k-1}}{2\rho_{k}} \right| &amp;gt; 1\)&lt;/span&gt; ならば解あり。&lt;/p&gt;
&lt;p&gt;一般化ができたので2次相関を消してみたが、分散が上昇したり、2回連続で適用すると発散してしまう。やっぱり1次相関除去に命かけた方が良いか。&lt;/p&gt;
&lt;p&gt;改めて、今のボーダーラインは&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス(1)x2 + LPC(4), サブブロックでLPC(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 54.9%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プリエンファシス次の右シフト量を落とすと性能改善の傾向あり。あんまり精度がいらないということ？
1次相関除去が他の音源でも有効なのか検証必要あり。→うーん、ワン・ツー・スゥイーツとSPARKLEで1次相関より分散減らしのほうが良かった。。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティングの組み込み検証(9)</title><link href="/rihuteingunozu-miip-mijian-zheng-9.html" rel="alternate"></link><published>2021-08-07T10:00:00+09:00</published><updated>2021-08-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-07:/rihuteingunozu-miip-mijian-zheng-9.html</id><summary type="html">&lt;p&gt;早速2段階プリエンファシスを2次のLPCに切り替えてみた。予想としては丸め誤差除き同じになると思っていたが …&lt;/p&gt;</summary><content type="html">&lt;p&gt;早速2段階プリエンファシスを2次のLPCに切り替えてみた。予想としては丸め誤差除き同じになると思っていたが、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + LPC(2) + LPC(4), サブブロックでLPC(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 55.3%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;0.3%悪化。これは有意に差があるといえるだろう。数値演算誤差だけの話じゃないと思う。
そしてLPC(2)使用時の分散と2段プリエンファシスの分散を比較しようと思った。これも同じと思っていたが、、、違う…&lt;/p&gt;
&lt;p&gt;LPC(2)のときの分散は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
E[z_{2}^{2}] &amp;amp;= E[\left\{ x_{n} - a_{1} x_{n-1} - a_{2} x_{n-2} \right\}^{2}] \\
&amp;amp;= \sigma^{2} (1 + a_{1}^{2} + a_{2}^{2} - 2 \rho_{1} a_{1}  - 2 \rho_{2} a_{2} + 2 \rho_{1} a_{1} a_{2})
\end{align*}
&lt;/div&gt;
&lt;p&gt;より、これを係数で偏微分すると&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{\partial}{\partial a_{1}} E[z_{2}^{2}] &amp;amp;= 2\sigma^{2} (c - \rho_{1} + \rho_{1}d) \\
\frac{\partial}{\partial a_{2}} E[z_{2}^{2}] &amp;amp;= 2\sigma^{2} (d - \rho_{2} + \rho_{1}c)
\end{align*}
&lt;/div&gt;
&lt;p&gt;で、それぞれ0とおいて &lt;span class="math"&gt;\(a_{1}, a_{2}\)&lt;/span&gt; について解くと（省略）&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
a_{1} = \frac{\rho_{1}(1 - \rho_{2})}{1 - \rho_{1}^{2}}, a_{2} = \frac{\rho_{2} - \rho_{1}^{2}}{1 - \rho_{1}^{2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これを &lt;span class="math"&gt;\(E[z_{2}^{2}]\)&lt;/span&gt; に代入してプロットすると以下のようになる（きれいな式に整理できなかったので苦し紛れにプロット）&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="LPC(2)分散比" src="./images/var_ratio_lpc2.png" /&gt;
&lt;/div&gt;
&lt;p&gt;明らかに2段プリエンファシスとは違う。 &lt;span class="math"&gt;\(\rho_{2} \approx 1\)&lt;/span&gt; でも分散が小さくなる。そして、2段プリエンファシスとの比較として、 &lt;span class="math"&gt;\(\text{(2段プリエンファシスの分散比)} - \text{(LPC(2)の分散比)}\)&lt;/span&gt; をプロットした結果が以下。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="分散比の比較" src="./images/var_ratio_diff.png" /&gt;
&lt;/div&gt;
&lt;p&gt;殆どの領域でLPC(2)の方が分散をよく減らしていることがわかる。kanonop.wavでも、LPC(2)のトータル分散は0.001947, プリエンファシス2段は0.002008だったので実際に分散削減効果はLPC(2)の方が高い。&lt;/p&gt;
&lt;p&gt;では、2段プリエンファシスの方がより良い圧縮性能に寄与していたのはなぜ？&lt;/p&gt;
&lt;p&gt;kanonop.wavのトータル正規化相関を見ると、LPC(2)は0.383299、プリエンファシス2段は0.377010で、プリエンファシス2段の方が1次の相関を消せている事がわかる。この結果のみから考えると、1次相関を減らすことが大事ということか？いや、まだ時期尚早。2次相関まで見ておく。LPC(2)は-0.421879、プリエンファシス2段は-0.454856だった。2次相関はLPC(2)の方が絶対値が小さい。&lt;/p&gt;
&lt;p&gt;すると、1次相関を消すのが大事ということ？最適なフィルタ設計もできるで試してみる。
フィルタ係数を &lt;span class="math"&gt;\(a\)&lt;/span&gt; とする。1フィルタ処理後の1次相関は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
E[(x_{n} - ax_{n-1})(x_{n-1} - ax_{n-2})] &amp;amp;= E[x_{n}x_{n-1} - ax_{n}x_{n-2} - ax_{n-1}^{2} + a^{2}x_{n-1}x_{n-2}] \\
&amp;amp;= \sigma^{2} (\rho_{1} - \rho_{2} a - a + \rho_{1} a^{2}) \\
&amp;amp;= \sigma^{2} \left\{ \rho_{1} \left( a^{2} - \frac{1 + \rho_{2}}{\rho_{1}} a \right) + \rho_{1} \right\} \\
&amp;amp;= \sigma^{2} \left\{ \rho_{1} \left( a - \frac{1 + \rho_{2}}{2\rho_{1}} \right)^{2} + \rho_{1} - \frac{(1 + \rho_{2})^{2}}{4\rho_{1}} \right\}
\end{align*}
&lt;/div&gt;
&lt;p&gt;だから &lt;span class="math"&gt;\(a\)&lt;/span&gt; に関して凸な関数になっている。実信号では &lt;span class="math"&gt;\(\rho_{1} &amp;gt; 0\)&lt;/span&gt; だから下に凸と考えていい。そして、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
a = \frac{1 + \rho_{2}}{2\rho_{1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とすれば最小値 &lt;span class="math"&gt;\(\rho_{1} - \frac{(1 + \rho_{2})^{2}}{4\rho_{1}}\)&lt;/span&gt; が達成できる。この係数を使って2回適用してみた。すると、1次相関が 0.324132 になって54.9%を叩き出した。分散は0.002333で悪いのだが最終的な圧縮率はよい。これは効いているし、 &lt;strong&gt;1次相関を消すことが重要であることを示している&lt;/strong&gt; 。そして今は1次のフィルタだったけど、n次でも良いわけだから試してみたい。&lt;/p&gt;
&lt;p&gt;一方、1次相関が0になるときの &lt;span class="math"&gt;\(a\)&lt;/span&gt; は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
a = \frac{1 + \rho_{2}}{2\rho_{1}} \pm \sqrt{ \left(\frac{1 + \rho_{2}}{2\rho_{1}} \right)^{2} - 1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となるが、実装したところ発散した。おそらく上記方程式の判別式が負で解無し（ルートの中身が負に）になっている？判別式 &lt;span class="math"&gt;\(\left(\frac{1 + \rho_{2}}{\rho_{1}} \right)^{2} - 4\)&lt;/span&gt; が正、すなわち&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\left(\frac{1 + \rho_{2}}{\rho_{1}} \right)^{2} - 4 &amp;gt; 0 &amp;amp;\iff \left| \frac{1 + \rho_{2}}{\rho_{1}} \right| &amp;gt; 2 \\
&amp;amp;\iff \left| \frac{1 + \rho_{2}}{2\rho_{1}} \right| &amp;gt; 1
\end{align*}
&lt;/div&gt;
&lt;p&gt;ならば解を使うのが良いという示唆かもしれない。2段で早速使ってみたら、分散0.002227、1次相関0.325073、2次相関-0.546465で圧縮率は54.9%だけど解を直接使うより良くなってる。&lt;/p&gt;
&lt;p&gt;2次以上については要調査。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティングの組み込み検証(8)</title><link href="/rihuteingunozu-miip-mijian-zheng-8.html" rel="alternate"></link><published>2021-08-06T10:00:00+09:00</published><updated>2021-08-06T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-06:/rihuteingunozu-miip-mijian-zheng-8.html</id><summary type="html">&lt;p&gt;LPCへの移行中。昨夜の不具合は残差をもとに予測していたのが問題。in-placeで実行できると勘違いしていた。
そしてなんと …&lt;/p&gt;</summary><content type="html">&lt;p&gt;LPCへの移行中。昨夜の不具合は残差をもとに予測していたのが問題。in-placeで実行できると勘違いしていた。
そしてなんとなく動くようになったが現在0.1%程度の悪化を観測している。量子化でだいぶ手を抜いているのでそれが原因か。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;まず、前に経験したようにフィルタ加算前に0.5を加算→だいぶ良くなった。これでほぼPARCORと同等。&lt;/li&gt;
&lt;li&gt;前（SLA開発時代）も見たけど量子化ビット幅はあんまりいらないことが分かっている。12bitにした。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;結果、ほぼ同一の圧縮性能:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + LPC(4), サブブロックでLPC(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 55.0%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これでLPCは一旦いいだろう。再度構成を考えていく。&lt;/p&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;プリエンファシスによる分散の減少について&lt;/h2&gt;
&lt;p&gt;TODOにあったプリエンファシスによる分散の減少について考えた。いま、2連結でやってて経験的によくなることが分かっているが、さてどれくらい良いのか。
信号の分散を &lt;span class="math"&gt;\(\sigma^{2}\)&lt;/span&gt; 、1次,2次の正規化相関をそれぞれ &lt;span class="math"&gt;\(\rho_{1}, \rho_{2}\)&lt;/span&gt; と書く。平均0の離散時間系列信号 &lt;span class="math"&gt;\(x_{n}\)&lt;/span&gt; に対して、 &lt;span class="math"&gt;\(x_{n} - \rho_{1} x_{n-1}\)&lt;/span&gt; の分散は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
E[(x_{n} - \rho_{1} x_{n-1})^{2}] &amp;amp;= E[x_{n}^{2} - \rho_{1} x_{n} x_{n-1} + \rho_{1}^{2} x_{n-1}^{2}] \\
&amp;amp;= E[x_{n}^{2}] - \rho_{1} E[x_{n} x_{n-1}] + \rho_{1}^{2} E[x_{n-1}^{2}] \\
&amp;amp;= \sigma^{2} - 2 \rho_{1}^{2} \sigma^{2} + \rho_{1}^{2} \sigma^{2} \\
&amp;amp;= \sigma^{2} (1 - \rho_{1}^{2})
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。（これは1次のLPCなので、最小の分散を達成している。）さて、この操作の後になおも残る1次の相関は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
E[(x_{n} - \rho_{1} x_{n-1})(x_{n-1} - \rho_{1}x_{n-2})] &amp;amp;= E[x_{n}x_{n-1} - \rho_{1} x_{n} x_{n-2} - \rho_{1} x_{n-1}^{2} + \rho_{1}^{2} x_{n-1} x_{n-2}] \\
&amp;amp;= \rho_{1} \sigma^{2} - \rho_{1} \rho_{2} \sigma^{2} - \rho_{1} \sigma^{2} + \rho_{1}^{3} \sigma^{2} \\
&amp;amp;= \sigma^{2} \rho_{1} (\rho_{1}^{2} - \rho_{2})
\end{align*}
&lt;/div&gt;
&lt;p&gt;より、分散で割って正規化すると &lt;span class="math"&gt;\(\frac{\rho_{1} (\rho_{1}^{2} - \rho_{2})}{1 - \rho_{1}^{2}}\)&lt;/span&gt; となる。この正規化相関を使ってもう一度プリエンファシスをかけると、分散は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
E[(x_{n} - \rho_{1} x_{n-1})^{2}] \left[ 1 - \left\{ \frac{\rho_{1} (\rho_{1}^{2} - \rho_{2})}{1 - \rho_{1}^{2}} \right\}^{2} \right] = \sigma^{2} (1 - \rho_{1}^{2}) \left[ 1 - \left\{ \frac{\rho_{1} (\rho_{1}^{2} - \rho_{2})}{1 - \rho_{1}^{2}} \right\}^{2} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となって、元の分散 &lt;span class="math"&gt;\(\sigma^{2}\)&lt;/span&gt; と比を取ると&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
(1 - \rho_{1}^{2}) \left[ 1 - \left\{ \frac{\rho_{1} (\rho_{1}^{2} - \rho_{2})}{1 - \rho_{1}^{2}} \right\}^{2} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;だけ分散が減少することになる。どんな感じになるかプロットしたのが以下：&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="分散比" src="./images/var_ratio.png" /&gt;
&lt;/div&gt;
&lt;p&gt;色がついていない領域は負値を取っている（実現できない値？）
大体の音声では &lt;span class="math"&gt;\(\rho_{1} \approx 0.9\)&lt;/span&gt; を取るので（低域成分がオーバーサンプリングされているから）、 &lt;span class="math"&gt;\(\rho_{2}\)&lt;/span&gt; に関係なく相当の分散減少が期待できる。&lt;/p&gt;
&lt;p&gt;プリエンファシスを1回だけ行った場合の分散比 &lt;span class="math"&gt;\((1 - \rho_{1}^{2})\)&lt;/span&gt; と比べ、 &lt;span class="math"&gt;\(\left\{ \frac{\rho_{1} (\rho_{1}^{2} - \rho_{2})}{1 - \rho_{1}^{2}} \right\}^{2} \geq 0\)&lt;/span&gt; だからより小さくなるはずである。&lt;/p&gt;
&lt;p&gt;時間をおいて銭湯サウナでぼんやりしてたら、上記って必ずしも最適では無い気がしてきた。要は、2パラメータ &lt;span class="math"&gt;\(a,b\)&lt;/span&gt; があって、 &lt;span class="math"&gt;\(y_{n} = x_{n} - a x_{n-1}, z_{n} = y_{n} - b y_{n-1}\)&lt;/span&gt; としたとき、分散 &lt;span class="math"&gt;\(E[z_{n}^{2}]\)&lt;/span&gt; を最小にする &lt;span class="math"&gt;\(a,b\)&lt;/span&gt; は少なくとも &lt;span class="math"&gt;\(a=\rho_{1}\)&lt;/span&gt; とは限らない気がしている。もっと小さい値を取れるはずじゃないのか。&lt;/p&gt;
&lt;p&gt;多分、もっと良いパラメータ組 &lt;span class="math"&gt;\((a,b)\)&lt;/span&gt; があると踏んでいる。なぜならプリエンファシスは直交変換ではないように見えるから。1次の相関が残っているところを見ると、分散をより小さくする変換があるはず。早速試してるけど簡単に見た感じでは難しそう。小さくできれば利益が大きい。1日考えてみようか。&lt;/p&gt;
&lt;p&gt;と思ったが、冷静になる（ならなくても）と、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
z_{n} = (x_{n} - a x_{n-1}) - b (x_{n-1} - a x_{n-2}) = x_{n} - (a + b) x_{n-1} + ab x_{n-2}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となってその分散の最小化を考えているので、結局プリエンファシス2段で最適なのは2次のプリエンファシスということになる。しかし、1次を2段重ねることとの差をちゃんと見たい。&lt;/p&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティングの組み込み検証(7)</title><link href="/rihuteingunozu-miip-mijian-zheng-7.html" rel="alternate"></link><published>2021-08-05T10:00:00+09:00</published><updated>2021-08-05T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-05:/rihuteingunozu-miip-mijian-zheng-7.html</id><summary type="html">&lt;p&gt;Sign-SignアルゴリズムとCDF42の組み合わせを再度検討。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4), サブブロックでPARCOR(4) + CDF42を1段 + 低 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Sign-SignアルゴリズムとCDF42の組み合わせを再度検討。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4), サブブロックでPARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 55.0%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;をベースラインに、サブブロックを変えてみる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4), サブブロックでPARCOR(4): 59.3%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4), サブブロックでPARCOR(4) + CDF42を1段: 58.0%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4), サブブロックでPARCOR(8) + CDF42を1段: 56.1%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4), サブブロックでCDF42を1段: 62.0%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4), サブブロックでCDF42を1段 + 低域でSS(4), 高域でSS(4): 56.2%&lt;/li&gt;
&lt;li&gt;MS変換, サブブロックでPARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 58.0%&lt;ul&gt;
&lt;li&gt;単に分割サイズが小さいだけで性能が上がることを示している&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;サブブロックでPARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 60.6%&lt;ul&gt;
&lt;li&gt;MS変換は重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最適プリエンファシス, サブブロックでPARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 59.1%&lt;/li&gt;
&lt;li&gt;最適プリエンファシス x2, サブブロックでPARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 58.6%&lt;ul&gt;
&lt;li&gt;プリエンファシスは1つで1.5%，2つで2.0%の利益。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;サブブロックで最適プリエンファシス + PARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 60.9%&lt;/li&gt;
&lt;li&gt;サブブロックで最適プリエンファシスx2 + PARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 60.9%&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;プリエンファシスは大ブロック（長い区間）でやったほうが良いということを強く支持する結果&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;1ラグ相関は長い区間で計算しましょう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2, サブブロックでPARCOR(4) + SS(4) + CDF42を1段: 58.0%&lt;ul&gt;
&lt;li&gt;最後のSAはCDF42の後が良い。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2, サブブロックでPARCOR(4) + SS(4): 58.6%&lt;ul&gt;
&lt;li&gt;CDF42で分けてSA、そして帯域分割符号化は有効な筋&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2, サブブロックでCDF42を1段 + 各帯域でPARCOR(4) + SS(4): 60.4%&lt;ul&gt;
&lt;li&gt;CDF42で帯域を分けるのは早すぎてもいけない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2パスが強いのは、プリエンファシスが精密になるからに尽きるのではないか？&lt;/p&gt;
&lt;p&gt;そしてPARCORをLPCに差し替えようと思って結構強引に修正していったら、案の定良くない状態。圧縮率が大幅に悪化。
間違いがあるだろうが（予測結果をプロットしたらだいぶ外れている）、頭が動いておらんので今日はここまでにする。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティングの組み込み検証(6)</title><link href="/rihuteingunozu-miip-mijian-zheng-6.html" rel="alternate"></link><published>2021-08-04T10:00:00+09:00</published><updated>2021-08-04T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-04:/rihuteingunozu-miip-mijian-zheng-6.html</id><summary type="html">&lt;p&gt;2パス符号化を試す。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 各帯域でSS(4): 56.1%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;からスタート。単純にブロック …&lt;/p&gt;</summary><content type="html">&lt;p&gt;2パス符号化を試す。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 各帯域でSS(4): 56.1%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;からスタート。単純にブロックサイズ8192, サブブロックサイズ2048とする&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4), サブブロックでPARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 55.0%&lt;ul&gt;
&lt;li&gt;薬効あり。1.1%減った。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4), サブブロックでCDF42を1段 + 低域でSS(4), 高域でSS(4): 56.2%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2, サブブロックでPARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 56.0%&lt;ul&gt;
&lt;li&gt;0.1%改善。&lt;/li&gt;
&lt;li&gt;これもわかる。プリエンファシスはより正確な相関でやるべきでより長い区間を見れているから正確にプリエンファシスできている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + PARCOR(4), サブブロックで最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 55.1%&lt;ul&gt;
&lt;li&gt;ブロック単位で最適プリエンファシスを行ったほうが0.1%減る。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プリエンファシスの観察からわかるように、圧縮は、大域的（定常的）なものからだんだん細かく（パラメータが大きいモデルを使う）していくのがミソでは。&lt;/p&gt;
&lt;p&gt;(ブロックサイズ, サブブロックサイズ)をいじって様子を見よう。以下のモデルを使用。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4), サブブロックでPARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4)&lt;ul&gt;
&lt;li&gt;( 4096,   512): 55.0%&lt;/li&gt;
&lt;li&gt;( 4096,  1024): 55.0%&lt;/li&gt;
&lt;li&gt;( 4096,  2048): 55.0%&lt;/li&gt;
&lt;li&gt;( 4096,  4098): 55.2%&lt;/li&gt;
&lt;li&gt;( 8192,   512): 55.0% (1024より微妙に減った)&lt;/li&gt;
&lt;li&gt;( 8192,  1024): 55.0% (2048より微妙に減った)&lt;/li&gt;
&lt;li&gt;( 8192,  2048): 55.0%&lt;/li&gt;
&lt;li&gt;( 8192,  4096): 55.1%&lt;/li&gt;
&lt;li&gt;( 8192,  8192): 55.2% &amp;lt;- PARCOR(4)の2段適用で減るということ&lt;/li&gt;
&lt;li&gt;(16384,   512): 54.9%&lt;/li&gt;
&lt;li&gt;(16384,  1024): 54.9%&lt;/li&gt;
&lt;li&gt;(16384,  2048): 55.0%&lt;/li&gt;
&lt;li&gt;(16384,  4096): 55.1%&lt;/li&gt;
&lt;li&gt;(16384,  8192): 55.2%&lt;/li&gt;
&lt;li&gt;(16384, 16384): 55.2%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;細かく分けたほうが0.1%単位で得のようだ。一応(8192, 2048)で話をすすめる。&lt;/p&gt;
&lt;p&gt;次気になるのが、LPCの次数。予測としては、ブロック単位のLPC次数は小さくしたほうが良いと思っている。(ブロック次数, サブブロック次数)で考えよう&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;( 0,  4): 56.0% &amp;lt;- !!!&lt;/li&gt;
&lt;li&gt;( 0,  8): 54.8% &amp;lt;- !!!&lt;/li&gt;
&lt;li&gt;( 0, 16): 54.2% &amp;lt;- !!!&lt;/li&gt;
&lt;li&gt;( 0, 32): 53.5% &amp;lt;- !!!&lt;/li&gt;
&lt;li&gt;( 0, 64): 52.9% &amp;lt;- !!!&lt;/li&gt;
&lt;li&gt;( 0,128): 52.4% &amp;lt;- !!!&lt;/li&gt;
&lt;li&gt;( 2,  4): 55.3%&lt;/li&gt;
&lt;li&gt;( 2, 16): 54.0%&lt;/li&gt;
&lt;li&gt;( 2, 32): 53.4%&lt;/li&gt;
&lt;li&gt;( 2, 64): 52.7% &amp;lt;-&lt;/li&gt;
&lt;li&gt;( 2,128): 52.1% &amp;lt;-&lt;/li&gt;
&lt;li&gt;( 4,  4): 55.0%&lt;/li&gt;
&lt;li&gt;( 4,  8): 54.7%&lt;/li&gt;
&lt;li&gt;( 4, 12): 54.3%&lt;/li&gt;
&lt;li&gt;( 4, 16): 54.1%&lt;/li&gt;
&lt;li&gt;( 4, 20): 53.9%&lt;/li&gt;
&lt;li&gt;( 4, 32): 53.4% &amp;lt;- !!!&lt;/li&gt;
&lt;li&gt;( 4, 64): 52.7% &amp;lt;- !!!&lt;/li&gt;
&lt;li&gt;( 4,128): 52.1% &amp;lt;- !!!&lt;/li&gt;
&lt;li&gt;( 8,  8): 54.8%&lt;/li&gt;
&lt;li&gt;( 8, 12): 54.5%&lt;/li&gt;
&lt;li&gt;( 8, 16): 54.2%&lt;/li&gt;
&lt;li&gt;( 8, 20): 54.0%&lt;/li&gt;
&lt;li&gt;( 8,  4): 55.0% ((4,4)よりは微妙に減る)&lt;/li&gt;
&lt;li&gt;(12,  4): 54.8%&lt;/li&gt;
&lt;li&gt;(16,  4): 54.7%&lt;/li&gt;
&lt;li&gt;(20,  4): 54.6%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これも予測通りというか、大ブロック単位では次数を小さく、サブブロックは次数を大きくした方が改善度合いが大きい。 &lt;strong&gt;大ブロックでは適用しなくても良い結果。&lt;/strong&gt; しかもサブブロックは増やし続けても悪化しない。スケールする。
ひとまず(4,4)を使い続ける。現在のベースラインは以下:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4), サブブロックでPARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4): 55.0%
- ブロックサイズ8192, サブブロックサイズ2048&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;次は、Sign-Signアルゴリズムの出力をフィードバックして効果を確かめたい。
「情報源符号化 歪みのあるデータ圧縮」（大名著）で触れられていて思い出した。次数を(履歴次数, 出力次数)で変えてみた結果は以下:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;(4, 0): 55.0% (ベースライン)&lt;/li&gt;
&lt;li&gt;(4, 2): 54.89%&lt;/li&gt;
&lt;li&gt;(4, 4): 54.87%&lt;/li&gt;
&lt;li&gt;(4, 6): 54.82%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;かつてのワン・ツー・スゥイーツ突っ込んだら微妙な結果を出していた。とくに出力次数をいじるとボロボロ(使わない方が10%低かった)。特にダイナミックな音源で、極型フィルタにしてしまうと発散する危険があると見て良いと思う。海苔音源は多いと思うので &lt;strong&gt;不採用とする。&lt;/strong&gt;&lt;/p&gt;
&lt;div class="section" id="flac"&gt;
&lt;h2&gt;FLACの係数の扱い&lt;/h2&gt;
&lt;p&gt;おそらくLPCをやることになる。今のうちFLACのソースガン見して係数の扱いをよく見ておく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/xiph/flac/blob/1.3.3/src/libFLAC/lpc.c#L122"&gt;LPC係数の計算はここ&lt;/a&gt; 。結果は2次元配列で、最大次数を与えると0次から最大次数までのLPC係数を求める。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/xiph/flac/blob/1.3.3/src/libFLAC/lpc.c#L166"&gt;LPC係数の量子化&lt;/a&gt; 量子化。予め決めたビット幅precisionに収めるように丸め込む。同時にシフト幅も計算。 &lt;cite&gt;FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN&lt;/cite&gt; bit(=5bit)で表現できる範囲で計算している。5bitは大きすぎないか。 &lt;cite&gt;frexp&lt;/cite&gt; で指数部を取り出して計算してるのはスマート。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/xiph/flac/blob/1.3.3/src/libFLAC/lpc.c#L267"&gt;予測&lt;/a&gt; 。マジで1サンプルごとにLPC予測を実行。ただし積和した結果を &lt;cite&gt;lp_quantization&lt;/cite&gt; だけ右シフト。&lt;ul&gt;
&lt;li&gt;シフト幅は &lt;a class="reference external" href="https://github.com/xiph/flac/blob/1.3.3/src/libFLAC/stream_encoder.c#L3783"&gt;エンコーダ側の呼び出し&lt;/a&gt; を見るに、量子化で得られたシフト幅をそのまま入力している。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/xiph/flac/blob/1.3.3/src/libFLAC/stream_encoder.c#L677-L697"&gt;ビット幅はここ&lt;/a&gt; で定めている。サンプルあたりのビット幅とブロックサイズに応じて決めている。最大は &lt;cite&gt;FLAC__MAX_QLP_COEFF_PRECISION&lt;/cite&gt; =15。そういやあTAKは14と言ってたな。&lt;/li&gt;
&lt;li&gt;今まで自分は固定シフトでやってきたので新鮮。こっちのほうが有効に使えるビット幅が広くて良いかもしれない。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/xiph/flac/blob/1.3.3/src/libFLAC/stream_encoder.c#L3820"&gt;24bitのために関数は分けてなくて、係数ビット幅と次数によって64bit整数を使うか呼び分けている。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/xiph/flac/blob/1.3.3/src/libFLAC/lpc.c#L784"&gt;合成&lt;/a&gt; 。予測の逆。特に難しいことはないはず。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティングの組み込み検証(5)</title><link href="/rihuteingunozu-miip-mijian-zheng-5.html" rel="alternate"></link><published>2021-08-03T10:00:00+09:00</published><updated>2021-08-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-03:/rihuteingunozu-miip-mijian-zheng-5.html</id><summary type="html">&lt;p&gt;ローカルなメモをブログに移行していた。読み返すと、論文調べがあんまり活きてないように見える。。。
でもリフティン …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ローカルなメモをブログに移行していた。読み返すと、論文調べがあんまり活きてないように見える。。。
でもリフティングを適応させるのは難しいということがわかったしなあ。L2ノルムなどの評価関数を最小化する係数は求まるが、直交性や消失モーメントがなくなる。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティングの組み込み検証(4)</title><link href="/rihuteingunozu-miip-mijian-zheng-4.html" rel="alternate"></link><published>2021-08-02T10:00:00+09:00</published><updated>2021-08-08T17:30:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-02:/rihuteingunozu-miip-mijian-zheng-4.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\sgn{\mathrm{sgn}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Sign-Signアルゴリズムを導入する。良くなるのは以前からよくわかっているが、さてなんでと …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\sgn{\mathrm{sgn}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Sign-Signアルゴリズムを導入する。良くなるのは以前からよくわかっているが、さてなんでというところに考えが至っていない。ここで見るだけ見ておきたい。&lt;/p&gt;
&lt;p&gt;「再考・適応アルゴリズム」を再びにらみながら考え中。考えてたら、Sign-Signアルゴリズムの評価関数が見えて、それを対数尤度と思ってFisher情報行列を計算したら、入力の符号の自己相関行列が出てきた。&lt;/p&gt;
&lt;p&gt;Sign-Signアルゴリズムの評価関数 &lt;span class="math"&gt;\(J(\ve{h})\)&lt;/span&gt; は、符号成分を入力したシステムの残差 &lt;span class="math"&gt;\(\hat{e} = \ve{h}^{\ast\mathsf{T}} \sgn(\ve{x}) - \ve{h}^{\mathsf{T}} \sgn(\ve{x})\)&lt;/span&gt; を使って&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
J(\ve{h}) = \sgn(e) \hat{e}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と書くことができる（SAでは &lt;span class="math"&gt;\(\hat{e}\)&lt;/span&gt; を &lt;span class="math"&gt;\(|e|\)&lt;/span&gt; に入れ替える）。理由は、&lt;span class="math"&gt;\(e\)&lt;/span&gt; の符号に応じて場合分けすればよい。 &lt;span class="math"&gt;\(e &amp;gt; 0\)&lt;/span&gt; のときは&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
J(\ve{h}) = \hat{e} = (\ve{h}^{\ast} - \ve{h})^{\mathsf{T}} \sgn(\ve{x}) \\
\Rightarrow \frac{\partial}{\partial \ve{h}} J(\ve{h}) = - \sgn(\ve{x})
\end{align*}
&lt;/div&gt;
&lt;p&gt;で、&lt;span class="math"&gt;\(e &amp;lt; 0\)&lt;/span&gt; のときは&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
J(\ve{h}) = -\hat{e} = -(\ve{h}^{\ast} - \ve{h})^{\mathsf{T}} \sgn(\ve{x}) \\
\Rightarrow \frac{\partial}{\partial \ve{h}} J(\ve{h}) = \sgn(\ve{x})
\end{align*}
&lt;/div&gt;
&lt;p&gt;となって、まとめると&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\partial}{\partial \ve{h}} J(\ve{h}) = - \sgn(e) \sgn(\ve{x})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となってSign-Signアルゴリズムが得られた。これを対数尤度の偏微分（スコア関数）と思って Fisher情報行列 &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; を計算すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{F} &amp;amp;= E\left[ J(\ve{h}) J(\ve{h})^{\mathsf{T}} \right] \\
&amp;amp;= E\left[ \sgn(e) \sgn(\ve{x}) \sgn(e) \sgn(\ve{x})^{\mathsf{T}} \right] \\
&amp;amp;= E\left[ \sgn(\ve{x}) \sgn(\ve{x})^{\mathsf{T}} \right] \ (a.e.)
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。Fisher情報行列の各要素 &lt;span class="math"&gt;\((\ve{F})_{ij}\)&lt;/span&gt; に着目すると&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
(\ve{F})_{ij} &amp;amp;= E\left[ \sgn(x_{i}) \sgn(x_{j}) \right] \\
&amp;amp;= \frac{2}{\pi} \sin^{-1}\left(\frac{\rho_{ij}}{\sigma_{i} \sigma_{j}} \right)\ E[x_{i}x_{j}] = \rho_{ij}, E[x_{i}^{2}] = \sigma_{i}^{2}
\end{align*}
&lt;/div&gt;
&lt;p&gt;となっている。最後の結果は自明ではない。「 &lt;a class="reference external" href="https://ieeexplore.ieee.org/document/50391"&gt;Sign-sign LMS convergence with independent stochastic inputs&lt;/a&gt; 」に証明がある。簡単に観察すると、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;対角要素は必ず全て1。よって固有値は0からNを取る。次数を増やすと条件数が悪くなりそうなのはすぐわかる。&lt;/li&gt;
&lt;li&gt;arcsinを使っているので相関が高くとも1に近づきにくい。高相関な信号でもSAより性能劣化しにくいっぽい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ところまで見えた。見えないのは次の2点。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;逆行列が計算できれば高速化に至れるがまだ分からない。&lt;/li&gt;
&lt;li&gt;対数尤度から分布を逆算できるが、これは一体何の分布だろうか。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ちょっと置いて実装に戻ろう。ひとまずSign-Signを導入。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 各帯域でSS(4): 56.1%&lt;ul&gt;
&lt;li&gt;SAと比べて0.8%の改善。これは大きい。採用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;残差を見ていると、高域のプチノイズがかなり気になる。ほぼインパルスで誤差が出ており、しかもブロック周期でもない。と思ったらブロック周期だった。端点処理の問題。直す。&lt;/p&gt;
&lt;p&gt;デバッグしていたら、低域の先頭要素と高域の末尾への書き込みが抜けていることが分かった。先頭要素は状態を持たせればよいけど、末尾は未来の値を知らないといけないので難しい。
状態を持たせるのは好きではないので、0次ホールドか2サンプルの線形補間で良い方を選びたい。
と思ったけど端点処理以外に難しいな。完全再構成するために計算依存関係を見なければならない。今日はこれでつぶれそう。0次ホールド補間で再構成できるようにした。&lt;/p&gt;
&lt;p&gt;CDF42での不連続点が改善（注: 0次ホールド補間なので消えてない）して若干の圧縮率改善が見られた。しかし最終予測結果は大量のインパルス形誤差が…。&lt;/p&gt;
&lt;p&gt;折を見てLPC分析前に窓かけしてるんだけどよくならない。&lt;/p&gt;
&lt;p&gt;フィルタカスケード接続を試す。案の定良くなるが、これは最適な構造を見つけるのが大変に思える。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 低域でSS(4)+SS(4), 高域でSS(4): 56.0%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4)+SS(4): 55.7%&lt;ul&gt;
&lt;li&gt;高域の方が伸びしろがある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4)+SS(2): 55.7%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(2)+SS(2): 55.9%&lt;ul&gt;
&lt;li&gt;SS(4)を1回やるよりSS(2)を連結した方が性能が高い&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(2)+SS(2)+SS(2): 55.8%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(2)+SS(2)+SS(2)+SS(2): 55.8%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4)+SS(2)+SS(2): 55.7%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 低域でSS(4), 高域でSS(4)+SS(2)+SS(2)+SS(2): 55.7%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;カスケード構造は最後に回した方が良さそう。もっとほかの改善策を探るべき。&lt;/p&gt;
&lt;p&gt;残差wavをflac(-8)やwavpack(-hh)で圧縮してみると、今のベストより小さくなる。
この現象前も見て落胆したけど今なら分かる。これ、2パスエンコードが有効であることを示唆してる。
やるのであれば、例えば250ms拾ってきて1回目をLPCなりでやって、その残差に対し2回目を4096サンプルなどの短い区間でLPCなどを実行する。
これがTAKの秘訣ではないか？TAKの250msの異様に長いフレームと短い&amp;quot;サブフレーム&amp;quot;（公式に最大5つのサブブロックに分割されるとある）はそれを指しているのでは？&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティングの組み込み検証(3)</title><link href="/rihuteingunozu-miip-mijian-zheng-3.html" rel="alternate"></link><published>2021-08-01T10:00:00+09:00</published><updated>2021-08-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-08-01:/rihuteingunozu-miip-mijian-zheng-3.html</id><summary type="html">&lt;p&gt;さて、今月から過ごし方を変えていく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;午前: 情報幾何と群論（本進める）&lt;/li&gt;
&lt;li&gt;午後: 研究&lt;/li&gt;
&lt;li&gt;飯ピアノ後: リスニング, Rust, サマポケ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さっ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;さて、今月から過ごし方を変えていく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;午前: 情報幾何と群論（本進める）&lt;/li&gt;
&lt;li&gt;午後: 研究&lt;/li&gt;
&lt;li&gt;飯ピアノ後: リスニング, Rust, サマポケ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さっそくバイトがあったので午前は予定通りではなかった。
午後、まずはSAの次数を変えて様子を見てみる。帯域分割前と帯域分割後で変えた方が良いというのが直感。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + SA適用(4) + CDF42を2段 + 各帯域でSA(4): 58.5%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + SA適用(8) + CDF42を2段 + 各帯域でSA(4): 59.3%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + SA適用(12) + CDF42を2段 + 各帯域でSA(4): 59.2%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + SA適用(4) + CDF42を2段 + 各帯域でSA(8): 58.5%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + SA適用(4) + CDF42を2段 + 各帯域でSA(12): 58.7%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CDF42の2段適用は性能が悪いので一旦外す。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + SA適用(4) + CDF42を1段 + 各帯域でSA(4): 57.7%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + SA適用(8) + CDF42を1段 + 各帯域でSA(4): 58.5%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + SA適用(12) + CDF42を1段 + 各帯域でSA(4): 58.3%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + SA適用(4) + CDF42を1段 + 各帯域でSA(8): 57.7%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + SA適用(4) + CDF42を1段 + 各帯域でSA(12): 57.9%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;業を煮やしてLPCを導入。ALAのPARCORを拝借。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 各帯域でSA(4): 57.2%&lt;ul&gt;
&lt;li&gt;SA(4)を入れ替えて約0.5%の改善。大。&lt;/li&gt;
&lt;li&gt;エントロピーは8.88(55.6%)、まだ残差を減らすべき&lt;/li&gt;
&lt;li&gt;低域31.4%&lt;/li&gt;
&lt;li&gt;高域25.8%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(8) + CDF42を1段 + 各帯域でSA(4): 56.9%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(16) + CDF42を1段 + 各帯域でSA(4): 56.5%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(8) + SA(4): 58.5%&lt;ul&gt;
&lt;li&gt;やはり帯域分割はあった方が良い&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(8) + CDF22を1段 + 各帯域でSA(4): 59.2%&lt;ul&gt;
&lt;li&gt;...といっても適切なリフティングをすべき。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(8) + CDF62を1段 + 各帯域でSA(4): 56.9%&lt;ul&gt;
&lt;li&gt;CDF(8,2)はきっと自分で導かなけらばならないが、その予備試験としてCDF(6,2)を実装して試した。&lt;/li&gt;
&lt;li&gt;CDF(4,2)とほぼ変わらない。しばらくCDF(4,2)で粘る。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + PARCOR(4) + CDF42を1段 + 各帯域でSA(4): 58.7%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス + PARCOR(4) + CDF42を1段 + 各帯域でSA(4): 57.6%&lt;ul&gt;
&lt;li&gt;プリエンファシスはやる価値あり。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x3 + PARCOR(4) + CDF42を1段 + 各帯域でSA(4): 57.1%&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + CDF42を1段 + 各帯域でPARCOR(4), SA(4): 60.5%&lt;/li&gt;
&lt;li&gt;SAをSign-Signに置き換えると0.5%ほど改善したが踏み込まない。&lt;ul&gt;
&lt;li&gt;ハイパラいじらずに、良い構造を見つけたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TAKに張り合うには53%はほしい。52%なら勝てる兆しあり。&lt;/p&gt;
&lt;p&gt;一発で1ラグ相関を打ち消すフィルタ、代数計算できないか？なんか、最適プリエンファシスの2回がけは果たして意味があるか気になってきた。
2次の相関使ってプリエンファシスできない？→やっつけでやってみたがだめ。粗悪なLPCになっていそう
最適プリエンファシスをかけた後の信号の1ラグ相関はどうなっている？代数計算したい。&lt;/p&gt;
&lt;p&gt;ずーっと気になっていたこと。自分の再帰ライス符号が貧弱なのではないかという点にメスを入れたい。
（手詰まり感が半端ないので符号に逃げている。しかし気になって仕方ない。）
TTAでは符号対象値の移動平均sum0を元に、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;sum0が(k &amp;gt; 0) &amp;amp;&amp;amp; (sum0 &amp;lt; (k &amp;lt;&amp;lt; 4))ならばk--&lt;/li&gt;
&lt;li&gt;sum0が(sum0 &amp;gt; (k &amp;lt;&amp;lt; 5))ならばk++&lt;/li&gt;
&lt;li&gt;注意: 更新前にkの値を取り、その値でRice符号化してる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実装してみた、が、微妙に悪化。つまり、自前の方が良かったということになる。
しかしTTA側の実装の単純さは非常に魅力的ではある。&lt;/p&gt;
&lt;p&gt;符号をいじるときに、値が周期的（ブロック長/2の周期）にでかい値を取っていたのを確認した。
かなり気になるので消しにかかる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;プリエンファシスに状態を持たせた&lt;/li&gt;
&lt;li&gt;LPC予測器に状態を持たせた&lt;/li&gt;
&lt;li&gt;CDFの端点処理が抜けている。。。。と思ったがこれが本質的原因ではなかった。上2つが主原因。&lt;ul&gt;
&lt;li&gt;端点処理の要らないHaarウェーブレットでだいぶ高域に不連続点が出る。&lt;ul&gt;
&lt;li&gt;特にSide成分高域。ダイナミックレンジが高まっているのは確かにわかる。&lt;/li&gt;
&lt;li&gt;(M,低域) &amp;lt; (M,高域), (S,低域) &amp;lt; (S,高域)に気を付けてビット配分するのがミソ？&lt;/li&gt;
&lt;li&gt;クリップしている可能性大。&lt;/li&gt;
&lt;li&gt;端点処理を加えても特に外形変わらず。若干圧縮率が改善する程度。&lt;/li&gt;
&lt;li&gt;CDF42の遮断特性が素晴らしい。高域はほぼ16k以上（注意：ダウンサンプル後の残差波形の周波数）しか残っていない。音楽的要素はほぼない。&lt;ul&gt;
&lt;li&gt;これロッシーコーデック作れるわ。高域適当に線形量子化して。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CDF22ではまだ若干高域に音楽が残る。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + 最適プリエンファシス x2 + PARCOR(4) + CDF42を1段 + 各帯域でSA(4): 56.9%&lt;ul&gt;
&lt;li&gt;不連続点を除くことで0.3%ほどの改善&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sign-Signが有意に良い成果を出している。。切り替えてしまおうか。&lt;/p&gt;
&lt;p&gt;MPEG4-ALSでもそうだったけど、FLACの-mオプションは符号量見てMS変換するかどうか判定するみたいね。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティングの組み込み検証(2)</title><link href="/rihuteingunozu-miip-mijian-zheng-2.html" rel="alternate"></link><published>2021-07-31T10:00:00+09:00</published><updated>2021-07-31T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-31:/rihuteingunozu-miip-mijian-zheng-2.html</id><summary type="html">&lt;p&gt;帯域分割信号に対してSAを適用してどれくらい減るか様子を見る。こればかりはやってみないと分からない。&lt;/p&gt;
&lt;p&gt;試して …&lt;/p&gt;</summary><content type="html">&lt;p&gt;帯域分割信号に対してSAを適用してどれくらい減るか様子を見る。こればかりはやってみないと分からない。&lt;/p&gt;
&lt;p&gt;試してみた概観。ブロックサイズは8192。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換: 89.4%&lt;/li&gt;
&lt;li&gt;MS変換 + SA適用: 72.4%&lt;/li&gt;
&lt;li&gt;MS変換 + CDF42の1段適用: 74.3%&lt;/li&gt;
&lt;li&gt;MS変換 + CDF42の2段適用: 71.72%&lt;/li&gt;
&lt;li&gt;MS変換 + CDF42の1段適用で両帯域にSA: 66.5%&lt;/li&gt;
&lt;li&gt;MS変換 + CDF42の2段適用で全帯域にSA: 66.4%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;うーん、パット見渋い。エントロピー見て符号が悪いかどうか判定する。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + CDF42の2段適用で全帯域にSA: で9.87[bit] -&amp;gt; 61.69%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;だから、理論上FLACより悪い。。。符号というよりは残差のエントロピーがまだ高い。
SAじゃ弱すぎるか。LPC使うか。。。&lt;/p&gt;
&lt;p&gt;悲しみに暮れていたが、MS変換の後ろにプリエンファシスを突っ込むと有意に改善。。。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;MS変換 + プリエンファシス: 76.7%&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + SA適用: 66.0%&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + CDF42を1段: 69.9%&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + CDF42を2段: 69.7%&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + CDF42を1段 + 各帯域でSA: 63.2%&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + CDF42を2段 + 各帯域でSA: 63.3% （エントロピー: 9.63bit, 60.2%）&lt;ul&gt;
&lt;li&gt;ただし瞬間的に大きい残差が出ているようだ（サンプルカウントでSEGVした）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + SA適用 + CDF42を1段: 63.4%&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + SA適用 + CDF42を1段 + 各帯域でSA: 58.8% &amp;lt;- !!!&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + SA適用 + CDF42を2段 + 各帯域でSA: 59.5%&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + SA適用 + SA適用: 60.6%&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + SA適用 + SA適用 + SA適用: 59.2%&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + SA適用 + SA適用 + CDF42を1段: 59.9%&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + SA適用 + SA適用 + CDF42を2段: 61.0%&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + SA適用 + SA適用 + CDF42を2段 + 各帯域でSA: 59.8%&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + SA適用 + SA適用 + SA適用 + CDF42を2段 + 各帯域でSA: 60.9%&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + プリエンファシス + SA適用 + CDF42を2段 + 各帯域でSA: 58.7% &amp;lt;- !!!&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + プリエンファシス + SA適用 + CDF42を1段 + 各帯域でSA: 58.0% &amp;lt;- !!!&lt;/li&gt;
&lt;li&gt;MS変換 + プリエンファシス + プリエンファシス + SA適用: 64.5%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CDFは、2段適用より1段の方が良さそう。&lt;/p&gt;
&lt;p&gt;SAを適用してから帯域分割すると有意…？どう考察すればよい？
また、次数4のSAでここまでやれているから、まだ伸びしろがありそうに思える。
いや、弱いフィルタを連結しているから性能が良くなっているのか？&lt;/p&gt;
&lt;p&gt;「音声の高能率符号化」で、プリエンファシスのような差分処理によって確か分散（符号量）が減ることは言及していた。
（書籍を確認すると、1ラグの正規化相関を乗じて差分符号化すると確実に分散（符号量）を落とせると書いてある。式的にも明らか。）
かといって2連結でさらに小さくなるのは聞いてない。初めての経験。1処理で消しきれない分があるということだ。
ガチの1ラグ相関（=最適値）でプリエンファシスやるとどうなる？→良くなった。統計的にもそうか。
多段適用すると、頭打ちになるけど減り続けている。&lt;/p&gt;
&lt;p&gt;上の構成を並べて思ったのは、予測は大域的なものから局所的なものに持っていくと良さそうに見える。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティングの組み込み検証(1)</title><link href="/rihuteingunozu-miip-mijian-zheng-1.html" rel="alternate"></link><published>2021-07-30T10:00:00+09:00</published><updated>2021-07-30T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-30:/rihuteingunozu-miip-mijian-zheng-1.html</id><summary type="html">&lt;p&gt;CDF42をC言語で実装してみた。懸念だった1ループによる実装もOK。想像通り。
分散は確かに減っているからエントロピ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;CDF42をC言語で実装してみた。懸念だった1ループによる実装もOK。想像通り。
分散は確かに減っているからエントロピーも減っているはず。&lt;/p&gt;
&lt;p&gt;さて、もう符号化まで試してしまうべきか？
ちょっと考えてたけど、やってしまおうと思う。
今までのありあわせの符号化スキームを転用してやってみる。&lt;/p&gt;
&lt;p&gt;やっつけで超簡易コーデックを作った。風の巡る場所で試す。観察としては、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;何もしないで直接再帰的ライス符号を適用すると（元データ比）90%&lt;/li&gt;
&lt;li&gt;Haarの1段適用では84%, 2段適用で82.7%&lt;/li&gt;
&lt;li&gt;CDF22の1段適用では81%, 2段適用で79.0%&lt;/li&gt;
&lt;li&gt;CDF42を1段かませた場合76%&lt;ul&gt;
&lt;li&gt;低域が42%&lt;/li&gt;
&lt;li&gt;高域が34%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CDF42を2段かませると75%&lt;ul&gt;
&lt;li&gt;低域/低域が20%&lt;/li&gt;
&lt;li&gt;低域/高域が20%&lt;/li&gt;
&lt;li&gt;高域が34%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高域を分割すると悪化（77%くらい）&lt;/li&gt;
&lt;li&gt;flac(-8)は60.2%, WavPack(-hh)は59.1%&lt;/li&gt;
&lt;li&gt;ブロックサイズを4096から8192に上げると0.05%程度の減少。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SAの導入はこれから、さてどれくらい減らせるだろうか。
分割設定を変えながら見るべし。&lt;/p&gt;
&lt;p&gt;CDF(8,2)も試したいと思い係数を探していたが見つからず。代わりに以下の論文がヒット。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://core.ac.uk/download/pdf/30791653.pdf"&gt;Optimization of biorthogonal wavelet filters for signal and image compression&lt;/a&gt; フィルタ係数を代数的に求めている？制約を入れて望ましいフィルタを設計しているように見える。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティング観察(6)</title><link href="/rihuteinguguan-cha-6.html" rel="alternate"></link><published>2021-07-29T10:00:00+09:00</published><updated>2021-07-29T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-29:/rihuteinguguan-cha-6.html</id><summary type="html">&lt;p&gt;「音声の高能率符号化」の3.4節「予測符号化」で予測による分散（ひいてはビット数）の減少について記述がある。
これをリ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;「音声の高能率符号化」の3.4節「予測符号化」で予測による分散（ひいてはビット数）の減少について記述がある。
これをリフティングで考えるとどうなるだろうか？
誤差分散を最小にしようとすると線形予測符号化にぶつかってしまうが、リフティングによる効果を知りたい。&lt;/p&gt;
&lt;p&gt;ロスレス圧縮に組み込む前に、やはりもう少し調査したい。
リフティングで帯域分割した信号に対してLMSしたとき、さてエントロピーは改善するのか？&lt;/p&gt;
&lt;p&gt;ステップサイズを変えつつ観察したら、どのステップサイズでもエントロピーが減少していた。実データで1bit程度（16bitPCMの仮定で）の減少。これは大きい。&lt;/p&gt;
&lt;p&gt;さらに、多段に帯域分割したときはさらにエントロピーが減少していた。&lt;/p&gt;
&lt;p&gt;計算負荷的にはCDF(4,2)を推したい。C言語で実装して、整数値でエントロピーがマジで減ってるか見てみたい。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティング観察(5)</title><link href="/rihuteinguguan-cha-5.html" rel="alternate"></link><published>2021-07-28T10:00:00+09:00</published><updated>2021-07-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-28:/rihuteinguguan-cha-5.html</id><summary type="html">&lt;p&gt;「音声の高能率符号化」はやはり素晴らしい。今日に通じる基本事項がもれなく列挙されている。
逆に言うと、技術進歩が …&lt;/p&gt;</summary><content type="html">&lt;p&gt;「音声の高能率符号化」はやはり素晴らしい。今日に通じる基本事項がもれなく列挙されている。
逆に言うと、技術進歩がまったくないと言うことになるが。&lt;/p&gt;
&lt;p&gt;今日は2段階適用したときの相関変化をよく見たい。相関はさらに減るだろうというのが大方の予測だが、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;相関は減っていく傾向&lt;ul&gt;
&lt;li&gt;ただし、周期的な構造は縮んで表れてくる&lt;/li&gt;
&lt;li&gt;実データ（ピアノ）でCDF(4,2)を2回まで適用すると低域の1次相関が0.5くらいになっている。これはプリエンファシスより優れている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2回適用したとき、高域+低域のエントロピーが底を打っている印象を受ける。&lt;ul&gt;
&lt;li&gt;高域のエントロピーは増加傾向。低次の高域成分は構造的だが、高次では取り除ききれない成分が出てくるので当然だと思うことに。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実験をやりながら漠然と思っていたが、CDF(4,2)が以下の意味で優れている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;高域はもちろん、低域成分の分散減少も多きい。&lt;/li&gt;
&lt;li&gt;相関除去能力&lt;/li&gt;
&lt;li&gt;負荷の低さ（シフト演算を多く使える）&lt;ul&gt;
&lt;li&gt;CDF(5,1), CDF(6,2)も同様の効果を与えているが、負荷はより高い印象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;画像ではCDF(2,2)がJPEG2000ロスレスに採用されているが、画像の方が低域成分が多いから有効に作用していると想像する。音声の方が高域周波数成分が多いからより高次のモーメントを必要としているように見受けられる。&lt;/p&gt;
&lt;p&gt;上記の意味でCDF(4,2)を超えるフィルタ設計を行いたいな。
同時に、CDF(4,2)を使ったコーデック（ロッシー可）はどれくらい良いのか実装して確かめたい。AAD2とか？&lt;/p&gt;
&lt;p&gt;例のBuildingの資料を読んでいる。DDウェーブレットは多項式補間、Donohoウェーブレットは平均値補間でDilation方程式の解になっているところはなんとなく読めた。しかし、具体的に設計するにはどうすればよいか書いてないように見受けられる。集中力が切れたので風呂入って「音声の高能率符号化」を流し読みする。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティング観察(4)</title><link href="/rihuteinguguan-cha-4.html" rel="alternate"></link><published>2021-07-26T10:00:00+09:00</published><updated>2021-07-26T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-26:/rihuteinguguan-cha-4.html</id><summary type="html">&lt;p&gt;「音声の高能率符号化」を読んでいたら、音声データ一般で相関が高い理由が明確に書いてあった。それは、低域の信号を …&lt;/p&gt;</summary><content type="html">&lt;p&gt;「音声の高能率符号化」を読んでいたら、音声データ一般で相関が高い理由が明確に書いてあった。それは、低域の信号をオーバーサンプリングしているからである。
人の声は8kHzがいい所の上限だが、それに対して44100Hzでサンプリングすると明らかにオーバーサンプリングになる。つまり、低域信号はゆっくり変化しているのに過剰にサンプリングされ、相関が高くなる。&lt;/p&gt;
&lt;p&gt;この意味でも帯域分割は意味を持ちそうな印象を受ける。ウェーブレットで低域/高域に分けると低域のオーバーサンプリング効果が低減する。実際、相関が下がることを確認している。&lt;/p&gt;
&lt;p&gt;ストーリーとしては、&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;適応アルゴリズムの収束特性が悪いのは音声データに相関があるから&lt;/li&gt;
&lt;li&gt;相関は低域信号のオーバーサンプリングにより生じている&lt;/li&gt;
&lt;li&gt;ウェーブレットで低域信号をリサンプリングすることでレートを下げて扱える、相関は下がっているので有効なはずだ&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;相関を消すというのもウェーブレット設計の方針になる。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティング観察(3)</title><link href="/rihuteinguguan-cha-3.html" rel="alternate"></link><published>2021-07-25T10:00:00+09:00</published><updated>2021-07-25T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-25:/rihuteinguguan-cha-3.html</id><summary type="html">&lt;p&gt;より次数を上げたCDFを実装して様子（統計量）を見る。&lt;/p&gt;
&lt;p&gt;CDF(5,1), (5,3), (6,2), (6,4)まで実装してみた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;4以上になると低域成分 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;より次数を上げたCDFを実装して様子（統計量）を見る。&lt;/p&gt;
&lt;p&gt;CDF(5,1), (5,3), (6,2), (6,4)まで実装してみた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;4以上になると低域成分の分散の減少も顕著&lt;/li&gt;
&lt;li&gt;しかし5,6では高域の分散は上昇傾向&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全体的にいえることとしては、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;相関は減少している。高域は勿論だが、低域も。&lt;/li&gt;
&lt;li&gt;高周波（10000以上）に対して自己相関がほぼ同じになる。（低域の振幅は減少しているが）&lt;/li&gt;
&lt;li&gt;ナイキスト周波数での振動に対して高域が大きな定数値をとる（分散はほぼ0）&lt;/li&gt;
&lt;li&gt;スイープも高周波数帯域で高域が大きな定数値をとりがち。&lt;ul&gt;
&lt;li&gt;高域の予測は外れがちのよう。低域の分離はできているようだ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プリエンファシスと比較している。前どっかで見たけど、周波数特性も低域が完全に消えていないし、高域は強調されてる。
相関はリフティングとどっこいどっこい。合計のエントロピーもどっこい？いや、リフティングの方が高域がかなり小さい。
低域にプリエンファシスを適用することもできるし。&lt;/p&gt;
&lt;p&gt;また、純音（440Hz）に対してプリエンファシスをかけると自己相関はほぼ変わらないが、リフティングの場合は高域にて相関が減少（高次になるにつれてすぐに0に収斂）し、低域も相関の減少が見られた。&lt;/p&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;所感&lt;/h2&gt;
&lt;p&gt;音声圧縮に適したリフティングウェーブレットの設計は、テーマとしてありだと思う。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;消失モーメント多め（CDF(2,2)よりもCDF(4,2)の方が良いことを受け）&lt;/li&gt;
&lt;li&gt;シフトと加算で実装可能&lt;/li&gt;
&lt;li&gt;L1ノルムの意味スパース or エントロピー最小化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;どうやればいいかつかみどころがないけど、確かお家で自分だけのウェーブレットを作る論文あったと思うので、そこからアプローチしてみるか。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cm-bell-labs.github.io/who/wim/papers/athome/"&gt;Building Your Own Wavelets At Home&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;今なら目的意識をもって戦えそう。スライドもある。もらっていこう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティング観察(2)</title><link href="/rihuteinguguan-cha-2.html" rel="alternate"></link><published>2021-07-24T10:00:00+09:00</published><updated>2021-07-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-24:/rihuteinguguan-cha-2.html</id><summary type="html">&lt;p&gt;前日までで、MSの代わりにCDF(2,2)を使うのは有効ではないというのが分かった。LRの信号は一般にズレており、線形予 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;前日までで、MSの代わりにCDF(2,2)を使うのは有効ではないというのが分かった。LRの信号は一般にズレており、線形予測のような局所的な予測はうまくいかない。周波数特性としてもずれがある。
従って1チャンネルの信号に対してウェーブレットを適用する道を探る。
次はどうするか。&lt;/p&gt;
&lt;p&gt;単にCDF(2,2)で帯域分割して各帯域でLPC/適応フィルタするのは安直すぎるし工夫の余地がない。
もっと何か理論的な工夫は及ばないか？考えてみる。&lt;/p&gt;
&lt;p&gt;リフティングによって何が変わるのかをまだ観察してなかったかも。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;適応的にリフティング係数を設定する&lt;ul&gt;
&lt;li&gt;予測・更新フィルタを両方ともSAにしちゃうとか。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CDF(2,2)通した後の信号の特性&lt;ul&gt;
&lt;li&gt;分かり切ってることだが、2次までのモーメントが消えてる。&lt;/li&gt;
&lt;li&gt;信号の統計量（平均、分散、自己相関、L1ノルム、エントロピー）はどのように変化するか？&lt;/li&gt;
&lt;li&gt;高域と低域で分けて考える。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プリエンファシスをリフティングに置き換えることの是非。&lt;ul&gt;
&lt;li&gt;例えばHaarは直流成分（0次モーメント）を完全に消す。&lt;/li&gt;
&lt;li&gt;変換域適応と同じになると思う。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2.が大事に思える。地味に論じている文献ないし。
リフティング後の信号の性質は、NoteBook上でいろいろ見てみるのが良さそう。&lt;/p&gt;
&lt;p&gt;というわけで実装を進めている。Haar, CDFは良さそうだけど、ドベシィの実装は&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://core.ac.uk/download/pdf/226136339.pdf"&gt;DESIGN AND IMPLEMENTATION OF LIFTING BASED DAUBECHIES WAVELET TRANSFORMS USING ALGEBRAIC INTEGERS&lt;/a&gt; の22pあたりを参照。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CDF9/7については実装あり&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.archive.org/web/20110714234934/http://www.olhovsky.com/content/wavelet/2dwavelet97lift.py"&gt;2D CDF 9/7 Wavelet Forward and Inverse Transform (lifting implementation)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.archive.org/web/20120305164605/http://www.embl.de/~gpau/misc/dwt97.c"&gt;dwt97.c - Fast discrete biorthogonal CDF 9/7 wavelet forward and inverse transform (lifting implementation)&lt;/a&gt; マージで予測・更新の度にループ回している。。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CDF(1,1)(=Haar), CDF(2,2), CDF(3,1), CDF(4,2)と実装してみたが、どうもprimal liftingの次数を上げていくと良好な結果になる。良好というのは、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;高域成分の分散、L1ノルム、エントロピー減少（自己相関はほぼ0に）&lt;/li&gt;
&lt;li&gt;低域成分の分散、L1ノルム減少（(3,1), (4,2)で顕著）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;より次数を上げたCDFを実装して観察してみる。音声では次数を上げた方が良いのかもしれないという示唆。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>リフティング観察(1)</title><link href="/rihuteinguguan-cha-1.html" rel="alternate"></link><published>2021-07-23T10:00:00+09:00</published><updated>2021-07-23T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-23:/rihuteinguguan-cha-1.html</id><summary type="html">&lt;p&gt;今考えているウェーブレットによるチャンネル間相関除去って既知の技術だと思ったんだがなあ。資料がないよう …&lt;/p&gt;</summary><content type="html">&lt;p&gt;今考えているウェーブレットによるチャンネル間相関除去って既知の技術だと思ったんだがなあ。資料がないように見える。&lt;/p&gt;
&lt;p&gt;音声のLRチャンネルの相互相関を観察してみよう。そして、LRをレイジーウェーブレット（スプリット）の結果と考えてリフティングしてみる。
作って動かしてみてるけど、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;無音部（とリリース）でしか相関が高くならない&lt;ul&gt;
&lt;li&gt;残響成分はなんやかんやで位相が揃っているのかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MS処理してみると全体的に相関が小さくなる。（1次以上のラグ相関も消えている感じ）&lt;/li&gt;
&lt;li&gt;CDF22をやっつけで適用してみたけどMS処理とほぼ変わらず。まじで？実装ミスを疑っている。良くなる予想なんだが。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CDF22をNARUに突っ込んでみた（MSで使ってみた）が、案の定というか性能悪化の傾向。
LRは周波数特性が違うから、スプリット（レイジーウェーブレット）した状態とは違う状態になっているかかも。スプリットしたら正確にサンプリングの半周期分遅れた自分に対して処理できるけど、LR信号はスピーカー配置とかで変わってくる。
そしてもっと重大なことに可逆じゃない。端点処理が怪しい。デバッグしてたらくたばってしまい夕方…。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;CDF22Forward&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;CDF22Inverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;どう見ても順変換で &lt;cite&gt;data[0][smpl + 1]&lt;/cite&gt; が書き換え前に参照されてて、逆変換で戻す前の値を参照していてうまくいくはずがない。
悶絶してたら &lt;a class="reference external" href="https://fussy.web.fc2.com/algo/compress9_wavelet2.htm"&gt;(9) ウェーブレット変換 -2-&lt;/a&gt; に実装があって、以下のように書き換えたら可逆になった。性能はHaarより少し悪い。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;CDF22Forward&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;CDF22Inverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;確かに可逆になるんだけどループ2回回すのがかっこ悪い。1回でやり切れるはずなんだな。しかしこれ以上は追わない。MS変換を置き換えるには至らない感じか。でも、CDF(2,2)は低域と高域で2次までのモーメントを消せるのが強い。チャンネル毎の処理としては使ってみたい。&lt;/p&gt;
&lt;p&gt;他に少し収穫。MS処理をHaarリフティングと考えると以下のように簡潔かつ高速になる。
（ただし現行のMS処理と圧縮結果が微妙に変わることに注意。）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* LR -&amp;gt; MS（int32_t） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;LRtoMSInt32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* MS -&amp;gt; LR（int32_t） */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;MStoLRInt32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_samples&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;smpl&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>戦略会議中2021(20)</title><link href="/zhan-lue-hui-yi-zhong-202120.html" rel="alternate"></link><published>2021-07-22T10:00:00+09:00</published><updated>2021-07-22T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-22:/zhan-lue-hui-yi-zhong-202120.html</id><summary type="html">&lt;p&gt;S+P変換を踏まえて次を考えているが、今気になるのはチャンネル間の相関。チャンネルx信号の2次元でウェーブ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;S+P変換を踏まえて次を考えているが、今気になるのはチャンネル間の相関。チャンネルx信号の2次元でウェーブレットしようと考えているけど、実際の信号はどれくらい相関があるのか気になる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ieice.org/publications/conference-FIT-DVDs/FIT2004/pdf/M/M_016.pdf"&gt;チャンネル間相関を用いた多チャンネル信号の可逆圧縮符号化&lt;/a&gt; チャンネル配置の幾何学的位置に基づいた相関係数により、MS処理の重みを決める。MPEG4より良くなっていることを確認。&lt;ul&gt;
&lt;li&gt;面子がだいぶMPEG4に寄っとる。標準に取り込まれている？それとも採用されなかったネタ？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1603.03364.pdf"&gt;Channel Decorrelation For Stereo Acoustic Echo Cancellation In High-Quality Audio Communication&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;チャンネル間の干渉により音質が悪化するので改善を試みる研究。&lt;/li&gt;
&lt;li&gt;Vorbisの聴覚モデルの評価関数が高くなるように、各チャンネルでノイズ付加とオールパスフィルタを適用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/6287809"&gt;Inter-channel decorrelation by sub-band resampling in frequency domain&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;集中が途切れた…読めてない…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;うーん、いい情報が出てこない。
窓関数に対する完全再構成条件がPrincen-Bradley条件。論文で触れていたので気になった。すると以下の資料がヒット。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.spcom.ecei.tohoku.ac.jp/~aito/kisosemi/slides2.pdf"&gt;高効率音楽符号化&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;音声符号化に関する包括的な資料 &lt;a class="reference external" href="http://www.spcom.ecei.tohoku.ac.jp/~aito/kisosemi/slides.pdf"&gt;こちら&lt;/a&gt; もよい。&lt;/li&gt;
&lt;li&gt;というか、伊藤教授が音声全般でかなり突っ込んだことやってる。 &lt;a class="reference external" href="http://www.spcom.ecei.tohoku.ac.jp/index.html"&gt;研究室サイト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>戦略会議中2021(19)</title><link href="/zhan-lue-hui-yi-zhong-202119.html" rel="alternate"></link><published>2021-07-19T10:00:00+09:00</published><updated>2021-07-19T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-19:/zhan-lue-hui-yi-zhong-202119.html</id><summary type="html">&lt;p&gt;バッテリー交換した翌日からMacくんkernel_taskが暴走。SMC/PRAMリセットしても改善せず。
炎天下で持ち出したのが災いしたか …&lt;/p&gt;</summary><content type="html">&lt;p&gt;バッテリー交換した翌日からMacくんkernel_taskが暴走。SMC/PRAMリセットしても改善せず。
炎天下で持ち出したのが災いしたか…？（土曜日はリリイベ）
今一度修理に出した。しばらくは仮環境で作業せざるを得ない。&lt;/p&gt;
&lt;p&gt;今日は出先で藤ノ木先生のリフティング資料を流し読みした。なんとなくはつかめた感じ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/publication/2610733_An_Image_Multiresolution_Representation_for_Lossless_and_Lossy_Compression"&gt;An Image Multiresolution Representation for Lossless and Lossy Compression&lt;/a&gt; S(Sequential) + P(Predict) Transformの論文。といってもリフティングに含まれるが。&lt;ul&gt;
&lt;li&gt;S+P変換による分散の変化を論じているところが腑に落ちた。ここを突破点にもっと議論を進められないか？&lt;/li&gt;
&lt;li&gt;高級なプリエンファシスとしてリフティングを使うのはあり。そして相関が確かに除去できていることが示せるとなおよい。&lt;/li&gt;
&lt;li&gt;もうちょっと読みたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>戦略会議中2021(18)</title><link href="/zhan-lue-hui-yi-zhong-202118.html" rel="alternate"></link><published>2021-07-15T10:00:00+09:00</published><updated>2021-07-15T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-15:/zhan-lue-hui-yi-zhong-202118.html</id><summary type="html">&lt;p&gt;ちょっと目的もなくふらふら見ている。。。どうするか方針が立たない。
良いWavelet係数を学習適応するのはwavenetで微妙（できる …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ちょっと目的もなくふらふら見ている。。。どうするか方針が立たない。
良いWavelet係数を学習適応するのはwavenetで微妙（できるけど、直交条件が崩れる）と分かったし、かといって出来合いのwaveletを使ってしまうと理論的な新しさがない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/6658828"&gt;1857.2-2013 - IEEE Standard for Advanced Audio Coding&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;IEEE 1857.2 の公式文書&lt;/li&gt;
&lt;li&gt;Wavelet係数組の選定経緯は特に言及されてない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ウェーブレット係数の比較で調べてみる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/785671"&gt;Performance evaluation of reversible integer-to-integer wavelet transforms for image compression&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;画像圧縮向けの整数Wavelet変換の比較。5/3(CDF(2,2))がリーズナブルといういう結論。&lt;/li&gt;
&lt;li&gt;音声はどうだろうか&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://d-nb.info/97013312X/34"&gt;Lossless Wideband Audio Compression: Prediction and Transform&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;あやしい博論。6.6.2にて音声ロスレス圧縮の比較あり。&lt;/li&gt;
&lt;li&gt;CDF(2,2), つまり5/3の平均ビットレートが優れていたという結論。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リフティングの理解をもう少し進めるべきかと感じできた。藤ノ木先生のドキュメントを印刷する。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>戦略会議中2021(17)</title><link href="/zhan-lue-hui-yi-zhong-202117.html" rel="alternate"></link><published>2021-07-14T10:00:00+09:00</published><updated>2021-07-14T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-14:/zhan-lue-hui-yi-zhong-202117.html</id><summary type="html">&lt;p&gt;昨日試したリフティングの意味をぐるぐる考えていた。
偶数成分と奇数成分で分けて、偶数（奇数）成分から奇数（偶数）成 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;昨日試したリフティングの意味をぐるぐる考えていた。
偶数成分と奇数成分で分けて、偶数（奇数）成分から奇数（偶数）成分を予測するとどうなるか。
DPCMとは違った成分になるのは分かっていて、Haarと同じく低域と高域に分割することも分かっているつもりだけど、その意味とか、LPCやる価値はあるのかがすっきり来ない。&lt;/p&gt;
&lt;p&gt;リフティングを復習したくて &lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jsiamt/28/2/28_72/_pdf/-char/ja"&gt;リフティングスキームによるウェーブレットの構成法&lt;/a&gt; を流し読みした。多項式分解などの細かいところは追えないが、相当な良資料と思っている。任意の離散ウェーブレット変換はLiftingで表現できることを再度確認。証明はまだ追ってない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.cpp.edu/~jskang/files/integer.pdf"&gt;WAVELET TRANSFORMS THAT MAP INTEGERS TO INTEGERS&lt;/a&gt; 整数ウェーブレット変換について。整数liftingについても取り扱っている。各ウェーブレットでの画像に対するエントロピー比較あり。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/publication/221026663_Integer_wavelet_transforms_based_lossless_audio_compression"&gt;INTEGER WAVELET TRANSFORM BASED LOSSLESS AUDIO COMPRESSION&lt;/a&gt; 1999年の。整数ウェーブレット変換したのをGolomb-Rice。&lt;ul&gt;
&lt;li&gt;事前知識を排したいと言ってる。まさにそうだな&lt;/li&gt;
&lt;li&gt;試してみた取った感じのproceedings。ヒントがあるかもしれないのでガン見。&lt;/li&gt;
&lt;li&gt;DD(4,2)を使っている。理由は各帯域でゲインが同じだから？とのこと（？）&lt;/li&gt;
&lt;li&gt;お、Rice符号の最適条件を久々に見た。 &lt;span class="math"&gt;\(\theta^{l}(1 + \theta) \leq 1 &amp;lt; \theta^{l}(1 + \theta^{-1})\)&lt;/span&gt; けどこんな形だったっけ？&lt;/li&gt;
&lt;li&gt;Rice符号の工夫は自分と同じかもしくはより進んでいる。移動平均のバイアス除去手法があるというのを初めて聞いた。&lt;/li&gt;
&lt;li&gt;コンテキスト選択を入れてる。やり方分かってない。&lt;/li&gt;
&lt;li&gt;他手法の比較がなく、提案手法内での比較だけ。結言がないのでもやっとする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;思うことは、リフティングとLMS/LPCを組み合わせてコーデック作りましただけでは弱いと思っている。何か理論的な新しさがほしいが、lifting回りで新しさを出すとしたらどうしたらいいか？&lt;/p&gt;
&lt;p&gt;Haarのliftingの式はMS変換と一致するなあ。つまり、L,Rチャンネルをそれぞれ偶奇でスプリットしたと考えてもいいわけか。CDFとか突っ込めそうだなと即座に思う。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>戦略会議中2021(16)</title><link href="/zhan-lue-hui-yi-zhong-202116.html" rel="alternate"></link><published>2021-07-13T10:00:00+09:00</published><updated>2021-07-13T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-13:/zhan-lue-hui-yi-zhong-202116.html</id><summary type="html">&lt;p&gt;Haarウェーブレット（lifting）で2分割して、それぞれにSAを適用してみた。
分割しないでSAを実行するものと予測誤差を比較 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Haarウェーブレット（lifting）で2分割して、それぞれにSAを適用してみた。
分割しないでSAを実行するものと予測誤差を比較したところ、RMSの意味で悪化。
ステップサイズをまったく同じにしているがそれはいいのかなど気になる。&lt;/p&gt;
&lt;p&gt;いやでも、単純にHaarかけるだけでも平均絶対値は下がってるな。有益に見える。
L2ノルムも半分になってるのはどうしてだ？パーセバルの等式やいかに。&lt;/p&gt;
&lt;p&gt;純音を相手にしているので綺麗に性質が表れている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;奇数（差分）成分は周期を2倍（周波数0.5倍）にした成分。&lt;ul&gt;
&lt;li&gt;差分なので振幅は小さい&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;偶数成分は周期を0.5倍（周波数2倍）にした成分&lt;ul&gt;
&lt;li&gt;振幅は元の信号と変わらない&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分割した帯域に対してLPC/LMSするなり帯域ごとに異なる符号を割り当てるのはまったく自然な発想に思える。他の信号でも試して様子を見るべきかもしれない。&lt;/p&gt;
&lt;p&gt;LPCしたらどうなるだろうか。分割しない場合との比較をしたい。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>戦略会議中2021(15)</title><link href="/zhan-lue-hui-yi-zhong-202115.html" rel="alternate"></link><published>2021-07-12T10:00:00+09:00</published><updated>2021-07-12T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-12:/zhan-lue-hui-yi-zhong-202115.html</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="http://yoksis.bilkent.edu.tr/pdf/files/10.1109-83.869176.pdf"&gt;Adaptive Polyphase Subband Decomposition Structures for Image Compression&lt;/a&gt; を引用している音声関連の文献を漁る。もしくは適応的リフティング、整数ウェーブレット変換の …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a class="reference external" href="http://yoksis.bilkent.edu.tr/pdf/files/10.1109-83.869176.pdf"&gt;Adaptive Polyphase Subband Decomposition Structures for Image Compression&lt;/a&gt; を引用している音声関連の文献を漁る。もしくは適応的リフティング、整数ウェーブレット変換の音声圧縮への適用を探る。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.1893&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Lossless Sound Compression using the Discrete Wavelet Transform&lt;/a&gt; 離散ウェーブレット変換を使って圧縮を試みる。算術符号を使用。Shortenよりも高い圧縮率。しかし当然遅い。&lt;ul&gt;
&lt;li&gt;試してみたという感じの文体だが、ウェーブレットでロスレス圧縮するときの示唆にはなっている。&lt;/li&gt;
&lt;li&gt;まとめにおいて &lt;strong&gt;Ultimately, our experiences suggest that wavelets may not be the right paradigm for lossless sound compression.&lt;/strong&gt; と言った。LPCの方が少ないパラメータで信号を表現できているとも指摘している。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://support.hdfgroup.org/doc_resource/SZIP/"&gt;SZIP&lt;/a&gt; というRice符号の変種を比較対象としていた。強いかも。よく見るべし。下記所感に詳しく。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.idmt.fraunhofer.de/content/dam/idmt/documents/IL/Personal%20Websites/Schuller/publications/asilomar2003.pdf"&gt;IMPROVED INTEGER TRANSFORMS FOR LOSSLESS AUDIO CODING&lt;/a&gt; 整数DCTベースの手法。LTACでダメだったということがわかっている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://aip.scitation.org/doi/pdf/10.1063/1.5002024"&gt;A review of lossless audio compression standards and algorithms&lt;/a&gt; ロスレス音声符号化のまとめ2017年度版。&lt;ul&gt;
&lt;li&gt;IEEE 1857.2が整数ウェーブレット変換したのをLPC予測にかけている。つまり変換域適応している。&lt;/li&gt;
&lt;li&gt;なるほど正しい流れっぽいな。IEEE 1857.2にもっと探り入れるか。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/publication/317829002_Investigation_of_Lossless_Audio_Compression_using_IEEE_18572_Advanced_Audio_Coding"&gt;Investigation of Lossless Audio Compression using IEEE 1857.2 Advanced Audio Coding&lt;/a&gt; 固定係数Liftingの後にLPCが刺さっている。&lt;ul&gt;
&lt;li&gt;固定係数なのがうーんという感じ。&lt;/li&gt;
&lt;li&gt;符号は算術符号。これもうーん。&lt;/li&gt;
&lt;li&gt;論文での比較によると圧縮率はMonkey's Audioより高いけど圧縮速度は遅い。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="ezw"&gt;
&lt;h2&gt;EZW（符号化手法）について&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://dns2.asia.edu.tw/~ysho/YSHO-English/2000%20Engineering/PDF/IEE%20Tra%20Sig%20Pro41,%203445.pdf"&gt;Embedded Image Coding Using Zerotrees of Wavelet Coefficients&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Embeded zerotree wavelet の略らしい&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/136597"&gt;Image coding using wavelet transform&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;ドベシィ含む。EZWのさらに原点たる文献。Embeded zero tree(EZT)を提案。Adaptive Polyphase Subband Decomposition Structures for Image Compression はEZTを使用。&lt;/li&gt;
&lt;li&gt;内容は基礎的なので腰を入れて読むのが良いかも？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;所感&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;適応リフティング（適応フィルタ）試してみるか。そんなんで良くなるとはどうも思えないが見てみよう。間引き（受容野拡大）で何か魔法が起こるかもしれない。間引いてLPCは常套手段だったりしない？（フィルタバンクの適応みたいな話になりそう）&lt;/li&gt;
&lt;li&gt;間引きLPC（適応的フィルタバンク）が次世代標準だったりしないかとちょっと思う。&lt;ul&gt;
&lt;li&gt;というか、フィルタバンクの適応やってるんだよな今の研究。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/486471"&gt;Adaptive filtering using filter banks&lt;/a&gt; 完全再構成に突っ込みすぎてて難解かも&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;なんかタンペレ大でロスレス音声の研究をやってた残骸があるな。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://support.hdfgroup.org/doc_resource/SZIP/"&gt;SZIP&lt;/a&gt; 気になる。ライス符号ベースというのがいい印象だし、再帰的Golomb-Riceを見切ってもよさそう。
- &lt;a class="reference external" href="https://oku.edu.mie-u.ac.jp/~okumura/compression.html"&gt;奥村先生&lt;/a&gt; によるとBurrows-Wheeler 変換（ブロック整列法）を使った手法のようだ。つまりブロック整列+Rice符号か。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>戦略会議中2021(14)</title><link href="/zhan-lue-hui-yi-zhong-202114.html" rel="alternate"></link><published>2021-07-11T10:00:00+09:00</published><updated>2021-07-11T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-11:/zhan-lue-hui-yi-zhong-202114.html</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="http://yoksis.bilkent.edu.tr/pdf/files/10.1109-83.869176.pdf"&gt;Adaptive Polyphase Subband Decomposition Structures for Image Compression&lt;/a&gt; を引用している文献を漁る。改善したやつ、音声に適用したやつが出てくるはず。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://web.stanford.edu/~bgirod/pdfs/ChangTransIP2007.pdf"&gt;Direction-Adaptive Discrete Wavelet Transform for Image Compression&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;画 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;a class="reference external" href="http://yoksis.bilkent.edu.tr/pdf/files/10.1109-83.869176.pdf"&gt;Adaptive Polyphase Subband Decomposition Structures for Image Compression&lt;/a&gt; を引用している文献を漁る。改善したやつ、音声に適用したやつが出てくるはず。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://web.stanford.edu/~bgirod/pdfs/ChangTransIP2007.pdf"&gt;Direction-Adaptive Discrete Wavelet Transform for Image Compression&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;画像の方位性に着目したウェーブレットの適応。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdf.sciencedirectassets.com/272379/1-s2.0-S1063520309X00023/1-s2.0-S1063520308000444/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEMz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJGMEQCIFmEkvxq3HJFRXo7Vzj6LjewHyylZw4drd1raiifgOUUAiBttYw%2FFIwbsG35Z3i%2FsekJxbteMdHWCDH%2FunUnWaZAniqDBAi1%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAQaDDA1OTAwMzU0Njg2NSIMFYoJ4DsgIydz%2Fi%2BAKtcDRegAb8fO985CrVG7UPs1Sp6CJb02Y4WGIL%2FPVs3Wr22E0pXt%2BqcBmahKy25H99GaG%2B5zulEfyVWTcZ7iwOBLiC%2FDuOEan4oKITBjXu0FzBO9heJ37kQ1xBNEorE1kkNAukcAFujp8DTSfwEu72m9QH4ApG8XxB1Ss0jmC9dCowZy2yW7ceuVgV24HnrAadz3JfNxq2I18Wsrh3BB7kq3c24pgM8D2H1W3Afrfov%2Fpsc80%2BaNmtnVPlIqVI0RMFOD8aordkvhcQ2DTLrJGkOfbniCDNXEiwWJOZbWzzmCf5QEDQezlzUysfQbylx5yBVL9HENUEWCqfPhzXFZe6qrhYgt3so12QVwIspfA6f02yvG6zbqd8YcSia94D%2Bk7rQaWc%2FGc2wEYtkzUE%2FSdIkcALnpereQu7cBISz4TmtQiSqsvlKVRKxD%2B85fPJ4VQBsEjEgDJ74Sygt232PcaMQl3Ms3ZtsSkOgl7xsgY4iM%2Fhg%2FDhhK2h0hl9VAmDtcj0roV0dlujKozm2DjCqIbmNV%2FsTM%2BKvirpHzfWVOXG7gvmIpcMWWigKnen5XPn3xeAWaZ7Kb%2BRvDaJZpwFEoT%2BXEM0sBFEesKSGtMxUiODQ2cSeaRV1EdU%2FmMKjTqYcGOqYBnusoQIMgtLG88X4hLsBtndo0boqW%2BL5BbfxfgOIDD5VfnhbxBnLjgfYriuLAfObo5UuFBMd3Vkiu%2Fo8iGiXvjqFQVsdiPb9Ujp1QnjpS6I%2Ftn2cSyNNfws56Uh%2Bt%2FHvKxnKae5cxhfrXYkAJI4TCyO9rDYLBc2UcUCjhte%2FkH3hMvER5%2FQhwVUez6azll54gyum8NbOC3es8pgvwU%2FTLiN382Cxq%2FA%3D%3D&amp;amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Date=20210711T042207Z&amp;amp;X-Amz-SignedHeaders=host&amp;amp;X-Amz-Expires=300&amp;amp;X-Amz-Credential=ASIAQ3PHCVTY2YYWOK3U%2F20210711%2Fus-east-1%2Fs3%2Faws4_request&amp;amp;X-Amz-Signature=707f095234c580099e4e7c88d904a9a67f2d5b9e3891f3091a54fc210d0a9c4d&amp;amp;hash=7f97fac7e48d0b9eac518b5a1b683c62e29f7c8035a87c548306821b5d080813&amp;amp;host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&amp;amp;pii=S1063520308000444&amp;amp;tid=spdf-f0ee7752-c063-46e3-8c8f-8c2106a538d1&amp;amp;sid=101f207585c9304d8d3823245aab047baeb5gxrqa&amp;amp;type=client"&gt;Geometrical grouplets&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;勾配ベースで適応する手法は、直交していないし、安定性(stability)がしばしば保証されてないという指摘。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/4106738"&gt;Direction-Adaptive Discrete Wavelet Transform via Directional Lifting and Bandeletization&lt;/a&gt; が源流のようだが、これも得られるウェーブレットが直交してないと指摘。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://repository.bilkent.edu.tr/bitstream/handle/11693/23883/bilkent-research-paper.pdf?sequence=1"&gt;A 2-D Orientation-Adaptive Prediction Filter in Lifting Structures for Image Coding&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;(5,3)を斜め方向（±45°）に対応したフィルタを作った。画像に特化しすぎ？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://d1wqtxts1xzle7.cloudfront.net/50223070/Design_of_Signal-Adapted_Multidimensiona20161109-18656-1ywkqwt.pdf?1478752780=&amp;amp;response-content-disposition=inline%3B+filename%3DDesign_of_signal_adapted_multidimensiona.pdf&amp;amp;Expires=1625981295&amp;amp;Signature=DFFnOGgdFojfMUn-8KzExqu5lYiITRmnkM8iE2g5k3jwxlYud8zIBNfaQA~LnIpVejGnZ2Aw4dNWhPOIfOJiOttOnrsPPATNtSmHZNO3fCCKMTtgpqZvNpYL-Ku09u9TjLryRQNWLIoDTaKpKoYkGu4M-XNS1cNZxWLaHYeNRVR4K9q65~NVh5mHx7qAxMFfRaG6MnNdQvzzabenVAA6OcNoikPI9N3O2rQvq5AL8wMVsTueSu81nn7VPA7~MqNF5DAU6magfBG6ZXdLdEH86z7~drA8NPJwBImSip1NgXctppaHe1Qx811jj7WqwlL5NWFVr8nxWSw9k5K78gk0Qw__&amp;amp;Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA"&gt;Design of signal-adapted multidimensional lifting scheme for lossy coding&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;2乗誤差最小化+直交制約をつけてラグランジュ未定乗数で解く。&lt;/li&gt;
&lt;li&gt;ロッシー向けと言っているが有益そう。&lt;/li&gt;
&lt;li&gt;まだちゃんと読めてない。。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://reader.elsevier.com/reader/sd/pii/S1063520304000879?token=526F3D01C1CE5CF3BF516BFA6E078BB030C91D79A90601D2F8F691F73B6CFC211182591B49A1569D8A889ADF426D4EA4&amp;amp;originRegion=us-east-1&amp;amp;originCreation=20210710051603"&gt;Building nonredundant adaptive wavelets by update lifting&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;適応リフティングを通じてウェーブレットを設計する手段を提案？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://d1wqtxts1xzle7.cloudfront.net/47476681/tgrs.2002.80384520160724-24253-bg93bf.pdf?1469370223=&amp;amp;response-content-disposition=inline%3B+filename%3DVector_lifting_schemes_for_lossless_codi.pdf&amp;amp;Expires=1625981862&amp;amp;Signature=Wf2~T~eUn0EgyqG1vp-yAs2jGZ7xPagLcW94ZVZ5JeH~dyueSybc-6DgDINlopu-oie0HetIftHjuogHECHgcfzpUyEPic5XDWqg43vo2SGSuyfX1dZkFAIua~zDCjUILfnx987eDWcuZL3nHAtJrNDEYkf5HvEUK5WjOhYEFULutT5YY2yIW6kApYkNqZh1bu2BGiVnPoy3AUdLsAzH49QcFz2LKLtJ20ia5g3tVVre~1dMDTywNqSszouL5zqdXOQ4NF9YGovifGd~Grn-LihIAC-60Q~52aBBSmM9LtjgpGmSKULCwMErCZ39E9v6WwTDgDT8CdqPRS3jF1kpXg__&amp;amp;Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA"&gt;Vector-Lifting Schemes for Lossless Coding and Progressive Archival of Multispectral Images&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/profile/Peng-Lang-Shui-2/publication/3481086_Image_denoising_algorithm_via_best_wavelet_packet_base_using_Wiener_cost_function/links/00b495332855a0f174000000/Image-denoising-algorithm-via-best-wavelet-packet-base-using-Wiener-cost-function.pdf"&gt;Image denoising algorithm via best wavelet packet base using Wiener cost function&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Wienerコスト、つまり誤差分散最小化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://imatge.upc.edu/web/sites/default/files/bkp/pub/ICASSP_2004_Sole_Salembier.pdf"&gt;ADAPTIVE DISCRETE GENERALIZED LIFTING FOR LOSSLESS COMPRESSION&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;これも決定写像ベースに見える。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.12.76&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;ADAPTIVE MULTIRESOLUTION DECOMPOSITION: APPLICATION TO LOSSLESS IMAGE COMPRESSION&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;適応的フィルタベースのロスレス静止画圧縮手法。RLSで適応。&lt;/li&gt;
&lt;li&gt;ICASSPなので短い。気になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://repository.bilkent.edu.tr/bitstream/handle/11693/27213/LMS%20based%20adaptive%20prediction%20for%20scalable%20video%20coding.pdf?sequence=1"&gt;LMS BASED ADAPTIVE PREDICTION FOR SCALABLE VIDEO CODING&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;動画の動き補償の文脈で適応フィルタを使用している？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/abstract/document/6825819"&gt;Efficient Least Absolute Deviation Adaptive Wavelet Filter Bank&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;誤差絶対値基準で最小化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://repository.bilkent.edu.tr/bitstream/handle/11693/24897/Lossless%20image%20compression%20by%20LMS%20adaptive%20filter%20banks.pdf?sequence=1"&gt;Lossless image compression by LMS adaptive filter banks&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;短いけど、まさに自分がイメージしていること。適応フィルタ学習によるロスレス圧縮。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;音声への適用が見つからないのはどういうこと？確かに2013ICASSPでもウェーブレットパケットで満足してたから少ないのはうなずけるけど不穏かも。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>戦略会議中2021(13)</title><link href="/zhan-lue-hui-yi-zhong-202113.html" rel="alternate"></link><published>2021-07-10T10:00:00+09:00</published><updated>2021-07-10T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-10:/zhan-lue-hui-yi-zhong-202113.html</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jsiamt/28/2/28_72/_pdf"&gt;リフティングスキームによるウェーブレットの構成法&lt;/a&gt; の6.2節で挙げられた論文を見やる。良さそうなものは読む …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jsiamt/28/2/28_72/_pdf"&gt;リフティングスキームによるウェーブレットの構成法&lt;/a&gt; の6.2節で挙げられた論文を見やる。良さそうなものは読む。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/892438"&gt;Lossless Image Compression Based on Optimal Prediction, Adaptive Lifting, and Conditional Arithmetic Coding&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;一般のn次元でのリフティング構成を提案。算術符号を使った画像ロスレス圧縮で高い圧縮率。算術符号は強すぎでは？JPEG2000-LSってライス符号だったような。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://yoksis.bilkent.edu.tr/pdf/files/10.1109-83.869176.pdf"&gt;Adaptive Polyphase Subband Decomposition Structures for Image Compression&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;適応フィルタっぽくやってるな。よく見よう。&lt;/li&gt;
&lt;li&gt;その通りで、リフティングの予測フィルタを誤差に応じて学習するというもの。&lt;ul&gt;
&lt;li&gt;NLMSで、誤差の大きさに応じてスケールサイズを変える方策をとっていた。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;誰でも思いつくやり方だよなあ、、性能は良いとのこと。試してみる？&lt;ul&gt;
&lt;li&gt;NGSAを突っ込めそうに思える。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://repository.bilkent.edu.tr/bitstream/handle/11693/25983/Adaptive%20Filtering%20for%20Non-Gaussian%20Stable%20Processes.pdf?sequence=1&amp;amp;isAllowed=y"&gt;Adaptive Filtering for Non-Gaussian Stable Processes&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;本文に出てちょっと気になったので。非ガウスな雑音での適応。誤差Lpノルム最小化の話になる。&lt;/li&gt;
&lt;li&gt;p=1でしかFisher計量が簡易にならないことを再度確認。特に新しいことなし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/1355939"&gt;Design of signal-adapted multidimensional lifting scheme for lossy coding&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;ロッシーと言ってるけどロスレスに活かせる可能性がある。&lt;/li&gt;
&lt;li&gt;Wienerフィルタの要領で、最小二乗誤差（分散）基準で係数の最小化をしている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/5430944"&gt;Adaptive 2-D Wavelet Transform Based on the Lifting Scheme With Preserved Vanishing Moments&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;消失モーメントを保つように適応。（普通に適応すると消失モーメントが無くなるらしい）デノイジングでいい結果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.worldscientific.com/doi/abs/10.1142/S0219691306001087"&gt;ADAPTIVE WAVELETS FOR IMAGE COMPRESSION USING UPDATE LIFTING: QUANTIZATION AND ERROR ANALYSIS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;内容は読めず。&lt;/li&gt;
&lt;li&gt;適応リフティングによる量子誤差を評価&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1011203"&gt;Adaptive Lifting Schemes With Perfect Reconstruction&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;完全再構成となるような適応リフティング手法の提案。これは重要そう。&lt;/li&gt;
&lt;li&gt;リフティングによって（モルフォロジーなどの）非線形処理もできるようになったけど、局所な特徴はとらえられてないよね、という問題意識。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.di.ens.fr/~mallat/papiers/WaveletTourChap1-2-3.pdf"&gt;A Wavelet Tour of Signal Processing&lt;/a&gt; Mallatさん。ブロック単位で最適な係数を計算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上から2番目の論文とはアプローチが違うとのこと&lt;/li&gt;
&lt;li&gt;スプリットした後の入力を元に決定写像（decision map）を決めて適応する&lt;ul&gt;
&lt;li&gt;この決定が完全再構成となる条件を導いている&lt;/li&gt;
&lt;li&gt;うーん、筋が悪い気がしてならない。写像設計が難しい印象を受けるし、事実論文では簡易な結果しか見せられてない。そして作った写像の評価も難しそうな印象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/1043871"&gt;Adaptive update lifting with a decision rule based on derivative filters&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;上の論文の拡張。決定写像を拡張している。あんまりちゃんと読んでない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>戦略会議中2021(12)</title><link href="/zhan-lue-hui-yi-zhong-202112.html" rel="alternate"></link><published>2021-07-09T10:00:00+09:00</published><updated>2021-07-09T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-09:/zhan-lue-hui-yi-zhong-202112.html</id><summary type="html">&lt;p&gt;7月上旬、macのバッテリーがもうヘタれてしまったのでバッテリーを取り替えてもらった。
1週間後には修理が終わ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;7月上旬、macのバッテリーがもうヘタれてしまったのでバッテリーを取り替えてもらった。
1週間後には修理が終わったが、受け取った次の日にkernel_taskが暴走・・・再度修理に出して2週間。
8月3日にようやく落ち着いたとのことで受け取る。&lt;/p&gt;
&lt;p&gt;それまでのメモは全てWローカルに残していたので、こちらに移していく。今日はメモ以降で終わるかな。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Learning optimal wavelet bases using a natural network approach を読んだ。&lt;ul&gt;
&lt;li&gt;直行条件は制約条件として入ってきて、それを最適化するように学習する&lt;/li&gt;
&lt;li&gt;でもそれは学習の途中では完全に直交していない状態を経由することになる（筆者も論文中でsub-orthogonalと言ってた）&lt;/li&gt;
&lt;li&gt;ラグランジュ未定乗数法で閉形式で解ければ格好いいが、係数による偏微分が係数の和を含むので閉形式に持っていくのが難しい。&lt;ul&gt;
&lt;li&gt;相互最適化、というかEMアルゴリズムのように、係数を損失最小化するように更新→制約を満たすように更新→損失最小化→…でやれないか？少し考えたけどピントこない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ウェーブレットを学習する方策は筋が悪いように思える。近似解になってしまうのがどうも納得いかない。ロッシーならともかく、再構成が絶対要件になるロスレスと相性が悪い。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前から思っていたけど、適応的リフティングに舵を切る。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ipsj.ixsq.nii.ac.jp/ej/?action=repository_action_common_download&amp;amp;item_id=111421&amp;amp;item_no=1&amp;amp;attribute_id=1&amp;amp;file_no=1"&gt;個人の音声特徴を適応的に抽出するリフティングウェーブレットフィルタの設計&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;ほしい周波数特性を持つリフティングウェーブレットフィルタを評価関数ベースで作成。&lt;/li&gt;
&lt;li&gt;どうやって評価関数を最小化するかはなぞ。&lt;/li&gt;
&lt;li&gt;リフティングの解説見てると、自由パラメータがあってそれを調節することで適応を実現しているな。そんなのあったっけ。リフティングに立ち戻る。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.iadisportal.org/digital-library/speaker-identification-system-using-lifting-wavelet-filters"&gt;SPEAKER IDENTIFICATION SYSTEM USING LIFTING WAVELET FILTERS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;話者識別の文脈&lt;/li&gt;
&lt;li&gt;GMMでフィッティングしている？未知入力に対してGAを使ってGMMのパラメータを推定し、話者識別を行う。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cm-bell-labs.github.io/who/wim/papers/lift2.pdf"&gt;THE LIFTING SCHEME: A CONSTRUCTION OF SECOND GENERATION WAVELETS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;リフティングの原論文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jsiamt/28/2/28_72/_pdf"&gt;リフティングスキームによるウェーブレットの構成法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;何回目かわからんが挙げとく。&lt;/li&gt;
&lt;li&gt;6.2節で適応的リフティングの文献を挙げている。これは舐めよう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>戦略会議中2021(11)</title><link href="/zhan-lue-hui-yi-zhong-202111.html" rel="alternate"></link><published>2021-07-06T10:00:00+09:00</published><updated>2021-07-06T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-06:/zhan-lue-hui-yi-zhong-202111.html</id><summary type="html">&lt;p&gt;ウェーブレット係数の適応について考えている。
昨日見たwavenetは制約もコスト関数に入れて逐次最適化により係数を …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ウェーブレット係数の適応について考えている。
昨日見たwavenetは制約もコスト関数に入れて逐次最適化により係数を求めている。が、もっとうまくやれないか？制約付き最適化問題として、未定乗数法に突っ込めないか考えている。&lt;/p&gt;
&lt;p&gt;考えるより手を動かしてできるかどうか見るのが良いかも。wavenetが2018年と考えるとあんまり考えている人がいなそう。
単純な、1層だけの（パーセプトロン）ウェーブレットを係数で微分してみてどうなる？&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>戦略会議中2021(10)</title><link href="/zhan-lue-hui-yi-zhong-202110.html" rel="alternate"></link><published>2021-07-05T10:00:00+09:00</published><updated>2021-07-05T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-05:/zhan-lue-hui-yi-zhong-202110.html</id><summary type="html">&lt;p&gt;Adaptive liftingについて見る。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.76.1481&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;ADAPTIVE WAVELET TRANSFORMS VIA LIFTING&lt;/a&gt; 1999年。&lt;ul&gt;
&lt;li&gt;軽く読んだ。短くてあんまり詳細はつかめてないが。2通りの適応手法を紹介。&lt;ul&gt;
&lt;li&gt;スケ …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Adaptive liftingについて見る。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.76.1481&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;ADAPTIVE WAVELET TRANSFORMS VIA LIFTING&lt;/a&gt; 1999年。&lt;ul&gt;
&lt;li&gt;軽く読んだ。短くてあんまり詳細はつかめてないが。2通りの適応手法を紹介。&lt;ul&gt;
&lt;li&gt;スケール適応: （スケーリング係数が満たすべき制約(6式)のもとで）予測誤差最小化でフィルタを構築しているだけに見える。そんな単純だったかな…&lt;ul&gt;
&lt;li&gt;ラグランジェ未定乗数法で解けないかね？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;スペース適応: 1サンプルごとに更新する手法。詳細がまったくない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ドベシィ8, Haarと比べて同等かちょっと優れた結果（エントロピー尺度で）&lt;/li&gt;
&lt;li&gt;引用してる文献を更に見るべきかも。具体的な更新が見えてこない&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://drum.lib.umd.edu/bitstream/handle/1903/5588/TR_94-3.pdf;jsessionid=745E02179D775527EE4DF35D420BA176?sequence=1"&gt;On the optimal choice of a wavelet for signal representation&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;これはウェーブレット係数勾配を計算してエントロピー最小化の意味で最小化していそう。読む。&lt;/li&gt;
&lt;li&gt;まさにやりたいことで感動した。&lt;/li&gt;
&lt;li&gt;エントロピー尺度最小の基底を探す…って言ってるけど、これ指数型分布のなかで最小のポテンシャルを持つ基底（座標変換）を探しているのと同じでは…。&lt;/li&gt;
&lt;li&gt;信号fを固定し、基底をウェーブレット（スケーリング）関数にとって変換して、エントロピー尺度で最小化を行う。&lt;/li&gt;
&lt;li&gt;実験結果がない。続く論文を見たい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/547754"&gt;Constructing optimal wavelet basis for image compression&lt;/a&gt; 上記理論の画像に対する実験結果。&lt;ul&gt;
&lt;li&gt;上手くいってドベシィ4よりは良い圧縮率（+エントロピー）を達成している&lt;/li&gt;
&lt;li&gt;制限としては局所最適に止まりやすいことが指摘されてた。局所最適でもまあ良い（acceptableな）結果だったとのこと。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1706.03041.pdf"&gt;Learning optimal wavelet bases using a neural network approach&lt;/a&gt; MRAをDCNNと捉えて学習する手法。わかる。&lt;ul&gt;
&lt;li&gt;ウェーブレットをまとめているときに、ストライドつきコンボリューションと言いたのがすべてここにかかっている。&lt;/li&gt;
&lt;li&gt;重要な気がしてきた。ちゃんと読む。&lt;/li&gt;
&lt;li&gt;制約を保ったまま学習しているだけに見える。本当にうまくいくかなあ。実装見てみるか&lt;/li&gt;
&lt;li&gt;実装:&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/asogaard/Wavenet"&gt;https://github.com/asogaard/Wavenet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/asogaard/wavenet-pytorch"&gt;https://github.com/asogaard/wavenet-pytorch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/abstract/document/887001"&gt;Algorithms for Designing Wavelets to Match a Specified Signal&lt;/a&gt; まだ読めてないが、スペクトラムベースでマッチングしてる。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>戦略会議中2021(9)</title><link href="/zhan-lue-hui-yi-zhong-20219.html" rel="alternate"></link><published>2021-07-04T10:00:00+09:00</published><updated>2021-07-04T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-04:/zhan-lue-hui-yi-zhong-20219.html</id><summary type="html">&lt;p&gt;論文をざっと読んだ。まだ腰を落ち着けるべきではなさそう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/558477"&gt;Wavelet Transform Domain Adaptive FIR Filtering&lt;/a&gt; 「ウェーブレット変換とその応用」で触れら …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;論文をざっと読んだ。まだ腰を落ち着けるべきではなさそう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/558477"&gt;Wavelet Transform Domain Adaptive FIR Filtering&lt;/a&gt; 「ウェーブレット変換とその応用」で触れられていたもう一つの論文。&lt;ul&gt;
&lt;li&gt;ウェーブレット変換域でLMS/Newtonを使う。うまいことコレスキー分解して、スパース推定を使って計算効率化を図る。&lt;/li&gt;
&lt;li&gt;当然単純な変換域でのLMSよりは性能が良い。&lt;/li&gt;
&lt;li&gt;変換域で自己相関行列を見ており、しかもその逆はスパースであると言っている。&lt;/li&gt;
&lt;li&gt;自分の発想を突っ込めそうに思える。が、変換域でAR過程になるのだろうか？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/258086"&gt;Low Bit Rate Transparent Audio Compression using Adapted Wavelets&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;最大消失モーメントを持つウェーブレットはタップ数に応じて有限個しか無い（ドベシィ。例えばタップ数40なら最大で20次までのモーメントを消せるが、そのウェーブレットの組み合わせは1024通りしか無いとのこと。10bitで送れる。）より、その中から適切なウェーブレットを適応的に選ぶ&lt;ul&gt;
&lt;li&gt;この事実は気になる。ウェーブレット10講に書いてあるかな。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;選択尺度は等誤差面の議論から割と自然に出てくる。しかしその選択は総当りっぽい。デコード負荷は低いから許されるか…&lt;/li&gt;
&lt;li&gt;ほかにも、LPCは人間の声道管モデルベースだから音楽などでの無声音（ピッチがない音）は厳しいという指摘があった。確かに。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.seas.ucla.edu/spapl/codecs/G722tut.pdf"&gt;G.722: a new CCITT coding standard for digital transmission of wideband audio signals&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;QMF(20タップ)で高域と低域に分け、それぞれの帯域でG.711のADPCMを使う。高域は低いビットを割り当てる。&lt;/li&gt;
&lt;li&gt;G721.などと比べ音質がよくなったことを報告しとる。そうだよなあという感じ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;予め用意してあるウェーブレットから選ぶというのはどうなんだろう…個人的には適応的リフィティングを検討してみたい。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category></entry><entry><title>戦略会議中2021(8)</title><link href="/zhan-lue-hui-yi-zhong-20218.html" rel="alternate"></link><published>2021-07-03T10:00:00+09:00</published><updated>2021-07-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-03:/zhan-lue-hui-yi-zhong-20218.html</id><summary type="html">&lt;p&gt;昨日見た下記3論文を読んで、展望を考えたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/558477"&gt;Wavelet Transform Domain Adaptive FIR Filtering&lt;/a&gt; 「ウェーブレット変換とその応用」で触れられていたもう …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;昨日見た下記3論文を読んで、展望を考えたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/558477"&gt;Wavelet Transform Domain Adaptive FIR Filtering&lt;/a&gt; 「ウェーブレット変換とその応用」で触れられていたもう一つの論文。&lt;ul&gt;
&lt;li&gt;かるく見たけど、…ん？まじで変換域で適応フィルタしてるだけ？自己相関の逆かけて白色化するのはたしかに大事だけど、これでいいのか？&lt;/li&gt;
&lt;li&gt;不思議なのは、自己回帰過程を考えていてその自己相関行列も計算しているが、逆の計算を考えていない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/258086"&gt;Low Bit Rate Transparent Audio Compression using Adapted Wavelets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.seas.ucla.edu/spapl/codecs/G722tut.pdf"&gt;G.722: a new CCITT coding standard for digital transmission of wideband audio signals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category></entry><entry><title>戦略会議中2021(7)</title><link href="/zhan-lue-hui-yi-zhong-20217.html" rel="alternate"></link><published>2021-07-02T10:00:00+09:00</published><updated>2021-07-02T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-07-02:/zhan-lue-hui-yi-zhong-20217.html</id><summary type="html">&lt;p&gt;改めて音声符号化にウェーブレットを使うことの是非を見る意図で、「ウェーブレットとサブバンド符号化」をつまん …&lt;/p&gt;</summary><content type="html">&lt;p&gt;改めて音声符号化にウェーブレットを使うことの是非を見る意図で、「ウェーブレットとサブバンド符号化」をつまんでいる。
概要を述べているだけなので厳しい。見つかった文献を漁る。高音質と中音質に分けていたので分類に従って列挙。&lt;/p&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;高音質&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.aes.org/e-lib/online/browse.cfm?elib=6768"&gt;High-Quality, Low-Rate Audio Transform Coding for Transmission and Multimedia Applications&lt;/a&gt; AES会員でないと読めないっぽい。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/151054"&gt;A MUSICAM source codec for digital audio broadcasting and storage&lt;/a&gt; MPEG-Iの基礎になっている考え方。フィルタバンクを使用。知覚符号化そのものか？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/225993"&gt;Sum-difference stereo transform coding&lt;/a&gt; これもフィルタバンク+量子化の流れ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/258086"&gt;Low Bit Rate Transparent Audio Compression using Adapted Wavelets&lt;/a&gt; 適応的（辞書的）にウェーブレットを選んで冗長性を減らす。ウェーブレットパケットの構成も動的に決めている？これってICASSPのやつと同等に見える。腰を入れて読むべきかも。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/117212"&gt;High quality audio bit-rate reduction system family for different applications&lt;/a&gt; MUSICAMの解説論文。より概要に寄った感じ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.mp3-tech.org/programmer/docs/ac3-flex.pdf"&gt;AC-3: Flexible Perceptual Coding for Audio Transmission and Storage&lt;/a&gt; ドルビーが提案しているっぽいコーデック。フィルタバンク+知覚符号化。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/publication/234825071_Acoustic_Signal_Compression_with_Wavelet_Packets"&gt;Acoustic Signal Compression with Wavelet Packets&lt;/a&gt; コスト関数の最適化に基づいてウェーブレット基底を選択する手法。ちゃんと読めず。そういえばリフィティング使ってないけど、リフィティングが現れる前の話？&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;中音質&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/6769805"&gt;Digital Coding of Speech in Sub-bands&lt;/a&gt; ノキアベルラボの人。だいぶクラシカルだけど、基本が詰まっている。小さめのサブバンドに分割して符号化。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/1170341"&gt;Application of quadrature mirror filters to split band voice coding schemes&lt;/a&gt; これもフィルタバンク(QMF)で分割して、フィルタ出力を量子化して送るというもの。単純極まるけど基本的でわかりやすい。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=1170894"&gt;16kbps Real time QMF sub-band coding implementation&lt;/a&gt; これもQMF+線形量子化。自分も試してみるか？問題点はQMFの設計だけに思える。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.seas.ucla.edu/spapl/codecs/G722tut.pdf"&gt;G.722: a new CCITT coding standard for digital transmission of wideband audio signals&lt;/a&gt; QMF出力に対して、低域と高域でそれぞれADPCM。これは素晴らしい。ピンときたし、ウェーブレット変換領域での適応フィルタに一致していると思う。これも読みたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category></entry><entry><title>戦略会議中2021(6)</title><link href="/zhan-lue-hui-yi-zhong-20216.html" rel="alternate"></link><published>2021-06-28T10:00:00+09:00</published><updated>2021-06-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-06-28:/zhan-lue-hui-yi-zhong-20216.html</id><summary type="html">&lt;p&gt;4月からここまでだいたい論文執筆やら発表準備、ゼミ輪講で潰れていた。
GWはウェーブレット理解のために合宿。高 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;4月からここまでだいたい論文執筆やら発表準備、ゼミ輪講で潰れていた。
GWはウェーブレット理解のために合宿。高速ウェーブレット変換まではOKということで資料公開。
論文発表の準備がようやく落ち着いてきた。7月からは調査に再度着手したい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/558477"&gt;Wavelet Transform Domain Adaptive FIR Filtering&lt;/a&gt; 「ウェーブレット変換とその応用」で触れられていたもう一つの論文。&lt;ul&gt;
&lt;li&gt;これから再度スタートする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://yukara-13.hatenablog.com/entry/2013/12/01/222742"&gt;【Python】 Constant-Q 変換 (対数周波数スペクトログラム)&lt;/a&gt; 定Q変換について。周波数に応じて窓幅を変えて解析する。それってウェーブレットの問題意識と全く同じ。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category></entry><entry><title>リバーブ開発</title><link href="/ribabukai-fa.html" rel="alternate"></link><published>2021-06-18T12:00:00+09:00</published><updated>2021-06-18T22:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-06-18:/ribabukai-fa.html</id><summary type="html">&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kurims.kyoto-u.ac.jp/~ooura/fftman/index.html"&gt;FFT (高速フーリエ・コサイン・サイン変換) の概略と設計法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;文字化けしてるのでEUCで読むべし&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kurims.kyoto-u.ac.jp/~ooura/fftman/fft_note_s.pdf"&gt;pdf資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kurims.kyoto-u.ac.jp/~ooura/fftman/ftmn2_1.html#sec2_1"&gt;実離散Fourier変換&lt;/a&gt; 複 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kurims.kyoto-u.ac.jp/~ooura/fftman/index.html"&gt;FFT (高速フーリエ・コサイン・サイン変換) の概略と設計法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;文字化けしてるのでEUCで読むべし&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kurims.kyoto-u.ac.jp/~ooura/fftman/fft_note_s.pdf"&gt;pdf資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kurims.kyoto-u.ac.jp/~ooura/fftman/ftmn2_1.html#sec2_1"&gt;実離散Fourier変換&lt;/a&gt; 複素部を0埋めするのはもったいない視点に立ち、複素FFTを用いて効率的に計算する&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kurims.kyoto-u.ac.jp/~ooura/fftman/ftmn2_12.html"&gt;実離散Fourier変換の実装例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Numerical recipies in Cのrealftと同じだ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://wwwa.pikara.ne.jp/okojisan/stockham/stockham3.html#stockham4"&gt;４基底の Stockham FFT&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Stockham FFTはビットリバース不要なFFT&lt;/li&gt;
&lt;li&gt;普通のFFTは分解を2サンプル単位でやるが、こちらは4サンプル単位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;統合すると、realft方式で行きたい。そして基板部のFFTは4基底のStockhamFFTで。&lt;/p&gt;
</content><category term="趣味"></category><category term="リバーブ"></category><category term="エフェクター"></category></entry><entry><title>戦略会議中2021(5)</title><link href="/zhan-lue-hui-yi-zhong-20215.html" rel="alternate"></link><published>2021-04-15T10:00:00+09:00</published><updated>2021-04-15T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-04-15:/zhan-lue-hui-yi-zhong-20215.html</id><summary type="html">&lt;p&gt;紹介を進め、ウェーブレットの適用について考え始めている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/558477"&gt;Wavelet Transform Domain Adaptive FIR Filtering&lt;/a&gt; 「ウェーブレット変換とその応用」で触れら …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;紹介を進め、ウェーブレットの適用について考え始めている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/document/558477"&gt;Wavelet Transform Domain Adaptive FIR Filtering&lt;/a&gt; 「ウェーブレット変換とその応用」で触れられていたもう一つの論文。&lt;ul&gt;
&lt;li&gt;こっちも古いので、もっと新しい論文を見て考えたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category></entry><entry><title>戦略会議中2021(4)</title><link href="/zhan-lue-hui-yi-zhong-20214.html" rel="alternate"></link><published>2021-04-14T10:00:00+09:00</published><updated>2021-04-14T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-04-14:/zhan-lue-hui-yi-zhong-20214.html</id><summary type="html">&lt;p&gt;紹介を進め、ウェーブレットの適用について考え始めている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/abstract/document/536674?casa_token=fIVBeh0AOcIAAAAA:Q_3gyG3siw1wY-Eqm9y7B1IVmAQEG8EJ0sExiLhSlmGR2iA4260KPX-BApaRWjfyyXNrgDzN39w"&gt;Wavelet Transform Based Adaptive Filters: Analvsis and New Results&lt;/a&gt; 「ウェーブレット変換とその応用」で …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;紹介を進め、ウェーブレットの適用について考え始めている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ieeexplore.ieee.org/abstract/document/536674?casa_token=fIVBeh0AOcIAAAAA:Q_3gyG3siw1wY-Eqm9y7B1IVmAQEG8EJ0sExiLhSlmGR2iA4260KPX-BApaRWjfyyXNrgDzN39w"&gt;Wavelet Transform Based Adaptive Filters: Analvsis and New Results&lt;/a&gt; 「ウェーブレット変換とその応用」で触れられていたウェーブレット変換してから適用フィルタをかませる論文。&lt;ul&gt;
&lt;li&gt;ざっと読んでみた。入力信号とウェーブレット関数の内積でウェーブレット領域に飛ばして、その領域での係数を適応学習するというもの。定常的な信号ではDFT領域に飛ばして適応するアルゴリズムには敵わなかったが、インパルーシブな信号に対しては、（ドベシィウェーブレットで）速い収束性能を示していた。また、理論的に条件数が向上することが示され、普通のLMSよりも収束が速いことが分かっている。紙に印刷したい。&lt;/li&gt;
&lt;li&gt;ウェーブレット関数の自己相関行列のようなものが出てきている。すげえ気になる。&lt;/li&gt;
&lt;li&gt;SAのように、ラプラス分布仮定を入れるとどうなるか試してみたい。&lt;/li&gt;
&lt;li&gt;他のウェーブレットはどうか？も気になる。&lt;/li&gt;
&lt;li&gt;古いので、もっと新しい論文を見て考えたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category><category term="Wavelet"></category></entry><entry><title>戦略会議中2021(3)</title><link href="/zhan-lue-hui-yi-zhong-20213.html" rel="alternate"></link><published>2021-04-11T10:00:00+09:00</published><updated>2021-04-11T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-04-11:/zhan-lue-hui-yi-zhong-20213.html</id><summary type="html">&lt;p&gt;紹介をほぼ進めた。背景理論をどこまで書くか考える。
また、NARUの警告つぶしをした。ほぼこれで固まるかな。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www5d.biglobe.ne.jp/~noocyte/Programming/CMacros.html"&gt;C/C++ 関数・ …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;紹介をほぼ進めた。背景理論をどこまで書くか考える。
また、NARUの警告つぶしをした。ほぼこれで固まるかな。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www5d.biglobe.ne.jp/~noocyte/Programming/CMacros.html"&gt;C/C++ 関数・マクロ集 ((ほぼ？) 処理系・OS 非依存)&lt;/a&gt; Cマクロ集（いつか使える）&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://cppemb.blog17.fc2.com/blog-entry-21.html"&gt;境界調整（アラインメント）を調べる&lt;/a&gt; alignofの可搬性のある実装。どこかで刺さるはず。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://git.sr.ht/~rabbits/uxn/tree/master/item/src/uxn.c"&gt;~rabbits/uxn&lt;/a&gt; 200行以内の8bit(16bitもっぽい)スタックマシン実装。本質が全て詰まっている。解説本あったら買う。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ethw.org/History_of_Lossless_Data_Compression_Algorithms"&gt;History of Lossless Data Compression Algorithms&lt;/a&gt; ロスレスデータ圧縮アルゴリズムの歴史と特許批判&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://android.googlesource.com/platform/external/libldac/"&gt;libldac&lt;/a&gt; ソニーの高音質ロッシーコーデックLDACのソース。オープンソース化している。DCTベースのようだが詳細不明。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>戦略会議中2021(2)</title><link href="/zhan-lue-hui-yi-zhong-20212.html" rel="alternate"></link><published>2021-04-08T10:00:00+09:00</published><updated>2021-04-08T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-04-08:/zhan-lue-hui-yi-zhong-20212.html</id><content type="html">&lt;p&gt;研究紹介を進めながら、今年一年をどうするか考えつつある。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://elvera.nue.tu-berlin.de/files/0843Purat1997.pdf"&gt;Lossless Transform Coding of Audio Signals&lt;/a&gt; LTACの理論解説論文&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>戦略会議中2021(1)</title><link href="/zhan-lue-hui-yi-zhong-20211.html" rel="alternate"></link><published>2021-04-07T10:00:00+09:00</published><updated>2021-04-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-04-07:/zhan-lue-hui-yi-zhong-20211.html</id><summary type="html">&lt;p&gt;今年一年をどう過ごすか決めつつある。今年はウェーブレットを攻める。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.oreilly.co.jp/BOOK/osp/OpenSource_Web_Version/Web_version000106.html"&gt;オープンソースソフトウェア 彼らはいかに …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;今年一年をどう過ごすか決めつつある。今年はウェーブレットを攻める。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.oreilly.co.jp/BOOK/osp/OpenSource_Web_Version/Web_version000106.html"&gt;オープンソースソフトウェア 彼らはいかにしてビジネススタンダードになったのか&lt;/a&gt; OSSの偉人たちのコメントがただで見れる。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(32)</title><link href="/kodetsukuzuo-ri2021chun-32.html" rel="alternate"></link><published>2021-04-01T10:00:00+09:00</published><updated>2021-04-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-04-01:/kodetsukuzuo-ri2021chun-32.html</id><summary type="html">&lt;p&gt;.editorconfigのチェックを追加。github actionsに追加。便利で宜しい。&lt;/p&gt;
&lt;p&gt;つかの間の休息。今日はmsbuild対応と、playerビルド時にpulseaudioを導入したい（sudo apt-getで …&lt;/p&gt;</summary><content type="html">&lt;p&gt;.editorconfigのチェックを追加。github actionsに追加。便利で宜しい。&lt;/p&gt;
&lt;p&gt;つかの間の休息。今日はmsbuild対応と、playerビルド時にpulseaudioを導入したい（sudo apt-getでいいらしい）。また、gtestをWindowsで動かすには…？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://zenn.dev/shimat/articles/d9ed0345c9866e"&gt;GitHub ActionsでMSBuildによるビルドを行う&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ライブラリの整理もしたい。。。ライブラリを細く切りすぎてる感じがある。→オブジェクトファイルのみを取るやり方があった。全てを1つのライブラリにまとめられた。勝利。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(31)</title><link href="/kodetsukuzuo-ri2021chun-31.html" rel="alternate"></link><published>2021-03-31T10:00:00+09:00</published><updated>2021-03-31T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-31:/kodetsukuzuo-ri2021chun-31.html</id><summary type="html">&lt;p&gt;editorconfigに怒られてるが、インデント調整を手でやるのがめんどい。vimでうまくやれないか（プラグイン無しで）調べていたら …&lt;/p&gt;</summary><content type="html">&lt;p&gt;editorconfigに怒られてるが、インデント調整を手でやるのがめんどい。vimでうまくやれないか（プラグイン無しで）調べていたら、tabstop=4として、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vim -c &lt;span class="s1"&gt;&amp;#39;normal! gg=G&amp;#39;&lt;/span&gt; -c &lt;span class="s1"&gt;&amp;#39;:wq&amp;#39;&lt;/span&gt; CMakeLists.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;で行けることが分かった。-cはvim起動時にコマンドを実行するコマンド。'normal'はノーマルコマンドをぶち込む。gg=Gでファイル全体をインデント。':wq'で保存して終了。&lt;/p&gt;
&lt;p&gt;vimのインデントの挙動もすこし辛かったのでいじった。 &lt;a class="reference external" href="https://vim-jp.org/vimdoc-ja/indent.html#cino-E"&gt;ここ&lt;/a&gt; 参照。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(30)</title><link href="/kodetsukuzuo-ri2021chun-30.html" rel="alternate"></link><published>2021-03-30T10:00:00+09:00</published><updated>2021-03-30T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-30:/kodetsukuzuo-ri2021chun-30.html</id><summary type="html">&lt;p&gt;このスキにプロセッサをワーク領域対応させるか。やった。作業なので特に工夫はない。ワークサイズがどこかで重要 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;このスキにプロセッサをワーク領域対応させるか。やった。作業なので特に工夫はない。ワークサイズがどこかで重要になるかも。&lt;/p&gt;
&lt;p&gt;整理として &lt;cite&gt;.editorconfig&lt;/cite&gt; 設定して &lt;cite&gt;editorconfig-checker&lt;/cite&gt; かけたらボロボロであることが分かった。修正しなきゃ。でも論文返ってきた。直す。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.gfd-dennou.org/arch/hiroki/homepage-old/main027.html"&gt;科学英語論文における時制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;のんびりしてたらBNN(Binarised Newral Network)を予測モデルに使うのが良さそうというのが去来した。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(29)</title><link href="/kodetsukuzuo-ri2021chun-29.html" rel="alternate"></link><published>2021-03-29T10:00:00+09:00</published><updated>2021-03-29T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-29:/kodetsukuzuo-ri2021chun-29.html</id><summary type="html">&lt;p&gt;プレーヤー作成中、ブロックデコード関数を公開したけど、仕様の厳しさを感じている。末端でブロックサンプル数が …&lt;/p&gt;</summary><content type="html">&lt;p&gt;プレーヤー作成中、ブロックデコード関数を公開したけど、仕様の厳しさを感じている。末端でブロックサンプル数が少なくなったときの処理が難しい。&lt;/p&gt;
&lt;p&gt;ブロックヘッダにサンプル数を記録すべきでは無いかと考えている。そしてヘッダのブロックあたりサンプル数は最大ブロックサンプル数に変更。そうしないと現在のブロックをデコードするときに何サンプルデコードすべきかわからなくなる。末端までサンプル数固定にするのもありだけど、無音が挿入されるのが汚い。&lt;/p&gt;
&lt;p&gt;論文についての返事がないので実装を進めた。ブロックヘッダにサンプル数を入れた。&lt;/p&gt;
&lt;p&gt;単純再生サンプル作った。この春できるのはここらへんまでかな。参考にしたリンクは以下。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gist.github.com/andormade/1360885/6b239efc7bc59a7dd038b9543b98bdd6afd40559"&gt;Audio Queue example&lt;/a&gt; CoreAudio出力の参考に。&lt;/li&gt;
&lt;li&gt;WASAPIが一番大変だった&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gist.github.com/kevinmoran/3d05e190fb4e7f27c1043a3ba321cede"&gt;WASAPI Play .wav File.cpp&lt;/a&gt; わかりやすかったがWAVEFORMATEXを0クリアしてなくてCbsizeが未初期化クラッシュ。ドハマリ&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://charatsoft.sakura.ne.jp/develop/toaru2/index.php?did=7"&gt;WASAPIをプログラムしてみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ameblo.jp/shuz096/entry-10916035039.html"&gt;WASAPIによる音声再生&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://achurch.org/SIL/current/src/sysdep/windows/sound-wasapi.c"&gt;System Interface Library for games&lt;/a&gt; ピュアCでやろうとするとGUIDが取れない。自力でGUIDを定義しているのがこれ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://0pointer.de/lennart/projects/pulseaudio/doxygen/pacat-simple_8c-example.html"&gt;pacat-simple.c&lt;/a&gt; pulseaudio出力の参考に。pa_simpleで十分だった。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;データフォーマット&lt;/h2&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3&gt;ヘッダフォーマット&lt;/h3&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;bit幅&lt;/th&gt;
&lt;th class="head"&gt;内容&lt;/th&gt;
&lt;th class="head"&gt;補足&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;&lt;cite&gt;'N', 'A', 'R', 'U'&lt;/cite&gt;&lt;/td&gt;
&lt;td&gt;NARUファイルであることを示すシグネチャ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;フォーマットバージョン番号&lt;/td&gt;
&lt;td&gt;エンコードしたときのフォーマットバージョン&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;エンコーダバージョン番号&lt;/td&gt;
&lt;td&gt;エンコードしたときのエンコーダバージョン&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;チャンネル数&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;サンプル数&lt;/td&gt;
&lt;td&gt;1チャンネルあたりの全サンプル数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;サンプリングレート&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;サンプルあたりビット数&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;ブロックあたりサンプル数&lt;/td&gt;
&lt;td&gt;現状固定の想定。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;フィルタ次数N&lt;/td&gt;
&lt;td&gt;2の冪定数に限定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;AR(p) モデルの次数p&lt;/td&gt;
&lt;td&gt;N &amp;gt; 2*p を満たさなければならない&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;チャンネル毎の処理法&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3&gt;ブロックフォーマット&lt;/h3&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;col width="33%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;bit幅&lt;/th&gt;
&lt;th class="head"&gt;内容&lt;/th&gt;
&lt;th class="head"&gt;補足&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;&lt;cite&gt;'0xFFFF'&lt;/cite&gt;&lt;/td&gt;
&lt;td&gt;ブロック先頭を示す同期コード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;ブロックサイズ&lt;/td&gt;
&lt;td&gt;この領域以降のブロックのサイズ[byte]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;CRC16&lt;/td&gt;
&lt;td&gt;この領域以降のブロックのCRC16値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;ブロックデータタイプ&lt;/td&gt;
&lt;td&gt;0:残差、1:無音（ランレングス符号化）、2:生データ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;チャンネルあたりサンプル数&lt;/td&gt;
&lt;td&gt;このブロックに含まれる1チャンネルあたりのサンプル数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;不定&lt;/td&gt;
&lt;td&gt;データ&lt;/td&gt;
&lt;td&gt;圧縮済みデータ or 生データ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="todo"&gt;
&lt;h3&gt;TODOリスト&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;リングバッファアクセス高速化: 済&lt;/li&gt;
&lt;li&gt;ハンドルのワーク配置化: 済&lt;ul&gt;
&lt;li&gt;将来的にフィルタもワーク配置したい。自己割当なしで実装すれば良さそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CRC16対応: 済&lt;/li&gt;
&lt;li&gt;コマンドライン整理: 済&lt;/li&gt;
&lt;li&gt;プリセット選定: 済&lt;ul&gt;
&lt;li&gt;いまのところ、(NGSA次数, SA次数, ブロックサイズ) と書くとしたとき&lt;ul&gt;
&lt;li&gt;高速（低圧縮モード）は(4, 4, 8192)&lt;/li&gt;
&lt;li&gt;通常（デフォルト）は(8, 8, 8192)&lt;/li&gt;
&lt;li&gt;低速（高圧縮モード）は(16, 8, 16384)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;でいこうと思ってたけど、フィルタ次数を増やしても負荷インパクトが大きくならない+圧縮率が向上し続けるのを見て、次数は4, 8, 16, 32, 64まで選べるようにした。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MSVC環境で &lt;cite&gt;_BitScanReverse&lt;/cite&gt; を使う: 済&lt;/li&gt;
&lt;li&gt;MSVC環境で &lt;cite&gt;gtest&lt;/cite&gt; できるようにする: 手が空いたらでよい。&lt;/li&gt;
&lt;li&gt;評価開始（評価スクリプトを作る。Rubyでいい。）&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(28)</title><link href="/kodetsukuzuo-ri2021chun-28.html" rel="alternate"></link><published>2021-03-27T10:00:00+09:00</published><updated>2021-03-27T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-27:/kodetsukuzuo-ri2021chun-28.html</id><summary type="html">&lt;p&gt;論文化が入ってしまったので作業が止まった。。。ギリギリ形にはなってる。&lt;/p&gt;
&lt;p&gt;Monkey's AudioがCNN使ってるのを改めて見る。Binarised NNとか …&lt;/p&gt;</summary><content type="html">&lt;p&gt;論文化が入ってしまったので作業が止まった。。。ギリギリ形にはなってる。&lt;/p&gt;
&lt;p&gt;Monkey's AudioがCNN使ってるのを改めて見る。Binarised NNとか使えないか妄想する。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;コーダーのパラメーター数は定数でいい。引数いらん。&lt;ul&gt;
&lt;li&gt;と思ってやってみたけど、さして負荷変わるわけでもなし、実装が単純になったかというとそうでもないのでやめる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プレーヤー作りたい。サウンドドライバのインターフェイスは最小限に。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(27)</title><link href="/kodetsukuzuo-ri2021chun-27.html" rel="alternate"></link><published>2021-03-22T10:00:00+09:00</published><updated>2021-03-22T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-22:/kodetsukuzuo-ri2021chun-27.html</id><summary type="html">&lt;p&gt;再度確かめてwavpack(-hh)を0.1%リードしているのを再確認。実装を修正、テストを固めた。アサートはデコードが不完全なこ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;再度確かめてwavpack(-hh)を0.1%リードしているのを再確認。実装を修正、テストを固めた。アサートはデコードが不完全なことに起因していた。&lt;/p&gt;
&lt;p&gt;お話作りにはいる（が、23日になってしまった…）&lt;/p&gt;
&lt;p&gt;wavpackのsign algorithmの係数更新がかっこよすぎる...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#if 1   &lt;/span&gt;&lt;span class="c1"&gt;// PERFCOND&lt;/span&gt;
&lt;span class="cp"&gt;#define update_weight(weight, delta, source, result) \&lt;/span&gt;
&lt;span class="cp"&gt;    if (source &amp;amp;&amp;amp; result) { int32_t s = (int32_t) (source ^ result) &amp;gt;&amp;gt; 31; weight = (delta ^ s) + (weight - s); }&lt;/span&gt;
&lt;span class="cp"&gt;#elif 1&lt;/span&gt;
&lt;span class="cp"&gt;#define update_weight(weight, delta, source, result) \&lt;/span&gt;
&lt;span class="cp"&gt;    if (source &amp;amp;&amp;amp; result) weight += (((source ^ result) &amp;gt;&amp;gt; 30) | 1) * delta;&lt;/span&gt;
&lt;span class="cp"&gt;#else&lt;/span&gt;
&lt;span class="cp"&gt;#define update_weight(weight, delta, source, result) \&lt;/span&gt;
&lt;span class="cp"&gt;    if (source &amp;amp;&amp;amp; result) (source ^ result) &amp;lt; 0 ? (weight -= delta) : (weight += delta);&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;cite&gt;(source ^ result) &amp;gt;&amp;gt; 31&lt;/cite&gt; で予測と信号の符号が合っているかどうかがわかる。合ってたら0, 合ってなかったら~0=-1。係数更新も &lt;cite&gt;weight = (delta ^ s) + (weight - s)&lt;/cite&gt; で確かに成立している( &lt;cite&gt;s=0,~0=-1&lt;/cite&gt; で考えよ）。難点は、source == resultのときに+=で更新してしまうところか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(26)</title><link href="/kodetsukuzuo-ri2021chun-26.html" rel="alternate"></link><published>2021-03-21T10:00:00+09:00</published><updated>2021-03-21T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-21:/kodetsukuzuo-ri2021chun-26.html</id><summary type="html">&lt;p&gt;圧縮率向上の工夫として、やはり、振幅に応じてステップサイズ乗じるのが効くはず。（固定でシフト量をいじるとかな …&lt;/p&gt;</summary><content type="html">&lt;p&gt;圧縮率向上の工夫として、やはり、振幅に応じてステップサイズ乗じるのが効くはず。（固定でシフト量をいじるとかなり圧縮率が変わってくるので）&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;やってみたが、計測した振幅（分散）をどうステップサイズに反映させるかがうまく行かないのでやめる。単純に分散逆数を乗じるとステップサイズが大きくなりすぎて劣化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他にも、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;プリエンファシスのシフト量を5から4に変えたら若干の改善が見られたので採用。とおもったけどもう一度検証したら悪化してた。5のままにする。&lt;/li&gt;
&lt;li&gt;SAのフィルタ次数を16にした時、そのままでは性能が悪いが、係数更新時にlog2(次数)だけ右シフトすると具合がいい（これは次数で割っていることに相当する）。高振幅な音源では改善したけど、問題のデータでは悪化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さらにあがいていると、SAは右シフト量0で更新すると、低振幅音源で安定してよい圧縮率を出してくれる事がわかった（当然高振幅音源は悪化するけど、それほどひどくない）。特にクラシック音源に限ればwavpack(-hh)を0.5%リードしている。ワン・ツー・スゥイーツでもリードしているし、話の作り方としても良いかもしれないので、これで検証掛けてみる。就寝。&lt;/p&gt;
&lt;p&gt;3:30くらいになんか勝手に起きた。結果を見たら0.1%リードしてるのを確認した。念の為テストを実行したら圧縮できずにアサートしている…まだ怪しい。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(25)</title><link href="/kodetsukuzuo-ri2021chun-25.html" rel="alternate"></link><published>2021-03-20T10:00:00+09:00</published><updated>2021-03-20T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-20:/kodetsukuzuo-ri2021chun-25.html</id><summary type="html">&lt;p&gt;金曜日に試した項目を整理。やはり低振幅信号ではGolomb符号が重要なので突っ込んだ。移動が多くて夕方過ぎは失神し …&lt;/p&gt;</summary><content type="html">&lt;p&gt;金曜日に試した項目を整理。やはり低振幅信号ではGolomb符号が重要なので突っ込んだ。移動が多くて夕方過ぎは失神した。&lt;/p&gt;
&lt;p&gt;ほぼ最終手段だけど、エンコードを複数回実行する手段を突っ込んだ。とうぜん圧縮率は上がる。当然エンコード負荷もあがる。これから評価。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(24)</title><link href="/kodetsukuzuo-ri2021chun-24.html" rel="alternate"></link><published>2021-03-19T10:00:00+09:00</published><updated>2021-03-19T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-19:/kodetsukuzuo-ri2021chun-24.html</id><summary type="html">&lt;ul class="simple"&gt;
&lt;li&gt;ゴロムは減るけど、最終手段としよう。気になってるのはステップサイズのとり方かな。&lt;/li&gt;
&lt;li&gt;ブロックヘッダのデータのビ …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;ゴロムは減るけど、最終手段としよう。気になってるのはステップサイズのとり方かな。&lt;/li&gt;
&lt;li&gt;ブロックヘッダのデータのビット幅は8でもよかったしサイズ削減に貢献したので8に戻した。&lt;/li&gt;
&lt;li&gt;いろいろあがく。低振幅音源で効くのでゴロム符号は採用。SAの残差をsignからlogに置き換えたら低振幅音源で改善傾向。wavpack+0.4%くらい(-m4だと+0.1%)&lt;/li&gt;
&lt;li&gt;うーん、Golomb符号ありなら、signもlogもあんまり変わらない感じ。Golombの影響力が大きい。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(23)</title><link href="/kodetsukuzuo-ri2021chun-23.html" rel="alternate"></link><published>2021-03-18T10:00:00+09:00</published><updated>2021-03-18T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-18:/kodetsukuzuo-ri2021chun-23.html</id><summary type="html">&lt;p&gt;評価スクリプトをSLAから持ってきて試してみると、平均圧縮率が悪い。
なぜだ。手元の音源ではよかったのに。&lt;/p&gt;
&lt;p&gt;結果を見 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;評価スクリプトをSLAから持ってきて試してみると、平均圧縮率が悪い。
なぜだ。手元の音源ではよかったのに。&lt;/p&gt;
&lt;p&gt;結果を見ると、音量が控えめな音源でかなり性能が悪くなっている事がわかった。（完全な無音ではない）&lt;/p&gt;
&lt;p&gt;フィルタ次数を減らしたほうが結果が良い状態。どうする。観察。&lt;/p&gt;
&lt;p&gt;フィルタ係数を見ると、次数16では大きくなりすぎている印象。。そこで、フィルタ係数のビット幅を小さくしたら改善に向かったが、flacには及ばない。また、SLAと同じようにライスパラメータが小さいときは固定のゴロム符号を行うようにしたらわずかに改善した。ゴロム符号の対処は最終手段とする。&lt;/p&gt;
&lt;p&gt;もっとフィルタ係数の変化を観察すべきかと思う。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;AR係数が小さいときはほぼ白色雑音だから係数をリセットする→すこしは良くなったけどだめだった。&lt;/li&gt;
&lt;li&gt;フィルタ係数（ブロックヘッダ）の記録にとるビット幅を8から12に増やしたら改善傾向。しかしまだ断然悪い。（追記：NGSAの計算精度向上後は8の方が良かった）&lt;/li&gt;
&lt;li&gt;以前フィルタ末尾の重みが大きかったのを見ていた。（末尾が原因で係数右シフトが起きてた）末尾係数を見てみる。&lt;ul&gt;
&lt;li&gt;係数の動きが不自然（先頭と末尾の動きが同期してる等）なので自然勾配の更新がおかしいと思って、勾配における積和演算で丸めをやめたら、低振幅音源で圧縮率が大幅に改善した（全体的に良くなったので採用）。。。。固定小数演算よくわからん・・・なんで良くなった…。多分、丸めの方向が正方向にしかできてなかったのが災いしていたかも。引くときは丸めのための加算がいらないはず。&lt;/li&gt;
&lt;li&gt;ステップサイズを大きくとると、低振幅音源で改善、大振幅音源で悪化。当然だけど、これから、ステップサイズは分散に合わせて変えるべきであることがわかる。&lt;/li&gt;
&lt;li&gt;これでWavpack(-hh)と比べて+0.5%くらい。ゴロムを加えるのもあり。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(22)</title><link href="/kodetsukuzuo-ri2021chun-22.html" rel="alternate"></link><published>2021-03-17T10:00:00+09:00</published><updated>2021-03-17T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-17:/kodetsukuzuo-ri2021chun-22.html</id><summary type="html">&lt;p&gt;CRC16対応をした。あとはコマンドライン整理とプリセット精査なんだけど、処理負荷でどこが重くなってんのか見てお …&lt;/p&gt;</summary><content type="html">&lt;p&gt;CRC16対応をした。あとはコマンドライン整理とプリセット精査なんだけど、処理負荷でどこが重くなってんのか見ておきたい。&lt;/p&gt;
&lt;p&gt;負荷測定については、instrumentsがdeparchedなので、 &lt;cite&gt;xcrun xctrace&lt;/cite&gt; を使う。&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
xcrun xctrace record --template 'Time Profiler' --launch -- ./naru -e a.wav a.nar
&lt;/pre&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(21)</title><link href="/kodetsukuzuo-ri2021chun-21.html" rel="alternate"></link><published>2021-03-16T10:00:00+09:00</published><updated>2021-03-16T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-16:/kodetsukuzuo-ri2021chun-21.html</id><summary type="html">&lt;p&gt;ワーク配置をする。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LPC計算ハンドル: 済&lt;/li&gt;
&lt;li&gt;コーダー: 済（まよったけど、今後別用途ありうる）&lt;/li&gt;
&lt;li&gt;プロセッサ: やめる。内部モジュー …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;ワーク配置をする。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LPC計算ハンドル: 済&lt;/li&gt;
&lt;li&gt;コーダー: 済（まよったけど、今後別用途ありうる）&lt;/li&gt;
&lt;li&gt;プロセッサ: やめる。内部モジュールであって構造体公開してるし。&lt;/li&gt;
&lt;li&gt;エンコーダ: 済&lt;/li&gt;
&lt;li&gt;デコーダ: 済&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の順に。かるくデコーダのワークサイズみた。8ch, 最大32次とすると9kくらい。プロセッサがほとんどを占めてる。まだメモリを削る要望はないけど、やるとしたらここかな。コンフィグの最大次数に合わせて動的確保する実装に変えるべき。&lt;/p&gt;
&lt;p&gt;Windowsで軽く動かしてたら、NLZは &lt;cite&gt;_BitScanReverse&lt;/cite&gt; を使えば早くできそうな印象で、やっつけたらたしかに早くなった。630ms-&amp;gt;550msとか。全部NLZ(CLZ)使ってんのもよくなくて、CTZも使ったほうがいいんじゃないか。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://blog.jiubao.org/2015/01/gcc-bitscanforward-bitscanreverse-msvc.html"&gt;gcc で _BitScanForward &amp;amp; _BitScanReverse 互換関数、MSVC で __builtin_clz &amp;amp; __builtin_ctz 互換関数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(20)</title><link href="/kodetsukuzuo-ri2021chun-20.html" rel="alternate"></link><published>2021-03-15T10:00:00+09:00</published><updated>2021-03-15T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-15:/kodetsukuzuo-ri2021chun-20.html</id><summary type="html">&lt;p&gt;3/13はイベント、3/14はリングバッファ高速化（やった）。今日3/15は事務用で一日潰れる。&lt;/p&gt;
&lt;p&gt;作業開始は22:30となる。また、論 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;3/13はイベント、3/14はリングバッファ高速化（やった）。今日3/15は事務用で一日潰れる。&lt;/p&gt;
&lt;p&gt;作業開始は22:30となる。また、論文にまとめないといけなそうな雰囲気。しかし焦りたくない。&lt;/p&gt;
&lt;p&gt;今日はフィルタモジュール整理から初めて、できれば&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LPC計算ハンドル&lt;/li&gt;
&lt;li&gt;コーダー&lt;/li&gt;
&lt;li&gt;プロセッサ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;をワーク配置形式に作っていきたい。フィルタモジュール整理してたら24時回りそう。。。。&lt;/p&gt;
&lt;p&gt;AR次数が2以上の場合に対処していたら1:00回ったので切り上げる。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(19)</title><link href="/kodetsukuzuo-ri2021chun-19.html" rel="alternate"></link><published>2021-03-12T10:00:00+09:00</published><updated>2021-03-12T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-12:/kodetsukuzuo-ri2021chun-19.html</id><summary type="html">&lt;p&gt;Riceパラメータはlog2で記録するようにした。
残差が大きく(=圧縮率が悪化)なったら対策を考える。問題後回し。&lt;/p&gt;
&lt;p&gt;そして、固定 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Riceパラメータはlog2で記録するようにした。
残差が大きく(=圧縮率が悪化)なったら対策を考える。問題後回し。&lt;/p&gt;
&lt;p&gt;そして、固定小数幅を14bitにするのを試行する。→やってみたら実音声で大幅悪化。やめやめ。&lt;/p&gt;
&lt;p&gt;残りで大きいところは&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;リングバッファアクセス高速化&lt;/li&gt;
&lt;li&gt;ハンドルのワーク配置化&lt;/li&gt;
&lt;li&gt;コマンドライン整理&lt;/li&gt;
&lt;li&gt;プリセット選定&lt;ul&gt;
&lt;li&gt;いまのところ、(NGSA次数, SA次数, ブロックサイズ) と書くとしたとき&lt;ul&gt;
&lt;li&gt;高速（低圧縮モード）は(4, 4, 8192)&lt;/li&gt;
&lt;li&gt;通常（デフォルト）は(8, 8, 8192)&lt;/li&gt;
&lt;li&gt;低速（高圧縮モード）は(16, 8, 16384)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上が残件になるが、致命的なところは除いたつもりなので、今の内容で公開する。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(18)</title><link href="/kodetsukuzuo-ri2021chun-18.html" rel="alternate"></link><published>2021-03-11T10:00:00+09:00</published><updated>2021-03-11T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-11:/kodetsukuzuo-ri2021chun-18.html</id><summary type="html">&lt;p&gt;1サンプル単位で振動する信号への対処を考慮中。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;64bit化してオーバーフロー原因かしらべる-&amp;gt;コンパイルエラー多発 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;1サンプル単位で振動する信号への対処を考慮中。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;64bit化してオーバーフロー原因かしらべる-&amp;gt;コンパイルエラー多発。そして解決してない。オーバーフローせずに吹っ飛んでるっぽい。&lt;/li&gt;
&lt;li&gt;プリエンファシスをLPCで計算した1次フィルタに置き換える: 前提がほぼ崩れるので最終手段に近い。&lt;/li&gt;
&lt;li&gt;アサートしているのは（残差増大に伴って）Rice符号の初期パラメータが大きくなりすぎているからなので、パラメータ保存領域を大きくする&lt;ul&gt;
&lt;li&gt;うまく行かなかった。発散してるっぽいし、この対処だと本質的な問題（発散）を隠してる気がする。&lt;/li&gt;
&lt;li&gt;Riceパラメータのlog2ceilをとって記録することで5bitに確実に収まり、アサートは発生しなくなる…が、やっぱ残差が大きくなっている事実は変わらないわけで、どうするか考えるべき。テストケースは18とか出てるので大きいとおもふ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ブロックサンプル数を8192より大きくすると収束する&lt;ul&gt;
&lt;li&gt;何故？AR係数がうまく求まるから？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;固定小数のビット数を14にしたら性能向上したけど、後の検証に回す。（12,13だと性能悪化）&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(17)</title><link href="/kodetsukuzuo-ri2021chun-17.html" rel="alternate"></link><published>2021-03-10T10:00:00+09:00</published><updated>2021-03-10T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-10:/kodetsukuzuo-ri2021chun-17.html</id><summary type="html">&lt;p&gt;テストケース追加中。実装も並行して修正かけてる。&lt;/p&gt;
&lt;p&gt;ノイズ（エントロピー大）エンコード時に残差が大きくなってライ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;テストケース追加中。実装も並行して修正かけてる。&lt;/p&gt;
&lt;p&gt;ノイズ（エントロピー大）エンコード時に残差が大きくなってライスパラメータが記録できずクラッシュしていた。このため、生データブロックを追加。&lt;/p&gt;
&lt;p&gt;同時にブロックヘッダのフォーマットを整理。ビットストリームなしでもブロックヘッダはエンコード/デコードできるようにする。そのためブロックデータタイプを1byteにした。&lt;/p&gt;
&lt;p&gt;1サンプル周期の振動に対して残差が発散している。。。
デバッグ中。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;NGSAの勾配がすぐに止まってしまうのを見ている。（定常的だから当然かも知れない）。&lt;/li&gt;
&lt;li&gt;プリエンファシスが逆効果（振幅増大）している...。オーバーフロー多発。&lt;/li&gt;
&lt;li&gt;勾配の更新タイミングを履歴更新後にしたら若干改善したが、それでも発散している。（以前圧縮率悪化を確認していたが、あまり悪化しなかった。何故？）&lt;/li&gt;
&lt;li&gt;係数初期値をLPCで求めるのもありか？&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(16)</title><link href="/kodetsukuzuo-ri2021chun-16.html" rel="alternate"></link><published>2021-03-09T10:00:00+09:00</published><updated>2021-03-09T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-09:/kodetsukuzuo-ri2021chun-16.html</id><summary type="html">&lt;p&gt;テストケース追加中。&lt;/p&gt;
&lt;p&gt;動かしていて、ブロックにサイズに準じるデータが無いことに気づく。
AADでは固定ビットレート …&lt;/p&gt;</summary><content type="html">&lt;p&gt;テストケース追加中。&lt;/p&gt;
&lt;p&gt;動かしていて、ブロックにサイズに準じるデータが無いことに気づく。
AADでは固定ビットレートだからブロックサイズが固定されていたのでいらなかったが、こっち可変ビットレートだから必須のはず。&lt;/p&gt;
&lt;p&gt;もう少し考えるとサイズのbit幅をいくつにしようか悩む。16bitでは小さい。SLAに倣うか→見たら32bitだった。まあそうか。
ついでにCRC検査向けに16bit入れとくか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(15)</title><link href="/kodetsukuzuo-ri2021chun-15.html" rel="alternate"></link><published>2021-03-08T10:00:00+09:00</published><updated>2021-03-08T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-08:/kodetsukuzuo-ri2021chun-15.html</id><summary type="html">&lt;p&gt;引き続き発散現象調査。&lt;/p&gt;
&lt;p&gt;対策として、フィルタ係数のクリップ処理を入れてしまうのはどうかと考えている。&lt;/p&gt;
&lt;p&gt;なるべく …&lt;/p&gt;</summary><content type="html">&lt;p&gt;引き続き発散現象調査。&lt;/p&gt;
&lt;p&gt;対策として、フィルタ係数のクリップ処理を入れてしまうのはどうかと考えている。&lt;/p&gt;
&lt;p&gt;なるべく、というか厳密にフィルタの出力を変えないように係数をクリップしたいのだが、どうすればいいのか。その議論ってあんまりされてないように見えるんやがな。（FIRフィルタ係数の同値類ってなんだ？）&lt;/p&gt;
&lt;p&gt;色々見ると、（あんまり記述無いけど）&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.csee.umbc.edu/~tinoosh/cmpe691/slides/Handout.fir.scaling.pdf"&gt;FIR FILTER SCALING&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;にあるように、全係数を定数で割ると案の定ゲインが定数倍だけ小さくなる。しかし周波数特性はそのまま。&lt;/p&gt;
&lt;p&gt;周波数特性は保たれるからええか、というノリで定数倍の方策を取る。幅は18bit（[-4,4]の範囲）とした。16, 17bitだと顕著に性能が悪い。しっかしオーバーフローが怖いかも。&lt;/p&gt;
&lt;p&gt;テスト追加に入る。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(14)</title><link href="/kodetsukuzuo-ri2021chun-14.html" rel="alternate"></link><published>2021-03-07T10:00:00+09:00</published><updated>2021-03-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-07:/kodetsukuzuo-ri2021chun-14.html</id><summary type="html">&lt;p&gt;「重ねる努力」での発散現象を観察している。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;SAのフィルタ係数が正の値に徐々に吹っ飛んでいる&lt;/li&gt;
&lt;li&gt;ブロックの切り替わり …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;「重ねる努力」での発散現象を観察している。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;SAのフィルタ係数が正の値に徐々に吹っ飛んでいる&lt;/li&gt;
&lt;li&gt;ブロックの切り替わりが原因ぽい&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ブロックの切り替わりで怪しい処理はなにかと見ていたら、NGSAの残差初期値がただのデータ履歴で更新されていて、勾配が不連続になっていて怪しいことが見えた。リファレンス通りに、取得した履歴を元に自然勾配の初期値を計算してみる。&lt;/p&gt;
&lt;p&gt;すると、問題を確認したケースにおいては発散しなくなった。しかし、デバッグのためにブロックサイズを小さくして切り替わりが多く出るようにしたら再度発散。原因を追う。&lt;/p&gt;
&lt;p&gt;調査したところ、ブロックサイズを1024サンプルにしたとき、「重ねる努力」の1041000サンプル付近で「シャーン」というエントロピーの高い振幅大音源をきっかけにフィルタ係数が発散していた。もっと見たところAR係数が0.3等の低い数値をとっていた（確認したらそれまでは0.9以上をとっていたのに、急落していた。）&lt;/p&gt;
&lt;p&gt;対策をどうしようか。0.4未満ならリセットするとかやれば、1024では発散しないけど、ブロックサイズを512, 256にしたら発散する。。。（しかも、発散時にAR係数は0.9以上だった。）アドホックなのでやりたくないし、AR係数が本質的な原因では無いと考えている。&lt;/p&gt;
&lt;p&gt;バグを疑って調査を続ける。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(13)</title><link href="/kodetsukuzuo-ri2021chun-13.html" rel="alternate"></link><published>2021-03-06T10:00:00+09:00</published><updated>2021-03-06T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-06:/kodetsukuzuo-ri2021chun-13.html</id><summary type="html">&lt;p&gt;デコーダを作った。といっても枠は作ってあってプロセッサ部を埋めるだけ。
動かしたところSAの係数を記録してな …&lt;/p&gt;</summary><content type="html">&lt;p&gt;デコーダを作った。といっても枠は作ってあってプロセッサ部を埋めるだけ。
動かしたところSAの係数を記録してなかった。追加。&lt;/p&gt;
&lt;p&gt;処理順序を整理して、たぶんロスレスに戻っていることを確認。&lt;/p&gt;
&lt;p&gt;テストに入っていく。大規模なテストをやる前に手元のファイルをいくつか試していると、「重ねる努力」でアサート。こいつのバグを潰したら、テスト追加に入ろう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(12)</title><link href="/kodetsukuzuo-ri2021chun-12.html" rel="alternate"></link><published>2021-03-05T10:00:00+09:00</published><updated>2021-03-05T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-05:/kodetsukuzuo-ri2021chun-12.html</id><summary type="html">&lt;p&gt;ちょっとCmake整理した。&lt;/p&gt;
&lt;p&gt;で、昨日の続きといく。発散している現象はフィルタ係数をダンプしてみたけど、不連続的じゃな …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ちょっとCmake整理した。&lt;/p&gt;
&lt;p&gt;で、昨日の続きといく。発散している現象はフィルタ係数をダンプしてみたけど、不連続的じゃなくてゆっくりと値が大きくなっていたので、厄介かもしれない。&lt;/p&gt;
&lt;p&gt;発散対策としてステップサイズをいじる。NGSAの係数右シフト量を4から6にしたら安定する+圧縮率上がる。設定次第でwavpack(-hh)を超える状況になる。&lt;/p&gt;
&lt;p&gt;ステップサイズをいじってコード整理。デコーダの制作に入ろうと思う。（SAのシフト前に0.5加えたら圧縮率向上した。こういうのがこわい。なお、プリエンファシスは0.5加算は不要。定数乗算だから。）
デコーダができてビットパーフェクトに戻るまではぬか喜びなので、気合い入れる。&lt;/p&gt;
&lt;p&gt;デコード側だけでもin-placeな復号ができるといいなあ・・・&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(11)</title><link href="/kodetsukuzuo-ri2021chun-11.html" rel="alternate"></link><published>2021-03-04T10:00:00+09:00</published><updated>2021-03-04T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-04:/kodetsukuzuo-ri2021chun-11.html</id><summary type="html">&lt;p&gt;起床ミスって日中の作業時間が、、&lt;/p&gt;
&lt;p&gt;8bit音声に対して圧縮率が悪いのは、8bit音声を非常に低振幅(-128 - 127)のデータとして扱っ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;起床ミスって日中の作業時間が、、&lt;/p&gt;
&lt;p&gt;8bit音声に対して圧縮率が悪いのは、8bit音声を非常に低振幅(-128 - 127)のデータとして扱っているからと思われる。対策としては16bit固定小数に合わせて処理する。後でいいと思う。&lt;/p&gt;
&lt;p&gt;振幅が高い、ボーカル付きデータとしてカレンダーガールを導入したらMS処理で16bit範囲を超えてしまった…プリエンファシス処理のバッファもシフトしないとだめ。&lt;/p&gt;
&lt;p&gt;うーん、データ/フィルタ記録が馬鹿になってない。TTAを見習ってすべて8bit範囲に収まるように記録するのが吉か？（シフト量も記録しておく。）
8bitはやりすぎな気もするから、12bitも検討したい。シフト量は4bitでいいだろう。→でも、SLAでみたように、量子化幅はあんまりドラスティックに効かないとおもう。一応いじれるようにして、調節はあと。と思ったら8bitで保存しても圧縮性能に影響が大きく出ないので、8bitにしてみる。&lt;/p&gt;
&lt;p&gt;ちょっとした思いつきでSAをさらにもう一段重ねたけど不安定（圧縮率・係数発散）なのでやめておく。&lt;/p&gt;
&lt;p&gt;実装整理。in-placeにしてみた。でもコーダーが1サンプル単位で動いとらんからバッファがいる状況。早いうちになんとかしたいかも。&lt;/p&gt;
&lt;p&gt;2段目のフィルタをいじって遊んでたら、発散するパターンを見つけた。現在デバッグ中。落ち着いたらデコーダ作り始めたいところ。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(10)</title><link href="/kodetsukuzuo-ri2021chun-10.html" rel="alternate"></link><published>2021-03-03T10:00:00+09:00</published><updated>2021-03-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-03:/kodetsukuzuo-ri2021chun-10.html</id><summary type="html">&lt;p&gt;NNGSAとのRMS比較をやる。NNGSAが低いのなら後段でSAかませたい。
残差の振幅分布を見ると、やっぱNGSAの方が良い。0付近へよ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;NNGSAとのRMS比較をやる。NNGSAが低いのなら後段でSAかませたい。
残差の振幅分布を見ると、やっぱNGSAの方が良い。0付近へよくデータが集まる。
RMSEもNGSAのほうが良かった。。。&lt;/p&gt;
&lt;p&gt;うーん、変だ。確かにSLAのときも全く同様の現象を見たんだけど。
実験ではNGSAとても悪かったはずなんだがなあ。。。&lt;/p&gt;
&lt;p&gt;グダグダしてのんびりとしている。根本的な改善策がないか、過去のブログを見直してみる。&lt;/p&gt;
&lt;p&gt;気になったのはTTAのエンコード部分。再帰的ライスを使っているのは知っていたが、さらに、指数移動平均によって平均を更新していることが分かった。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// aiki: 1つの残差出力&lt;/span&gt;
&lt;span class="kr"&gt;__forceinline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;tta_encoder_put_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TTA_adapt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;TTAint32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;TTAuint32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 符号付き整数を符号なし整数に変換(非負数は奇, 負数は偶)&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ENC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// encode Rice unsigned&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 指数移動平均式で平均を更新: sum0 &amp;lt;- (15/16) * sum0 + outval&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: shift_16[x] は 2^(4 + x) = 16 * 2^(x) を計算するテーブル.&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: k0 &amp;gt; 0 &amp;amp;&amp;amp; sum0 &amp;lt; 16 * 2^(k0) ならば k0 が大きいので減らす&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: sum0 &amp;gt; 32 * 2^(k0) ならば k0 が小さいので増やす&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_shift&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 出力値が 2^(k0) 以上ならば&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 出力値を引く: outval -= 2^(k0)&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_shift&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 指数移動平均式で平均を更新: sum1 &amp;lt;- (15/16) * sum1 + outval&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// aiki: k1 &amp;gt; 0 &amp;amp;&amp;amp; sum1 &amp;lt; 16 * 2^(k1) ならば k1 が大きいので減らす&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// aiki: sum0 &amp;gt; 32 * 2^(k1) ならば k1 が小さいので増やす&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: unaryの計算&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// aiki: elseをブロックで囲った&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 出力値が 2^(k0) より小さければ、unaryは0&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: static変数の補足&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: enc_fifo_bcount: static変数。キャッシュ内のビットカウント。&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: enc_fifo_bcache: static変数。キャッシュ内のビット。&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// put unary&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: unaryの連続した1を出力する&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: キャッシュ内に1バイト以上データがあるなら1バイト未満になるまで出力&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;write_byte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// aiki: bit_mask[x]は下位x[bit]に1が立ったマスク&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// aiki: unaryが24以上ならば, 23bit分をマスクで一気に書き出す&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 24が特別になっているのは, これに7bit以上のデータがあるとオーバーランするから&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// aiki: マスクを使って一気に書き出す&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unary&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// put binary&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: キャッシュ内に1バイト以上データがあるなら1バイト未満になるまで出力&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;write_byte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: Rice符号の剰余部出力: k(k0 or k1)が1以上であれば、outvalの下位k[bit]を出力&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outval&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;enc_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// tta_encoder_put_value&lt;/span&gt;

&lt;span class="c1"&gt;// aiki: 1つの残差を復号&lt;/span&gt;
&lt;span class="kr"&gt;__forceinline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;TTAint32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;tta_decoder_get_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TTA_adapt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;TTAuint32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;TTAint32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// decode Rice unsigned&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: unary部を復号し連続した1の数をvalueに&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: バイト単位の読み出し&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;read_byte&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xff&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;read_byte&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 残ったビット分のカウント&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: valueが0ならlevelは0でk0, それ以上ならlevelは1でk1をつかう&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: Rice符号の剰余部取得: k(k0 or k1)が1以上であれば、outvalの下位k[bit]を出力&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: キャッシュがk[bit]以上になるまでバイト単位で読み込み&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;read_byte&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: Rice符号の取得値の確定。右辺のvalueはunaryと同等。&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: k[bit]読み込み後のキャッシュ更新&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcache&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_mask&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dec_fifo_bcount&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 指数移動平均式で平均を更新: sum1 &amp;lt;- (15/16) * sum1 + outval&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// aiki: k1 &amp;gt; 0 &amp;amp;&amp;amp; sum1 &amp;lt; 16 * 2^(k1) ならば k1 が大きいので減らす&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// aiki: k1 &amp;gt; 0 &amp;amp;&amp;amp; sum1 &amp;lt; 16 * 2^(k1) ならば k1 が大きいので減らす&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 出力値を足す: outval += 2^(k0)&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit_shift&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 指数移動平均式で平均を更新: sum0 &amp;lt;- (15/16) * sum0 + outval&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: k0 &amp;gt; 0 &amp;amp;&amp;amp; sum0 &amp;lt; 16 * 2^(k0) ならば k0 が大きいので減らす&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sum0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift_16&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// aiki: sum0 &amp;gt; 32 * 2^(k0) ならば k0 が小さいので増やす&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;rice&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k0&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// aiki: 符号なし整数を符号付き整数に変換&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// tta_decoder_get_value&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ビット出力がよく洗練されている... static変数にしているのはむしろ扱いやすくしているのかもしれない。やっぱ俺はまだまだだ...&lt;/p&gt;
&lt;p&gt;単独のフィルタでは伸び悩みを感じてきたので、奥の手たるカスケードを召喚した。組み合わせとしてはNGSA-&amp;gt;SA, SA-&amp;gt;NGSA, NGSA-&amp;gt;NGSA, SA-&amp;gt;SAがあったが、NGSA-&amp;gt;SAが最もよく、フィルタ次数とブロックサイズ設定よってはwavpack(-hh)を超える結果を出したので、採用する。&lt;/p&gt;
&lt;p&gt;良くなる理由は、カスケード接続が一般によい手段であることが指摘されている他、NGSAで相関除去が強く動くからではないかと想像している。&lt;/p&gt;
&lt;p&gt;コード整理。NNGSAを廃止。1サンプル単位で予測できるように実装する。 &lt;cite&gt;static&lt;/cite&gt; 関数とするのでインライン展開が効くはず。整理していたらすべてin-placeでやりきれそうに見えた。やってしまっていいか、寝てからやってしまおう。&lt;/p&gt;
&lt;p&gt;AR係数次数0にするとSAになるわけだが、性能が良かったりする。。。。。もう少し検証必須。
また、SAは次数小さくしたほうが良い結果が出る。4とか、NGSAの半分とか。&lt;/p&gt;
&lt;p&gt;係数の観察もしたい。丸めの影響も見たいところ。&lt;/p&gt;
&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;全部in-placeにしてバッファ1つでやりきるように整理&lt;/li&gt;
&lt;li&gt;SAのフィルタ次数策定&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(9)</title><link href="/kodetsukuzuo-ri2021chun-9.html" rel="alternate"></link><published>2021-03-02T10:00:00+09:00</published><updated>2021-03-02T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-02:/kodetsukuzuo-ri2021chun-9.html</id><summary type="html">&lt;p&gt;NNGSAは一旦置く。NGSAで勝負をしかけていく。&lt;/p&gt;
&lt;p&gt;ステップサイズの調節を入れてみたが、上がったり下がったり。もっとよく見 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;NNGSAは一旦置く。NGSAで勝負をしかけていく。&lt;/p&gt;
&lt;p&gt;ステップサイズの調節を入れてみたが、上がったり下がったり。もっとよく見る必要がある。→ステップサイズに掛ける固定小数の精度を11bitにしたら、総じて良くなったので採用の方向で検討。&lt;/p&gt;
&lt;p&gt;残差を見たら-2.0, 2.0に近い値をとっており危ないことに気づく。観察した所入力信号に不連続点が入っていた。おそらく、プリエンファシスのときにブロック先頭で毎回0入れてしまっているのが原因。→そのとおりだった。修正の結果範囲は-0.5-0.5以内に収まっている。圧縮率も向上。&lt;/p&gt;
&lt;p&gt;flacは倒せて、ttaはブロックサイズとフィルタ次数の設定次第で上回る結果。（総じて、ブロックサイズとフィルタ次数を大きく取ると良い。）
しかしwavpack(-hh)が強い。もう一段フィルタぶち込むか…まだ時期尚早か？&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(8)</title><link href="/kodetsukuzuo-ri2021chun-8.html" rel="alternate"></link><published>2021-03-01T10:00:00+09:00</published><updated>2021-03-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-03-01:/kodetsukuzuo-ri2021chun-8.html</id><summary type="html">&lt;p&gt;NNGSAをうまく動かしたい。キモは整数除算。&lt;/p&gt;
&lt;p&gt;と思っていたら正規化定数が負になっているのを見て、異常だと思った。アル …&lt;/p&gt;</summary><content type="html">&lt;p&gt;NNGSAをうまく動かしたい。キモは整数除算。&lt;/p&gt;
&lt;p&gt;と思っていたら正規化定数が負になっているのを見て、異常だと思った。アルゴリズムのミスからPython実装まで疑ったが問題なかった。&lt;/p&gt;
&lt;p&gt;そこでC言語実装版を見たら誤差が蓄積していた。固定小数演算による誤差蓄積。&lt;/p&gt;
&lt;p&gt;対策としては、ブロック計算開始時に真の値にセットし直すこと。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.sage-p.com/compone/toda/fixdec.htm"&gt;固定小数&lt;/a&gt; いつもお世話になってる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://midarekazu.g2.xrea.com/math-library.html"&gt;固定小数点数の算術関数ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://hp200lx.cocolog-nifty.com/blog/2014/11/memo-a1c8.html"&gt;■固定小数点数の除算&lt;/a&gt; 補正によって32bitのまま精度を良くする方法が載っている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.emit.jp/prog/prog_div.html"&gt;整数除算の高速化&lt;/a&gt; これ、どこかで効いてくるはず。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、除算の誤差もなんとか収まって発散は収まったように見える、が、圧縮率が悪い。&lt;/p&gt;
&lt;p&gt;短めの音声で見てみると、先頭10000サンプルぐらいの残差が大きいことが見えてきていた。正規化定数の最小値を大きく取りすぎていたので小さくするなどの対処で若干改善したが、まだLMS(AR(1))に及ばず。&lt;/p&gt;
&lt;p&gt;超えないことを真面目に追うべきなのだが、その後色々と弄っていた。すると、（やはりというか…）NGSA（正規化なしの残差の符号を取るだけ）にしたら圧縮性能が向上。。。。しかも、プリエンファシスと組み合わせてさらに圧縮性能向上。。。FLAC(-8)を超えた。SLAでやった残差のlog2を取るのは良くなかった。&lt;/p&gt;
&lt;p&gt;フィルタを2段重ねることでttaも超えた。が、wavpack(-hh)は超えない。でも2段重ねは最終手段にしたい。ギリギリまでフィルタ次数8で戦い続ける。（8にするのはAR(2)まで試すことができるから。4は高速モード、16は高圧縮モードにしたい。）&lt;/p&gt;
&lt;p&gt;NGSAで行くとして考えたいのはステップサイズ。分散（とAR係数から決まる係数）を掛けたほうがよいはず。自然勾配法の定義から、AR(1)の場合は &lt;span class="math"&gt;\(1/(1 - \psi_{1}^{2})\)&lt;/span&gt; を掛けてやれば良いことが見えている。
また、デコーダを作る前準備として、ブロックヘッダの仕様を策定したい。&lt;/p&gt;
&lt;p&gt;（一瞬怖くなって普通のsignアルゴリズムにしてみたら、NGSAのほうが良いのが確認できた。でも圧縮率の差は1%未満。。。）&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(6)</title><link href="/kodetsukuzuo-ri2021chun-6.html" rel="alternate"></link><published>2021-02-28T10:00:00+09:00</published><updated>2021-02-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-28:/kodetsukuzuo-ri2021chun-6.html</id><summary type="html">&lt;p&gt;ナイーブな全体エンコード・デコードはできている。
また、LMS/Newton AR(1)もまあできたかなというところ。flac, wavpackと同程度に …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ナイーブな全体エンコード・デコードはできている。
また、LMS/Newton AR(1)もまあできたかなというところ。flac, wavpackと同程度に見える。ステップサイズ依存で結構性能が揺らぐ。&lt;/p&gt;
&lt;p&gt;AR(2)ではステップサイズを小さく取らないと厳しい。
また、プリエンファシスをかけると結構性能が落ちているように見える。もう少し詳しく見ていく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;AR(1)でプリエンファシスをかけると性能悪化。勾配でプリエンファシスみたいなことしてるからそりゃそうか？&lt;/li&gt;
&lt;li&gt;AR(2)は良くなった。（けどAR(1)と同じくらいの性能。）直流を削ることで解析精度が良くなっている？&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(7)</title><link href="/kodetsukuzuo-ri2021chun-7.html" rel="alternate"></link><published>2021-02-28T10:00:00+09:00</published><updated>2021-02-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-28:/kodetsukuzuo-ri2021chun-7.html</id><summary type="html">&lt;p&gt;プリエンファシスを掛けるとよくない。
これは確かにAR(1)のアルゴリズム的にもうなずける。&lt;/p&gt;
&lt;p&gt;今日はNNGSAをためしてみ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;プリエンファシスを掛けるとよくない。
これは確かにAR(1)のアルゴリズム的にもうなずける。&lt;/p&gt;
&lt;p&gt;今日はNNGSAをためしてみる。が、良くない。
除算時の左シフトを入れるととても悪い。むしろ乗算と同じ、15bit右シフトを入れるとそれなりに安定してくる…&lt;/p&gt;
&lt;p&gt;いま一番良いのがLMS/Newton AR(1)でステップサイズ設定無しの組み合わせ。
しかしflacにすら及んでいない…&lt;/p&gt;
&lt;p&gt;NNGSAがうまくいかん、というところで終わりそう。除算が鬼門で、すぐにオーバーフローしてしまう。。。
オーバーフローの他に、正規化定数が小さくなりすぎて係数値が吹っ飛ぶ現象も確認。
整数除算についてデバッグと調査を続ける。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(5)</title><link href="/kodetsukuzuo-ri2021chun-5.html" rel="alternate"></link><published>2021-02-25T10:00:00+09:00</published><updated>2021-02-25T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-25:/kodetsukuzuo-ri2021chun-5.html</id><summary type="html">&lt;p&gt;今日は少なくともヘッダエンコード・デコード、ハンドル作成までいっておきたい。
その先は一括エンコード、デコー …&lt;/p&gt;</summary><content type="html">&lt;p&gt;今日は少なくともヘッダエンコード・デコード、ハンドル作成までいっておきたい。
その先は一括エンコード、デコード関数を追加して動作確認フェイズに入りたい。そこでテストを固めてしまうと動きが鈍くなりそうなので、一括エンコード、一括デコード追加中はテスト追加一旦停止で。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(4)</title><link href="/kodetsukuzuo-ri2021chun-4.html" rel="alternate"></link><published>2021-02-24T10:00:00+09:00</published><updated>2021-02-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-24:/kodetsukuzuo-ri2021chun-4.html</id><summary type="html">&lt;p&gt;ディレクトリ構成を固めてみた。
内部依存がある場合がどうなるかわからん。今日コーダーモジュールを持ってくる …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ディレクトリ構成を固めてみた。
内部依存がある場合がどうなるかわからん。今日コーダーモジュールを持ってくるので、そこで何かわかるはず。&lt;/p&gt;
&lt;p&gt;→構成をかえたり、ファイル命名規則を統一したりしていたら1日ほぼ終わった。一応コーディングモジュールは持ってきた。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(3)</title><link href="/kodetsukuzuo-ri2021chun-3.html" rel="alternate"></link><published>2021-02-23T10:00:00+09:00</published><updated>2021-02-23T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-23:/kodetsukuzuo-ri2021chun-3.html</id><summary type="html">&lt;p&gt;cmake+gtestのディレクトリ構成を迷っている。。。&lt;/p&gt;
&lt;p&gt;現在各モジュールごとにtestを作っているが、もしかしたら細かくやりすぎ？
SLA …&lt;/p&gt;</summary><content type="html">&lt;p&gt;cmake+gtestのディレクトリ構成を迷っている。。。&lt;/p&gt;
&lt;p&gt;現在各モジュールごとにtestを作っているが、もしかしたら細かくやりすぎ？
SLAのときでもsrc以下にすべてを入れていたので、それでいいはず。そちらにしよう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;トップレベルにCMakeLists.txtを置く。そこでテストの分岐をこなす。&lt;/li&gt;
&lt;li&gt;src以下に全ソース&lt;/li&gt;
&lt;li&gt;include以下に公開ヘッダ&lt;/li&gt;
&lt;li&gt;test以下にテストソース&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/januswel/ctest-gtest"&gt;サンプル&lt;/a&gt; をよく見ましょう。。。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(2)</title><link href="/kodetsukuzuo-ri2021chun-2.html" rel="alternate"></link><published>2021-02-22T10:00:00+09:00</published><updated>2021-02-22T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-22:/kodetsukuzuo-ri2021chun-2.html</id><summary type="html">&lt;p&gt;テスト環境整備中。&lt;/p&gt;
&lt;p&gt;gtestはC++用のフレームワークのようで、Cコンパイラでビルドするとエラーが出る（ &lt;cite&gt;&amp;lt;limits&amp;gt;&lt;/cite&gt; なんて無い、と …&lt;/p&gt;</summary><content type="html">&lt;p&gt;テスト環境整備中。&lt;/p&gt;
&lt;p&gt;gtestはC++用のフレームワークのようで、Cコンパイラでビルドするとエラーが出る（ &lt;cite&gt;&amp;lt;limits&amp;gt;&lt;/cite&gt; なんて無い、と言われた）。
でも無理やりビルドするためにcmakeの CXX で新しくプロジェクトを作った。
かなり強引にやった。型を中心に色々警告でてるし、C89との差異で苦しむかもしれない。&lt;/p&gt;
&lt;p&gt;さて、フォーマットを決めよう。フォーマットが決まればあとはそのとおり実装していくだけのはずだ。&lt;/p&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;基本設計方針&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;AR(p) Natural Gradientの実装。&lt;/li&gt;
&lt;li&gt;符号はSLAの再帰的ライスを使用する。SLAの実装はそのままでシンボルを変えてポーティングする。&lt;/li&gt;
&lt;li&gt;目標はTTA, Wavpackの圧縮率を超えること。（超えたら対外発表可能とする）&lt;/li&gt;
&lt;li&gt;圧縮性能を試すだけなので、SIMDやアセンブリレベルの過度な高速化はしない。&lt;/li&gt;
&lt;li&gt;無音時のランレングス符号化はあり。&lt;ul&gt;
&lt;li&gt;ひとまずは残差のみで実装していく。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;データの正常性検査はほとんど入れない。（ブロックのシグネチャはあり。CRCはやらない。）&lt;/li&gt;
&lt;li&gt;ひとまずは16bitwavの対応で良い。&lt;ul&gt;
&lt;li&gt;やろうと思えばできるが、複雑化のコストが大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>コーデック作り2021春(1)</title><link href="/kodetsukuzuo-ri2021chun-1.html" rel="alternate"></link><published>2021-02-19T10:00:00+09:00</published><updated>2021-02-19T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-19:/kodetsukuzuo-ri2021chun-1.html</id><summary type="html">&lt;p&gt;さて、コーデックづくりに入ろう。今回は、CMake/C89で作る。
テストもctestを使おうと思っており、その導入検討を行う。&lt;/p&gt;
&lt;p&gt;まず、ctestの …&lt;/p&gt;</summary><content type="html">&lt;p&gt;さて、コーデックづくりに入ろう。今回は、CMake/C89で作る。
テストもctestを使おうと思っており、その導入検討を行う。&lt;/p&gt;
&lt;p&gt;まず、ctestのほかにgoogleが出しているgtestというのがある。これもcmakeとの親和性が良いらしい。
今回はctestで試してみる...と思ったらgtestがいいかも。できないことはないはずなのでやってみよう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gitlab.kitware.com/cmake/community/-/wikis/doc/ctest/Testing-With-CTest"&gt;Testing With CTest&lt;/a&gt; ピンと来ないのでKitware公式情報を見る。&lt;ul&gt;
&lt;li&gt;うーん？どうもCtestは &lt;cite&gt;enable_testing()&lt;/cite&gt; によってテスト用のディレクトリを生成するのを有効化しているだけ？&lt;/li&gt;
&lt;li&gt;&lt;cite&gt;add_test&lt;/cite&gt; でテスト追加。 &lt;cite&gt;make test&lt;/cite&gt; でテスト実行。&lt;/li&gt;
&lt;li&gt;多分、プログラム実行時の返り値だけをみているっぽい。アサーションマクロとかはサポートしていない？？&lt;/li&gt;
&lt;li&gt;それだと gtest が良いということになる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/janus_wel/items/4e6c12f9104f501104c7"&gt;C++ のユニットテストをいい感じにする&lt;/a&gt; がいいかも...と思ったらgtest使ってる。うーん。&lt;ul&gt;
&lt;li&gt;&lt;cite&gt;ExternalProject&lt;/cite&gt; でCMakeの機能でgtestを導入することができる。これで可搬性が担保できそう。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/januswel/ctest-gtest"&gt;GitHubはこちら&lt;/a&gt; 構成はmain除きこれに前ならえでよいはずだ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio Codec"></category></entry><entry><title>\(\mathrm{AR}(p)\) へ一般化(6)</title><link href="/mathrmarp-heyi-ban-hua-6.html" rel="alternate"></link><published>2021-02-12T10:00:00+09:00</published><updated>2021-02-12T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-12:/mathrmarp-heyi-ban-hua-6.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;論文出したけど、自己共分散と自己相関でまだ混乱してる。
実装時には嘘つ …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;論文出したけど、自己共分散と自己相関でまだ混乱してる。
実装時には嘘つけないので整理しないといけない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bookdown.org/gary_a_napier/time_series_lecture_notes/ChapterThree.html"&gt;Chapter 3 Autoregressive processes&lt;/a&gt; 一般のAR(p)モデルの分散の求め方が載ってる。そしてその分散を掛けたものを我々は自己相関と言っている気がする。&lt;ul&gt;
&lt;li&gt;AR(1)なら &lt;span class="math"&gt;\(\sigma_{x}^{2} = \frac{\sigma_{z}^{2}}{1 - \rho^{2}}\)&lt;/span&gt; が分散になる。以下、システムノイズを標準正規分布 &lt;span class="math"&gt;\(N(0,1)\)&lt;/span&gt; とする。すると &lt;span class="math"&gt;\(\sigma_{z}^{2} = 1\)&lt;/span&gt; だから &lt;span class="math"&gt;\(\sigma_{x}^{2} = \frac{1}{1 - \rho^{2}}\)&lt;/span&gt; となる。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\((\ve{K})_{ij} = \rho^{|i-j|}\)&lt;/span&gt; とすると、自己相関行列は &lt;span class="math"&gt;\(\ve{R} = \sigma_{x}^{2}\ve{K} = \frac{1}{1 - \rho^{2}}\ve{K}\)&lt;/span&gt; と書ける。ここで、自己相関行列と自己共分散行列は全く同じものを指しているので注意。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\ve{R}^{-1} = \left(\frac{1}{1 - \rho^{2}}\right)^{-1} \ve{K}^{-1} = \frac{1 - \rho^{2}}{1 - \rho^{2}} \ve{A}^{-1} = \ve{A}^{-1}\)&lt;/span&gt; ここで &lt;span class="math"&gt;\(\ve{A}^{-1}\)&lt;/span&gt; は &lt;a class="reference external" href="https://projecteuclid.org/download/pdf_1/euclid.aoms/1177706636"&gt;共分散の逆を求める論文&lt;/a&gt; で求めたもの。だから、スカラーはキャンセルされて、結局 &lt;span class="math"&gt;\(\ve{A}^{-1}\)&lt;/span&gt; で良かったことになる。おそらく一般の &lt;span class="math"&gt;\(\mathrm{AR}(p)\)&lt;/span&gt; でスカラーがキャンセルされるはず。&lt;/li&gt;
&lt;li&gt;overleafに書いてる &lt;span class="math"&gt;\(\sigma^{2}\)&lt;/span&gt; は &lt;span class="math"&gt;\(\sigma_{x}^{2}\)&lt;/span&gt; と考えればよい…はず。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\ve{R}_{1}^{-1}\)&lt;/span&gt; の替わりに &lt;span class="math"&gt;\(\ve{K}_{1}^{-1}\)&lt;/span&gt; を使ってLMS/Newtonアルゴリズムを実装すると、収束範囲はどうなるか。 &lt;span class="math"&gt;\(\ve{R}_{1} = \frac{1}{1 - \rho^{2}}\ve{K}_{1}\)&lt;/span&gt; だから、 &lt;span class="math"&gt;\(\ve{R}_{1}\)&lt;/span&gt; の固有値 &lt;span class="math"&gt;\(\lambda_{k}\)&lt;/span&gt; に対し &lt;span class="math"&gt;\(\ve{K}_{1}\)&lt;/span&gt; の固有値 &lt;span class="math"&gt;\(\mu_{k}\)&lt;/span&gt; の範囲は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{\sigma_{x}^{2} (1 - \rho^{2})}{1 + 2 \rho + \rho^{2}} &amp;lt; \lambda_{k} &amp;lt; \frac{\sigma_{x}^{2} (1 - \rho^{2})}{1 - 2 \rho + \rho^{2}} \\
\iff \frac{\sigma_{x}^{2}}{1 + 2 \rho + \rho^{2}} &amp;lt; \mu_{k} &amp;lt; \frac{\sigma_{x}^{2}}{1 - 2 \rho + \rho^{2}} \\
\iff \frac{\sigma_{x}^{2}}{(1 + \rho)^{2}} &amp;lt; \mu_{k} &amp;lt; \frac{\sigma_{x}^{2}}{(1 - \rho)^{2}}
\end{align*}
&lt;/div&gt;
&lt;p&gt;これより、一般化固有値問題 &lt;span class="math"&gt;\(\ve{R}\ve{x} = \eta\ve{K}_{1}\ve{x}\)&lt;/span&gt; の最大固有値 &lt;span class="math"&gt;\(\eta_{\max}\)&lt;/span&gt; は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\eta_{\max} &amp;amp;= \max_{\ve{x} \neq \ve{0}} \frac{\ve{x}^{\mathsf{T}}\ve{R}\ve{x}}{\ve{x}^{\mathsf{T}}\ve{K}_{1}\ve{x}} = \max_{\ve{x} \neq \ve{0}} \frac{\ve{x}^{\mathsf{T}}\ve{R}\ve{x}}{\ve{x}^{\mathsf{T}}\ve{x}} \frac{\ve{x}^{\mathsf{T}}\ve{x}}{\ve{x}^{\mathsf{T}}\ve{K}_{1}\ve{x}} \\
&amp;amp;\leq \left( \max_{\ve{x} \neq \ve{0}} \frac{\ve{x}^{\mathsf{T}}\ve{R}\ve{x}}{\ve{x}^{\mathsf{T}}\ve{x}} \right) \left( \min_{\ve{x} \neq \ve{0}} \frac{\ve{x}^{\mathsf{T}}\ve{K}_{1}\ve{x}}{\ve{x}^{\mathsf{T}}\ve{x}} \right)^{-1} \\
&amp;amp;&amp;lt; N\sigma_{x}^{2} \left\{ \frac{\sigma_{x}^{2}}{(1 + \rho)^{2}} \right\}^{-1} = N (1 + \rho)^{2} \\
&amp;amp;&amp;lt; 2N
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。しかし、ここまでやっておいてあれだけど、逆行列は &lt;span class="math"&gt;\(\ve{R}^{-1} = \ve{A}^{-1}\)&lt;/span&gt; で間違いない（わざわざ &lt;span class="math"&gt;\(\ve{K}_{1}^{-1}\)&lt;/span&gt; を計算するのが大変で不自然）ので問題なことが分かった。むしろ問題は標準正規分布と書いてないことだろうか。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Auto Regressive"></category><category term="Inverse Auto Correlation"></category></entry><entry><title>\(\mathrm{AR}(p)\) へ一般化(5)</title><link href="/mathrmarp-heyi-ban-hua-5.html" rel="alternate"></link><published>2021-02-05T10:00:00+09:00</published><updated>2021-02-05T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-02-05:/mathrmarp-heyi-ban-hua-5.html</id><summary type="html">&lt;p&gt;査読が返るまでの間既存手法の調査をやろう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;cite&gt;Simplified Newton-Type Adaptive Estimation Algorithms &amp;lt;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.882.2918&amp;amp;rep=rep1&amp;amp;type=pdf&amp;gt;&lt;/cite&gt; 最初に気になって …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;査読が返るまでの間既存手法の調査をやろう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;cite&gt;Simplified Newton-Type Adaptive Estimation Algorithms &amp;lt;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.882.2918&amp;amp;rep=rep1&amp;amp;type=pdf&amp;gt;&lt;/cite&gt; 最初に気になってた所。バシッと言ってくれてない。FNTF(fast Newton transversal filters)というのが源流かもしれない。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ssp.ece.upatras.gr/moustakides/downloads/journals/ada1991.pdf"&gt;Fast Newton transversal filters--A new class of adaptive estimation algorithms&lt;/a&gt; &lt;a class="reference external" href="https://www.researchgate.net/publication/3314234_Fast_Newton_transversal_filters--A_new_class_of_adaptive_estimation_algorithms"&gt;ここ&lt;/a&gt; からでもいける。とても近いように見えるんだが、、、AR仮定しているし計算量も同等なんだが、、、、適応的に共分散行列の逆を求めているように見受けられる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/d142/4e76ba905ce822bc26d59a97e6c3aa18d412.pdf?_ga=2.17625393.981950394.1612533179-1720100206.1612533179"&gt;Fast LMS/Newton Algorithms Based on Autoregressive Modeling and Their Application to Acoustic Echo Cancellation&lt;/a&gt; これもちょっと前に読んでいる。確かに近いが、コレスキー分解した行列の積を計算しているので遅いのでは…。LPCで求めた係数がコレスキー分解の三角行列に入ってきているのは参考になる。&lt;ul&gt;
&lt;li&gt;上の論文のAlgorithm 2が非常に近いかも。勾配(u)を1時刻ずらして、格子フィルタ通して、その出力結果を最新の勾配にしている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/profile/Behrouz_Farhang-Boroujeny/publication/224400239_Fast_LMSNewton_Algorithms_for_Stereophonic_Acoustic_Echo_Cancelation/links/00b495329e1f99d45c000000/Fast-LMS-Newton-Algorithms-for-Stereophonic-Acoustic-Echo-Cancelation.pdf"&gt;Fast LMS/Newton Algorithms for Stereophonic Acoustic Echo Cancelation&lt;/a&gt; 上の論文の弟子？が書いたステレオチャンネル拡張論文。原理はほぼおなじに見える。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.720.7573&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Analysis of the Stereophonic LMS/Newton Algorithm and Impact of Signal Nonlinearity on Its Convergence Behavior&lt;/a&gt; これも著者ほぼ同じ感じ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.448.3364&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Tracking of Time-Varying Mobile Radio Channels—Part I: The Wiener LMS Algorithm&lt;/a&gt; 一瞬だけ触れている。効率的だと言っている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/publication/3321287_Efficient_least_squares_adaptive_algorithms_for_FIR_transversal_filtering"&gt;Efficient least squares adaptive algorithms for FIR transversal filtering&lt;/a&gt; 前も挙げたと思うけど、包括的な内容。詳しく見てみよう。→パット見、ない。上のFast LMS/Newton...も引用してない。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/profile/Kazushi_Ikeda2/publication/3318680_A_numerically_stable_fast_Newton-type_adaptive_filter_based_on_order_recursive_least_squares_algorithm/links/02e7e53b4b2c3efe52000000/A-numerically-stable-fast-Newton-type-adaptive-filter-based-on-order-recursive-least-squares-algorithm.pdf"&gt;A Numerically Stable Fast Newton-Type Adaptive Filter Based on Order Recursive Least Squares Algorithm&lt;/a&gt; 近いようで、近くない…うーん、はっきりと共分散行列が(2p+1)-重対角行列だと言い切って欲しい…。どうやら、予測係数を更新しながらの手法のようだ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://core.ac.uk/download/pdf/37884714.pdf"&gt;A WAVELET BASED PARTIAL UPDATE FAST LMS/NEWTON ALGORITHM&lt;/a&gt; ウェーブレット係数を適応学習。発想はとても良くて、将来的に使うことになるかも。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Auto Regressive"></category><category term="Inverse Auto Correlation"></category></entry><entry><title>\(\mathrm{AR}(p)\) へ一般化(4)</title><link href="/mathrmarp-heyi-ban-hua-4.html" rel="alternate"></link><published>2021-01-31T10:00:00+09:00</published><updated>2021-01-31T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-01-31:/mathrmarp-heyi-ban-hua-4.html</id><summary type="html">&lt;p&gt;rejectはショックやなあ…コメント悪くなかっただけに…。&lt;/p&gt;
&lt;p&gt;一般化については記述した。残りは調査だと思う。しかし次の論文 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;rejectはショックやなあ…コメント悪くなかっただけに…。&lt;/p&gt;
&lt;p&gt;一般化については記述した。残りは調査だと思う。しかし次の論文書きの期限が迫る。&lt;/p&gt;
</content><category term="雑記"></category><category term="Auto Regressive"></category><category term="Inverse Auto Correlation"></category></entry><entry><title>\(\mathrm{AR}(p)\) へ一般化(3)</title><link href="/mathrmarp-heyi-ban-hua-3.html" rel="alternate"></link><published>2021-01-25T10:00:00+09:00</published><updated>2021-01-25T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-01-25:/mathrmarp-heyi-ban-hua-3.html</id><summary type="html">&lt;p&gt;論文読みを通し、紙に書いた。一般的な逆行列の構造が見えた。かなり美しいし、もうやってるだろという直感がある。。。
し …&lt;/p&gt;</summary><content type="html">&lt;p&gt;論文読みを通し、紙に書いた。一般的な逆行列の構造が見えた。かなり美しいし、もうやってるだろという直感がある。。。
しかし、査読結果が返るまでに勾配更新の一般化までやっておこう。&lt;/p&gt;
&lt;p&gt;どこかで徹底的な調査が必要と考える。&lt;/p&gt;
</content><category term="雑記"></category><category term="Auto Regressive"></category><category term="Inverse Auto Correlation"></category></entry><entry><title>\(\mathrm{AR}(p)\) へ一般化(2)</title><link href="/mathrmarp-heyi-ban-hua-2.html" rel="alternate"></link><published>2021-01-24T10:00:00+09:00</published><updated>2021-01-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-01-24:/mathrmarp-heyi-ban-hua-2.html</id><summary type="html">&lt;p&gt;午前中に &lt;span class="math"&gt;\(p=2\)&lt;/span&gt; のケースをまとめた。やっぱ成り立っている。しかも2次形式はどうも &lt;span class="math"&gt;\(\mathcal{O}(1)\)&lt;/span&gt; で更新できるっぽい。&lt;/p&gt;
&lt;p&gt;午後 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;午前中に &lt;span class="math"&gt;\(p=2\)&lt;/span&gt; のケースをまとめた。やっぱ成り立っている。しかも2次形式はどうも &lt;span class="math"&gt;\(\mathcal{O}(1)\)&lt;/span&gt; で更新できるっぽい。&lt;/p&gt;
&lt;p&gt;午後、一般化のために論文を読み始めた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://projecteuclid.org/download/pdf_1/euclid.aoms/1177706636"&gt;On the Inversion of the Sample Covariance Matrix in a Stationary Autoregressive Process&lt;/a&gt; これ。読めないものでもない。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/648856/how-to-prove-that-the-inverse-of-a-persymmetric-matrix-is-also-persymmetric"&gt;How to prove that the inverse of a persymmetric matrix is also persymmetric?&lt;/a&gt; persymmetricの逆はまたpersymmetricであることの証明。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Auto Regressive"></category><category term="Inverse Auto Correlation"></category></entry><entry><title>\(\mathrm{AR}(p)\) へ一般化(1)</title><link href="/mathrmarp-heyi-ban-hua-1.html" rel="alternate"></link><published>2021-01-23T10:00:00+09:00</published><updated>2021-01-23T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-01-23:/mathrmarp-heyi-ban-hua-1.html</id><summary type="html">&lt;p&gt;手始めに &lt;span class="math"&gt;\(p=2\)&lt;/span&gt; で効率的に計算できることを示すべきだろう。
また、 &lt;span class="math"&gt;\(p=2\)&lt;/span&gt; の場合の自己相関行列がどうなっているかも …&lt;/p&gt;</summary><content type="html">&lt;p&gt;手始めに &lt;span class="math"&gt;\(p=2\)&lt;/span&gt; で効率的に計算できることを示すべきだろう。
また、 &lt;span class="math"&gt;\(p=2\)&lt;/span&gt; の場合の自己相関行列がどうなっているかももう少し見たい。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Auto Regressive"></category><category term="Inverse Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(34) (完)</title><link href="/r-1-noji-suan-34-wan.html" rel="alternate"></link><published>2021-01-22T10:00:00+09:00</published><updated>2021-01-22T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-01-22:/r-1-noji-suan-34-wan.html</id><summary type="html">&lt;p&gt;だいぶ更新が滞ってしまった。しかし何もしてなかったわけではない。&lt;/p&gt;
&lt;p&gt;まずOverleafに結果をまとめていた（実験含め）。AR(1)の …&lt;/p&gt;</summary><content type="html">&lt;p&gt;だいぶ更新が滞ってしまった。しかし何もしてなかったわけではない。&lt;/p&gt;
&lt;p&gt;まずOverleafに結果をまとめていた（実験含め）。AR(1)の自己相関行列の固有値はやっぱり陽に求まらない。存在範囲が示されているだけ。&lt;/p&gt;
&lt;p&gt;1/9にはOverleafの内容を先生に公開した（がまだ見てもらってない・・・）&lt;/p&gt;
&lt;p&gt;1/13に論文のRebuttalがきて、1/15までその対応に追われていた。その次の1/18に進捗発表あるのを失念していて、麻雀CUIをガリガリ書いてた。1/20に進捗発表。「Acoustic Speech &amp;amp; Signal Processing」もしくは「Access」に出すのが良いのではないかという啓示を受ける。&lt;/p&gt;
&lt;p&gt;残った仕事は&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;上記論文誌はどうか見てみる&lt;/li&gt;
&lt;li&gt;既存の手法と被ってないか: これは継続してやる。&lt;/li&gt;
&lt;li&gt;一般の &lt;span class="math"&gt;\(AR(p)\)&lt;/span&gt; について議論する&lt;ul&gt;
&lt;li&gt;逆行列が一般化して書けるか、とても不安&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定常誤差のバウンドを求めたい。&lt;ul&gt;
&lt;li&gt;SAの評価だと上界しかわからない。Widrow本に書いてないか？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ロスレス音声に突っ込む&lt;ul&gt;
&lt;li&gt;これは春やる。長期休みで1つコーデックを作ろう。ウェーブレットを使うアイデアも残っている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;卒論とか落ち着いたら突っ込む事を忘れずに。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; にフォーカスして頑張るのは終わったと思う。連載はここで切り上げて、AR(p)のまとめに全力を入れていく。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(33)</title><link href="/r-1-noji-suan-33.html" rel="alternate"></link><published>2021-01-03T10:00:00+09:00</published><updated>2021-01-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2021-01-03:/r-1-noji-suan-33.html</id><summary type="html">&lt;p&gt;Overleafにまとめようと思ってガリガリ書いてたら、AR(1)の自己相関行列の逆って一様三項行列になっていないことに気 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Overleafにまとめようと思ってガリガリ書いてたら、AR(1)の自己相関行列の逆って一様三項行列になっていないことに気づく。
簡単な式変形で行けないかなと思ったけどうまく行かずハマっていた。
（一様三項行列も差分方程式が出てくるのでかなり手強い。。。）&lt;/p&gt;
&lt;p&gt;5時間くらい苦悶した後にネットの海を泳いで探していた所、AR(1)の逆行列を議論しているところがあった
（AR(1)の自己相関行列はKac--Murdock--Szego (KMS) matrixというらしい）&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://reader.elsevier.com/reader/sd/pii/S0024379599000804?token=77D3B38ACFC349B36FFAE83B2E5AD1E466D8E0D91C45D8A8FBF49228DFBF347B41379B44D26B8E4F99DD26A3856F8E7F"&gt;Asymptotic distribution of the spectra of aclass of generalized Kac--Murdock--Szego matrices&lt;/a&gt; 周辺文献も書いていて有益。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://babel.hathitrust.org/cgi/pt?id=uc1.31822012438206&amp;amp;view=1up&amp;amp;seq=86"&gt;Toeplitz forms and their applications&lt;/a&gt; 上の文献が参照していた。導出が書いてあるかなり広範な文献。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/publication/238877783_Numerical_Solution_of_the_Eigenvalue_Problem_for_Symmetric_Rationally_Generated_Toeplitz_matrices"&gt;Numerical Solution of the Eigenvalue Problem for Symmetric Rationally Generated Toeplitz matrices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/publication/241615223_Properties_of_Some_Generalizations_of_Kac-Murdock-Szego_Matrices"&gt;Properties of Some Generalizations of Kac-Murdock-Szeg ̈o Matrices&lt;/a&gt; いろいろなKMS行列に対して固有値を計算している。どこかで刺さるかも。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;問題は、バシッとした固有値が書かれていないところか。固有値の満たす範囲を示している。そして導出ちゃんと見てない。明日見よう。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\lambda_{k} &amp;amp;= \frac{1 - \rho^{2}}{1 + \rho^{2} - 2\rho\cos \theta_{k}} \\
&amp;amp; \frac{(k-1)\pi}{n+1} &amp;lt; \theta_{k} &amp;lt; \frac{k\pi}{n+1} \quad k = 1, ..., n
\end{align*}
&lt;/div&gt;
&lt;p&gt;一方、一様三項行列の固有値は &lt;span class="math"&gt;\(\lambda_{k} = \frac{1 - \rho^{2}}{1 + \rho^{2} - 2\rho\cos\left( \frac{k\pi}{n+1} \right)}\)&lt;/span&gt; となっている。つまり、KMSの方は僅かに角度が小さくて、それ以外は全く同じということになる。また &lt;span class="math"&gt;\(n\)&lt;/span&gt; を大きくしていけばその差はどんどん狭まる。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(32)</title><link href="/r-1-noji-suan-32.html" rel="alternate"></link><published>2020-12-29T10:00:00+09:00</published><updated>2020-12-29T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-29:/r-1-noji-suan-32.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;追加調査。今日まで見てみてなさそうであれば追加実験に入る。実信号のパ …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;追加調査。今日まで見てみてなさそうであれば追加実験に入る。実信号のパフォーマンスが気になっている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.stanford.edu/class/stats253/lectures/lect6.pdf"&gt;Autoregressive Processes in Time&lt;/a&gt; 前にもみたけどもう一度挙げる。本質的な指摘はここでされている。論文があってもおかしくない。&lt;ul&gt;
&lt;li&gt;自己共分散行列の逆の解釈もされているから、目を通すべきか。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.882.2918&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Simplified Newton-Type Adaptive Estimation Algorithms&lt;/a&gt; これもほぼ同じことを言ってる。少なくとも入力データをAR(p)と見做すという仮定は全く同一。精読がいる。通しで軽く読んでみた。うーん、再帰的に &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; に該当する行列を求めているようで、効率が良さそう。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ssp.ece.upatras.gr/moustakides/downloads/journals/ada1991.pdf"&gt;Fast Newton transversal filters-A new class of adaptive estimation algorithms&lt;/a&gt; その筆者がFNTFとして提案した論文。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/d142/4e76ba905ce822bc26d59a97e6c3aa18d412.pdf?_ga=2.31362239.1402051301.1609139051-1178548257.1609139051"&gt;Fast LMS/Newton Algorithms Based on Autoregressive Modeling and Their Application to Acoustic Echo Cancellation&lt;/a&gt; 昨日挙げた論文。&lt;ul&gt;
&lt;li&gt;やっぱり陽に逆行列を求めてはいないように見える。（むしろ、 &lt;span class="math"&gt;\(R^{-1}x\)&lt;/span&gt; を直接推定することに重きがある）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;格子フィルタで再帰的に行列要素を求めているのは大変参考になる。&lt;/strong&gt; 定数倍除きあってればいいので、いまやろうとしていることに組み込めないか？&lt;/li&gt;
&lt;li&gt;実験でFNTFを叩いてる。収束が極端に遅くなるケースがある、とのこと。特に特性が急に変わるケース。多分 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; が適応できてないんだと思ふ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まとめ。近いこと言ってると思うんだけど、どの論文もなぜか &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; がn重対角行列であることを指摘していない。もう、結果まとめて上に回そう。&lt;/p&gt;
&lt;p&gt;追加実験:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;分散は入力データ全体を見て計算し、更新しない。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;i.i.d.のときの性能はLMSと一致するか&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;一致を確認。ついでに &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; が単位行列に近くなっていることも確認。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;相関を変えたときの性能はどうか&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LMSより優位に収束が早くなる。&lt;/li&gt;
&lt;li&gt;定常誤差が少し持ち上がる。←相関を上げると顕著。行列要素が大きくなり、勾配もでかくなっていると想像。&lt;/li&gt;
&lt;li&gt;LMSより安定した学習曲線になっているように見える←要観察。前サンプルを使っているのが功奏している？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;相関付き雑音でフィルタ次数を変えたときはどうか&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2は当然早い（降下時SAより早いのが気になった。また、NLMSは暴れ気味）&lt;/li&gt;
&lt;li&gt;大きくしていくと定常誤差が大きくなっていく。同時に、NLMSの収束が遅くなっている&lt;/li&gt;
&lt;li&gt;50で完全にNLMSより収束が早い。&lt;/li&gt;
&lt;li&gt;100でLMSは発散、AR(1)はNLMSより早く収束。ただし定常誤差は悪目。&lt;/li&gt;
&lt;li&gt;500ではLMSもろとも発散した。学習係数設定が悪そう。→0.01から0.001にしたらちゃんと収束する方向に進んだ。ちゃんと固有値解析すれば収束条件が得られるはず。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;実データでLMSより良くなるか&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;ステップサイズを大きく取ると発散する。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;小さく取ればNGSAに近い性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;実データでの &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; も対角優位になってるかチェックしとく。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;なっていなそう。&lt;/strong&gt; 行列の中心が最大で、それから端っこに行くに従って小さくなる。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="聖者の行進の5000-10000サンプルにおける自己相関行列(左から真値, AR(1), 絶対値誤差)" src="./images/realdata_inv_cutocorr_gt_and_ar1.png" style="width: 400px;" /&gt;
&lt;/div&gt;
&lt;div class="figure"&gt;
&lt;img alt="聖者の行進の5000-10000サンプルにおける自己相関行列(左から真値, glasso, 絶対値誤差)" src="./images/realdata_inv_cutocorr_gt_and_gl.png" style="width: 400px;" /&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;これはどう説明できるだろうか。AR(p)のpを増やせばいくらか中心を大きく持っていけるが、MA要素もあるとしか。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;glassoと近いのはポジれる。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;glassoと近く、スパースな &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; で計算できているのは理想的であると考える。&lt;/p&gt;
&lt;p&gt;明日以降、学習曲線の追加実験を行っていく。
また、以前計算を投げてしまった事項が気になっている。AR(1)の &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; は単位行列+対称行列の形に表せる。これとベクトルの積はどういった意味があるのか。幾何学的意味も含めて少し考えてみたい。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(31)</title><link href="/r-1-noji-suan-31.html" rel="alternate"></link><published>2020-12-27T10:00:00+09:00</published><updated>2020-12-27T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-27:/r-1-noji-suan-31.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.cmu.edu/~andrewgw/andrewgwthesis.pdf"&gt;Covariance Kernels for Fast Automatic Pattern Discovery and Extrapolation with Gaussian Processes&lt;/a&gt; これの61p.あたり。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mloss.org/revision/view/1639/"&gt;Toeblitz Toolkit for Fast Toeplitz Matrix Operations 1.03&lt;/a&gt; Toeplitz行列を …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.cmu.edu/~andrewgw/andrewgwthesis.pdf"&gt;Covariance Kernels for Fast Automatic Pattern Discovery and Extrapolation with Gaussian Processes&lt;/a&gt; これの61p.あたり。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mloss.org/revision/view/1639/"&gt;Toeblitz Toolkit for Fast Toeplitz Matrix Operations 1.03&lt;/a&gt; Toeplitz行列をFFTで解くやつのライブラリ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ミソは、 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; そのものではなく、 &lt;span class="math"&gt;\(R^{-1}x\)&lt;/span&gt; をFFTを使って求めるということにあると思ふ。&lt;/p&gt;
&lt;p&gt;で、再開して手元でメモをとっているが、AR(p)が俄然悪い。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;背景雑音が悪さしてないか。背景雑音を-200dB（ほぼ0）に。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;傾向変わらず。ゆらぎが小さくなった程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;そういえば、なぜ AR(p) のオフセットが乗っているのか。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;SAのステップサイズを高めた状態に対応するものかと思っていたが、違うようだ。SAと同じ定常誤差になるようにステップサイズを設定しても収束が遅い。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;条件数悪化が原因ではないかと考えているので、S-MとAR(1)で求まった &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; の固有値をJupyterで観察してみた。すると、&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="S-Mの固有値変化" src="./images/NGSA_eigvals.png" style="width: 400px;" /&gt;
&lt;/div&gt;
&lt;div class="figure"&gt;
&lt;img alt="AR(1)の固有値変化" src="./images/NGSAAR1_eigvals.png" style="width: 400px;" /&gt;
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;条件数はS-MとAR(1)でほぼ同じ（30付近をフラフラ。N=5, 相関0.8）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;S-Mの固有値が指数的な減少をしている&lt;/strong&gt; 。一方のAR(1)の方はほぼ一定の固有値。&lt;/li&gt;
&lt;li&gt;そういえば、S-Mの &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; と真の &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; を比較するときはノルムを1に揃えていた。要素の大きさは加味していなかった。&lt;/li&gt;
&lt;li&gt;条件数が変わらないで固有値が減っているということは、&lt;strong&gt;S-Mは行列要素が小さくなっており、そしてそれが本質的に収束を早めることに寄与している。&lt;/strong&gt; AdaGradの如く、最初は勾配を大きくとり、徐々に勾配を小さくすることが有効になっているっぽい。&lt;ul&gt;
&lt;li&gt;AR(1)の &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; を1ノルム化したら定常誤差がNGSAと同等になった（ただし、収束は悪化）&lt;/li&gt;
&lt;li&gt;NGSAの &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; を1ノルム化にしたら性能悪化した（定常誤差大）&lt;/li&gt;
&lt;li&gt;AR(1)の &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; は真値ともよく一致しているので、足りないのはこの点だと思う。 &lt;strong&gt;学習が進むにつれて行列要素を小さくする必要がある。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;観察から、 &lt;strong&gt;誤差に応じて行列要素の大きさを変えるべき&lt;/strong&gt; であることが分かった。つまり、誤差の符号だけではなく、誤差の絶対値を使うべきである。そしてそれはNewton/LMSと同一。&lt;/p&gt;
&lt;p&gt;Newton/LMSの &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; を &lt;span class="math"&gt;\(\mathcal{O}(pN)\)&lt;/span&gt; で計算できるのは旨味がある。既存研究があるはず。調査してみる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/d142/4e76ba905ce822bc26d59a97e6c3aa18d412.pdf?_ga=2.31362239.1402051301.1609139051-1178548257.1609139051"&gt;Fast LMS/Newton Algorithms Based on Autoregressive Modeling and Their Application to Acoustic Echo Cancellation&lt;/a&gt; 発想としてはもうほぼ同一なんだけど、なぜか、本当に何故か &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; をn-重対角行列としてない。これ、明日腰を据えて読んでみよう。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://my.ece.utah.edu/~hrao/Journal09.pdf"&gt;Fast LMS/Newton Algorithms for Stereophonic Acoustic Echo Cancelation&lt;/a&gt; ちゃんと読んでない。ほぼ同じはず。行列や固有値の観察もあるのに、これも同様に何故かn重対角行列にしてない。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://home.eng.iastate.edu/~julied/classes/ee524/articles/firlmsfilters.pdf"&gt;Efficient least squares adaptive algorithms for FIR transversal filtering&lt;/a&gt; 古いけど、上記含め俯瞰的に触れている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.mdpi.com/1999-4893/12/1/4/htm"&gt;On Fast Converging Data-Selective Adaptive Filtering&lt;/a&gt; NNGSAと全く同じ手法が提案されておる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://sc.enseeiht.fr/doc/Seminar_Bermudez.pdf"&gt;Adaptive Filtering - Theory and Applications&lt;/a&gt; 適応フィルタの包括的まとめ。京大林先生並みにまとめてある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;祈るような感じで探している…。今の所なさそうに見えるが…。&lt;/p&gt;
&lt;p&gt;もう一回調べて、無ければ、追加実験の後にoverleaf執筆に入ろうかな。
一旦寝て、再度調査してみてからにしよう。落ち着いてからのほうがよい。実データで悪いかもしれないし。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(30)</title><link href="/r-1-noji-suan-30.html" rel="alternate"></link><published>2020-12-24T10:00:00+09:00</published><updated>2020-12-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-24:/r-1-noji-suan-30.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;まずはCGについての質問を投げておく。
KWBT先生にメール出す前にCGの状況 …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;まずはCGについての質問を投げておく。
KWBT先生にメール出す前にCGの状況を要約してみよう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;a class="reference external" href="http://www.cs.cmu.edu/~pradeepr/convexopt/Lecture_Slides/conjugate_direction_methods.pdf"&gt;Conjugate Gradient Descent&lt;/a&gt; 後ろの方で 、普通の共役勾配方でもモーメンタムがかかっていることを言っている。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;a class="reference external" href="https://users.ece.cmu.edu/~xinli/classes/cmu_18660/Lec23.pdf"&gt;18-660: Numerical Methods for Engineering Design and Optimization&lt;/a&gt; pre-conditioning（前処理）で共役勾配の性能を維持する方法を紹介。前処理はコレスキー分解に基づいている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://stanford.edu/class/ee364b/lectures/conj_grad_slides.pdf"&gt;Conjugate Gradient Method&lt;/a&gt; こっちは理論的にもかなり有益そう。もうちょっと見よう。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.slis.tsukuba.ac.jp/~fujisawa.makoto.fu/cgi-bin/wiki/index.php?%CF%A2%CE%A91%BC%A1%CA%FD%C4%F8%BC%B0%A1%A7%B6%A6%CC%F2%B8%FB%C7%DB%CB%A1#da9ac0ee"&gt;連立1次方程式：共役勾配法&lt;/a&gt; 日本語で言ったもの。一般に条件数が悪いと収束特性は悪化する。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.uio.no/studier/emner/matnat/ifi/nedlagte-emner/INF-MAT4350/h08/undervisningsmateriale/chap15slides.pdf"&gt;The Conjugate Gradient Method&lt;/a&gt; 条件数と収束特性の式が書いてある。 &lt;span class="math"&gt;\(\ve{Ax} = \ve{b}\)&lt;/span&gt; を解くことを考えたときに、 &lt;span class="math"&gt;\(\kappa = \frac{\lambda_{\mathrm{max}}}{\lambda_{\mathrm{min}}}\)&lt;/span&gt; を &lt;span class="math"&gt;\(\ve{A}\)&lt;/span&gt; の条件数とすると、&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{|| \ve{x} - \ve{x}_{k} ||_{\ve{A}}}{|| \ve{x} - \ve{x}_{0} ||_{\ve{A}}} \leq 2\left( \frac{\sqrt{\kappa} - 1}{\sqrt{\kappa} + 1} \right)^{k}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;条件数が大きくなると右辺は1に近づき、左辺のノルム比が減りづらくなって収束が遅くなることを示唆している。条件数が1より少し大きいときがベストの挙動か。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なぜ共役勾配が相関付きで悪いのかが分かった。一般に共役勾配法は条件数が悪いと収束特性が悪くなる。そして、次数を上げると条件数は悪化する…ということだと思う。条件数を見てみましょう。&lt;/p&gt;
&lt;p&gt;実験の結果、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;相関付きノイズで自己相関行列の条件数が増大すること&lt;/li&gt;
&lt;li&gt;同一の相関付きノイズで次数を高めると自己相関行列の条件数が増大すること&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が分かった。共役勾配法の限界にぶつかってしまったらしい。&lt;/p&gt;
&lt;p&gt;しかし得たものものある。共役勾配法はモーメンタムがかかっているということだ。
AR(p)の逆行列を組み込んでやればええのではないか。&lt;/p&gt;
&lt;p&gt;やってみた。がそもそも収束しない。暴れまくる。
&lt;span class="math"&gt;\(\ve{Hm} = \delta f\)&lt;/span&gt; だから脳死で &lt;span class="math"&gt;\(\ve{H} \ve{m}[n] = \delta f[n] \Rightarrow \ve{m}[n] = \ve{H}^{-1} \delta f[n]\)&lt;/span&gt; 成り立つだろとか思っていたけど、成り立っていなさそう（実験的に確かめた）。なぜなら &lt;span class="math"&gt;\(\ve{m}\)&lt;/span&gt; は逐次的に更新しているから。&lt;/p&gt;
&lt;p&gt;あと、共役勾配法の自己相関行列の更新は &lt;span class="math"&gt;\(\ve{R} \leftarrow \lambda \ve{R} + (1 - \lambda) \ve{x} \ve{x}^{\mathsf{T}}\)&lt;/span&gt; では性能が非常に悪く、 &lt;span class="math"&gt;\(\ve{R} \leftarrow \lambda \ve{R} + \ve{x} \ve{x}^{\mathsf{T}}\)&lt;/span&gt; でないとだめ。これは確かに指数移動平均の極限で見たな。確かに前者が正しい。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(29)</title><link href="/r-1-noji-suan-29.html" rel="alternate"></link><published>2020-12-23T10:00:00+09:00</published><updated>2020-12-23T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-23:/r-1-noji-suan-29.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;うーん、一週間抜けてしまった。木は講義+事務、金土日はマジミラ、月は講義+事 …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;うーん、一週間抜けてしまった。木は講義+事務、金土日はマジミラ、月は講義+事務、火はゼミ+レポ、水曜日はレポ。
こう書くと言い訳がましい。年末は研究にしたい。。実家にも帰れないし。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(28)</title><link href="/r-1-noji-suan-28.html" rel="alternate"></link><published>2020-12-16T10:00:00+09:00</published><updated>2020-12-16T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-16:/r-1-noji-suan-28.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;貰ったコメント&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;CGがうまく行かないのはKWBT先生に相談すべき。&lt;ul&gt;
&lt;li&gt;なるはや。状 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;貰ったコメント&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;CGがうまく行かないのはKWBT先生に相談すべき。&lt;ul&gt;
&lt;li&gt;なるはや。状況をまとめてメールを送る。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AR(p)がうまく行かないのは、AR以上のダイナミクスがデータにあるからでは？（AR(p)では表現できてない）&lt;ul&gt;
&lt;li&gt;AR(p)は &lt;span class="math"&gt;\(\varepsilon[n]\)&lt;/span&gt; がi.i.d.として定式化されるが、そうなってない。&lt;/li&gt;
&lt;li&gt;ARモデルに合った（AR過程に従って生成した）データに対して実験すべきでは？&lt;ul&gt;
&lt;li&gt;都合の良いデータに対して実験してよし。モデルは都合よくていい。そこから話を作っていい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;モデルの方をリッチにする。ARMAとか、雑音に相関がある場合を組み込んでしまう。&lt;/li&gt;
&lt;li&gt;そもそも、実信号データに対してARモデルはどこまで誤差を減らせるのか？&lt;ul&gt;
&lt;li&gt;Wiener-Hopf解のときの誤差と比較せよ、と理解した。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2021年4月まではなんとか粘れる。粘るのだ。方針としては悪くないように見える。
しっかしロスレスを絶対忘れたくない。ということで、TODOを入れておく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;春はDWTを使ったロッシーなコーデックを作ろう。&lt;/li&gt;
&lt;li&gt;論文著者に対する連絡を忘れずに出す。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(27)</title><link href="/r-1-noji-suan-27.html" rel="alternate"></link><published>2020-12-12T10:00:00+09:00</published><updated>2020-12-12T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-12:/r-1-noji-suan-27.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;AR(1), AR(2), 共役勾配は「低次ならうまくいく」という主張が本当か確かめたい …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;AR(1), AR(2), 共役勾配は「低次ならうまくいく」という主張が本当か確かめたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;全く逆の結果が出てきている。AR(p), 高次にしたときに強いように見える。&lt;ul&gt;
&lt;li&gt;128, 256, 512にすると収束速度がNGSAを上回る。。。。（定常誤差は悪い。注意。）&lt;ul&gt;
&lt;li&gt;512にすると計算量がはんぱない。。その場合AR(p)はSAよりも僅かに良い程度。&lt;/li&gt;
&lt;li&gt;256以上の高次環境下では、NGSA(Sharman-Morrison)はSAよりも収束特性が悪くなっている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;スパース制約（相関は低次までしかないという仮定）が効いている？&lt;/li&gt;
&lt;li&gt;高次でも、i.i.d.雑音はやはりSAと同等になる。&lt;ul&gt;
&lt;li&gt;高次の場合、Sharman-Morrison式は悪化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定常誤差は気になる。相関付き雑音だと最終的な定常誤差はSA, NGSA(Sharman-Morrison)より悪い。&lt;ul&gt;
&lt;li&gt;これが致命的かもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;初期の残差が気になるから、リファレンス係数のノルムを1にしたらSAが一番強くなった。&lt;ul&gt;
&lt;li&gt;これは問題を過度に優しくしている恐れがある。回答を単位超球上に制限している。&lt;/li&gt;
&lt;li&gt;全次元[-1,1]から一様乱数で選んだほうが遥かに難しい。ノルムを1にするというのは次元の呪いから開放されて議論しているので、おそらく正しくない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;実際のデータ突っ込んだときにどうなるか？&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;悪い。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;AR(1), AR(2)仮定は激烈に悪い。SAより悪い。定常性がないから入力全体で平均取るのをやめて指数移動平均に任せてみたけど、やっぱり悪い。&lt;/li&gt;
&lt;li&gt;CGベース手法も割と悪い。SAと同程度。定常じゃないからと思って忘却係数を小さくとっても同じ。&lt;/li&gt;
&lt;li&gt;実データもまた自己相関行列を観察するところから始めなければならないので、深追いするのはやめる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実データにたいして良くないことが分かった所でタイムアップ。京都に向かう。&lt;/p&gt;
&lt;p&gt;また、共役勾配の処理順序を変えたらなぜうまく行ったのか、金谷本と何が違うのかを見たい…がこれは厳しいか。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jnns/20/2/20_62/_pdf"&gt;正準相関分析&lt;/a&gt; ちょっと気になった。良い解説。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(26)</title><link href="/r-1-noji-suan-26.html" rel="alternate"></link><published>2020-12-11T10:00:00+09:00</published><updated>2020-12-11T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-11:/r-1-noji-suan-26.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;木曜日が潰れているのあんまり良くない。平日あまり進捗が出ていないの …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;木曜日が潰れているのあんまり良くない。平日あまり進捗が出ていないのは健全とは言えない。総受けでやりすぎている可能性を疑い、タスクを減らすべきかと感じている。&lt;/p&gt;
&lt;p&gt;今日は共役勾配法ベース手法の性能観察を行う。
土曜日までに各手法の状態をまとめて、来週月・火は報告内容をまとめていくことに集中する。&lt;/p&gt;
&lt;p&gt;基本的なところでは12/8に書いた内容と同じ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;i.i.d.でSharman-Morrison式とほぼ同等の性能（少し悪い）&lt;/li&gt;
&lt;li&gt;相関付き雑音でi.i.dと同じステップサイズ・忘却係数に設定していると爆裂に性能が悪くなる。（1000サンプル以内で全く定常状態に入らない）&lt;ul&gt;
&lt;li&gt;ステップサイズを大きくとってもあまり良くならない。大きくとると開始直後悪化。&lt;/li&gt;
&lt;li&gt;忘却係数を小さく取ると収束はするが定常誤差大。&lt;/li&gt;
&lt;li&gt;eta（共役勾配法の線形結合係数に乗じるパラメータ）を1.0未満にすると収束性能悪化。&lt;/li&gt;
&lt;li&gt;共役勾配法の他手法も試してみるか。&lt;ul&gt;
&lt;li&gt;Polak-Ribi`ere(PR)を使うと少しは相関に強そうな挙動を見せる。&lt;ul&gt;
&lt;li&gt;しかし、定常誤差が大きくなるような傾向。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Fletcher-Reeves(FR)は共役勾配が発散する。&lt;/li&gt;
&lt;li&gt;Hestenes-Stiefel(HS)は収束が遅い。&lt;ul&gt;
&lt;li&gt;ステップサイズを高くしても遅い。&lt;/li&gt;
&lt;li&gt;etaを変えても悪化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dai-Yuan(DY)もHSと同じく収束が遅い。&lt;ul&gt;
&lt;li&gt;ステップサイズを高くしても遅い。&lt;/li&gt;
&lt;li&gt;etaを変えても悪化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;うーん。良くない。そもそもなんで悪くなったかを考えるべきでは？&lt;ul&gt;
&lt;li&gt;悪条件だから、というのがあるはず。相関係数を変えてみてみる。&lt;ul&gt;
&lt;li&gt;0.1-0.2ではデフォルトとあまり変わらない。&lt;/li&gt;
&lt;li&gt;0.3あたりからプラトーというか収束が遅くなるような挙動を見せ始める。ただしSharman-Morrison式と同等の定常誤差に落ち着く&lt;/li&gt;
&lt;li&gt;0.5では完全に収束曲線が &amp;quot;膨らむ&amp;quot;。尾根に引っかかっていると思う。&lt;/li&gt;
&lt;li&gt;0.8では1000サンプル以内で収束しない。しかし、10000サンプルまで伸ばしてみてみると、定常誤差がSharman-Morrison式よりも小さくなる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;係数次数を大きく取ると傾向が顕著。逆に小さければ、相関が大きくても性能悪化が目立ちにくくなる。&lt;ul&gt;
&lt;li&gt;低次（とくに2）だと、共役勾配の二次の定式化が効いているのかもしれない。&lt;/li&gt;
&lt;li&gt;次数が上がるに従って勾配の広がり（残差勾配）が高次化してしまい、却って性能悪化に転じてしまう？&lt;/li&gt;
&lt;li&gt;AR(1), AR(2)も含めたまとめ方としては、「低次ならうまくいく」かもしれない。。。後ろ向きやなあ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(25)</title><link href="/r-1-noji-suan-25.html" rel="alternate"></link><published>2020-12-08T10:00:00+09:00</published><updated>2020-12-08T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-08:/r-1-noji-suan-25.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;共役勾配法を動くようにした。。。修正内容は、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;係数更新が先、共役勾配の更新を …&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;共役勾配法を動くようにした。。。修正内容は、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;係数更新が先、共役勾配の更新を後&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;論文の順序に合わせた結果。しかしなぜうまく行ったのか分かっていない。&lt;/li&gt;
&lt;li&gt;金谷先生の本では係数更新が後、これではうまく行かない（発散する）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sharman-Morrison式で &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; を更新&lt;ul&gt;
&lt;li&gt;これは観察からこっちが正しいことが見えている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能としては、i.i.d.でSharman-Morrison式とほぼ同等、相関付き雑音でSAと性能が近くなっているように見える。要観察。&lt;/p&gt;
&lt;p&gt;AR(1), AR(2)モデル仮定での &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を使う手法は、結局あんまりよくないという所で落ち着きそう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;i.i.d.雑音の場合はSAと同程度（ &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; は単位行列になる）&lt;ul&gt;
&lt;li&gt;理論的にも問題ないけど、性能が良くならないのはつらい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相関付き雑音の場合は、収束は早くなるが定常誤差が悪化。&lt;ul&gt;
&lt;li&gt;定常誤差を良くするためにステップサイズを小さくしていくとSAと一致してしまう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(24)</title><link href="/r-1-noji-suan-24.html" rel="alternate"></link><published>2020-12-07T10:00:00+09:00</published><updated>2020-12-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-07:/r-1-noji-suan-24.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;(23)の所でずっと詰まっていた。イベントを通り抜ける。その最中、そういえば …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;(23)の所でずっと詰まっていた。イベントを通り抜ける。その最中、そういえば共分散行列を忘却係数付きで更新し、その逆行列を求めたときどうなるかを確かめていないことを思い出した。&lt;/p&gt;
&lt;p&gt;すると、共分散行列の更新則の違いで差が出ていることが分かった。忘却係数を &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; とすると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{R}[n+1] &amp;amp;\leftarrow \lambda \ve{R}[n] + (1 - \lambda) \ve{x}[n] \ve{x}[n]^{\mathsf{T}} \tag{1} \\
\ve{R}[n+1] &amp;amp;\leftarrow \lambda \ve{R}[n] + \ve{x}[n] \ve{x}[n]^{\mathsf{T}} \tag{2}
\end{align*}
&lt;/div&gt;
&lt;p&gt;の2つの更新則が考えられる。(1)は普通の指数移動平均、(2)はRLSとかの更新則。そして、(1), (2)の性能を比べると、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;(1)は詰まっていた所の性能と同じ性能。&lt;ul&gt;
&lt;li&gt;i.i.d.の場合はSAと同等&lt;/li&gt;
&lt;li&gt;相関付きの場合は一旦SAより早めに残差が落ちるが、その後残差悪化に転じて定常誤差が大きい状態になってしまう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(2)はSherman-Morrison式NGSAと同等の性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あれ？(2)が正しいんだっけ？
おかしいと思ってもう一度適応フィルタ本（Heykin）を見たら、やはり(2)が正しい。(2)の更新則によってRLSが成り立っている。また、(2)で &lt;span class="math"&gt;\(\ve{R}[1] = \ve{I}\)&lt;/span&gt; とするのはL2正則化に該当する。&lt;/p&gt;
&lt;p&gt;すると(2)の方式を採用しつつ、逆行列のAR(1)近似が取れればよいということになるが、標本分散を(2)の方式で更新してみても全く性能が良くない。&lt;/p&gt;
&lt;p&gt;あがいてレバガチャしてしまう前に、(2)で求められている &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; の観察を開始。（もしかして共役勾配法も(2)でやればうまくいくのか…？）&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(23)</title><link href="/r-1-noji-suan-23.html" rel="alternate"></link><published>2020-12-03T10:00:00+09:00</published><updated>2020-12-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-03:/r-1-noji-suan-23.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;glassoが自己相関行列を指数移動平均で更新したら、NGSAとほぼ同等の性能を出 …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;glassoが自己相関行列を指数移動平均で更新したら、NGSAとほぼ同等の性能を出していたので、その観察から、
モーメンタムを込めながらAR(1)仮定の高速計算ができないか、で今考え中。&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;摂動展開&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;詰まってる。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\lambda \ve{R} + \ve{M})^{-1} \approx \lambda^{-1}\ve{R}^{-1} - \lambda^{-2} \ve{R}^{-1}\ve{M}\ve{R}^{-1}
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;となるけど、それをどうする？右辺第二項の計算で &lt;span class="math"&gt;\(\mathcal{O}(N^{2})\)&lt;/span&gt; なのがうーんという感じ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;AR(1)仮定での &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; の構造に着目する&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{R}^{-1} = \ve{I}
- \rho \left[ \begin{array}{cccc}
  0 &amp;amp; 1      &amp;amp;        &amp;amp;   \\
  1 &amp;amp; 0      &amp;amp; \ddots &amp;amp;   \\
    &amp;amp; \ddots &amp;amp; \ddots &amp;amp; 1 \\
    &amp;amp;        &amp;amp; 1      &amp;amp; 0 \\
  \end{array} \right]
+ \rho^{2} \left[ \begin{array}{ccccc}
  0 &amp;amp;   &amp;amp;        &amp;amp;   &amp;amp;   \\
    &amp;amp; 1 &amp;amp;        &amp;amp;   &amp;amp;   \\
    &amp;amp;   &amp;amp; \ddots &amp;amp;   &amp;amp;   \\
    &amp;amp;   &amp;amp;        &amp;amp; 1 &amp;amp;   \\
    &amp;amp;   &amp;amp;        &amp;amp;   &amp;amp; 0 \\
  \end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;というふうに分解できるから、 &lt;span class="math"&gt;\(\rho\)&lt;/span&gt; に摂動を加えるなりしたら何か起こらないかなあと思ってるんだけど、良さげな更新則は出てこない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;AR(2)仮定を探る&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;真の &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を見ていると、5重対角行列成分も無視できないくらいある。陽に求まるはず。&lt;ul&gt;
&lt;li&gt;でも、モーメンタムから目をそらすことになってしまいそう。i.i.d.のときの性能は変わらないはず。&lt;/li&gt;
&lt;li&gt;それでも試すだけ試してみるか&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ARMAまで手を伸ばしたらあった。もう少し探る。 &lt;a class="reference external" href="https://library.wolfram.com/infocenter/MathSource/5723/#downloads"&gt;Inverse of the Covariance Matrix of ARMA(p,q) Time Series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ism.ac.jp/editsec/aism/pdf/062_5_0967.pdf"&gt;Statistical inference for functions of the covariance matrix in the stationary Gaussian time-orthogonal principal components model&lt;/a&gt; これのpp.979が答えでは？うん、答えだわ。使ってみようぜ。&lt;/li&gt;
&lt;li&gt;&lt;cite&gt;On the inversion of the sample covariance matrix in a stationary autoregressive process &amp;lt;https://projecteuclid.org/download/pdf_1/euclid.aoms/1177706636&amp;gt;__&lt;/cite&gt; 引用している論文。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=&amp;amp;ved=2ahUKEwj3wfbw7bTtAhVNJaYKHeE5BeQQFjABegQIAxAC&amp;amp;url=https%3A%2F%2Fwww.sid.ir%2FFileServer%2FJE%2F10012004A204&amp;amp;usg=AOvVaw2O9EqdHNmqDdro32aAFB7V"&gt;THE INVERSE OF COVARIANCE MATRICES FOR THE ARMA (p, q) CLASS OF PROCESSES*&lt;/a&gt; 昨日に引き続き。これは包括的に結果のみを述べてる。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://watermark.silverchair.com/60-1-193.pdf?token=AQECAHi208BE49Ooan9kkhW_Ercy7Dm3ZL_9Cf3qfKAc485ysgAAAqgwggKkBgkqhkiG9w0BBwagggKVMIICkQIBADCCAooGCSqGSIb3DQEHATAeBglghkgBZQMEAS4wEQQMCZNl7JbYxA_CjO0KAgEQgIICW85GXJBCY8NesN8BBLt6LmnsJxhYFHRTCUjzCd9LiHZkm6ztS4fBeyXN8_umUkHYiUW08GdJ7gV4paSnBsylGuSzdSVx3hfRdOKWMQ0_SNRAfYgfNC4OwZAm1lMMGCe543EtFABcGDbPWtK5NMW0J9-svryZAHDSAtRlZbMXB_vMftrYeTB2VpVwrYhuRlx8YfvXG7OXttk_UplS8T6kC9v_qEXW2Pa9dqB6tYB1Dhm0t9-1vMKr8LedPAt7NccTlfCLFbViEXpDrwuKkQcctgab8tstd86L_CkNqijOxSdmA6ZbH2AdOmNLztGXJdL7_zVtP1xa9SVU7VOO3ORZX2Q8XHhO8bk6vCjDnbOdWasI8z040Xb1aiI65VbANSEu9IEAPZSYdc-06WQaihgH3TmMyc9GC93Ue9nWAk--jbdtrYJqSeukMXfa_aIM4dmIS0OHWfvTcc0dXtlAWST5HaRh_LNNtlBl_iQ0A4rENRbrtHSZvLo2jdeGlgAPMNT0QwTare-B3rrPcM7icppYuxdteFbxBp6PaTGdEG22eE-eeCS34zR6XFgHia3AGESzvsSvAs6WjVZtT8BhQSQX2olWlrHRPPmW8AP4lBeR3ceXgaXae7dn2bEjzSjh5iEWteJSXMfLR9jataZnKWoRd0q-8athStWQIV3yPBlawOU_hw-G6DB1ZIHI60uaYUVN1QndwAIkyS8vFUEwOngip4lWQrrb62byC2FFHAQtC2M_gJXg1T08_0L9JKIXM69zMkH4B4hj-7J16C65mcFsagB15zf_9J6MUUW8AQ"&gt;On the inverse of the covariance matrix for an autoregressive-moving average process&lt;/a&gt; 上で参照している論文。これも答えが出とる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;どん詰まりよ。AR(1)仮定は相関付きであっても微妙。i.i.d.の場合はSAと同程度。うーん。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(22)</title><link href="/r-1-noji-suan-22.html" rel="alternate"></link><published>2020-12-02T10:00:00+09:00</published><updated>2020-12-02T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-02:/r-1-noji-suan-22.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;前日見ていた &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; のAR(1)仮定による近似を実験しているが、渋いな〜渋い …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;前日見ていた &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; のAR(1)仮定による近似を実験しているが、渋いな〜渋い。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;真の（共分散行列を計算してから逆行列を計算した） &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; とはかなり類似。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;当然3重対角成分以外は0にしているので誤差がある。しかし真の &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; も小さい値を取るので全体的な誤差は小さい。&lt;/li&gt;
&lt;li&gt;真値とのRMSを見たら減少してることを確認。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;i.i.d.雑音ではSAとほぼ変わらんくらいの性能。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;頷ける。 &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; が単位行列の定数倍に近くなるから。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;相関付き雑音ならちょっと改善。NGSAとSAの中間くらいか？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;以下の条件下ではSharman-Morrison式NGSAの性能と近い。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;入力雑音のパワー（分散）を大きくする（0dBとか）&lt;/li&gt;
&lt;li&gt;フィルタ係数の次元を落とす（2とか）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;NGSAで求まってる &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; は何なの…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;実験で見たとき、Sharman-Morrisonによる &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; もほぼ多重対角行列だったのを見ている&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;i.i.d.雑音でSharman-Morrison式NGSAがよくなる現象、一体何なんだ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;スケールを揃えて見てみた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;10サンプル後, 対角優位ではあるが、対角要素以外がおおきい。&lt;/li&gt;
&lt;li&gt;1000サンプル, 2000サンプル後もほぼ同様。対角要素以外は小さくなるものの小さくなりきっていない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;なんかモーメンタムみたいになってる？慣性が残って加速しているのか？まさか…&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;曲率以外の概念が無いと、この収束加速は説明できない。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;モーメンタムありえる。&lt;/strong&gt; 更新式の横から勾配 &lt;span class="math"&gt;\(\ve{v}\)&lt;/span&gt; を乗じると、&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{R}^{-1}[n+1] &amp;amp;= \frac{1}{\lambda} \left[ \ve{R}^{-1}[n] - \frac{\ve{R}^{-1}[n]\ve{x}[n]\left\{\ve{R}^{-1}\ve{x}[n]\right\}^{\mathsf{T}}}{\lambda + \ve{x}[n]^{\mathsf{T}} \ve{R}^{-1}[n] \ve{x}[n]} \right] \\
\implies \ve{R}^{-1}[n+1]\ve{v} &amp;amp;= \frac{1}{\lambda} \left[ \ve{R}^{-1}[n]\ve{v} - \frac{\ve{R}^{-1}[n]\ve{x}[n]\left\{\ve{R}^{-1}\ve{x}[n]\right\}^{\mathsf{T}}}{\lambda + \ve{x}[n]^{\mathsf{T}} \ve{R}^{-1}[n] \ve{x}[n]} \ve{v} \right]
\end{align*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;だから、直前ステップの自然勾配 &lt;span class="math"&gt;\(\ve{R}^{-1}[n]\ve{v}\)&lt;/span&gt; に対して修正を掛けながら更新している事がわかる。&lt;/li&gt;
&lt;li&gt;前に進捗報告でglasso版がほぼ同じような結果を出していたのは、共分散行列を &lt;span class="math"&gt;\(\ve{R}[n+1] \leftarrow \lambda \ve{R}[n] + \ve{x}[n] \ve{x}[n]^{\mathsf{T}}\)&lt;/span&gt; と指数移動平均的に更新したからと思われる。両辺の逆を取ると、（1次）近似的には &lt;span class="math"&gt;\(\ve{R}^{-1}[n]\)&lt;/span&gt; の成分と &lt;span class="math"&gt;\((\ve{x}[n]\ve{x}[n]^{\mathsf{T}})^{-1}\)&lt;/span&gt; (擬似逆行列) の和に分けることができて、右から勾配を乗じると直前ステップの勾配成分が発生し、モーメンタムになる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;やはりモーメンタムの線が濃い。事前にSherman-Morrisonで &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を求めて固定して自然勾配学習を行うと、NGSAの収束性能が悪化した。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;しかし、固定した &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を使ってモーメンタムを使っても性能が良くない。SAと同程度。何が違うんだ…？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;アイデアとしては、行列を指数移動平均的に更新するやり方を採用することだろうか。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(21)</title><link href="/r-1-noji-suan-21.html" rel="alternate"></link><published>2020-12-01T10:00:00+09:00</published><updated>2020-12-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-12-01:/r-1-noji-suan-21.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;昨日あたりから三重対角行列の性質を使ってうまくやれないか...でずっと …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;昨日あたりから三重対角行列の性質を使ってうまくやれないか...でずっと悩んでいた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;（PCAより）共分散行列（今考えてる信号では自己相関行列としてよい、平均0だから）の固有値は各軸の分散になる&lt;/li&gt;
&lt;li&gt;自己相関行列の逆はほぼ三重対角行列とみなせる。その行列の要素と固有値には陽な関係がある&lt;/li&gt;
&lt;li&gt;ある行列の固有値は、その逆行列の固有値の逆数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という3点から攻めればいけるかな、と思ったけど、観測により得られる要素がほとんどなくて、&amp;quot;各軸の分散&amp;quot;も直交変換しないとわからない。という所で詰まっていた。&lt;/p&gt;
&lt;p&gt;しばらく悶絶していたら、今考えてるのは直前時刻との相関、つまりAR(1)だから、そいつ共分散の逆行列ならよく知られてるんじゃないと思って探したらすぐに陽な答えが見つかった:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/975069/the-inverse-of-ar-structure-correlation-matrix-kac-murdock-szeg-̈o-matrix"&gt;The inverse of AR structure correlation matrix / Kac-Murdock-Szeg ̈o matrix&lt;/a&gt; これにピンときた。前に &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を計算したときの結果ともかなり合ってる。&lt;ul&gt;
&lt;li&gt;手元で計算結果を確認した。コレスキー（Cholesky）分解を使っておる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mathoverflow.net/questions/65795/inverse-of-an-ar1-or-laplacian-or-kac-murdock-szegö-matrix"&gt;Inverse of an AR(1) or Laplacian (?) or Kac-Murdock-Szegö matrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.stanford.edu/class/stats253/lectures/lect6.pdf"&gt;Lecture 6 Autoregressive Processes in Time&lt;/a&gt; AR(2)も逆行列がシンボリックに求まるっぽい&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=&amp;amp;ved=2ahUKEwjF9dyVlK3tAhVPPHAKHcOYDNMQFjABegQIAhAC&amp;amp;url=https%3A%2F%2Fwww.sid.ir%2FFileServer%2FJE%2F10012004A204&amp;amp;usg=AOvVaw2O9EqdHNmqDdro32aAFB7V"&gt;THE INVERSE OF COVARIANCE MATRICES FOR THE ARMA (p, q) CLASS OF PROCESSES&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;かなり上手い結果が出ている。AR(1)だと仮定してやれば、1つシフトさせたときの相関を求めてしまえば自己相関行列の逆が求まってしまう。&lt;/p&gt;
&lt;p&gt;主張としては、1サンプルギャップでの相関が &lt;span class="math"&gt;\(0 &amp;lt; \rho &amp;lt; 1\)&lt;/span&gt; のとき、 &lt;span class="math"&gt;\(N \times N\)&lt;/span&gt; の相関行列&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{R} = \left[ \begin{array}{ccccc}
1          &amp;amp; \rho       &amp;amp; \rho^{2} &amp;amp; ... &amp;amp; \rho^{N-1} \\
\rho       &amp;amp; 1          &amp;amp; \rho     &amp;amp;     &amp;amp; \rho^{N-2} \\
\vdots     &amp;amp;            &amp;amp; \ddots   &amp;amp;     &amp;amp; \vdots     \\
\rho^{N-1} &amp;amp; \rho^{N-2} &amp;amp; ...      &amp;amp;     &amp;amp; 1          \\
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;の逆行列 &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{R}^{-1} = \frac{1}{1 - \rho^{2}} \left[ \begin{array}{ccccc}
1      &amp;amp; -\rho        &amp;amp; 0         &amp;amp; ...          &amp;amp; 0      \\
-\rho  &amp;amp; 1 + \rho^{2} &amp;amp; -\rho     &amp;amp; \ddots       &amp;amp; \vdots \\
0      &amp;amp; -\rho        &amp;amp; \ddots    &amp;amp; \ddots       &amp;amp; 0      \\
\vdots &amp;amp; \ddots       &amp;amp; \ddots    &amp;amp; 1 + \rho^{2} &amp;amp; -\rho  \\
0      &amp;amp; ...          &amp;amp; 0         &amp;amp; -\rho        &amp;amp; 1      \\
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる。特に、&lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; に信号の分散 &lt;span class="math"&gt;\(\sigma^{2}\)&lt;/span&gt; を乗じると自己相関行列 &lt;span class="math"&gt;\(\ve{K}\)&lt;/span&gt; に一致するから&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{K} &amp;amp;= \sigma^{2} \ve{R} \\
\ve{K}^{-1} &amp;amp;= \sigma^{-2} \ve{R}^{-1}
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。&lt;/p&gt;
&lt;p&gt;証明） &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; はコレスキー（Cholesky）分解によって&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{R} = \ve{L}\  \mathrm{diag}(1, 1 - \rho^{2}, ..., 1 - \rho^{2})\  \ve{L}^{\mathsf{T}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と分解できる。ここで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{L} = \left[ \begin{array}{ccccc}
1          &amp;amp; 0           &amp;amp; 0         &amp;amp; ...    &amp;amp; 0      \\
\rho       &amp;amp; 1           &amp;amp; 0         &amp;amp; \ddots &amp;amp;        \\
\vdots     &amp;amp; \rho        &amp;amp; 1         &amp;amp; \ddots &amp;amp; 0      \\
\rho^{N-2} &amp;amp; \ddots      &amp;amp; \ddots    &amp;amp; \ddots &amp;amp; 0      \\
\rho^{N-1} &amp;amp; \rho^{N-2}  &amp;amp; ...       &amp;amp; \rho   &amp;amp; 1      \\
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;確認すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
&amp;amp; \ve{L}\  \mathrm{diag}(1, 1 - \rho^{2}, ..., 1 - \rho^{2})\  \ve{L}^{\mathsf{T}} \\
&amp;amp;= \left[ \begin{array}{ccccc}
1          &amp;amp; 0           &amp;amp; 0         &amp;amp; ...    &amp;amp; 0   \\
\rho       &amp;amp; 1           &amp;amp; 0         &amp;amp; \ddots &amp;amp;     \\
\vdots     &amp;amp; \rho        &amp;amp; 1         &amp;amp; \ddots &amp;amp; 0   \\
\rho^{N-2} &amp;amp; \ddots      &amp;amp; \ddots    &amp;amp; \ddots &amp;amp; 0   \\
\rho^{N-1} &amp;amp; \rho^{N-2}  &amp;amp; ...       &amp;amp; \rho   &amp;amp; 1   \\
\end{array} \right]
\left[ \begin{array}{cccc}
1 &amp;amp;              &amp;amp;        &amp;amp;             \\
  &amp;amp; 1 - \rho^{2} &amp;amp;        &amp;amp;             \\
  &amp;amp;              &amp;amp; \ddots &amp;amp;             \\
  &amp;amp;              &amp;amp;        &amp;amp; 1- \rho^{2} \\
\end{array} \right]
\left[ \begin{array}{ccccc}
1      &amp;amp; \rho   &amp;amp; ...    &amp;amp; \rho^{N-2} &amp;amp; \rho^{N-1}  \\
0      &amp;amp; 1      &amp;amp; \rho   &amp;amp; \ddots     &amp;amp; \rho^{N-2}  \\
\vdots &amp;amp; 0      &amp;amp; 1      &amp;amp; \ddots     &amp;amp; 0           \\
0      &amp;amp; \ddots &amp;amp; \ddots &amp;amp; \ddots     &amp;amp; \rho        \\
0      &amp;amp; 0      &amp;amp; ...    &amp;amp; 0          &amp;amp; 1           \\
\end{array} \right] \\
&amp;amp;= \left[ \begin{array}{ccccc}
1          &amp;amp; 0                        &amp;amp; 0            &amp;amp; ...                &amp;amp; 0             \\
\rho       &amp;amp; 1 - \rho^{2}             &amp;amp; 0            &amp;amp; \ddots             &amp;amp; \vdots        \\
\rho^{2}   &amp;amp; \rho(1 - \rho^{2})       &amp;amp; 1 - \rho^{2} &amp;amp; \ddots             &amp;amp; 0             \\
\vdots     &amp;amp; \vdots                   &amp;amp; \ddots       &amp;amp; \ddots             &amp;amp; 0             \\
\rho^{N-1} &amp;amp; \rho^{N-2}(1 - \rho^{2}) &amp;amp; ...          &amp;amp; \rho(1 - \rho^{2}) &amp;amp; 1 - \rho^{2}  \\
\end{array} \right]
\left[ \begin{array}{ccccc}
1      &amp;amp; \rho   &amp;amp; ...    &amp;amp; \rho^{N-2} &amp;amp; \rho^{N-1}  \\
0      &amp;amp; 1      &amp;amp; \rho   &amp;amp; \ddots     &amp;amp; \rho^{N-2}  \\
\vdots &amp;amp; 0      &amp;amp; 1      &amp;amp; \ddots     &amp;amp; 0           \\
0      &amp;amp; \ddots &amp;amp; \ddots &amp;amp; \ddots     &amp;amp; \rho        \\
0      &amp;amp; 0      &amp;amp; ...    &amp;amp; 0          &amp;amp; 1           \\
\end{array} \right] \\
&amp;amp;= \left[ \begin{array}{ccccc}
1          &amp;amp; \rho       &amp;amp; \rho^{2} &amp;amp; ... &amp;amp; \rho^{N-1} \\
\rho       &amp;amp; 1          &amp;amp; \rho     &amp;amp;     &amp;amp; \rho^{N-2} \\
\vdots     &amp;amp;            &amp;amp; \ddots   &amp;amp;     &amp;amp; \vdots     \\
\rho^{N-1} &amp;amp; \rho^{N-2} &amp;amp; ...      &amp;amp;     &amp;amp; 1          \\
\end{array} \right] = \ve{R}
\end{align*}
&lt;/div&gt;
&lt;p&gt;OKであることが分かる。では、 &lt;span class="math"&gt;\(\ve{L}^{-1}\)&lt;/span&gt; を求めることを考えるが、これは拡張行列に対して行基本変形（ガウスの消去法）を使って求めてみる。
つまり、 &lt;span class="math"&gt;\(\left[ \ve{L}\  \ve{I} \right] \rightarrow \left[ \ve{I}\  \ve{L}^{-1} \right]\)&lt;/span&gt; として求める。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\left[ \ve{L}\  \ve{I} \right]
&amp;amp;= \left[ \begin{array}{cccccccccc}
1          &amp;amp; 0          &amp;amp; 0      &amp;amp; ...    &amp;amp; 0  &amp;amp; 1 &amp;amp;   &amp;amp;        &amp;amp;   &amp;amp;   \\
\rho       &amp;amp; 1          &amp;amp; 0      &amp;amp; \ddots &amp;amp;    &amp;amp;   &amp;amp; 1 &amp;amp;        &amp;amp;   &amp;amp;   \\
\vdots     &amp;amp; \rho       &amp;amp; 1      &amp;amp; \ddots &amp;amp; 0  &amp;amp;   &amp;amp;   &amp;amp; \ddots &amp;amp;   &amp;amp;   \\
\rho^{N-2} &amp;amp; \ddots     &amp;amp; \ddots &amp;amp; \ddots &amp;amp; 0  &amp;amp;   &amp;amp;   &amp;amp;        &amp;amp; 1 &amp;amp;   \\
\rho^{N-1} &amp;amp; \rho^{N-2} &amp;amp; ...    &amp;amp; \rho   &amp;amp; 1  &amp;amp;   &amp;amp;   &amp;amp;        &amp;amp;   &amp;amp; 1 \\
\end{array} \right] \\
&amp;amp; \rightarrow \left[ \begin{array}{cccccccccc}
1      &amp;amp; 0          &amp;amp; 0      &amp;amp; ...    &amp;amp; 0  &amp;amp; 1           &amp;amp;   &amp;amp;        &amp;amp;   &amp;amp;   \\
0      &amp;amp; 1          &amp;amp; 0      &amp;amp; \ddots &amp;amp;    &amp;amp; -\rho       &amp;amp; 1 &amp;amp;        &amp;amp;   &amp;amp;   \\
0      &amp;amp; \rho       &amp;amp; 1      &amp;amp; \ddots &amp;amp; 0  &amp;amp; -\rho^{2}   &amp;amp;   &amp;amp; \ddots &amp;amp;   &amp;amp;   \\
\vdots &amp;amp; \ddots     &amp;amp; \ddots &amp;amp; \ddots &amp;amp; 0  &amp;amp; \vdots      &amp;amp;   &amp;amp;        &amp;amp; 1 &amp;amp;   \\
0      &amp;amp; \rho^{N-2} &amp;amp; ...    &amp;amp; \rho   &amp;amp; 1  &amp;amp; -\rho^{N-1} &amp;amp;   &amp;amp;        &amp;amp;   &amp;amp; 1 \\
\end{array} \right] \\
&amp;amp; \rightarrow \left[ \begin{array}{cccccccccc}
1      &amp;amp; 0      &amp;amp; 0      &amp;amp; ...    &amp;amp; 0  &amp;amp; 1      &amp;amp;             &amp;amp;        &amp;amp;   &amp;amp;   \\
0      &amp;amp; 1      &amp;amp; 0      &amp;amp; \ddots &amp;amp;    &amp;amp; -\rho  &amp;amp; 1           &amp;amp;        &amp;amp;   &amp;amp;   \\
0      &amp;amp; 0      &amp;amp; 1      &amp;amp; \ddots &amp;amp; 0  &amp;amp; 0      &amp;amp; -\rho       &amp;amp; \ddots &amp;amp;   &amp;amp;   \\
\vdots &amp;amp; \ddots &amp;amp; \ddots &amp;amp; \ddots &amp;amp; 0  &amp;amp; \vdots &amp;amp; \vdots      &amp;amp;        &amp;amp; 1 &amp;amp;   \\
0      &amp;amp; 0      &amp;amp; ...    &amp;amp; \rho   &amp;amp; 1  &amp;amp; 0      &amp;amp; -\rho^{N-2} &amp;amp;        &amp;amp;   &amp;amp; 1 \\
\end{array} \right] \\
\rightarrow ... &amp;amp;\rightarrow \left[ \begin{array}{cccccccccc}
1      &amp;amp; 0      &amp;amp; 0      &amp;amp; ...    &amp;amp; 0  &amp;amp; 1      &amp;amp;             &amp;amp;        &amp;amp;       &amp;amp;   \\
0      &amp;amp; 1      &amp;amp; 0      &amp;amp; \ddots &amp;amp;    &amp;amp; -\rho  &amp;amp; 1           &amp;amp;        &amp;amp;       &amp;amp;   \\
0      &amp;amp; 0      &amp;amp; 1      &amp;amp; \ddots &amp;amp; 0  &amp;amp; 0      &amp;amp; -\rho       &amp;amp; \ddots &amp;amp;       &amp;amp;   \\
\vdots &amp;amp; \ddots &amp;amp; \ddots &amp;amp; \ddots &amp;amp; 0  &amp;amp; \vdots &amp;amp; \ddots      &amp;amp; \ddots &amp;amp; 1     &amp;amp;   \\
0      &amp;amp; 0      &amp;amp; ...    &amp;amp; 0      &amp;amp; 1  &amp;amp; 0      &amp;amp; ...         &amp;amp; 0      &amp;amp; -\rho &amp;amp; 1 \\
\end{array} \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{L}^{-1} =
\left[ \begin{array}{cccc}
1     &amp;amp;        &amp;amp;        &amp;amp;   \\
-\rho &amp;amp; 1      &amp;amp;        &amp;amp;   \\
      &amp;amp; \ddots &amp;amp; \ddots &amp;amp;   \\
      &amp;amp;        &amp;amp; -\rho  &amp;amp; 1 \\
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（下三角行列だからなんかえもい結果でないかな）この結果から、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{R}^{-1} &amp;amp;= (\ve{L}^{\mathsf{T}})^{-1} \  \mathrm{diag}(1, 1 - \rho^{2}, ..., 1 - \rho^{2})^{-1}\  \ve{L}^{-1} \\
&amp;amp;= (\ve{L}^{-1})^{\mathsf{T}} \  \mathrm{diag}(1, \frac{1}{1 - \rho^{2}}, ..., \frac{1}{1 - \rho^{2}})\  \ve{L}^{-1} \\
&amp;amp;= \frac{1}{1 - \rho^{2}}
\left[ \begin{array}{cccc}
1 &amp;amp; -\rho  &amp;amp;        &amp;amp;       \\
  &amp;amp; 1      &amp;amp; \ddots &amp;amp;       \\
  &amp;amp;        &amp;amp; \ddots &amp;amp; -\rho \\
  &amp;amp;        &amp;amp;        &amp;amp; 1     \\
\end{array} \right]
\left[ \begin{array}{cccc}
1 - \rho^{2} &amp;amp;   &amp;amp;        &amp;amp;   \\
             &amp;amp; 1 &amp;amp;        &amp;amp;   \\
             &amp;amp;   &amp;amp; \ddots &amp;amp;   \\
             &amp;amp;   &amp;amp;        &amp;amp; 1 \\
\end{array} \right]
\left[ \begin{array}{cccc}
1     &amp;amp;        &amp;amp;        &amp;amp;   \\
-\rho &amp;amp; 1      &amp;amp;        &amp;amp;   \\
      &amp;amp; \ddots &amp;amp; \ddots &amp;amp;   \\
      &amp;amp;        &amp;amp; -\rho  &amp;amp; 1 \\
\end{array} \right] \\
&amp;amp;= \frac{1}{1 - \rho^{2}}
\left[ \begin{array}{cccc}
1 - \rho^{2} &amp;amp; -\rho  &amp;amp;        &amp;amp;       \\
             &amp;amp; 1      &amp;amp; \ddots &amp;amp;       \\
             &amp;amp;        &amp;amp; \ddots &amp;amp; -\rho \\
             &amp;amp;        &amp;amp;        &amp;amp; 1     \\
\end{array} \right]
\left[ \begin{array}{cccc}
1     &amp;amp;        &amp;amp;        &amp;amp;   \\
-\rho &amp;amp; 1      &amp;amp;        &amp;amp;   \\
      &amp;amp; \ddots &amp;amp; \ddots &amp;amp;   \\
      &amp;amp;        &amp;amp; -\rho  &amp;amp; 1 \\
\end{array} \right] \\
&amp;amp;= \frac{1}{1 - \rho^{2}}
\left[ \begin{array}{ccccc}
1      &amp;amp; -\rho        &amp;amp; 0         &amp;amp; ...          &amp;amp; 0      \\
-\rho  &amp;amp; 1 + \rho^{2} &amp;amp; -\rho     &amp;amp; \ddots       &amp;amp; \vdots \\
0      &amp;amp; -\rho        &amp;amp; \ddots    &amp;amp; \ddots       &amp;amp; 0      \\
\vdots &amp;amp; \ddots       &amp;amp; \ddots    &amp;amp; 1 + \rho^{2} &amp;amp; -\rho  \\
0      &amp;amp; ...          &amp;amp; 0         &amp;amp; -\rho        &amp;amp; 1      \\
\end{array} \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;となって結果が確かめられた。&lt;/p&gt;
&lt;p&gt;もう一度考えると、i.i.d.雑音のときは有効な情報は分散（の逆数）ということになる。（入力がi.i.d.雑音のとき &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; は対角行列であることは見た）
それだけでも収束性能が上がるということは、分散で正規化するだけでも意味がある、というかNLMSとほぼ同じ発想になっている。
このことからもNLMSと同等かそれ以下の性能しか出せないのは頷ける。NGSAでは残差の大きさ入れてないから。&lt;/p&gt;
&lt;p&gt;現実の信号は直前サンプルに強い相関を持つのは妥当な仮定。だから良くなるはずというのが自分の印象。
自分、実験いいすか？&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(20)</title><link href="/r-1-noji-suan-20.html" rel="alternate"></link><published>2020-11-30T10:00:00+09:00</published><updated>2020-11-30T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-30:/r-1-noji-suan-20.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;色々方針がグッ …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;色々方針がグッチャになってるのが良くない。現状をまとめる&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LARSを試す&lt;ul&gt;
&lt;li&gt;とにかく遅い。CDよりも遅い。&lt;/li&gt;
&lt;li&gt;原因を知りたいが、実装だけでは理解不能。&lt;/li&gt;
&lt;li&gt;最小角の原理から抑えていかないとだめか。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;巡回行列化してFFT:&lt;ul&gt;
&lt;li&gt;基礎は抑えた。&lt;/li&gt;
&lt;li&gt;実装するにしても &lt;span class="math"&gt;\(n\)&lt;/span&gt; が小さいから &lt;span class="math"&gt;\(\mathcal{O}(n \log n)\)&lt;/span&gt; との差が出なそうな印象。&lt;/li&gt;
&lt;li&gt;一般の大規模自然勾配に対しては有効に思える。既存研究がないか調査。&lt;ul&gt;
&lt;li&gt;しかし既存研究が無かったとしても、これは技法であって提案手法に足りるか疑問。有効性をどうやって示す？3層パーセプトロンでやるのが良さそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;できない実装のコード共有&lt;ul&gt;
&lt;li&gt;単純に &lt;span class="math"&gt;\(\ve{H}=\ve{R}\)&lt;/span&gt; にした実装が上手くいかんやつ。&lt;/li&gt;
&lt;li&gt;これはなるべく早く。今週中に上げたい。&lt;/li&gt;
&lt;li&gt;次元を落として(2とか)上手く行かない理由を見る。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;摂動展開&lt;ul&gt;
&lt;li&gt;甘利先生の適応的自然勾配学習に近い形になる。つまり、不安定になる未来が見えている。初夏に一回試している。&lt;/li&gt;
&lt;li&gt;しかしいま一度試してみる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sharman-Morrisonをもう一段展開してなにか見えないか&lt;ul&gt;
&lt;li&gt;やるだけやってみるべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重要: 方針相談&lt;ul&gt;
&lt;li&gt;落とし所が上手く定まらない。12月中に先生と相談する機会を設ける。&lt;/li&gt;
&lt;li&gt;なるべく早く。今年中に舵切らないと危険。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指摘事項に対応するのは大事なので、今日は摂動展開を試す。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/2961686/approximating-the-inverse-of-a-perturbed-matrix"&gt;Approximating the inverse of a perturbed matrix&lt;/a&gt; にあるように、行列 &lt;span class="math"&gt;\(\ve{A}\)&lt;/span&gt; に摂動を加えた行列 &lt;span class="math"&gt;\(\partial\ve{A}\)&lt;/span&gt; の逆行列の近似は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\ve{A} + \partial\ve{A})^{-1} \approx \ve{A}^{-1} - \ve{A}^{-1} \partial\ve{A} \ve{A}^{-1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;で与えられる。&lt;/p&gt;
&lt;p&gt;上ページにもあったけど証明を与えておく。 &lt;span class="math"&gt;\(\ve{A}\)&lt;/span&gt; に摂動 &lt;span class="math"&gt;\(\ve{X}\)&lt;/span&gt; を与えることを考え、 &lt;span class="math"&gt;\((\ve{A} + \ve{X})^{-1}\)&lt;/span&gt; をテイラー展開すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\ve{A} + \ve{X})^{-1} = \ve{A}^{-1} + \ve{Y} + O(||\ve{X}||^{2})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と書ける。ここで &lt;span class="math"&gt;\(\ve{Y}\)&lt;/span&gt; は一次（線形）の変化を表す行列。ここで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
&amp;amp; (\ve{A} + \ve{X})^{-1}(\ve{A} + \ve{X}) = \ve{I} \\
&amp;amp; \iff (\ve{A}^{-1} + \ve{Y} + O(||\ve{X}||^{2}))(\ve{A} + \ve{X}) = \ve{I} \\
&amp;amp; \iff \ve{A}^{-1}\ve{A} + \ve{A}^{-1}\ve{X} + \ve{Y}\ve{A} + \ve{Y}\ve{X} + O(||\ve{X}||^{2})(\ve{A} + \ve{X}) = \ve{I} \\
&amp;amp; \iff \ve{A}^{-1}\ve{X} + \ve{Y}\ve{A} + \ve{Y}\ve{X} + O(||\ve{X}||^{2})(\ve{A} + \ve{X}) = \ve{O} \\
&amp;amp; \implies \ve{A}^{-1}\ve{X} + \ve{Y}\ve{A} \approx \ve{O} \quad (\because \ve{Y}\text{は微小だから} \ve{Y}\ve{X} \approx \ve{O}) \\
&amp;amp; \implies \ve{Y} \approx -\ve{A}^{-1}\ve{X}\ve{A}^{-1}
\end{align*}
&lt;/div&gt;
&lt;p&gt;この &lt;span class="math"&gt;\(\ve{Y}\)&lt;/span&gt; をテイラー展開の式に代入して二次以上の項を無視すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\ve{A} + \ve{X})^{-1} \approx \ve{A}^{-1} - \ve{A}^{-1}\ve{X}\ve{A}^{-1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が得られる。&lt;/p&gt;
&lt;p&gt;逐次計算に応用してみよう。 &lt;span class="math"&gt;\(\ve{A} = \epsilon\ve{R}[n], \ \ve{X} = \ve{x}[n]\ve{x}[n]^{\mathsf{T}}\)&lt;/span&gt; とおくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\epsilon\ve{R}[n] + \ve{x}[n]\ve{x}[n]^{\mathsf{T}})^{-1} \approx \epsilon^{-1} \ve{R}[n]^{-1} - \epsilon^{-2} \ve{R}[n]^{-1} \ve{x}[n]\ve{x}[n]^{\mathsf{T}} \ve{R}[n]^{-1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となり、ほぼ適応的自然勾配学習法の式だ（&lt;span class="math"&gt;\(\epsilon^{-1}\)&lt;/span&gt; に対しても近似すると一致する）。&lt;/p&gt;
&lt;p&gt;実装してみて試すのはもちろんだが、安定性をもっと追うべきかとは思っている。上の更新式でちゃんと &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; の真値に収束する？&lt;/p&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;三重対角行列の固有値&lt;/h2&gt;
&lt;p&gt;ぼんやり（すまぬ）行列の性質を見ていたら、ずっと探していた「三重対角行列の固有値」の結果が出ていた:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://nalab.mind.meiji.ac.jp/~mk/labo/text/linear-eq-3.pdf"&gt;連立1次方程式 III — 自分が使うための線型代数 —&lt;/a&gt; これの9.5.2。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;サイズ &lt;span class="math"&gt;\(N \times N\)&lt;/span&gt; の一様三項行列&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left[ \begin{array}{ccccc}
a      &amp;amp; b      &amp;amp; 0      &amp;amp; ...    &amp;amp; 0      \\
c      &amp;amp; a      &amp;amp; b      &amp;amp; \ddots &amp;amp; \vdots \\
0      &amp;amp; c      &amp;amp; \ddots &amp;amp; \ddots &amp;amp; 0      \\
\vdots &amp;amp; \ddots &amp;amp; \ddots &amp;amp; a      &amp;amp; b      \\
0      &amp;amp; ...    &amp;amp; 0      &amp;amp; c      &amp;amp; a      \\
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;の &lt;span class="math"&gt;\((bc \neq 0)\)&lt;/span&gt; 固有値 &lt;span class="math"&gt;\(\lambda_{k}\)&lt;/span&gt; と固有ベクトル &lt;span class="math"&gt;\(\ve{v}_{k}\)&lt;/span&gt; は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\lambda_{k} &amp;amp;= a + 2\sqrt{bc} \cos\left(\frac{k \pi}{N+1}\right) \\
\ve{v}_{k} &amp;amp;= \left[ \sqrt{\frac{c}{b}} \sin\left(\frac{k \pi}{N+1}\right),\  \left(\sqrt{\frac{c}{b}}\right)^{2}\sin\left(\frac{2k \pi}{N+1}\right),\ ...,\ \left(\sqrt{\frac{c}{b}}\right)^{N} \sin\left(\frac{Nk \pi}{N+1}\right) \right]^{\mathsf{T}} \\
k &amp;amp;= 1, ..., N
\end{align*}
&lt;/div&gt;
&lt;p&gt;これを上手くやるにはどうしたらいいか、しばらく考えてた。今では &lt;span class="math"&gt;\(b=c\)&lt;/span&gt; とすればいいから行列は対称行列になって、各固有ベクトルは直交するはず（示せなかった。。。）。また、固有値を並べた行列を使って直交対角化もできるはずなんや。&lt;/p&gt;
&lt;p&gt;さて、依然として残る問題は &lt;span class="math"&gt;\(a,b\)&lt;/span&gt; もしくは &lt;span class="math"&gt;\(\lambda_{k}\)&lt;/span&gt; をどうやって観測から求めればいいかというところ。頭に極配置法が思い浮かぶが、なにか違う。素朴なやり方がありそうで、あと一歩な気がするのだ。&lt;/p&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(19)</title><link href="/r-1-noji-suan-19.html" rel="alternate"></link><published>2020-11-28T10:00:00+09:00</published><updated>2020-11-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-28:/r-1-noji-suan-19.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; はToeplitz（テプ …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; はToeplitz（テプリッツ行列）だから、それをFFTベースで高速計算する手法がある（テプリッツ法というらしい）&lt;/p&gt;
&lt;p&gt;『ガウス過程と機械学習』によると、テプリッツ行列を巡回行列に展開して、それに対してFFTを実行して &lt;span class="math"&gt;\(\mathcal{O}(nlogn)\)&lt;/span&gt; で処理を進めるというもの。ただし本には明らかな誤りがある。巡回行列の1行目は &lt;span class="math"&gt;\([ K_{1,1} K_{1,2} ... K_{1,M-1} K_{1,M} K_{1,M-1} K_{1,M-1} ... K_{1,2} ]\)&lt;/span&gt; のはずだ。そうじゃないと巡回して行列を作ったときにおかしなことになる。&lt;/p&gt;
&lt;p&gt;他にも論文がある。下はFFTベースの手法のようだ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.kravanja.eu/pages/Kravanja-2001-Toeplitz.pdf"&gt;A STABILIZED SUPERFAST SOLVER FOR NONSYMMETRIC TOEPLITZ SYSTEMS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;思ったのが、一般の自然勾配法において超巨大なFisher情報行列に対してこれは使えんるんじゃないかというところ。とっくにやってる？&lt;/p&gt;
&lt;p&gt;Fisher情報行列はスコア関数の共分散だからテプリッツ行列。だから行けるんじゃね？&lt;/p&gt;
&lt;p&gt;ん？他にも共分散行列の高速推定手法を提案してる:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.sys.es.osaka-u.ac.jp/sch/paper/B1999/yamamoto-k/index.html"&gt;Toeplitz構造をもつ共分散行列の最尤推定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>巡回行列と離散フーリエ変換</title><link href="/xun-hui-xing-lie-toli-san-huriebian-huan.html" rel="alternate"></link><published>2020-11-28T10:00:00+09:00</published><updated>2020-11-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-28:/xun-hui-xing-lie-toli-san-huriebian-huan.html</id><summary type="html">&lt;p class="first last"&gt;巡回行列と離散フーリエ変換の関係。周期性はすごいということ。&lt;/p&gt;
</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;巡回行列は何度も何度も重要性を認識している。群論では巡回群が密接に絡む。&lt;/p&gt;
&lt;p&gt;以下の記事&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://takahiro-itazuri.hatenadiary.jp/entry/2018/03/11/162122"&gt;巡回行列とフーリエ変換による対角化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の焼き直しに過ぎないが、自分の言葉で再度書き直してみる。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(n \times n\)&lt;/span&gt; 行列&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{C} = \left[ \begin{array}{ccccc}
c_{0}   &amp;amp; c_{1} &amp;amp;  c_{2} &amp;amp;    ... &amp;amp; c_{n-1} \\
c_{n-1} &amp;amp; c_{0} &amp;amp;  c_{1} &amp;amp;    ... &amp;amp; c_{n-2} \\
\vdots  &amp;amp;       &amp;amp; \ddots &amp;amp; \ddots &amp;amp; \vdots  \\
c_{1}   &amp;amp; c_{2} &amp;amp;  c_{3} &amp;amp;    ... &amp;amp; c_{0}   \\
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を巡回行列（Circulant Matrix）という。これに対してDFT（離散フーリエ変換）を行うことを考える。離散フーリエ変換は、フーリエ変換行列&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{F} &amp;amp;= \left[ \begin{array}{cccc}
\omega_{n}^{0 \times 0}     &amp;amp; \omega_{n}^{0 \times 1} &amp;amp; ...    &amp;amp; \omega_{n}^{0 \times (n-1)} \\
\omega_{n}^{1 \times 0}     &amp;amp; \omega_{n}^{1 \times 1} &amp;amp;        &amp;amp; \omega_{n}^{1 \times (n-1)} \\
\vdots                      &amp;amp;                         &amp;amp; \ddots &amp;amp; \vdots  \\
\omega_{n}^{(n-1) \times 0} &amp;amp; ...                     &amp;amp;        &amp;amp; \omega_{n}^{(n-1) \times (n-1)}   \\
\end{array} \right] \\
\omega_{n} &amp;amp;:= \frac{1}{\sqrt{n}} \exp\left(\frac{j2\pi}{n}\right)
\end{align*}
&lt;/div&gt;
&lt;p&gt;を作用させる（乗ずる）ことで実現される。いま、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{F} := \left[\ \ve{f}_{0} \ \ve{f}_{1} \ ... \ \ve{f}_{n-1} \ \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; を列ベクトルに分解して表す（ &lt;span class="math"&gt;\((\ve{F})_{ij} = (\ve{f}_{j})_{i} = \omega_{n}^{ij}\)&lt;/span&gt; となる。議論の簡単のため、ここでは、行列要素のインデックスは0から始めている）。このとき、おもむろに &lt;span class="math"&gt;\(\ve{y} = \ve{C} \ve{f}_{k}\)&lt;/span&gt; を計算してみると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
(\ve{y})_{l} &amp;amp;= \sum_{j=0}^{n-1} c_{j-l}(\ve{f}_{k})_{j} := \sum_{j=0}^{n-1} c_{j-l} \omega_{n}^{jk} \\
&amp;amp;= \omega_{n}^{lk} \sum_{j=0}^{n-1} c_{j-l} \omega_{n}^{(j-l)k}
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、&lt;span class="math"&gt;\(c_{j}\)&lt;/span&gt; と &lt;span class="math"&gt;\(\omega_{n}\)&lt;/span&gt; は共に周期 &lt;span class="math"&gt;\(n\)&lt;/span&gt; (すなわち &lt;span class="math"&gt;\(c_{j} = c_{j + mn},\ \omega_{n}^{m} = \omega_{n}^{mn}\ (m \in \mathbb{Z})\)&lt;/span&gt; ) だから、 &lt;span class="math"&gt;\(\sum_{j=0}^{n-1} c_{j-l} \omega_{n}^{(j-l)k}\)&lt;/span&gt; は1周期分の和になっており &lt;span class="math"&gt;\(l\)&lt;/span&gt; に依存しない。そこで、 &lt;span class="math"&gt;\(k\)&lt;/span&gt; だけに依存する数として&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\lambda_{k} := \sum_{j=0}^{n-1} c_{j-l} \omega_{n}^{(j-l)k}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とおく。すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
(\ve{y})_{l} &amp;amp;= \omega_{n}^{lk} \lambda_{k} = (\ve{f}_{k})_{l} \lambda_{k} \\
&amp;amp;= \lambda_{k} (\ve{f}_{k})_{l}
\end{align*}
&lt;/div&gt;
&lt;p&gt;だから、結果をベクトルにまとめると&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{y} = \lambda_{k} \ve{f}_{k} = \ve{C} \ve{f}_{k}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この結果を見ると、 &lt;span class="math"&gt;\(\lambda_{k}\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{C}\)&lt;/span&gt; は固有値、 &lt;span class="math"&gt;\(\ve{f}_{k}\)&lt;/span&gt; はそれに対応する固有ベクトルになっていることがわかる。さらに、この結果を &lt;span class="math"&gt;\(k=0,...,n-1\)&lt;/span&gt; で並べていくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\left[\ \lambda_{0} \ve{f}_{0} \ \lambda_{1} \ve{f}_{1} \ ... \ \lambda_{n-1}\ve{f}_{n-1} \ \right] &amp;amp;= \left[\ \ve{C}\ve{f}_{0} \ \ve{C}\ve{f}_{1} \ ... \ \ve{C}\ve{f}_{n-1} \ \right] \\
&amp;amp;= \ve{C} \left[ \ \ve{f}_{0} \ \ve{f}_{1} \ ... \ \ve{f}_{n-1}\ \right] = \ve{CF}
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{F}^{\mathsf{T}} \ve{C} \ve{F} &amp;amp;= \left[ \ \ve{f}_{0} \ \ve{f}_{1} \ ... \ \ve{f}_{n-1}\ \right]^{\mathsf{T}} \left[ \ \lambda_{0} \ve{f}_{0} \ \lambda_{1} \ve{f}_{1} \ ... \ \lambda_{n-1} \ve{f}_{n-1} \ \right] \\
&amp;amp;= \left[ \begin{array}{c} \ve{f}_{0}^{\mathsf{T}} \\ \vdots \\ \ve{f}_{n-1}^{\mathsf{T}} \end{array} \right] \left[ \ \lambda_{0} \ve{f}_{0} \ \lambda_{1} \ve{f}_{1} \ ... \ \lambda_{n-1}\ve{f}_{n-1} \ \right] \\
&amp;amp;= \left[ \begin{array}{cccc}
\lambda_{0}\ve{f}_{0}^{\mathsf{T}}\ve{f}_{0} &amp;amp; \lambda_{1}\ve{f}_{0}^{\mathsf{T}}\ve{f}_{1} &amp;amp; ... &amp;amp; \lambda_{n-1}\ve{f}_{n-1}^{\mathsf{T}}\ve{f}_{n-1} \\
\vdots                      &amp;amp;                         &amp;amp; \ddots &amp;amp; \vdots  \\
\lambda_{0}\ve{f}_{n-1}^{\mathsf{T}}\ve{f}_{0} &amp;amp; \lambda_{1}\ve{f}_{n-1}^{\mathsf{T}}\ve{f}_{1} &amp;amp; ... &amp;amp; \lambda_{n-1}\ve{f}_{n-1}^{\mathsf{T}}\ve{f}_{n-1} \\
\end{array} \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。行列の各要素は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{f}_{i}^{\mathsf{T}} \ve{f}_{j} &amp;amp;= \sum_{k=0}^{n-1} (\ve{f}_{i})_{k} (\ve{f}_{j})_{k} = \sum_{k=0}^{n-1} \frac{1}{\sqrt{n}} \omega_{n}^{ki} \frac{1}{\sqrt{n}} \omega_{n}^{kj} \\
&amp;amp;= \frac{1}{n} \sum_{k=0}^{n-1} \omega_{n}^{k(i+j)}
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで一旦止めて、式を見てみる。今、 &lt;span class="math"&gt;\(i+j=n\)&lt;/span&gt; つまり &lt;span class="math"&gt;\(i=n-j\)&lt;/span&gt; （もっというと &lt;span class="math"&gt;\(i \equiv j\ (\mathrm{mod}\  n)\)&lt;/span&gt; ）ならば、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{1}{n} \sum_{k=0}^{n-1} \omega_{n}^{k(i+j)} &amp;amp;= \frac{1}{n} \sum_{k=0}^{n-1} \omega_{n}^{kn} \\
&amp;amp;= \frac{1}{n} \sum_{k=0}^{n-1} \exp\left( j 2 \pi k \right) = \frac{1}{n} \sum_{k=0}^{n-1} 1 \\
&amp;amp;= 1
\end{align*}
&lt;/div&gt;
&lt;p&gt;それ以外の場合は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{1}{n} \sum_{k=0}^{n-1} \omega_{n}^{k(i+j)} &amp;amp;= \frac{1}{n} \omega_{n}^{(i+j)} \sum_{k=0}^{n-1} \omega_{n}^{k} \\
&amp;amp;= \frac{1}{n} \sum_{k=0}^{n-1} \exp\left( \frac{j 2 \pi}{n} k \right) \\
&amp;amp;= \exp(0) + \exp\left( j\frac{2\pi}{n} \right) + \exp\left( j\frac{\pi}{n} \right) + ... + \exp\left[ j\frac{(n-1)\pi}{n} \right] \\
&amp;amp;= 0
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる（実際に &lt;span class="math"&gt;\(n=2,3\)&lt;/span&gt; あたりで試してみると良い。複素平面上の単位円を &lt;span class="math"&gt;\(n\)&lt;/span&gt; 分割して和を取るので &lt;span class="math"&gt;\(0\)&lt;/span&gt; になる。厳密な証明は &lt;span class="math"&gt;\(n\)&lt;/span&gt; に関する帰納法を使えばよいが、やらない。。。）。まとめると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{f}_{i}^{\mathsf{T}} \ve{f}_{j} &amp;amp;= \delta_{ij} \quad (\delta_{ij}: \text{クロネッカーのデルタ}) \\
\delta_{ij} &amp;amp;= \left\{ \begin{array}{ll}
1 &amp;amp; i = j \\
0 &amp;amp; i \neq j
\end{array} \right.
\end{align*}
&lt;/div&gt;
&lt;p&gt;だから（これより、 &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; が直交行列 &lt;span class="math"&gt;\(\ve{F}^{-1} = \ve{F}^{\mathsf{T}}\)&lt;/span&gt; であることが分かる）、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{F}^{\mathsf{T}} \ve{C} \ve{F} = \left[ \begin{array}{cccc}
\lambda_{0} &amp;amp; 0           &amp;amp; ...    &amp;amp; 0 \\
0           &amp;amp; \lambda_{1} &amp;amp;        &amp;amp; 0 \\
\vdots      &amp;amp;             &amp;amp; \ddots &amp;amp; \vdots \\
0           &amp;amp; ...         &amp;amp;        &amp;amp; \lambda_{n-1} \\
\end{array} \right] = \mathrm{diag}(\lambda_{0}, \lambda_{1}, ..., \lambda_{n-1})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この式は巡回行列 &lt;span class="math"&gt;\(\ve{C}\)&lt;/span&gt; はフーリエ変換行列 &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; で対角化できることを示している。&lt;/p&gt;
&lt;p&gt;さらに、巡回行列 &lt;span class="math"&gt;\(\ve{C}\)&lt;/span&gt; の1行目をDFTすると、 &lt;span class="math"&gt;\(\ve{C}\)&lt;/span&gt; の固有値が全て求まることが示せる。&lt;span class="math"&gt;\(\ve{C}\)&lt;/span&gt; の1行目を縦ベクトル化して &lt;span class="math"&gt;\(\ve{c} = [ c_{0} \ c_{1} \ ... \ c_{n-1} ]^{\mathsf{T}}\)&lt;/span&gt; と書き、そのDFTを &lt;span class="math"&gt;\(\mathcal{F}(\ve{c})\)&lt;/span&gt; と書くと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mathcal{F}(\ve{c}) &amp;amp;:= \ve{F}\ve{c} \\
&amp;amp;= \left[ \ \ve{f}_{0} \ \ve{f}_{1} \ ... \ \ve{f}_{n-1}\ \right] \ve{c} \\
&amp;amp;= \left[ \begin{array}{c}
(\ve{f}_{0})_{0} c_{0} + (\ve{f}_{1})_{0} c_{1} + ... + (\ve{f}_{n-1})_{0} c_{n-1} \\
(\ve{f}_{0})_{1} c_{0} + (\ve{f}_{1})_{1} c_{1} + ... + (\ve{f}_{n-1})_{1} c_{n-1} \\
\vdots \\
(\ve{f}_{0})_{n-1} c_{0} + (\ve{f}_{1})_{n-1} c_{1} + ... + (\ve{f}_{n-1})_{n-1} c_{n-1} \\
\end{array} \right] \\
&amp;amp;= \left[ \begin{array}{c}
\omega_{n}^{0 \times 0} c_{0} + \omega_{n}^{0 \times 1} c_{1} + ... + \omega_{n}^{0 \times (n-1)} c_{n-1} \\
\omega_{n}^{1 \times 0} c_{0} + \omega_{n}^{1 \times 1} c_{1} + ... + \omega_{n}^{1 \times (n-1)} c_{n-1} \\
\vdots \\
\omega_{n}^{(n-1) \times 0} c_{0} + \omega_{n}^{(n-1) \times 1} c_{1} + ... + \omega_{n}^{(n-1) \times (n-1)} c_{n-1} \\
\end{array} \right]
= \left[ \begin{array}{c}
\sum_{j=0}^{n-1} c_{j} \omega_{n}^{0 \times j} \\
\sum_{j=0}^{n-1} c_{j} \omega_{n}^{1 \times j} \\
\vdots \\
\sum_{j=0}^{n-1} c_{j} \omega_{n}^{(n-1) \times j}
\end{array} \right] \\
&amp;amp;= \left[ \begin{array}{c}
\lambda_{0} \\ \lambda_{1} \\ \vdots \\ \lambda_{n-1}
\end{array} \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;フーリエ係数がそのまま固有値になっており、したがって、 &lt;span class="math"&gt;\(\ve{c}\)&lt;/span&gt; のDFTは &lt;span class="math"&gt;\(\ve{C}\)&lt;/span&gt; の固有値を並べたベクトルに変換される事がわかった。求まった固有値の逆数をとって逆フーリエ変換すれば、巡回行列の逆 &lt;span class="math"&gt;\(\ve{C}^{-1}\)&lt;/span&gt; が求まってしまう。離散フーリエ変換はFFT（高速フーリエ変換）によって &lt;span class="math"&gt;\(\mathcal{O}(n\log n)\)&lt;/span&gt; で計算できるから高速に逆行列計算ができることになる。たまげたなあ。&lt;/p&gt;
&lt;p&gt;なにかの時系列データに対してDFT(FFT)を実行すると、それは巡回行列の固有値を求めていることに等しくなる。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="記事"></category><category term="巡回行列"></category><category term="Circulant Matrix"></category></entry><entry><title>\(R^{-1}\) の計算(18)</title><link href="/r-1-noji-suan-18.html" rel="alternate"></link><published>2020-11-25T10:00:00+09:00</published><updated>2020-11-25T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-25:/r-1-noji-suan-18.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;進捗報告。TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;sklearn …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;進捗報告。TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;sklearn.glasso: LARSを試す
- sllearn.glassoを使った。却ってくっそ遅い。また、alpha=1e-4とすると悪条件過ぎて収束せずエラーを出した。
- 性能は自前実装glassoとほぼ同じ。
- 自前実装座標降下 &amp;gt; sklearn座標降下 &amp;gt; sklearn最小角 と言った感じ。sklearnは前処理とか入念にやるから遅いのは当然。しかし最小角が遅い理由はなんだ？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/2961686/approximating-the-inverse-of-a-perturbed-matrix"&gt;摂動展開&lt;/a&gt; を試す&lt;/li&gt;
&lt;li&gt;ガウス過程の文脈で考えてFFTする
- テプリッツ行列を巡回行列化してFFTすれば逆行列が &lt;span class="math"&gt;\(\mathcal{O}(n\log n)\)&lt;/span&gt; で求まる。
- これは大事な別方針なので記事にした。
- &lt;a class="reference external" href="https://ryamada22.hatenablog.jp/entry/20131203/1386210156"&gt;周期性と巡回行列&lt;/a&gt; ここらへんの話もえぐい。&lt;/li&gt;
&lt;li&gt;逐次的glassoにはBaysianの考え方も使える。（Bayesian Graphical LASSO）&lt;/li&gt;
&lt;li&gt;Sherman-Morrisonをもう一段展開する&lt;/li&gt;
&lt;li&gt;厳密解とのズレはどうなっとる？安定性解析は？&lt;/li&gt;
&lt;li&gt;できないやつのコードを共有する
- 次元を落として解軌跡を調査する。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(17)</title><link href="/r-1-noji-suan-17.html" rel="alternate"></link><published>2020-11-21T10:00:00+09:00</published><updated>2020-11-21T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-21:/r-1-noji-suan-17.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;間に合うかわ …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;間に合うかわからんが、Wiener-Hopf解を解く共役勾配法を試してみるのだ。
上手く行かなくていじけて寝てたりしたら20:00。大きく変化しすぎているように見えたので、係数更新量をステップサイズで調節できるようにしたら、マトモな、NLMS以上の性能を出し始めた。おそらくこれが意図した性能のはず。&lt;/p&gt;
&lt;p&gt;簡単に見てみると、i.i.d.なノイズに対しては収束がかなり早い。NGSA以上。論文で言ってたようにRLSクラスに見える。&lt;/p&gt;
&lt;p&gt;相関ありノイズ入力では性能が落ちる。勾配の尾根には早く達するが、そこからが遅い。最適値に収束するまでにSAに追いつかれるパターンも見られた。&lt;/p&gt;
&lt;p&gt;自己相関行列は事前に計算したほうが性能が良い風に見受けられる（しかし、適応計算を考えて、デフォルトでは指数的更新則を使う）。また、ポラック・リビエールではなくガチの共役勾配法で勾配の結合係数を計算したら性能がより良くなったように見える。&lt;/p&gt;
&lt;p&gt;指数平均の更新則は(alpha * prev + (1-alpha) * current)ではなく(alpha * prev + current)が正しいので見つけ次第直している。&lt;/p&gt;
&lt;p&gt;さて、これをSA化しようと思っている。アルゴリズムの途中にLMSの勾配が現れているので、これをSA化すればいいじゃんと思ったら、非常に性能が悪くなった。最適値周辺で暴れまくる。ちゃんと式を追いましょう。&lt;/p&gt;
&lt;p&gt;うーん、わからん。共役勾配法は完全にWiener-Hopf方程式を解こうとしている。g（勾配）はWiener-Hopfとのズレ（残差ベクトル）として定義されている。そのズレをSAの勾配に置き換えても上手く行かない。。。&lt;/p&gt;
&lt;p&gt;どうしようか、報告としては、共役勾配法があって強力なんだけどSAとして持っていけない…という風に持っていこうかな。glassoはたしかに良いんだけど、効率的な更新方法が見つからない。というかんじ。&lt;/p&gt;
&lt;p&gt;ソース整理開始。glassoをsubmoduleにぶっこむのがTODO。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(16)</title><link href="/r-1-noji-suan-16.html" rel="alternate"></link><published>2020-11-20T23:00:00+09:00</published><updated>2020-11-20T23:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-20:/r-1-noji-suan-16.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;課題祭りで11 …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;課題祭りで11/19と11/20の昼は潰れる。今から進めるだけ進める。
前までに確認した「直前の勾配とは必ずしも直交しない」の解決策を今日は考えたい。3連休は準備に入らないとまずそう。色々やっちゃったし。&lt;/p&gt;
&lt;p&gt;解決策は &lt;a class="reference external" href="https://pdfs.semanticscholar.org/2f97/524c54126234535e2741581890f5f65cf627.pdf"&gt;論文&lt;/a&gt; にあると思う。適応的にやるんだったら上の問題は絶対に出てくるはずだし。&lt;/p&gt;
&lt;p&gt;論文に答えが色々書いてあった。手法の要点は、&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;共役勾配の線形結合係数にポラック・ラビエール（Polak-Ribiere）の式を使う。フレッチャー・リーブス（論文では(6)式）より実験的に性能が良かったらしい。&lt;/li&gt;
&lt;li&gt;線形結合係数には2次式を仮定した値を使う。ただし、η倍（定数倍）する（収束が保証される範囲が忘却係数により決まる）。これによって勾配は必ずしもステップ毎に直交しなくなり、定数ステップでの収束が保証されなくなる。（しかし、適応アルゴリズムにとってはむしろこれがいい！）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考になった情報は、&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;論文以前の共役勾配ベースの適応アルゴリズムは、ブロック単位で自己相関行列（とWiener-Hopfの式の右辺のb）を更新していた。この論文ではサンプル単位で更新するアルゴリズムを提案する。&lt;/li&gt;
&lt;li&gt;R,bをブロック単位で求めて更新する方法と、逐次的に忘却係数をかけて更新する手法の性能を比較。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;難点（というか、新規性が生まれそうなところ）は、そのままNGSAには突っ込めないところか。この論文では二乗誤差最小基準で議論している、すなわちWiener-Hopf解を求めようとしている。勾配はWiener-Hopf解とのズレベクトルで定義される。NGSA(SA)の目的関数はなんだ？&lt;/p&gt;
&lt;p&gt;論文のノーテーションに合わせ、実装を整理しつつも実験。でもやっぱ傾向は変わらんよ。SAと同等家それ以下。
気になるのは、NGSA(SA)の目的関数に合わせたことをしなければならないという点。Wiener-Hopf解を解く実装だとパフォーマンスは良いのか？まずはそこから切り込んで調べる。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(15)</title><link href="/r-1-noji-suan-15.html" rel="alternate"></link><published>2020-11-18T10:00:00+09:00</published><updated>2020-11-18T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-18:/r-1-noji-suan-15.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;どうするかな …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;どうするかな。中間発表まで残り1週間というところ。
話す内容のまとめを、明日辺り考えてからまとめに向けた作業を行いたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;主題: &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; の計算を避けるか高速に計算したい。&lt;ul&gt;
&lt;li&gt;方策1: Graphical LASSOを使おう&lt;ul&gt;
&lt;li&gt;真の逆行列とかなり近い行列が計算できてる。&lt;/li&gt;
&lt;li&gt;計算負荷が高い。。逐次計算でやるにはどうすればいいか。調査中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方策2: &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; の計算を避けよう&lt;ul&gt;
&lt;li&gt;共役勾配法を使う: 性能が良くない。なんで？理論的には納得いってるのに。&lt;/li&gt;
&lt;li&gt;準ニュートン法を使う: なかなか良い結果。だけど、&lt;span class="math"&gt;\(R\)&lt;/span&gt; すら使ってないから面白くない。準ニュートン法を使いましたで終わってしまう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日は共役勾配法が上手く行かないのが納得行かないから原因を追いたい。&lt;/p&gt;
&lt;p&gt;数式を軽く追ったところ、少し原因が見えた。共役勾配法をおさらいする。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(k\)&lt;/span&gt; ステップ目における共役勾配を &lt;span class="math"&gt;\(\ve{m}[k]\)&lt;/span&gt; 、関数 &lt;span class="math"&gt;\(f\)&lt;/span&gt; の勾配 &lt;span class="math"&gt;\(\parfrac{f}{\ve{h}}\)&lt;/span&gt; は、&lt;span class="math"&gt;\(\ve{R}\ve{m}[k] \propto \parfrac{f}{\ve{h}}\)&lt;/span&gt; の関係が成り立つ。（これは自然勾配法の原理からも自然に出てくる。ていうか、ここでの自然勾配は共役勾配に等しい）
また、直前の勾配と直交するから &lt;span class="math"&gt;\(\innerp{\ve{m}[k-1]}{\ve{R}\ve{m}[k]} = 0\)&lt;/span&gt; が成り立ち、&lt;span class="math"&gt;\(\ve{m}[k]\)&lt;/span&gt; は &lt;span class="math"&gt;\(\parfrac{f}{\ve{h}}\)&lt;/span&gt; と &lt;span class="math"&gt;\(\ve{m}[k-1]\)&lt;/span&gt; の線形結合で書ける: &lt;span class="math"&gt;\(\ve{m}[k] = \parfrac{f}{\ve{h}} + \alpha[k] \ve{m}[k-1]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;直交関係式から、 &lt;span class="math"&gt;\(\alpha[k] = - \frac{\innerp{\ve{m}[k-1]}{\ve{R}\parfrac{f}{\ve{h}}}}{\innerp{\ve{m}[k-1]}{\ve{R}\ve{m}[k-1]}}\)&lt;/span&gt; と求められる。こっから得られた &lt;span class="math"&gt;\(\ve{m}[k]\)&lt;/span&gt; で直線探索すればよい。という話。&lt;/p&gt;
&lt;p&gt;(13)で言った「Wiener-Hopf方程式を共役勾配法で」というのは、要は &lt;span class="math"&gt;\(\ve{R}\ve{h} = \ve{b}\)&lt;/span&gt; を共役勾配法で逐次的に解くということ。ここで、 &lt;span class="math"&gt;\(\ve{b}\)&lt;/span&gt; は入力とリファレンスの相関ベクトル。&lt;/p&gt;
&lt;p&gt;しかし、適応フィルタでは直交条件（&lt;span class="math"&gt;\(\innerp{\ve{m}[k-1]}{\ve{R}\ve{m}[k]} = 0\)&lt;/span&gt; ）が必ずしも成立しない。実験的に直前の勾配が今の勾配に直交しないことを確かめている。現に、 &lt;span class="math"&gt;\(\parfrac{f}{\ve{h}}\)&lt;/span&gt; は少しずつ変化しているから2ステップ間で直交していない。また、無理やり実装した共役勾配法はカクカクに、つまり前ステップの勾配と直交する方向に動くような挙動を観察している。&lt;/p&gt;
&lt;p&gt;この直交していないのをなんとかすれば解決できそうだけど、今の所解決策が思いつかない。考え中。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(14)</title><link href="/r-1-noji-suan-14.html" rel="alternate"></link><published>2020-11-17T10:00:00+09:00</published><updated>2020-11-17T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-17:/r-1-noji-suan-14.html</id><summary type="html">&lt;p&gt;課題が降ってきて研究が進まねえ。
今日はGraphical LASSOとの連携を試してみたい、かも。
共役勾配法はあんまり良くないでFA、準 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;課題が降ってきて研究が進まねえ。
今日はGraphical LASSOとの連携を試してみたい、かも。
共役勾配法はあんまり良くないでFA、準ニュートン法は統計量使ってないから面白くない、という結論に回す。&lt;/p&gt;
&lt;p&gt;最初は、Rの逆行列を事前に求めちゃってやる方式で試してみる。
よさそうなら逐次的実装にトライ。&lt;/p&gt;
&lt;p&gt;Rの逆行列を事前に求める方式はあんまり良くない、というかSAと同程度。
なんでなのか軽く見てみたら、事前計算でわかったR^-1をそのまま使うのはNGSAでも良くないということがわかった。
事前計算の場合の &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; はほぼ単位行列だから当然か・・・。&lt;/p&gt;
&lt;p&gt;逐次的が求められていると思い、むりやり逐次的にもとめるようにしてみた、が、あんまり結果が変わらん。
繰り返し回数を多くしても傾向は同様。等方的なのが変わらないから良くないのか？しかしそれはNGSAとて同じことでは？？？&lt;/p&gt;
&lt;p&gt;それどころか、相関付きノイズを入力すると発散する…いや、繰り返し回数が少なすぎるからだ。繰り返し回数を10とかにすると収束早め。
（事前計算する場合は発散しなかった。）&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;caption&gt;ここまで見た結果を表にまとめると…&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;col width="20%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;手法&lt;/td&gt;
&lt;td&gt;i.i.d.雑音 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; 事前&lt;/td&gt;
&lt;td&gt;i.i.d.雑音 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; 逐次&lt;/td&gt;
&lt;td&gt;相関雑音 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; 事前&lt;/td&gt;
&lt;td&gt;相関雑音 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; 逐次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;NGSA&lt;/td&gt;
&lt;td&gt;SAと同程度&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;良&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;良&lt;/td&gt;
&lt;td&gt;良&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;NGSA(glasso)&lt;/td&gt;
&lt;td&gt;SAと同程度&lt;/td&gt;
&lt;td&gt;SAと同程度&lt;/td&gt;
&lt;td&gt;良&lt;/td&gt;
&lt;td&gt;良（繰り返しが少ないと発散）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;表で &lt;strong&gt;強調&lt;/strong&gt; したように、NGSAのi.i.d.雑音の逐次計算が早いのが納得行かない。 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; は単位行列に近いから、早くなるのは妙。
前計算する場合、勾配がどうなってるか気になる。正則化パラメータを弄ったとき、勾配はどこを向くのだろうか。
i.i.d.雑音でなんでNGSAの収束が早いのかもすごい気になる…。&lt;/p&gt;
&lt;p&gt;Jupyterに追記。glassoの正則化パラメータを強く（alphaを大きく）すると通常のSAの勾配に近づく（精度行列が単位行列に近づく）。逆に正則化パラメータを小さくすると自然勾配に近づく。
想像したとおりの結果で、だからどうしたといった感じ。そう、glassoをどう活かせばよいか？がまだ浮かんでこない。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(13)</title><link href="/r-1-noji-suan-13.html" rel="alternate"></link><published>2020-11-16T10:00:00+09:00</published><updated>2020-11-16T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-16:/r-1-noji-suan-13.html</id><summary type="html">&lt;p&gt;共役勾配法が上手く行かない原因を求めようとして、そもそもLMSで共役勾配法使ってんじゃねと思ったら、確かに使 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;共役勾配法が上手く行かない原因を求めようとして、そもそもLMSで共役勾配法使ってんじゃねと思ったら、確かに使ってる事例あり。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/2f97/524c54126234535e2741581890f5f65cf627.pdf"&gt;Analysis of Conjugate Gradient Algorithms for Adaptive Filtering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://researchbank.swinburne.edu.au/file/178f868d-d5a1-4794-8839-a995a6641691/1/PDF%20(Published%20version).pdf"&gt;Conjugate Gradient Algorithm Design with RLS Normal Equation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要は、 &lt;a class="reference external" href="https://engineering.purdue.edu/~mikedz/research/RomeLabTutor.pdf"&gt;Wiener-Hopf方程式を共役勾配法で逐次的に解く手法&lt;/a&gt; に該当する。ただし、2乗誤差基準。&lt;/p&gt;
&lt;p&gt;性能を見るとRLSと張り合っているあたり、だいぶいいはず。少なくとも論文に書いてあるとおり実装すれば良い性能は出るはず。&lt;/p&gt;
&lt;p&gt;自己相関行列だよなあ、やっぱり。もう俺の研究の新規性分かんねぇなあ。
いや、いま気になったことがある。Wiener-Hopf方程式を解くのが最終目標になるんやが、それのスパース解を圧縮に使えないか。
うーん、でも劣決定問題じゃない（Rが正定とすると一意解が出る）からあんまりうまく行かない？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.kurims.kyoto-u.ac.jp/EMIS/journals/ETNA/vol.4.1996/pp14-36.dir/pp14-36.ps"&gt;LMS-NEWTON ADAPTIVE FILTERING USING FFT–BASED CONJUGATE GRADIENT ITERATIONS&lt;/a&gt; 自己相関行列（テプリッツ行列）の分解法を示していた。Ammar and Gader the cyclic displacement representationというらしいがヒットしない…。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(12)</title><link href="/r-1-noji-suan-12.html" rel="alternate"></link><published>2020-11-15T10:00:00+09:00</published><updated>2020-11-15T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-15:/r-1-noji-suan-12.html</id><summary type="html">&lt;p&gt;準ニュートン法をもうちょっと試す。
BFGS法とDFP法をやってるけど、今の所はBFGS法が良さそう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ja.wikipedia.org/wiki/準ニュートン法"&gt;準ニュートン法(wikipedia)&lt;/a&gt; が悔し …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;準ニュートン法をもうちょっと試す。
BFGS法とDFP法をやってるけど、今の所はBFGS法が良さそう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ja.wikipedia.org/wiki/準ニュートン法"&gt;準ニュートン法(wikipedia)&lt;/a&gt; が悔しいけどまとまってる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;準ニュートン法は、直線探索を事後残差最小化に取る限り、中々安定した性能を出す。
いや、NLMSとほぼ同じ性能だった。事後残差最小化が強すぎて、勾配がそれに引っ張られているものと想像。&lt;/p&gt;
&lt;p&gt;NNGSA &amp;lt; NGSA &amp;lt; 準ニュートン法 &amp;lt; SA &amp;lt; 共役勾配法といった感じ。
共役勾配法が弱すぎんのがすごい気になってる。曲率がRで明示的にわかってんだから、もっと早いと思うんだけどなあ。&lt;/p&gt;
&lt;p&gt;そしてちょっと前から気付いてたけど、準ニュートン法はRを一切使っていない。直前の勾配の値を上手く組み合わせて収束を加速させている。
これはモーメンタムに似たものであろう（ちゃんと追いきれてない…）。&lt;/p&gt;
&lt;p&gt;もう一度共役勾配法を整理したい。金谷先生の本でわかった気になってるけど、webの情報と食い違ってる部分がある。。。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf"&gt;An Introduction to the Conjugate Gradient Method Without the Agonizing Pain&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>麻雀プログラミング</title><link href="/ma-que-puroguramingu.html" rel="alternate"></link><published>2020-11-14T12:00:00+09:00</published><updated>2022-02-18T22:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-14:/ma-que-puroguramingu.html</id><summary type="html">&lt;p&gt;秋口あたりから麻雀のプログラミングにハマっているフシがある。
すこし成果がまとまってきたので記事にしてみ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;秋口あたりから麻雀のプログラミングにハマっているフシがある。
すこし成果がまとまってきたので記事にしてみよう。&lt;/p&gt;
&lt;p&gt;なんと言っても、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.archive.org/web/20190402234201/http://cmj3.web.fc2.com/index.htm"&gt;麻雀C言語プログラム集&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;がきっかけだし、これがweb魚拓しか残っていないことに危機感を覚えた。シャンテン数計算と役計算は実装したい。あと有効牌判定。
そこから簡単なシミュレータ作って実験までできればいいなあと思うところ。&lt;/p&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;お役立ちリンク&lt;/h2&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3&gt;他の有名な？プロジェクト&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ja.osdn.net/projects/openmahjong/"&gt;オープン麻雀プロジェクト(仮称)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mahjong-server/mahjong-server/tree/master/tsumogiri"&gt;mahjong-serverのクライアント実装例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.logos.t.u-tokyo.ac.jp/~mizukami/"&gt;爆打の中の人&lt;/a&gt; ちゃんと研究に落とし込んでいる方。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.amy.hi-ho.ne.jp/ishihata/maujong/"&gt;まうじゃん的空間&lt;/a&gt; フリーでプレーヤーを自前実装できる「まうじゃん」の配布サイト。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/nekobean/mahjong-cpp"&gt;mahjong-cpp&lt;/a&gt; C++17(+ boost)で美しく書かれたライブラリ。テストも充実。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pystyle.info/mahjong-expected-value-in-mahjong/"&gt;麻雀 - 何切る問題の期待値の計算方法について&lt;/a&gt; 期待値計算方法が載っている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mahjong.ara.black"&gt;あらの（一人）麻雀研究所&lt;/a&gt; 一人麻雀とそのシミュレーション方法が示されている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3&gt;アルゴリズム全般&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ksta.skr.jp/topic/diaryb15.html#20101230"&gt;気まぐれな戯れ言 バックナンバー１５&lt;/a&gt; 役判定アルゴリズムの概要がつかめる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://hp.vector.co.jp/authors/VA046927/mjscore/mjalgorism.html"&gt;麻雀 和了判定（役の判定） アルゴリズム&lt;/a&gt; バックトラック法とインデックスを用いた約判定アルゴリズムについて。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mahjong.org/training/training_006/"&gt;牌理/牌効率ツール&lt;/a&gt; 有効牌列挙の動作確認に。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3&gt;数理的側面&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www10.plala.or.jp/rascalhp/mjmath.htm"&gt;麻雀の数学&lt;/a&gt; 組み合わせの議論。乱数xorshiftじゃ周期が足りないことに気づく。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://jankenso.com/dataroom.asp"&gt;雀賢荘データ室&lt;/a&gt; 強い打ち手の統計情報の要約&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h4&gt;乱数について&lt;/h4&gt;
&lt;p&gt;端的に言って沼。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;a class="reference external" href="https://programming-place.net/ppp/contents/algorithm/other/002.html"&gt;ランダムシャッフル | Programming Place Plus&lt;/a&gt; ランダムシャッフルのやり方。Fisher-Yates法を使いましょう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cafeunder.github.io/rosenblock-chainers-blog/2018/03/02/shuffle_array.html"&gt;配列のシャッフルコードの間違った実装&lt;/a&gt; 実装を誤ると痛い目に合う。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;一様乱数の作り方一つとっても落とし穴がある。。。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://takeda25.hatenablog.jp/entry/20130818/1376837093"&gt;いつからその方法で偏りのない乱数が得られると錯覚していた？&lt;/a&gt; まず読みましょう。そして、偏らない乱数を出すためには、以下の実装で行く必要があるようです。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;uniform_int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;adjusted_max&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RAND_MAX&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RAND_MAX&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;adjusted_max&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)(((&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;adjusted_max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;乱数範囲をnの倍数で切り捨ててから、実数の一様乱数にキャストする。剰余は下位ビットの偏りに影響を受けるからNG。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.albow.net/entry/random-range"&gt;C言語/C++で範囲を指定した乱数を生成する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://omitakahiro.github.io/random/random_variables_generation.html#Uniform"&gt;C言語による乱数生成&lt;/a&gt; 注意点は、剰余による一様乱数は偏りが出るということか。例えばRAND_MAX=10でrand()%3して0,1,2の乱数を作ろうとすると、0は0,3,6,9、1は1,4,7,10、2は2,5,8だから偏る。解決法としては、[0,1]の浮動小数点乱数を作ってから整数化する方法が奥村先生のアルゴリズム本含め推奨されていた。→**よくない**&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www001.upp.so-net.ne.jp/isaku/rand.html"&gt;良い乱数・悪い乱数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://blog.visvirial.com/articles/575"&gt;Google Chromeが採用した、擬似乱数生成アルゴリズム「xorshift」の数理&lt;/a&gt; &lt;a class="reference external" href="https://admiswalker.blogspot.com/2018/06/marsaglia-g-2003-xorshift-rngs.html"&gt;論文の紹介と検証：Marsaglia, G. 2003. Xorshift RNGs.&lt;/a&gt; XorShiftの分かりやすい解説。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.timbreofprogram.info/blog/archives/384"&gt;乱数ライブラリを更新してみた&lt;/a&gt; XorShiftの初期値のとり方。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://prng.di.unimi.it"&gt;xoshiro / xoroshiro&lt;/a&gt; 統計的により望ましい乱数列を出すアルゴリズム。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="ai"&gt;
&lt;h3&gt;AI（プレーヤー）について&lt;/h3&gt;
&lt;p&gt;プレーヤーは間違いなくインターフェースとして実装すべきで、転用を考えて、他の有名なものと互換性のある形に実装しておきたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.amy.hi-ho.ne.jp/ishihata/maujong/iface.html"&gt;「まうじゃん」対戦相手プラグイン　インターフェース仕様&lt;/a&gt; C/C++版の解説。そうか、プレーヤーがゲーム側に問い合わせる状態取得インターフェースもいるな。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.amy.hi-ho.ne.jp/ishihata/maujong/java/javadoc/current/jp/gr/java_conf/ishihata/mj_ai/package-summary.html"&gt;まうじゃんのインターフェース仕様&lt;/a&gt; Java版の解説&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.nicovideo.jp/watch/sm21043481"&gt;[麻雀]コンピュータで鳳凰卓を目指すpart1[天鳳]&lt;/a&gt; 最初はシャンテン数を減らすことだけ考える。次はベタオリ、次は鳴き。取っ掛かりにはかなり良さそう。&lt;/li&gt;
&lt;li&gt;まうじゃんAI:&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.amy.hi-ho.ne.jp/ishihata/maujong/plugin.html"&gt;対戦相手プラグインの部屋&lt;/a&gt; まうじゃんの対戦相手のプラグイン集。強いことで有名な「アカギ」がいる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://maurato.blog.fc2.com/blog-entry-1.html"&gt;まうじゃん対戦相手プラグイン「しぐま０」v1.00公開&lt;/a&gt; アカギよりちょっと強い打ち手。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h3&gt;牌譜について&lt;/h3&gt;
&lt;p&gt;可能であれば牌譜出力にも対応できたほうが良い（AIがどんな挙動してるか見える）&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://blog.kobalab.net/entry/20151228/1451228689"&gt;電脳麻将の牌譜形式&lt;/a&gt; jsonで独自だが可読性に優れていそう。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.archive.org/web/20190403121158/http://mj.giganet.net/mjscore.htm"&gt;mjscore.txtの書式について&lt;/a&gt; シンプルで可読性あるけど日本語ガッツリ入ってるのでパースに苦戦しそう&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h3&gt;麻雀用語の英語&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://perceptualmahjong.blog.ss-blog.jp/2010-10-08"&gt;英語の麻雀用語集・表現集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://crescent.s255.xrea.com/cabinet/others/mahjong/"&gt;麻雀用語英名一覧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://blog.kobalab.net/entry/20170722/1500688645"&gt;電脳麻将のプログラム中の中国語一覧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="趣味"></category><category term="麻雀"></category><category term="向聴数"></category><category term="得点計算"></category></entry><entry><title>\(R^{-1}\) の計算(11)</title><link href="/r-1-noji-suan-11.html" rel="alternate"></link><published>2020-11-14T10:00:00+09:00</published><updated>2020-11-14T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-14:/r-1-noji-suan-11.html</id><summary type="html">&lt;p&gt;共役勾配法をもうちょっと見てから、準ニュートン法を試そうかというのが今日の目標。&lt;/p&gt;
&lt;p&gt;共役勾配法の性能をまとめ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;共役勾配法をもうちょっと見てから、準ニュートン法を試そうかというのが今日の目標。&lt;/p&gt;
&lt;p&gt;共役勾配法の性能をまとめると、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;SAより同程度かそれ以下。&lt;/li&gt;
&lt;li&gt;自己相関行列は逐次的に求めていった方がほんのわずかに性能が良い。&lt;/li&gt;
&lt;/ul&gt;
&lt;img alt="共役勾配法を使ったNGSAとSAの性能比較（i.i.d.な雑音入力, 自己相関は逐次的に計算）" class="align-center" src="./images/ngsa_cg_learning_curves_case01.png" style="width: 400px;" /&gt;
&lt;p&gt;で、なんで？というところで答えが出ない。
勾配プロットすりゃいいんじゃねと思うんだが、共役勾配は明示的に前ステップの情報を使うから、静的な勾配を見ることができない。&lt;/p&gt;
&lt;p&gt;準ニュートン法を試す。勾配をどれくらい進めるかを決める直線探索をいかに上手くやるかがポイントだった。
いつもの事後残差最小化で行ったら実に上手く行った。（直線探索を上手くやらず固定ステップサイズにすると性能悪化）
じゃあ共役勾配も事後残差最小基準でステップサイズ設定してやる→性能向上しない。なぜだ。&lt;/p&gt;
&lt;p&gt;今の所、準ニュートン法の結果は不安定に見える。異常に早いときは2~3イテレーションで極値近くに達する。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(10)</title><link href="/r-1-noji-suan-10.html" rel="alternate"></link><published>2020-11-11T10:00:00+09:00</published><updated>2020-11-11T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-11:/r-1-noji-suan-10.html</id><summary type="html">&lt;p&gt;共役勾配法を実装して（fが二次として金谷先生の例題3.5をそのまま使用）試してはいるが、性能が良くない。具体的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;共役勾配法を実装して（fが二次として金谷先生の例題3.5をそのまま使用）試してはいるが、性能が良くない。具体的には普通のSAと変わらんくらい。
実装ミスを疑っている。確かめるためにJupyterで検証しているけど、無難な結果が出ていると思われる。。。&lt;/p&gt;
&lt;p&gt;でもおかしいんだよなあ。発想自体は自然勾配と全く同じはずなのにあまり良くならないのは、やっぱり引っかかる。
もう少し追うけど、ダメそうなら切り替えて、次は準ニュートン法を試してみたい。
しっかし共役勾配法についてはもう少し粘るし、準ニュートン法との比較はちゃんとすること。投げっぱなし良くない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.uno.nuem.nagoya-u.ac.jp/~taji/lecture/mathprog/no9_18.pdf"&gt;制約なし問題の解法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://tm23forest.com/contents/bfgs-formula-quasi-newton-method-scipy-motivated"&gt;BFGS公式による準ニュートン法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;丁寧目の説明。ん？セカント方程式は劣決定問題だと言ってる。スパースな何かを使えないか？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://imclab.sys.okayama-u.ac.jp/~kent/DIR/opt08.pdf"&gt;システム制御最適化特論 非線形最適化&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;証明多め。丁寧な説明。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.orsj.or.jp/archive2/or59-03/or59_3_131.pdf"&gt;無制約最適化問題に対する アルゴリズムの最前線 ―非線形共役勾配法を中心に―&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.coyote009.com/non-linear-optimization"&gt;制約無し非線形最適化手法のいろいろ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.sist.ac.jp/~suganuma/kougi/other_lecture/SE/opt/nonlinear/nonlinear.htm"&gt;システムの最適化 － ２．非線形計画法（ NP: Nonlinear Programming ） －&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;簡単めな説明で実装しやすさがある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(9)</title><link href="/r-1-noji-suan-9.html" rel="alternate"></link><published>2020-11-09T10:00:00+09:00</published><updated>2020-11-09T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-09:/r-1-noji-suan-9.html</id><summary type="html">&lt;p&gt;講義受けてて思ったこと。Cramer-RaoをNGSAの学習能力の評価に使えないか？
パット見使えなそう。うーむ。右辺というかFisher情報行 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;講義受けてて思ったこと。Cramer-RaoをNGSAの学習能力の評価に使えないか？
パット見使えなそう。うーむ。右辺というかFisher情報行列の逆は見えてるんだけど、比較対象の左辺が具体的に構成できない。（思い浮かばない）&lt;/p&gt;
&lt;p&gt;共役勾配法を入れて色々試してみてるけど、普通の勾配法とほぼ性能が変わらないという謎の状態。
2次の情報を使ってるので何かしら変化があるはずなのに、ほぼ変わらないのはおかしい。
自己相関行列を逐次的ではなく、前もって計算してやってみても同じ。謎。&lt;/p&gt;
&lt;p&gt;また共役勾配を見ると高級なモーメンタム法にしか見えないなあ。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(8)</title><link href="/r-1-noji-suan-8.html" rel="alternate"></link><published>2020-11-08T10:00:00+09:00</published><updated>2020-11-08T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-08:/r-1-noji-suan-8.html</id><summary type="html">&lt;p&gt;今日は共役勾配法を試してみたい、が、その前にソース整理してcommitしとこう。&lt;/p&gt;
&lt;p&gt;pylintやるなりリファクタしてたら時間的に …&lt;/p&gt;</summary><content type="html">&lt;p&gt;今日は共役勾配法を試してみたい、が、その前にソース整理してcommitしとこう。&lt;/p&gt;
&lt;p&gt;pylintやるなりリファクタしてたら時間的にアウトになった。今日は見送りか...若干焦るけどしゃあない。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(7)</title><link href="/r-1-noji-suan-7.html" rel="alternate"></link><published>2020-11-07T10:00:00+09:00</published><updated>2020-11-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-07:/r-1-noji-suan-7.html</id><summary type="html">&lt;p&gt;課題にかまけていたら平日全く時間を取れなかった。まずい。
なんのためにここに来ているのか改めて考えなければ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;課題にかまけていたら平日全く時間を取れなかった。まずい。
なんのためにここに来ているのか改めて考えなければなるまい。&lt;/p&gt;
&lt;p&gt;やるべきは、NGSAにGraphical LASSOを入れるのが最終目的として、
他にもいきなり思い出したことがある。夏に一瞬、共役勾配法を使えないかと言うのを考えていた。
改めて金谷先生の本を読んでもやれそうに見えるのだ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Graphical LASSOを逐次的に実行する手法はあるか？&lt;ul&gt;
&lt;li&gt;手法自体は中々見つかっていない・・・&lt;ul&gt;
&lt;li&gt;繰り返し回数を1で固定して、経験自己相関を逐次的に更新できれば。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ないとしても、自己相関行列を逐次計算する手法はあるか？&lt;ul&gt;
&lt;li&gt;共分散行列としたら色々出てきている…が、ピンとくる手法は無いように思える。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1504.02995.pdf"&gt;An Overview on the Estimation of Large Covariance and Precision Matrices&lt;/a&gt; でかい精度行列を推定する手法のサーベイ&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://faculty.marshall.usc.edu/Jacob-Bien/papers/biometrika2011spcov.pdf"&gt;Sparse Estimation of a Covariance Matrix&lt;/a&gt; 共分散行列のスパース推定&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://webee.technion.ac.il/Sites/People/YoninaEldar/Info/Shrink.pdf"&gt;Shrinkage Algorithms for MMSE Covariance Estimation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://hal.inria.fr/inria-00369468/document"&gt;Efficient Covariance Matrix Update for Variable Metric Evolution Strategies&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;対称な3重対角行列であることを活かせない？&lt;ul&gt;
&lt;li&gt;活かすといっても何を活かせばいいんだろう。逆行列の計算が早い？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tridiagonal_matrix#Inversion"&gt;wikipedia&lt;/a&gt; に情報はあるけど、何をどう活かせばいいのか…うーん。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.phys.lsu.edu/faculty/oconnell_new/PDFfiles/241.%20Analytical%20Inversion%20of%20Symmetric%20Tridiagonal%20Matrices.pdf"&gt;Analytical inversion of symmetric tridiagonal matrices&lt;/a&gt; 簡単なケースに対するものは解析解が求まっている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共役勾配法を導入するとどうなる？&lt;ul&gt;
&lt;li&gt;ヘッセ行列の計算を省いたときの、ビール・ソレンソン、ポラック・リビエール、フレッチャー・リーブスはどうなる？&lt;ul&gt;
&lt;li&gt;これらを試すのは十分にあり。 &lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; を考える必要すらない。 ビール・ソレンソン等によれば &lt;span class="math"&gt;\(R\)&lt;/span&gt; すらいらなくなる。しかし、気になるのは既存研究。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;メモ:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nagahara-masaaki.github.io/assets/pdfs/lecture10.pdf"&gt;Gershgorinの定理の優しい解説&lt;/a&gt; 要約すると、固有値の範囲をその行列の要素から特定できる定理なのだ。スパースモデリングでも度々出てくる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jappstat1971/22/3/22_3_99/_pdf/-char/en"&gt;階層型ニューラルネットとその周辺&lt;/a&gt; NNに対する自然勾配法（Fisherのスコアリング法と言っている）の原始的な定式化。広島大学の栗田先生。甘利先生より早いのでは？&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/profile/Takio_Kurita/publication/2372487_Iterative_Weighted_Least_Squares_Algorithms_For_Neural_Networks_Classifiers/links/0fcfd509460b783ab6000000/Iterative-Weighted-Least-Squares-Algorithms-For-Neural-Networks-Classifiers.pdf"&gt;ITERATIVE WEIGHTED LEAST SQUARES ALGORITHMS FOR NEURAL NETWORKS CLASSIFIERS&lt;/a&gt; Fisherのスコアリング法を提案している論文。&lt;/li&gt;
&lt;li&gt;2乗誤差基準でFisher情報行列を求めると、重み付きの入力の相関になる…まさか、LMSも重み付き相関で求まることを言っている？→簡単に確認したけどそんなことは無いはず…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(6)</title><link href="/r-1-noji-suan-6.html" rel="alternate"></link><published>2020-11-01T10:00:00+09:00</published><updated>2020-11-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-11-01:/r-1-noji-suan-6.html</id><content type="html">&lt;p&gt;Graphical LASSOを積み込むべきなのかもしれない。
まずは遅くてもいいから、NGSAに入れてみて様子を見よう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(5)</title><link href="/r-1-noji-suan-5.html" rel="alternate"></link><published>2020-10-31T10:00:00+09:00</published><updated>2020-10-31T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-31:/r-1-noji-suan-5.html</id><summary type="html">&lt;p&gt;Graphical LASSOの実装ができたように見える。ハマったのは&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;精度行列と共分散行列を逆に見ていた ← 致命的&lt;/li&gt;
&lt;li&gt;座標降下法ではベク …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Graphical LASSOの実装ができたように見える。ハマったのは&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;精度行列と共分散行列を逆に見ていた ← 致命的&lt;/li&gt;
&lt;li&gt;座標降下法ではベクトルを一気に更新したらだめ（収束しない！！）で、要素1つづつ更新する必要がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;トイデータ（人工的なノイズ）はOKっぽい。
実データでリファレンス（sklearn実装）と対角要素がかなり違う。何故だ。&lt;/p&gt;
&lt;p&gt;実装ミスで間違いなさそう。入力信号を100で割るなりして小さくすると、共分散行列の逆の対角要素、及び精度行列の対角要素は大きくなるが、
自分の実装は大きくなっていかない。&lt;/p&gt;
&lt;p&gt;ノルム正規化したものを比較したら最大でも0.008程度の誤差。しかし、定数倍除き一致というのもおかしい。&lt;/p&gt;
&lt;p&gt;しばらく追っていたら、入力信号の振幅に対して逆二乗で差が出ていることに気づいた。もっと見たら、共分散行列の初期化で正則化をかけているのが原因であることが分かった。正則化をかけると対角要素が変わってしまう。やるなら、別の正則化パラメータにするかな。今は外した。外すことで入力信号問わずほぼ一致。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(4)</title><link href="/r-1-noji-suan-4.html" rel="alternate"></link><published>2020-10-27T10:00:00+09:00</published><updated>2020-10-27T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-27:/r-1-noji-suan-4.html</id><summary type="html">&lt;p&gt;引き続き&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf3/sklearn/covariance/_graph_lasso.py"&gt;sklearnのソース(Github)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;を見ながら、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ide-research.net/papers/2016_Iwanami_Ide.pdf"&gt;依存関係にスパース性を入れる — グラフィカル lasso の話 ∗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の対応を見出そうとしてい …&lt;/p&gt;</summary><content type="html">&lt;p&gt;引き続き&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf3/sklearn/covariance/_graph_lasso.py"&gt;sklearnのソース(Github)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;を見ながら、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ide-research.net/papers/2016_Iwanami_Ide.pdf"&gt;依存関係にスパース性を入れる — グラフィカル lasso の話 ∗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の対応を見出そうとしているが、どうも一致しない。pythonのソース側が対応していると言っているのがFriedman&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://statweb.stanford.edu/~tibs/ftp/graph.pdf"&gt;Sparse inverse covariance estimation with the graphical lasso&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;とあるので、それを参照したが、実装はFortran...（Rは呼び出しインターフェースだけ。。。）&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf39bbdacd6ed713c00724f8f871d60370/sklearn/covariance/_graph_lasso.py#L226"&gt;GLASSOの中身&lt;/a&gt; で &lt;a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf39bbdacd6ed713c00724f8f871d60370/sklearn/linear_model/_cd_fast.pyx#L99"&gt;enet_coordinate_descent関数&lt;/a&gt; を呼んでおり、数値最適化はLASSO(ElasticNetで片方の係数を0にしたもの)に任されている。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;どうやら元論文の実装(LASSO最適化を行う)をそのまま落とし込んだようで、ソフトしきい値作用素は一切出てこない。。。
githubで探してみても同様の実装が多数。&lt;/p&gt;
&lt;p&gt;いや、各 &lt;span class="math"&gt;\(\beta_{i}\)&lt;/span&gt; の最適化は座標降下法だから、むしろそれが正しいのか。&lt;/p&gt;
&lt;p&gt;いずれにしても簡単そうに見えるから実装してみるか。アルゴリズムを紙にまとめてみた。やってみよう。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(3)</title><link href="/r-1-noji-suan-3.html" rel="alternate"></link><published>2020-10-26T10:00:00+09:00</published><updated>2020-10-26T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-26:/r-1-noji-suan-3.html</id><summary type="html">&lt;p&gt;要約すると、もうGraphical LASSO実装して試してみるべきかと思う。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf3/sklearn/covariance/_graph_lasso.py"&gt;sklearnのソース(Github)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数式との対応を追っていく。（しっかし昼は全く …&lt;/p&gt;</summary><content type="html">&lt;p&gt;要約すると、もうGraphical LASSO実装して試してみるべきかと思う。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf3/sklearn/covariance/_graph_lasso.py"&gt;sklearnのソース(Github)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数式との対応を追っていく。（しっかし昼は全く集中できない。。。）
気になるのはオプティマイザ（勾配法orLARS）の実装が他のモジュールでやってるところか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(2)</title><link href="/r-1-noji-suan-2.html" rel="alternate"></link><published>2020-10-25T10:00:00+09:00</published><updated>2020-10-25T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-25:/r-1-noji-suan-2.html</id><summary type="html">&lt;p&gt;今更ながら三重対角行列、かなり具合が良さそうに見える。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mathtrain.jp/tridiagonal"&gt;三重対角行列の特殊形の固有値は綺麗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gg-hogehoge.hatenablog.com/entry/2013/07/20/140341"&gt;三重対角行列の固 …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;今更ながら三重対角行列、かなり具合が良さそうに見える。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mathtrain.jp/tridiagonal"&gt;三重対角行列の特殊形の固有値は綺麗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gg-hogehoge.hatenablog.com/entry/2013/07/20/140341"&gt;三重対角行列の固有値と固有ベクトルを計算したい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://hooktail.org/computer/index.php?%BB%B0%BD%C5%C2%D0%B3%D1%B2%BD"&gt;三重対角化 - [物理のかぎしっぽ]&lt;/a&gt; 頭に入れときたいのは、「対称行列は直交行列との積（直交変換）で3重対角行列に変換できる」ということ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.stat.yale.edu/~hz68/sparsePM.pdf"&gt;Estimating sparse precision matrices&lt;/a&gt; スパース（三重対角）な精度行列（共分散行列の逆行列）を求める。これ、かなり近いのでは。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;やはり、Graphical LASSOを遅くてもいいから試したくある。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://omedstu.jimdofree.com/2018/03/28/graph-lassoによる変数間の関係のグラフ化/"&gt;GraphLassoによる変数間の関係のグラフ化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;sklearnで実装されているから、逐次計算じゃなくても計算してみることはできる。次はsklearnによる結果と比較してみよう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>\(R^{-1}\) の計算(1)</title><link href="/r-1-noji-suan-1.html" rel="alternate"></link><published>2020-10-24T10:00:00+09:00</published><updated>2020-10-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-24:/r-1-noji-suan-1.html</id><summary type="html">&lt;p&gt;&lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; の計算高速化を考えていく。
なにより対象を知るのが一番だと思うので、まずは確認コードと真値の計算とその …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;span class="math"&gt;\(R^{-1}\)&lt;/span&gt; の計算高速化を考えていく。
なにより対象を知るのが一番だと思うので、まずは確認コードと真値の計算とその確認を行っていく。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Sign Algorithm"></category><category term="Auto Correlation"></category></entry><entry><title>論文書き(1)</title><link href="/lun-wen-shu-ki1.html" rel="alternate"></link><published>2020-10-16T10:00:00+09:00</published><updated>2020-10-16T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-16:/lun-wen-shu-ki1.html</id><summary type="html">&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;図:&lt;ul&gt;
&lt;li&gt;実データの結果、グレスケにすると手法の区別がつかない。移動平均サンプル数を多くする？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://linuxtricksandtips.blogspot.com/2015/01/how-to-convert-color-eps-to-grayscale.html"&gt;カラーeps → グレスケeps …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;図:&lt;ul&gt;
&lt;li&gt;実データの結果、グレスケにすると手法の区別がつかない。移動平均サンプル数を多くする？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://linuxtricksandtips.blogspot.com/2015/01/how-to-convert-color-eps-to-grayscale.html"&gt;カラーeps → グレスケepsの裏技&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;移動平均サンプル数を増やした。グレスケ画像を作った。でもグレスケ置換はしない。白黒印刷で問題ないことがわかればOK｡&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;概要:&lt;ul&gt;
&lt;li&gt;短い背景があるだけ。研究の新規性が明確でない。研究の目的が述べられず。すぐにLMSとSAの説明に入ってしまう。&lt;ul&gt;
&lt;li&gt;ラプラス分布がーがいるかも？→いや、うるさい。&lt;/li&gt;
&lt;li&gt;残差をスパースにする必要がある。したがって、圧縮率改善のためには予測モデルの改善を模索する必要がある。SAは…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;論理的なギャップに打ち勝つ新規性(novelty)をはっきりさせる。&lt;/li&gt;
&lt;li&gt;主張を強めるための数量的な改善点を述べよ。（例: 5%良くなった）。行を追加していい。&lt;/li&gt;
&lt;li&gt;実験結果から見れる研究の結論は何？結局コーデックに何が嬉しいの？&lt;/li&gt;
&lt;li&gt;TODO: 背景の既存研究の論理的なギャップを要約。結論の言葉を要約。&lt;ul&gt;
&lt;li&gt;背景と同じで論理的なギャップなんてなくて、「SAの収束改善」が大事で、これを強調する。To overcome...&lt;/li&gt;
&lt;li&gt;結論の言葉、どうするか。（他のSAの論文見てると、実験結果よかった！で終わってて、おれもそうなってるんだが。）ロスレス音声に関するところだと、Future workを述べるか？&lt;/li&gt;
&lt;li&gt;定量的な結果…。実験結果から言えることがない。どうしよう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;導入:&lt;ul&gt;
&lt;li&gt;関連する象徴的な(iconic)研究を載せるのを推奨→亀岡の研究のつもり。他にはOptimFROGか？→「A novel normalized sign algorithm for system identifica- tion under impulsive noise interference」を入れた。&lt;/li&gt;
&lt;li&gt;新規性をもっと明確に喋れ。既存研究の論理的ギャップに対する改善点は何？現状の問題の解決策になっている？&lt;/li&gt;
&lt;li&gt;研究の背後に有る動機は？&lt;/li&gt;
&lt;li&gt;TODO: 概要とかぶるが、既存研究の論理的なギャップは何か洗い出す。そして本研究が何を解決しているか（→適切な分布の仮定を満たす、収束の早い適応アルゴリズムが得られた。）整理。他に、関連する象徴的な研究を洗い出す。&lt;ul&gt;
&lt;li&gt;論理的なギャップなんてなくて、「SAの収束改善」が大事で、これを強調する。&lt;/li&gt;
&lt;li&gt;象徴的な研究としては「A novel normalized sign algorithm for system identification under impulsive noise interference」を入れた。新しめのまとまった、というかSAの方向性を述べた論文。もう一個くらい見繕っておくか。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ディスカッション:&lt;ul&gt;
&lt;li&gt;制限を述べただけになってる。&lt;/li&gt;
&lt;li&gt;他手法と比べて提案手法はどうなのか？得られた結果に対するコメントを述べるべし。&lt;/li&gt;
&lt;li&gt;他手法はどうなのか？&lt;/li&gt;
&lt;li&gt;結果が意味するのはなにか？（最終段落で短く述べられてるだけになっている。もっと書くべし。）&lt;/li&gt;
&lt;li&gt;TODO: 他手法との比較を追加。結果の吟味を追加。&lt;ul&gt;
&lt;li&gt;他と比べてよかった。はまず言う。 It is obvious that proposed algorithms show better convergence performance than that of the SA.&lt;/li&gt;
&lt;li&gt;RLSと似たパフォーマンスを出していたのも頷ける。The NNGSA had similar performances as RLS.&lt;/li&gt;
&lt;li&gt;しかし…負荷が…というつなぎ方に変える。On the other hand, however,&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;結論:&lt;ul&gt;
&lt;li&gt;コーデックや社会にどんな影響がある？&lt;/li&gt;
&lt;li&gt;コーデックにどのように適用する？&lt;/li&gt;
&lt;li&gt;今後の展望（研究範囲）をもっと掘り下げるべし。&lt;/li&gt;
&lt;li&gt;TODO: Future studyにロスレス音声予測モデルへの組み込みを検討する、とまず言う。そのために…をやる。という流れに。&lt;ul&gt;
&lt;li&gt;ロスレス音声への組み込みを将来研究に組み込んだ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Lossless Audio"></category><category term="Sign Algorithm"></category></entry><entry><title>論文読み(4)</title><link href="/lun-wen-du-mi4.html" rel="alternate"></link><published>2020-10-13T10:00:00+09:00</published><updated>2020-10-13T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-13:/lun-wen-du-mi4.html</id><summary type="html">&lt;p&gt;論文読みのコメント:&lt;/p&gt;
&lt;p&gt;「新板 情報幾何学の新展開」の15.7節（p190）にFisher情報行列の固有値の分布の議論が有る。なにか使えな …&lt;/p&gt;</summary><content type="html">&lt;p&gt;論文読みのコメント:&lt;/p&gt;
&lt;p&gt;「新板 情報幾何学の新展開」の15.7節（p190）にFisher情報行列の固有値の分布の議論が有る。なにか使えないか？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;DCの件、自分の研究内容にフォーカスしすぎてて広がりが見えにくかったという指摘があった。来年早いうちに着手する。春休み入ってからとか。&lt;/li&gt;
&lt;li&gt;筆者(Tianshu Quさん)に連絡してできたらソース貰う。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="BP"></category><category term="Lossless Audio"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>論文読み(3)</title><link href="/lun-wen-du-mi3.html" rel="alternate"></link><published>2020-10-10T10:00:00+09:00</published><updated>2020-10-10T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-10:/lun-wen-du-mi3.html</id><summary type="html">&lt;p&gt;一気に追い込んで資料を作成。雑かも。&lt;/p&gt;
&lt;p&gt;一点気になっていたのが &lt;span class="math"&gt;\(l^{2}\)&lt;/span&gt; と &lt;span class="math"&gt;\(L^{2}\)&lt;/span&gt; の違い。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://scicomp.stackexchange.com/questions/21761/difference-between-l2-norm-and-l2-norm"&gt;Difference between l2 norm and L2 norm&lt;/a&gt; 実数列に対するノ …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;一気に追い込んで資料を作成。雑かも。&lt;/p&gt;
&lt;p&gt;一点気になっていたのが &lt;span class="math"&gt;\(l^{2}\)&lt;/span&gt; と &lt;span class="math"&gt;\(L^{2}\)&lt;/span&gt; の違い。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://scicomp.stackexchange.com/questions/21761/difference-between-l2-norm-and-l2-norm"&gt;Difference between l2 norm and L2 norm&lt;/a&gt; 実数列に対するノルムは &lt;span class="math"&gt;\(l\)&lt;/span&gt; 、有界な定義域 &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; 上に定義されたルベーグ可測関数のノルムは &lt;span class="math"&gt;\(L\)&lt;/span&gt; で良さそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;クソ大雑把に言うと、列に対するノルムは &lt;span class="math"&gt;\(l\)&lt;/span&gt; となり、関数に対するノルムは &lt;span class="math"&gt;\(L\)&lt;/span&gt; と考えて良さそう。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="BP"></category><category term="Lossless Audio"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>論文読み(2)</title><link href="/lun-wen-du-mi2.html" rel="alternate"></link><published>2020-10-07T10:00:00+09:00</published><updated>2020-10-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-07:/lun-wen-du-mi2.html</id><summary type="html">&lt;p&gt;今日でCBCの概要を掴んで、プロット、スライド作成に入りたい。
Context-dependent bitplane coding in China AVS Audio あった。読んでる。なんとなくつかめたの …&lt;/p&gt;</summary><content type="html">&lt;p&gt;今日でCBCの概要を掴んで、プロット、スライド作成に入りたい。
Context-dependent bitplane coding in China AVS Audio あった。読んでる。なんとなくつかめたので、説明を試みたい。&lt;/p&gt;
</content><category term="雑記"></category><category term="BP"></category><category term="Lossless Audio"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>論文読み(1)</title><link href="/lun-wen-du-mi1.html" rel="alternate"></link><published>2020-10-06T10:00:00+09:00</published><updated>2020-10-06T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-10-06:/lun-wen-du-mi1.html</id><summary type="html">&lt;p&gt;標準化されたロスレス音声規格IEEE 1857.2、くっそ怪しい。 &lt;a class="reference external" href="https://hydrogenaud.io/index.php?topic=111683.0"&gt;リファレンスエンコーダが公開されてないっぽい。&lt;/a&gt;
一応概要み …&lt;/p&gt;</summary><content type="html">&lt;p&gt;標準化されたロスレス音声規格IEEE 1857.2、くっそ怪しい。 &lt;a class="reference external" href="https://hydrogenaud.io/index.php?topic=111683.0"&gt;リファレンスエンコーダが公開されてないっぽい。&lt;/a&gt;
一応概要みたいのは以下:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://150.162.46.34:8080/icassp2014/papers/p6984-haibin.pdf"&gt;LOSSLESS AUDIO COMPRESSION IN THE NEW IEEE STANDARD FOR ADVANCED AUDIO CODING&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さっと読んだ。工夫したのは、ブロック先頭で残差が大きくなるから、それをビットシフトして振幅を潰し、下位ビットの情報は別に送ること、算術符号はテンプレートとなる確率分布を使用すること、がメインである。うーん。かなり泥臭いと思う。モデルがすごいと言うよりは工夫メインな印象を受ける。また、他の論文でウェーブレットを使っているみたいな話があるけど、どうにもこちらも怪しい。&lt;/p&gt;
&lt;p&gt;ロスレス音声でウェーブレット+BPを使う話。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://150.162.46.34:8080/icassp2013/pdfs/0000552.pdf"&gt;AUDIO LOSSLESS CODING/DECODING METHOD USING BASIS PURSUIT ALGORITHM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;音声圧縮でウェーブレットを使うのは筋が悪かったので、少なくとも自分には衝撃ではある。で、ちゃんと読んでみようと思ったのだが4pで概要しか示されてない。&lt;/p&gt;
&lt;p&gt;肝となる部分でわからないのが、ウェーブレット辞書を結合して過完備な辞書を作るところ。基礎が抜けていることを疑って、Donohoを読む:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.stanford.edu/group/SOL/papers/BasisPursuit-SIGEST.pdf"&gt;Atomic Decomposition by Basis Pursuit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そして論文ではliftingを使ったと行っているが、liftingを使った場合、どうなるのか？画像に対して試したのが下:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://aircconline.com/ijma/V7N1/7115ijma01.pdf"&gt;IMAGE COMPRESSION BASED ON COMPRESSIVE SENSING USING WAVELET LIFTING SCHEME&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ロッシーなんだよなあ。&lt;/p&gt;
&lt;p&gt;BPで辞書作るときって、基底をサンプリングして作るんだっけか？BPの動きを確認し始める。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://eeweb.poly.edu/iselesni/teaching/lecture_notes/sparsity_intro/html/Example_BP.html#2"&gt;Example: Basis pursuit (BP)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ウェーブレットの場合の答えが以下にある。精読していく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://elad.cs.technion.ac.il/wp-content/uploads/2018/02/MultiScale-KSVD-IEEE-Selected-Topics.pdf"&gt;Multi-Scale Dictionary Learning using Wavelets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://danielmckenzie.github.io/DictLearning.pdf"&gt;Dictionary Learning Using Wavelets&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そもそもウェーブレット変換って行列表現できたっけ？と思ったら、余裕でできてた。これの高速算方が離散ウェーブレット変換(DWT)だったわ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cfme.chiba-u.jp/~haneishi/class/iyogazokougaku/Wavelet2.pdf"&gt;1次元ウェーブレット変換&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;論文が参照しているウェーブレット系のペーパーが重い。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cm-bell-labs.github.io/who/wim/papers/athome/athome.pdf"&gt;Building Your Own Wavelets at Home&lt;/a&gt; 有名なペーパー。ウェーブレット自分自身で構築できるようだ（2nd Generation Wavelet）。その計算方法がLifting Schemeとなる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://services.math.duke.edu/~ingrid/publications/J_Four_Anal_Appl_4_p247.pdf"&gt;Factoring Wavelet Transforms into Lifting Steps&lt;/a&gt; 1st Generation WaveletはLiftingの形式に持っていけると言っている&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非常にボリュームが大きい。。。弱った。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.tut.fi/~tabus/NOKIA_PS/Doru_nsip.ps"&gt;INTEGER WAVELET TRANSFORM BASED LOSSLESS AUDIO COMPRESSION&lt;/a&gt; 古いけど、ウェーブレットを使ったロスレス音声圧縮がここに。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理論一切抜きで、計算法は分かった。しかし、BPによってどのように基底を選んでいるのかさっぱり分からん。ウェーブレットは固定辞書だから、L1正則化問題を解析的に解いてはいないはず。Basis Pursuitはアルゴリズムじゃなくて原理だと &lt;a class="reference external" href="https://web.stanford.edu/group/SOL/papers/BasisPursuit-SIGEST.pdf"&gt;原論文&lt;/a&gt; で言っていたし:&lt;/p&gt;
&lt;blockquote&gt;
BP is an optimization principle, not an algorithm. Over the last 40 years, a tremendous amount of work has been done on the solution of linear programs. Until the 1980s, most work focused on variants of Dantzig’s sim- plex algorithm, which many readers have no doubt studied. In the last ten years, some spectacular breakthroughs have been made by the use of so-called interior-point methods, which use an entirely different principle.&lt;/blockquote&gt;
&lt;p&gt;うーん、妄想してみると、こんなかんじだろうか？&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;辞書作成: Cohen-Daubechies-Feuveau(cdf) wavelet, Daubechies(db) wavelet, Symlets(sym) 等（&amp;quot;等&amp;quot;は謎。全部書いてくれよ...）から辞書を作る。ここでは、cdf,db,symの3つ使ったと考える。&lt;/li&gt;
&lt;li&gt;ウェーブレット変換: cdf, db, symの3つで変換を行う。変換はLifting Schemeで行う。&lt;/li&gt;
&lt;li&gt;基底選択: 最もL1ノルム（残差絶対値和）が小さかったウェーブレット基底を選び、出力を確定させる。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;この操作を低域/高域成分の両方に対し、高解像度から低解像度に向かって行っていく。（高域/低域両方に対して分析をおこなうのをウェーブレットパケット解析というようだ。低域成分（画像で言うなら左上）だけに分析を続けるのはウェーブレット解析。ウェーブレットパケット解析は二分木をなす。）&lt;/p&gt;
&lt;p&gt;最終的に得られた出力をエントロピー符号化する。
解像度の深さと、選んだ基底の情報はside informationとして渡す。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.osaka-kyoiku.ac.jp/~morimoto/WSPRO/wavelet2014proceedingsR3.pdf"&gt;ウェーブレット理論と工学への応用&lt;/a&gt; 日本語でちゃんと書かれたリフティングの話。印刷して、読もう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;わからないのは後はエントロピー符号化(BCB)のはず。クローズっぽいんだよなあ…。
明日、プロットをまとめる。&lt;/p&gt;
</content><category term="雑記"></category><category term="BP"></category><category term="Lossless Audio"></category><category term="Wavelet"></category><category term="Lifting"></category></entry><entry><title>論文書きつつ(1)</title><link href="/lun-wen-shu-kitsutsu1.html" rel="alternate"></link><published>2020-09-24T10:00:00+09:00</published><updated>2020-09-24T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-24:/lun-wen-shu-kitsutsu1.html</id><summary type="html">&lt;p&gt;英語論文シコシコ書きつつ。断然収まらないので削ることを考えながら。&lt;/p&gt;
&lt;p&gt;GLASSO見てる。2重ループ最適化で、重そうに見え …&lt;/p&gt;</summary><content type="html">&lt;p&gt;英語論文シコシコ書きつつ。断然収まらないので削ることを考えながら。&lt;/p&gt;
&lt;p&gt;GLASSO見てる。2重ループ最適化で、重そうに見える。。。
βの更新でO(N)、さらに変数選択でO(N)。。。&lt;/p&gt;
&lt;p&gt;簡略化して、一回の更新でβの一要素更新でいいのでは？
とりあえず、実装を考えていく。&lt;/p&gt;
&lt;p&gt;しっかし書き始める前に、論文を軽く漁ってみよう。&lt;/p&gt;
</content><category term="雑記"></category><category term="GLASSO"></category></entry><entry><title>自由工作(10)</title><link href="/zi-you-gong-zuo-10.html" rel="alternate"></link><published>2020-09-16T10:00:00+09:00</published><updated>2020-09-16T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-16:/zi-you-gong-zuo-10.html</id><summary type="html">&lt;p&gt;黙々と進めた。残タスクは、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;コマンドラインの整備:DONE&lt;ul&gt;
&lt;li&gt;残差出力モードの追加(-e):DONE&lt;/li&gt;
&lt;li&gt;統計情報出力モードの追加(-c):DONE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;テスト …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;黙々と進めた。残タスクは、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;コマンドラインの整備:DONE&lt;ul&gt;
&lt;li&gt;残差出力モードの追加(-e):DONE&lt;/li&gt;
&lt;li&gt;統計情報出力モードの追加(-c):DONE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;テストケース追加:DONE&lt;ul&gt;
&lt;li&gt;白色雑音入力(randで生成したものでよい):DONE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;リリース実行確認:DONE&lt;/li&gt;
&lt;li&gt;先頭で一発空エンコードして適応を早める:DONE&lt;/li&gt;
&lt;li&gt;コード整理&lt;ul&gt;
&lt;li&gt;エンコーダとデコーダを分ける: DONE&lt;/li&gt;
&lt;li&gt;ブロックデータエンコード/デコード関数が大きいので関数化: 小さくまとまったのでいいかな。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;音質向上への工夫&lt;ul&gt;
&lt;li&gt;MS処理の再興。MS処理のスイッチオプションを追加&lt;ul&gt;
&lt;li&gt;もう一度試してみたらRMSEが悪化していることが分かった。（BGMとアイカツ音源で調べた）&lt;/li&gt;
&lt;li&gt;実際に聞いてみるとパチパチ言ってる。不連続点が出ている。パチパチ言ってた記憶はないので、何かがおかしい。デバッグ。&lt;ul&gt;
&lt;li&gt;デコード時にLRに戻す前にオーバーフローしていた。&lt;/li&gt;
&lt;li&gt;バグや。ブロックヘッダにLRが入っているが、フィルタはMSで予測していた。そらパチパチ言うわ。&lt;/li&gt;
&lt;li&gt;パチパチは直したが、得られた結果は微妙と言わざるを得ない。最大誤差は減ってるけど、平均誤差は増大した傾向。
オプションにしてもデフォルトでオフかなあ。&lt;/li&gt;
&lt;li&gt;MSでうまく行かない例としては、振幅が大きい振動波で、side成分が割れている場合。（ピエトロの気絶の55秒付近）そこをADPCM化すると、エフェクターを通したように割れてしまう。&lt;ul&gt;
&lt;li&gt;ロスレスではないから、エンコード時にsideも右シフトすることで、sideが割れる問題は緩和した。採用。しかしMSはオプションとする（デフォルトOFF）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;振幅がでかいときに誤差が大きくなる。じゃあ、入力を1bit右シフトして、出力時に1bit左シフトしていいんじゃない。&lt;ul&gt;
&lt;li&gt;純粋に情報量が落ちそう。試してみるが。→うん、だめ。1bitぶん何かがわからなくなるのはつらい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NG的なアイデア入らないか？&lt;ul&gt;
&lt;li&gt;プリエンファシスを掛けたもので勾配計算する。重いか…？&lt;/li&gt;
&lt;li&gt;爆裂に精度悪化。とりやめ。時間切れ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IIR的（出力）の適応: ダメだった。負荷も増えるし、やらん。&lt;/li&gt;
&lt;li&gt;モーメンタムみたいに、前の勾配を使えないか？&lt;ul&gt;
&lt;li&gt;やってみたが微妙。たいていRMSEが悪くなる。良くなっても劇的じゃない。&lt;/li&gt;
&lt;li&gt;SLAのLogSignを強引に入れてみたけど良くない。&lt;/li&gt;
&lt;li&gt;その他、残差と履歴をlog/sign化したけど芳しくなかった。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;コードを2の補数にしたい。&lt;ul&gt;
&lt;li&gt;上位ビットを埋めるのが帰って辛いように思えた。保留。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ノイズシェーピングが芳しくない。&lt;ul&gt;
&lt;li&gt;ちょっと考えると、品質の低いフィルター突っ込んでんのと同じに思えた。実際外すとRMSEが向上した。&lt;/li&gt;
&lt;li&gt;廃止の方向で検討。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;負荷 instruments -t &amp;quot;Time Profiler&amp;quot; ./aad ... でいける。&lt;/li&gt;
&lt;li&gt;今更だが、 &lt;a class="reference external" href="http://web.archive.org/web/20060818165032/http://ku-www.ss.titech.ac.jp:80/~yatsushi/adx.html"&gt;資料1&lt;/a&gt; , &lt;a class="reference external" href="https://www.ffmpeg.org/doxygen/0.6/adx_8h.html#bf98059cca648e492906344dd0873907"&gt;ffmpeg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Macでinstrumentsが廃止されたようだ。 xcrun xctrace record --template 'Time Profiler' --target-stdout - --launch -- ./aad -e ManiMani.wav a.aad で計測を行っている。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;感想・展望&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;うーん、性能が良くない。IMA-ADPCMに毛が生えた程度か。XMAみたく、ブロック区間の残差の最大振幅値を計測して割った方がええのかな。&lt;ul&gt;
&lt;li&gt;4bitのときは、残差を max(-最小残差/8, 最大残差/7) で割れば、残差が4bit収まる。&lt;/li&gt;
&lt;li&gt;3bitならば max(-最小残差/4, 最大残差/3), 2bitならば max(-最小残差/2, 最大残差/1) となるはず。&lt;/li&gt;
&lt;li&gt;一般化すると max(-最小残差/(1 &amp;lt;&amp;lt; (bits-1)), 最大残差/((1 &amp;lt;&amp;lt; (bits-1)) - 1))&lt;/li&gt;
&lt;li&gt;ブランチ切ってやってみたい...と思ったらできないことがすぐに分かった。量子化誤差が適応中にわからない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LPCを使うのもありだな。係数の絶対値が1を超えるから係数のスケール情報を入れる必要があるが。&lt;/li&gt;
&lt;li&gt;量子化誤差が適応的に出る（しかも、エンコード/デコードで全く同じ値が出る）から、これに応じてステップサイズ、もしくは符号化値を変えられないか。&lt;/li&gt;
&lt;li&gt;複数回エンコードを回すの有効かも。少なくともファイル先頭では効いた。&lt;ul&gt;
&lt;li&gt;単純に単一ブロックを繰り返しエンコードするのは効果が薄かった。&lt;/li&gt;
&lt;li&gt;次（前）の区間と合わせてエンコードするのもいいかも。オーバーラップする形。これは効いたので取り入れた。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;テーブルの見直し。急激に振幅がかわる（2〜3サンプルで-1から1に近づくときがある）ので、おそらく、テーブルの150以降の要素はもっと大きい値をとってもいいと思う。&lt;/li&gt;
&lt;li&gt;ステップサイズを適応的に計算するyamaha形式を試してみたい。IMAではテーブルの256階調に限られるが、こちらはより柔軟に思える。
* &lt;a class="reference external" href="http://www.piece-me.org/piece-lab/adpcm/adpcm1.html"&gt;ADPCMの仕組み#1&lt;/a&gt; や &lt;a class="reference external" href="https://github.com/mguentner/rockbox/blob/master/apps/codecs/libpcm/yamaha_adpcm.c"&gt;rockbox&lt;/a&gt; や &lt;a class="reference external" href="https://ffmpeg.org/doxygen/0.6/adpcm_8c-source.html"&gt;ffmpeg&lt;/a&gt; が参考になる。
* やっつけでやってみた。音圧の低い音源では少しよくなったが、りんごの木など音圧が大きい音源で軒並みRMSEが2割ほど悪化。取り下げていく。逆に考えると、低音圧音源で現在の実装があんまり良くないともいえる結果やな。&lt;/li&gt;
&lt;li&gt;残差波形を見ているとピッチの残差立ち上がりが大きくて、また、それによって聞こえやすいノイズが発生している。周期は170サンプル=282Hz(&amp;#64;48k)とか。&lt;ul&gt;
&lt;li&gt;ピッチを潰すのは有効かも。自己相関を計算して周期を解析して、その一点で潰しにかかる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;タイムオーバー。現実にもどりましょ。&lt;/p&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(9)</title><link href="/zi-you-gong-zuo-9.html" rel="alternate"></link><published>2020-09-14T10:00:00+09:00</published><updated>2020-09-14T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-14:/zi-you-gong-zuo-9.html</id><summary type="html">&lt;p&gt;AADのフォーマットを書いてく。デバッグ効率のため（データ到着順で見れるようにしたい）に、ビッグエンディアンで...&lt;/p&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;ヘ …&lt;/h2&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;AADのフォーマットを書いてく。デバッグ効率のため（データ到着順で見れるようにしたい）に、ビッグエンディアンで...&lt;/p&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;ヘッダフォーマット&lt;/h2&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="28%" /&gt;
&lt;col width="9%" /&gt;
&lt;col width="63%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;名前&lt;/th&gt;
&lt;th class="head"&gt;サイズ[byte]&lt;/th&gt;
&lt;th class="head"&gt;内容（補足）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;AADシグネチャ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'A', 'A', 'D', '0'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;フォーマットバージョン番号&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;チャンネル数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプル数&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1チャンネルあたりの全サンプル数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプリングレート&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプルあたりビット数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2, 3, 4のいずれか。1もいつかは対応したい。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックサイズ&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;ブロックのヘッダと圧縮済みデータを含めたサイズ。末尾のブロックではこの値以下になる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックあたりサンプル数&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;末尾のブロックではこの値以下になる&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ブロックサイズは256の倍数にしたい。デフォルト1024で。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;ブロックヘッダフォーマット&lt;/h2&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="27%" /&gt;
&lt;col width="12%" /&gt;
&lt;col width="61%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;名前&lt;/th&gt;
&lt;th class="head"&gt;サイズ[byte]&lt;/th&gt;
&lt;th class="head"&gt;内容（補足）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;フィルタ係数&lt;/td&gt;
&lt;td&gt;8 * チャンネル数&lt;/td&gt;
&lt;td&gt;符号付き16bit整数の係数が4つ それがチャンネル数ぶん&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;フィルタ入力履歴&lt;/td&gt;
&lt;td&gt;8 * チャンネル数&lt;/td&gt;
&lt;td&gt;符号付き16bit整数のサンプルが4つ（先頭4サンプル） それがチャンネル数ぶん&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;テーブルインデックス&lt;/td&gt;
&lt;td&gt;1 * チャンネル数&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;予約領域&lt;/td&gt;
&lt;td&gt;1 * チャンネル数&lt;/td&gt;
&lt;td&gt;偶数にするため。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ヘッダサイズは18 * チャンネル数[byte]。&lt;/p&gt;
&lt;p&gt;しかしヘッダが大きすぎるかもしれない。入力履歴は毎回リセットすべきか？
SLAではブロックごとにフィルタ係数をリセットしていたけど、こっちではまずそう。ブロックあたりサンプル数が少なくて適応が遅くなる。
→ホールド（直前サンプルが続いている）でもOK。軽く試したけど、当然、誤差は増える。&lt;/p&gt;
&lt;p&gt;まずは富豪的に、上のフォーマットで作る。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h2&gt;ブロックデータフォーマット&lt;/h2&gt;
&lt;p&gt;サンプルあたりビット数で異なる。ビッグエンディアンで、上位bitから順に書いていく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;4bit: 2サンプル(=1byte)単位でインターリーブ。&lt;/li&gt;
&lt;li&gt;3bit: 8サンプル(=3byte)単位でインターリーブ。&lt;/li&gt;
&lt;li&gt;2bit: 4サンプル(=1byte)単位でインターリーブ。&lt;/li&gt;
&lt;li&gt;1bit: 8サンプル(=1byte)単位でインターリーブ。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ブロックデータサイズは、(インターリーブの単位*チャンネル数)の倍数に設定する。&lt;/p&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3&gt;フォーマット&lt;/h3&gt;
&lt;p&gt;ビッグエンディアンで記録する。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h2&gt;ヘッダフォーマット&lt;/h2&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="28%" /&gt;
&lt;col width="9%" /&gt;
&lt;col width="63%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;名前&lt;/th&gt;
&lt;th class="head"&gt;サイズ[byte]&lt;/th&gt;
&lt;th class="head"&gt;内容（補足）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;AADシグネチャ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'A', 'A', 'D', '0'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;フォーマットバージョン番号&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;コーデックバージョン番号&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;チャンネル数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプル数&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1チャンネルあたりの全サンプル数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプリングレート&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプルあたりビット数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2, 3, 4のいずれか。1もいつかは対応したい。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックサイズ&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;ブロックのヘッダと圧縮済みデータを含めたサイズ。末尾のブロックではこの値以下になる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックあたりサンプル数&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;末尾のブロックではこの値以下になる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;マルチチャンネル処理法&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0:何もしていない、1:LR-&amp;gt;MS処理（効果が薄いため、廃止予定）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h2&gt;ブロックヘッダフォーマット&lt;/h2&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="37%" /&gt;
&lt;col width="10%" /&gt;
&lt;col width="53%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;名前&lt;/th&gt;
&lt;th class="head"&gt;サイズ[byte]&lt;/th&gt;
&lt;th class="head"&gt;内容（補足）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;テーブルインデックス上位8bit&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;テーブルインデックス下位4bit / 係数シフト数&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;下位4bitは固定小数の小数部。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;フィルタ係数&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;符号付き16bit整数の係数が4つ。係数シフト数分左シフトして使う。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;フィルタ入力履歴&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;符号付き16bit整数のサンプルが4つ（先頭4サンプル）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;これがチャンネル数分並ぶ。ヘッダサイズは18 * チャンネル数[byte]。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h2&gt;ブロックデータフォーマット&lt;/h2&gt;
&lt;p&gt;サンプルあたりビット数で異なる。ビッグエンディアンで、上位bitから順に書いていく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;4bit: 2サンプル(=1byte)単位でインターリーブ。&lt;/li&gt;
&lt;li&gt;3bit: 8サンプル(=3byte)単位でインターリーブ。&lt;/li&gt;
&lt;li&gt;2bit: 4サンプル(=1byte)単位でインターリーブ。&lt;/li&gt;
&lt;li&gt;1bit: 8サンプル(=1byte)単位でインターリーブ。（未サポート。将来的にやりたい。）&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(8)</title><link href="/zi-you-gong-zuo-8.html" rel="alternate"></link><published>2020-09-13T10:00:00+09:00</published><updated>2020-09-13T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-13:/zi-you-gong-zuo-8.html</id><summary type="html">&lt;ul class="simple"&gt;
&lt;li&gt;ステップサイズテーブルの再設計。256エントリでいいはず。8bitの領域を使い切るべき。
* インデックス更新テーブルの吟 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;ステップサイズテーブルの再設計。256エントリでいいはず。8bitの領域を使い切るべき。
* インデックス更新テーブルの吟味(特に3bit)。&lt;/li&gt;
&lt;li&gt;LMSフィルタの吟味（プリエンファシスもやったところで再度SAを確かめてみたい。→かんたんにやってみたけど、低音圧でSA、高音圧でLMSの印象。一応SAにしておく。発散する場合がみられている。。。nibbleが2の補数になったらそれを残差として突っ込むという夢がある。）&lt;/li&gt;
&lt;li&gt;フォーマット再度策定。2,3,4bitの書き出し処理分割。&lt;/li&gt;
&lt;li&gt;nibble（出力コード）は2の補数でいい。符号+絶対値だとエンコードデコードが複雑になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここまでやってて色々弄ってたら、なーんか音質が悪化していることに気付く。デフォルトのADPCMの方がよくね？
耳で聞くよりはRMSでがっちり評価していきたい。&lt;/p&gt;
&lt;p&gt;プリエンファシスが悪そう。実装を整理してON/OFFできるようにして調査する。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;インデックス更新値を持ち越して次サンプルで使う手法、あんまり美味しくない。&lt;/li&gt;
&lt;li&gt;テーブルを256エントリに拡張したら、高音圧音源ではグッドだけど、低音圧音源でジャリジャリが目立つ。sin波で適応が遅い感じ。&lt;ul&gt;
&lt;li&gt;2bitだとどうしても適応が遅い印象。&lt;/li&gt;
&lt;li&gt;フィルタの学習も遅い印象も受ける。最初のブロックを何回か回して処理開始するとかどうでしょう。いいアイデアだけど、フィルタの状態をブロックヘッダに入れる実装がまだなので、それができてから。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さて、コーデックとして仕立てていくか。基本的なAPIはIMAADPCMと同じで良いとして、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;命名規則の変更: IMAADPCM -&amp;gt; AAD (Ayashi Adaptive Differential pulse code modulation) 拡張子.aad&lt;/li&gt;
&lt;li&gt;フォーマット策定: ヘッダ, ブロックヘッダ, ブロック&lt;/li&gt;
&lt;li&gt;エンコードパラメータの整理&lt;/li&gt;
&lt;li&gt;プリエンファシス、デエンファシスをプロセッサハンドルを介してできるように。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(7)</title><link href="/zi-you-gong-zuo-7.html" rel="alternate"></link><published>2020-09-12T10:00:00+09:00</published><updated>2020-09-12T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-12:/zi-you-gong-zuo-7.html</id><summary type="html">&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.drdobbs.com/database/algorithm-alley/184410326"&gt;Inside IMA ADPCM&lt;/a&gt;  &lt;a class="reference external" href="http://orion.lcg.ufrj.br/Dr.Dobbs/books/book10/9711m/9711m.htm"&gt;こっちも同じ内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://multimedia.cx/simpleaudio.html#tth_sEc4.2"&gt;Simple Time Domain Audio Coding&lt;/a&gt; MediaWikiの前身となる資料。時間領域符号化の包括的なまとめでもある。有益そう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;強引 …&lt;/p&gt;</summary><content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.drdobbs.com/database/algorithm-alley/184410326"&gt;Inside IMA ADPCM&lt;/a&gt;  &lt;a class="reference external" href="http://orion.lcg.ufrj.br/Dr.Dobbs/books/book10/9711m/9711m.htm"&gt;こっちも同じ内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://multimedia.cx/simpleaudio.html#tth_sEc4.2"&gt;Simple Time Domain Audio Coding&lt;/a&gt; MediaWikiの前身となる資料。時間領域符号化の包括的なまとめでもある。有益そう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;強引に3,2bit化してみた。なんとなくできてしまっているが、2bitは流石にジリジリいう。
なんでかな、と思ったらステップサイズが4bitむけのものになっていて、テーブル参照インデックスが0でも7になってしまい、確実に揺れてしまうのが問題であると想像している。テーブル自作を試みているが、なかなかに苦戦。&lt;/p&gt;
&lt;p&gt;IMA-ADPCMのステップサイズが謎。どっから導出したんだろうか。
純粋な指数関数ではなさそう。とくに、最初の8要素は線形関数になってるのが奇特。（テーブルの情報量を増やしたいのかな？）しかし、後になると指数関数 &lt;span class="math"&gt;\(2^{\log_{2}(32767/7)/88 x + \log_{2}(7)}\)&lt;/span&gt; とほぼ一致。
自作のテーブルより、IMA-ADPCMのテーブルの方がいいRMSを出している。。。何故やろ・・・。&lt;/p&gt;
&lt;p&gt;テーブルは一旦諦めて、モデルの改善を考えたが、あんまり良くない。
フィルタ次数を8にしたり、IIR（予測値をフィードバック）したり。&lt;/p&gt;
&lt;p&gt;効果があったのが3つ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ノイズシェーピング。残差を量子化するからその量子化誤差を1/16を掛けてフィードバックする（大きすぎると発散する）。残差わずかに減少。&lt;/li&gt;
&lt;li&gt;LR-&amp;gt;MS。ステレオ音源で残差減少。注意点としては、16bit幅を超えるからやるならPCMを32bit幅で持つべき。いまは破壊的な処理をしてる。&lt;/li&gt;
&lt;li&gt;プリエンファシス。1サンプルエンコード/デコード処理でやりたいが、そうなってない（汚い実装になってる）。一回RMS減ったのは見たけど、本当かもう一度確かめたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらはスイッチできるといいなあ。
2bitとなると音質クッソ厳しい（りんごの木、Mani Mani等音圧変化の激しい曲はかなりきびしい。声のみだけだったらいける。）けど、ここらで独立させてみるか。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(6)</title><link href="/zi-you-gong-zuo-6.html" rel="alternate"></link><published>2020-09-11T10:00:00+09:00</published><updated>2020-09-11T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-11:/zi-you-gong-zuo-6.html</id><summary type="html">&lt;p&gt;群論再開させつつ。&lt;/p&gt;
&lt;p&gt;mac update以降、コンパイル警告がうざったくてしょうがなくなっていた。どうやら /usr/include が消えたようで …&lt;/p&gt;</summary><content type="html">&lt;p&gt;群論再開させつつ。&lt;/p&gt;
&lt;p&gt;mac update以降、コンパイル警告がうざったくてしょうがなくなっていた。どうやら /usr/include が消えたようで…&lt;/p&gt;
&lt;p&gt;export SDKROOT=&amp;quot;$(xcrun --sdk macosx --show-sdk-path)&amp;quot;&lt;/p&gt;
&lt;p&gt;で黙らせている。&lt;/p&gt;
&lt;p&gt;4次の適応フィルタを予測に突っ込んでみた。平均的な平均絶対値誤差は前値予測よりもガッツリ減っているが、音質はあんまり替わってない印象。
カレンダーガールを突っ込んだら高域（20k〜）にガッツリノイズがついた。ナイキストレートの早さでノイスがのってる。
48k音源ではどうも共通して現れる特徴のようだ。&lt;/p&gt;
&lt;p&gt;音質は、原音と変わんねえだろと思い続けている。ここがおかしいというのを具体的に指摘できないでいる。スペクトログラムを見て初めて分かる感じ。&lt;/p&gt;
&lt;p&gt;ビット数減らしに行くのがよさそう。試すのであれば、残差は4bitで書き出すけど、内容は3bitまでしか持たないようにするという方策。
3,2bitに応じたテーブル作成が熱い。&lt;/p&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(5)</title><link href="/zi-you-gong-zuo-5.html" rel="alternate"></link><published>2020-09-10T10:00:00+09:00</published><updated>2020-09-10T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-10:/zi-you-gong-zuo-5.html</id><summary type="html">&lt;p&gt;ノイズ（差分の量子化誤差）はまさにi.i.d.なラプラスからサンプリングした感じ。全帯域にある。
人間の声のところは …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ノイズ（差分の量子化誤差）はまさにi.i.d.なラプラスからサンプリングした感じ。全帯域にある。
人間の声のところは調波構造があるけど、それ以外、ピッチのない楽器などは単純な白色雑音といった印象。&lt;/p&gt;
&lt;p&gt;ノイズシェーピングを試しているが…本当にいいのか疑問。
プリエンファシスみたく直前サンプルで引くと、たしかにノイズの低域は消える、けど高域はそのままだし、
ノイズのRMSはむしろ悪化している状態。
逆に直前サンプルで足すとノイズ高域は消えるけど、低域が残ってｺﾞｰという感じのノイズになる。目立つ。うーん。&lt;/p&gt;
&lt;p&gt;ノイズシェーピングの基本は、ノイズ帯域を&amp;quot;おいやる&amp;quot;ことにあるようで、その後になにかしないとうまみがない？
（低域のノイズを消してノイズを高域に追いやってからローパスをかけるかんじ。）&lt;/p&gt;
&lt;p&gt;適応フィルタチックなことも試してみたが、不安定になりがち。
残差の符号だけ使い、ステップサイズをクソ小さくしてなんとか安定するが、ノイズのRMSは何もしないものから悪化。&lt;/p&gt;
&lt;p&gt;一旦ノイズシェーピングなしのやつをアップする。
自己流のやつを試してみたい気持ちがある。&lt;/p&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(4)</title><link href="/zi-you-gong-zuo-4.html" rel="alternate"></link><published>2020-09-09T10:00:00+09:00</published><updated>2020-09-09T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-09:/zi-you-gong-zuo-4.html</id><summary type="html">&lt;p&gt;エンコードもできた印象。まずは、量子化誤差の観察を開始している。
ラプラス分布っぽいので頻度を出してみる。→すご …&lt;/p&gt;</summary><content type="html">&lt;p&gt;エンコードもできた印象。まずは、量子化誤差の観察を開始している。
ラプラス分布っぽいので頻度を出してみる。→すごいラプラスだった。&lt;/p&gt;
&lt;p&gt;gnuplotで頻度を出すには以下で行ける。素晴らしい。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;::&lt;/dt&gt;
&lt;dd&gt;plot &amp;quot;foo.txt&amp;quot; u 1 smooth frequency with boxes
plot &amp;quot;foo.txt&amp;quot; u 1 smooth frequency with lines&lt;/dd&gt;
&lt;/dl&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(3)</title><link href="/zi-you-gong-zuo-3.html" rel="alternate"></link><published>2020-09-07T10:00:00+09:00</published><updated>2020-09-07T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-09-07:/zi-you-gong-zuo-3.html</id><summary type="html">&lt;p&gt;しばらく夏休みしてた。作業再開。エンコード作成中。
ADPCMの音質改善にはノイズシェーピング（量子化ノイズ）をへらすの …&lt;/p&gt;</summary><content type="html">&lt;p&gt;しばらく夏休みしてた。作業再開。エンコード作成中。
ADPCMの音質改善にはノイズシェーピング（量子化ノイズ）をへらすのが有効らしい。特許に注意だけど切れてそう。&lt;/p&gt;
&lt;p&gt;休んでいる間に色々リンク見つけたからまとめてからねる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/dbry/adpcm-xq"&gt;adpcm-xq&lt;/a&gt; WavPackの人のADPCM(IMA)の改良エンコーダ。いいアイデアが2つ。ノイズシェーピングと先読みエンコード。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://sericyb.com.au/audio.html"&gt;A comparison of Internet audio compression formats&lt;/a&gt; 音質比較&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://hydrogenaud.io/index.php?topic=109270.0"&gt;What quality measurement is best for (A)DPCM?&lt;/a&gt; ADPCMの評価指標について&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.kumikomi.net/archives/2010/07/ep22onse.php?page=5"&gt;G.726 ADPCMエンコーダの詳細&lt;/a&gt; 本と同じ内容だけど、こっちはいつでも見れる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/isciesci/61/2/61_76/_pdf/-char/en"&gt;信号品質を保つディジタル化技術: ノイズシェーピング量子化—I&lt;/a&gt; ノイズシェーピングの基礎。Ⅵまである。丁寧。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://kamedo2.hatenablog.jp/entry/20100812/1281640220"&gt;ADPCM音質改善&lt;/a&gt; 重要。ノイズシェーピングの効果について書いてある。ソースもある。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.a-r-tec.jp/DSADC2.pdf"&gt;ADCの動作原理&lt;/a&gt; ADCとノイズシェーピングの必要性がわかりやすく書いてある。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://kobaweb.ei.st.gunma-u.ac.jp/lecture/DSM_San_2008_pt02[1].pdf"&gt;AD変調器(2)&lt;/a&gt; こちらもADCとノイズシェーピングについて記述有り。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://graphics.stanford.edu/~seander/bithacks.html"&gt;Bit Twiddling Hacks&lt;/a&gt; Hacker's Delightに掲載されてないのもある。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(2)</title><link href="/zi-you-gong-zuo-2.html" rel="alternate"></link><published>2020-08-31T10:00:00+09:00</published><updated>2020-08-31T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-08-31:/zi-you-gong-zuo-2.html</id><summary type="html">&lt;p&gt;ADPCMのデコードはほぼできた。次はエンコード。&lt;/p&gt;
&lt;p&gt;いろんなソース見とるが、予測時に分岐しまくるのやばくね？とおもって …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ADPCMのデコードはほぼできた。次はエンコード。&lt;/p&gt;
&lt;p&gt;いろんなソース見とるが、予測時に分岐しまくるのやばくね？とおもってたらそのとおりで、ffmpeg実装は乗算を使ってる:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ffmpeg.org/doxygen/trunk/adpcm_8c_source.html"&gt;ffmpegの実装（adpcm_ima_expand_nibble）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ffmpeg.org/doxygen/trunk/adpcmenc_8c_source.html"&gt;ffmpegのエンコーダ実装(adpcm_ima_compress_sample)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;inline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int16_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;adpcm_ima_expand_nibble&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ADPCMChannelStatus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;predictor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delta&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ff_adpcm_step_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ff_adpcm_index_table&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;av_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;88&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;delta&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* perform direct multiplication instead of series of jumps proposed by&lt;/span&gt;
&lt;span class="cm"&gt;     * the reference ADPCM implementation since modern CPUs can do the mults&lt;/span&gt;
&lt;span class="cm"&gt;     * quickly enough */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delta&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shift&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;predictor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;predictor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;predictor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;predictor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;predictor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;av_clip_int16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predictor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int16_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;predictor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;inline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;adpcm_ima_compress_sample&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ADPCMChannelStatus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                                &lt;/span&gt;&lt;span class="kt"&gt;int16_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sample&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delta&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev_sample&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FFMIN&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delta&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="n"&gt;ff_adpcm_step_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delta&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;ff_adpcm_step_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="n"&gt;ff_adpcm_yamaha_difflookup&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;av_clip_int16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev_sample&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;av_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;step_index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ff_adpcm_index_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;88&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;nibbleってなんだよ・・・って思って調べたら1/2バイト(4bit)のことだった。&lt;/p&gt;
&lt;p&gt;デコーダ作って安定させてたら、AudacityとffmpegのADPCM(IMA)のデコード結果が違うことに気付く。
原因は、Audacityを始めとした多くのコーデックでは分岐が多い近似実装になっているからだった。 &lt;a class="reference external" href="http://web.mit.edu/ghudson/dev/nokrb/third/audiofile/libaudiofile/modules/adpcm.c"&gt;こいつ&lt;/a&gt; が原因か。
一方、ffmpegは近頃のCPUは十分乗算が早いからと言う理由で厳密計算している。ということで自分も厳密計算を選ぶ。&lt;/p&gt;
&lt;p&gt;もう一点、AudacityにADPCM(IMA)を突っ込むと末尾が伸びてしまう。これは末尾のブロックも同一サンプル数でデコードしているから…。
あきらかな不具合。PR送るか、送らざるべきか…。&lt;/p&gt;
&lt;p&gt;Audacityは内部でlibsndfileを使ってるから、 &lt;a class="reference external" href="https://github.com/erikd/libsndfile/blob/master/src/ima_adpcm.c"&gt;こっち&lt;/a&gt; にPRを送るべき。&lt;/p&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作(1)</title><link href="/zi-you-gong-zuo-1.html" rel="alternate"></link><published>2020-08-29T10:00:00+09:00</published><updated>2020-08-29T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-08-29:/zi-you-gong-zuo-1.html</id><summary type="html">&lt;p&gt;まずはIMA-ADPCM互換のデコーダ/エンコーダを作ってみますかね。かなり情報あるし。
FFMPEGで出力する方法は:&lt;/p&gt;
&lt;p&gt;ffmpeg -i &amp;lt;input.wav&amp;gt; -f wav -acodec adpcm …&lt;/p&gt;</summary><content type="html">&lt;p&gt;まずはIMA-ADPCM互換のデコーダ/エンコーダを作ってみますかね。かなり情報あるし。
FFMPEGで出力する方法は:&lt;/p&gt;
&lt;p&gt;ffmpeg -i &amp;lt;input.wav&amp;gt; -f wav -acodec adpcm_ima_wav &amp;lt;output.wav&amp;gt;&lt;/p&gt;
&lt;p&gt;Macで再生もできた。ほぼ1/4になる。理論的には1/4だけどwavに余計なチャンクが入っているから減っている？&lt;/p&gt;
&lt;p&gt;ステレオ以上はどうなってるのか見ている。インターリーブしているようだ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.multimedia.cx/index.php?title=Microsoft_IMA_ADPCM"&gt;Microsoft IMA ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記のサイト含めてフォーマットをまとめると（ &lt;strong&gt;全て&lt;/strong&gt; リトルエンディアン）&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="25%" /&gt;
&lt;col width="12%" /&gt;
&lt;col width="63%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;名前&lt;/th&gt;
&lt;th class="head"&gt;サイズ[byte]&lt;/th&gt;
&lt;th class="head"&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;RIFFチャンクID&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'R', 'I', 'F', 'F'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;RIFFチャンクサイズ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;ファイルサイズ - 8（これ以降の残りファイルサイズ）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ファイルフォーマットタイプ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'W', 'A', 'V', 'E'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;FMTチャンクID&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'f', 'm', 't', ' '&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;FMTチャンクサイズ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;これ以降のFMTフィールドのサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;WAVEフォーマットタイプ&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;IMA-ADPCMなら17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;チャンネル数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;IMA-ADPCMの場合は1（モノラル）か2（ステレオ）しかないっぽい&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプリングレート&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;データ速度（byte/sec）&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;= ブロックサイズ * サンプリングレート / ブロックあたりサンプル数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックサイズ&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;ブロックのヘッダと圧縮済みデータを含めたサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプルあたりビット数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;IMA-ADPCMなら4のはず&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;エキストラサイズ&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;これ以降に続く追加データサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;ブロックあたりサンプル数&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;FACTチャンクID&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'f', 'a', 'c', 't'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;FACTチャンクサイズ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;これ以降のFACTチャンクサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;サンプル数&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;= DATAチャンクサイズ * ブロックあたりサンプル数 / ブロックサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DATAチャンクID&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;'d', 'a', 't', 'a'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;DATAチャンクサイズ&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;これ以降のDATAチャンクサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;圧縮済みデータ&lt;/td&gt;
&lt;td&gt;※&lt;/td&gt;
&lt;td&gt;※ = DATAチャンクサイズ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>自由工作</title><link href="/zi-you-gong-zuo.html" rel="alternate"></link><published>2020-08-28T10:00:00+09:00</published><updated>2020-08-28T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-08-28:/zi-you-gong-zuo.html</id><summary type="html">&lt;p&gt;発表会終わり。発表準備と並行して群論やってた。
夏休みは自由工作（息抜き）としてADPCMエンコーダデコーダ作ろうかと …&lt;/p&gt;</summary><content type="html">&lt;p&gt;発表会終わり。発表準備と並行して群論やってた。
夏休みは自由工作（息抜き）としてADPCMエンコーダデコーダ作ろうかと思ってる。
もちろん、群論（リー群まで）と情報幾何（統計的応用まで、行間のまとめ）は進める。&lt;/p&gt;
&lt;p&gt;ADPCMのフォーマットを見ている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://forum.audacityteam.org/viewtopic.php?t=10950"&gt;IMA ADPCM vs MS ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.multimedia.cx/index.php/Microsoft_ADPCM"&gt;Microsoft ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.multimedia.cx/index.php/IMA_ADPCM"&gt;IMA ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.multimedia.cx/index.php/CRI_ADX_ADPCM"&gt;CRI ADX ADPCM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.columbia.edu/~hgs/audio/dvi/IMA_ADPCM.pdf"&gt;Recommended Practices for Enhancing Digital Audio Compatibility in Multimedia Systems&lt;/a&gt; IMA公式の推奨規格。実装も掲載されてて有益。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MS-ADPCMかIMA-ADPCMやなあ。IMA-ADPCMの方が説明が充実している。
そして、なんとなくステップ幅をテーブル引きするところにTAKとの類似点を感じる。
G.726もありだがテーブル引きを使ってない。説明は「音声&amp;amp;画像処理の常識」に書いてある。&lt;/p&gt;
&lt;p&gt;研究としてはグラフィカルLASSOの導入忘れずに。もう一度張っとく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ide-research.net/papers/2016_Iwanami_Ide.pdf"&gt;依存関係にスパース性を入れる — グラフィカル lasso の話&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="ADPCM"></category></entry><entry><title>研究会に向けて - 執筆(5)</title><link href="/yan-jiu-hui-nixiang-kete-zhi-bi-5.html" rel="alternate"></link><published>2020-08-03T10:00:00+09:00</published><updated>2020-08-03T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-08-03:/yan-jiu-hui-nixiang-kete-zhi-bi-5.html</id><summary type="html">&lt;p&gt;自己相関行列の逆の推定、グラフィカルLASSOが有効ではというありがたい指摘あり。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ide-research.net/papers/2016_Iwanami_Ide.pdf"&gt;依存関係にスパース性を入れる …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;自己相関行列の逆の推定、グラフィカルLASSOが有効ではというありがたい指摘あり。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ide-research.net/papers/2016_Iwanami_Ide.pdf"&gt;依存関係にスパース性を入れる — グラフィカル lasso の話&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他にも精度行列の推定を（スパース制約を入れて）高速にやるみたいな話がたくさん出てきている。参考にすべし。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>IGおべんきょ(4)</title><link href="/igobenkiyo4.html" rel="alternate"></link><published>2020-08-01T10:00:00+09:00</published><updated>2020-08-01T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-08-01:/igobenkiyo4.html</id><summary type="html">&lt;p&gt;しばらくIGをおべんきょしてた。行間メモは公開していきたい。
で、いまはChentsovの定理で絶賛ハマってる。(0,4)-テンソル場 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;しばらくIGをおべんきょしてた。行間メモは公開していきたい。
で、いまはChentsovの定理で絶賛ハマってる。(0,4)-テンソル場で定数倍にならない理由って何よ。&lt;/p&gt;
&lt;p&gt;証明の1ステップと言ったらラベルに対する付替えで、
4次元以上で起こる特殊なこと…を調べていて、群論が関わってくるのでは。と。
ラベルの付替えは対称群に相当するはず。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://orz107orz.hatenablog.com/entry/20140218/1392724434"&gt;交代群が非可換になること&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.tsuyama-ct.ac.jp/matsuda/eBooks/galios.pdf"&gt;ガロア理論を理解しよう&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;でももっと単純に考えるべきかも。 &lt;span class="math"&gt;\(F\)&lt;/span&gt; は当然計算できる上で、 &lt;span class="math"&gt;\(\~{F}\)&lt;/span&gt; も不変性の要求を満たす。
でも &lt;span class="math"&gt;\(\~{F}\)&lt;/span&gt; は &lt;span class="math"&gt;\(F\)&lt;/span&gt; の定数倍にならない、みたいな論法。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="IG"></category></entry><entry><title>IGおべんきょ(3)</title><link href="/igobenkiyo3.html" rel="alternate"></link><published>2020-07-30T10:00:00+09:00</published><updated>2020-07-30T10:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-30:/igobenkiyo3.html</id><content type="html">&lt;p&gt;IGがだいぶ止まってたので、レビューが帰るまでのあいだ進める。
今日の合言葉：写像の微分は接ベクトルの写像。&lt;/p&gt;
</content><category term="雑記"></category><category term="IG"></category></entry><entry><title>研究会に向けて - 執筆(4)</title><link href="/yan-jiu-hui-nixiang-kete-zhi-bi-4.html" rel="alternate"></link><published>2020-07-28T11:00:00+09:00</published><updated>2020-07-28T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-28:/yan-jiu-hui-nixiang-kete-zhi-bi-4.html</id><summary type="html">&lt;p&gt;引き続き執筆。今日あたりであらすじ書いてレビュー予定。&lt;/p&gt;
&lt;p&gt;思ったのが、先にデータの自己相関行列の逆を計算して勾 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;引き続き執筆。今日あたりであらすじ書いてレビュー予定。&lt;/p&gt;
&lt;p&gt;思ったのが、先にデータの自己相関行列の逆を計算して勾配計算用のデータを用意しちゃう発想はどうよ？という点。
もしくは、自己相関（の偏り）を打ち消すようなフィルタを先にかけてからフィルタ処理をおこなうのはどうか？演算誤差が気になるけど、ありえる発想。
これはもしかしたらプリエンファシスの一般化かもしれない。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて - 執筆(3)</title><link href="/yan-jiu-hui-nixiang-kete-zhi-bi-3.html" rel="alternate"></link><published>2020-07-26T11:00:00+09:00</published><updated>2020-07-26T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-26:/yan-jiu-hui-nixiang-kete-zhi-bi-3.html</id><summary type="html">&lt;p&gt;土日は黙々と執筆してた。
1点気になったのが、自然勾配法を共役勾配法的にやれないかというところ。そうすれば逆行 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;土日は黙々と執筆してた。
1点気になったのが、自然勾配法を共役勾配法的にやれないかというところ。そうすれば逆行列を計算しなくて済む。
ここらへん誰かやってないのかな？誰でも思いつくと思うけど。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://edisciplinas.usp.br/pluginfile.php/227194/mod_resource/content/1/Nascimento_Silva_2014_Adaptive_Filters.pdf"&gt;Adaptive Filters&lt;/a&gt; 適応フィルタの新しい良さげなまとめ。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて - 執筆(2)</title><link href="/yan-jiu-hui-nixiang-kete-zhi-bi-2.html" rel="alternate"></link><published>2020-07-24T11:00:00+09:00</published><updated>2020-07-24T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-24:/yan-jiu-hui-nixiang-kete-zhi-bi-2.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\inprod[2]{\langle #1,\ #2 \rangle}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;うーん、SAの原典を探ってるときに&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://read.pudn.com/downloads125/ebook/529634/Adaptive_Filtering_-_Algorithms_and_Practical_Implementation.pdf"&gt;Adaptive Filtering: Algorithms and Practical Implementation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が参照されてて、その中で&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www02.smt.ufrj.br/~diniz/conf/confi12.pdf"&gt;Performance of …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\inprod[2]{\langle #1,\ #2 \rangle}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;うーん、SAの原典を探ってるときに&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://read.pudn.com/downloads125/ebook/529634/Adaptive_Filtering_-_Algorithms_and_Practical_Implementation.pdf"&gt;Adaptive Filtering: Algorithms and Practical Implementation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が参照されてて、その中で&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www02.smt.ufrj.br/~diniz/conf/confi12.pdf"&gt;Performance of LMS-Newton Adaptation Algorithms With Variable Convergence Factor in Nonstationary Environments&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が参照されてたけど、全く同じやん…&lt;/p&gt;
&lt;p&gt;どうも、Winner解を求める最適化問題のニュートン法を求めると、自己相関行列の逆が自然に出てくるみたい。そして、その適応ステップ版アルゴリズム（LMS Newton Algorithm, 初出はAdaptive Signal Processing(Widrow)）は上記論文と完全に同一。&lt;/p&gt;
&lt;p&gt;LMS Newton Algorithmは、Adaptive Signal Processingのp142あたり（Chapter8冒頭）が詳しいが、残差の二乗を目的関数（Adaptive Filter Theory p105 2.38, 2.50に注目）としたときのニュートン法を近似して得られる。導出にあたり勾配を近似（確率降下）することでNewton法が成立している。&lt;/p&gt;
&lt;p&gt;適応ステップサイズの設定法には他にもある。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/ieejeiss1987/119/8-9/119_8-9_1027/_pdf/-char/ja"&gt;準最適ステップゲインを用いたBlock LMS-Newtonアルゴリズム&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;これはLMS Newton Algorithmに関する話だけど、ここで提案されているやり方をSAに持っていけないか？→ブロック単位で更新しているから話が違う？いや、もうちょっと読み込もう。&lt;ul&gt;
&lt;li&gt;この論文で可変ステップサイズに関する議論が出てきている。最適係数から垂線を下ろしたところでステップサイズを決めるという方針。それにしたがってNGSAにおいても最適なステップサイズを求めたら今までのNNGSAと同一の結果が出た。&lt;/li&gt;
&lt;li&gt;勾配 &lt;span class="math"&gt;\(\ve{g}[n] = \mathrm{sgn}(\varepsilon[n])\ve{x}[n]\)&lt;/span&gt; に対して &lt;span class="math"&gt;\(\inprod{\ve{R}^{-1}\ve{g}[n]}{\ve{h}_{\rm opt} - (\ve{h}[n] + \mu[n] \ve{R}^{-1} \ve{g}[n])}_{\ve{R}} = 0\)&lt;/span&gt; を満たす &lt;span class="math"&gt;\(\mu[n]\)&lt;/span&gt; こそ、勾配のなす方向に対して &lt;span class="math"&gt;\(\ve{h}_{\rm opt}\)&lt;/span&gt; から垂線を降ろせているから最適になる。直交条件を展開すると、 &lt;span class="math"&gt;\(\ve{g}[n]^{\mathsf{T}} \ve{R}^{-1} \ve{R} (\ve{h}_{opt} - \ve{h}[n]) - \mu[n] \ve{g}[n]^{\mathsf{T}} \ve{R}^{-1} \ve{R} \ve{R}^{-1} \ve{g}[n] = 0\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(\ve{g}[n] = \mathrm{sgn}(\varepsilon[n])\ve{x}[n]\)&lt;/span&gt; を突っ込むと &lt;span class="math"&gt;\(\mathrm{sgn}(\varepsilon[n]) \ve{x}[n]^{\mathsf{T}} (\ve{h}_{\rm opt} - \ve{h}[n]) - \mu[n] \ve{x}[n]^{\mathsf{T}} \ve{R}^{-1} \ve{x}[n] = \mathrm{sgn}(\varepsilon[n]) \varepsilon[n] + \mathrm{sgn}(\varepsilon[n]) v[n] - \mu[n] \ve{x}[n]^{\mathsf{T}} \ve{R}^{-1} \ve{x}[n] = 0\)&lt;/span&gt; より、&lt;span class="math"&gt;\(v[n]=0\)&lt;/span&gt; ならばいつものステップサイズが出てくる。論文間違ってると思う。。。&lt;/li&gt;
&lt;li&gt;つまり、NNGSAはその意味でも最適。追記すべきかも。しかし、勾配 &lt;span class="math"&gt;\(\ve{g}[n]\)&lt;/span&gt; がLMSのときとの差異が気になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有益そうなのは、ブロックあたり1回だけ逆行列補題を使うだけでもよいという主張（問題ないことを示している）。つまり自己相関行列の更新を間引く。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.academia.edu/14148013/Performance_of_LMS-Newton_adaptation_algorithms_with_variable_convergence_factor_in_nonstationary_environments"&gt;Analysis of LMS-Newton Adaptive Filtering Algorithms with Variable Convergence Factor&lt;/a&gt; Academaから落とした。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Newton LMS AlgorithmはRLSと等価。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.academia.edu/17820650/Optimal_variable_step_size_for_the_LMS_Newton_algorithm_with_application_to_subband_adaptive_filtering?auto=download"&gt;Optimal variable step size for the LMS/Newton algorithm with application to subband adaptive filtering&lt;/a&gt; これもAcademiaから&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;でも、NNGSAまで至らないと上記の一致は指摘できない。また、こっちはFisher情報行列ベースで話を進めているから、射影の足がKLダイバージェンスに一致することを議論できる。&lt;/p&gt;
&lt;p&gt;あ、でもNGSAは残差のsgnとってるだけだから、LMS Newton Algorithmのステップサイズを荒く量子化したやつに対応するのか。いや、それでも、ラプラス分布仮定時に最急勾配になってるはずなんや。最適値近傍で頑張って0に近づけるし、しかも遠いときはゆっくり近づいてロングテールな分布を作っているんや。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://core.ac.uk/download/pdf/52288867.pdf"&gt;Adaptive filters: stable but divergent&lt;/a&gt; なんか適応フィルタのまとめ。時間があれば。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SAの収束性能解析論文がヒットし始めた&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Adaptive Filtering with Binary Reinforcement とても重要な論文。SAの限界について基本的な定理が述べられている。そして、SAはLMSより遅いという指摘あり。これが欲しかった。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/fe70/e6867138651ac95130ec53cebc2ba8b7ecab.pdf?_ga=2.105956032.2125347977.1595579214-2033161310.1595579214"&gt;CONVERGENCE ANALYSIS OF THE SIGN ALGORITHM FOR ADAPTIVE FILTERING&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて - 執筆(1)</title><link href="/yan-jiu-hui-nixiang-kete-zhi-bi-1.html" rel="alternate"></link><published>2020-07-22T11:00:00+09:00</published><updated>2020-07-22T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-22:/yan-jiu-hui-nixiang-kete-zhi-bi-1.html</id><summary type="html">&lt;p&gt;今日から執筆していく。目標、7/27に第一般。&lt;/p&gt;
&lt;p&gt;しかしまだ書き始めず、プロットを練る。プロットの構成はだいたい発表と …&lt;/p&gt;</summary><content type="html">&lt;p&gt;今日から執筆していく。目標、7/27に第一般。&lt;/p&gt;
&lt;p&gt;しかしまだ書き始めず、プロットを練る。プロットの構成はだいたい発表とおんなじだが、
イントロをしっかり書きたいから、既存のロスレス音声の論文の構成を参考にしていく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.tut.fi/~tabus/2013GhidoTabus.pdf"&gt;Sparse modeling for lossless audio compression&lt;/a&gt; OptimFROGのひと。&lt;ul&gt;
&lt;li&gt;オーディオ環境は高級化している。その中でロスレス圧縮は現実的である。プレーヤが使うから、デコーダは高速実装できるべきだ。今現在使われているいろんなコーデックがある。MP4-ALS, WMAL, ALAC, Monkey's Audio, FLAC, OptimFROG等。それぞれ異なる予測モデルと圧縮アルゴリズムを使用している。圧縮率、エンコード速度、デコード速度の3つの評価軸があるが、全てを最大にすることはできず、トレードオフの関係にある。例えば、予測次数を最大にすれば圧縮率は向上するが、エンコード/デコード速度が悪化する。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://decoy.iki.fi/dsound/ambisonic/motherlode/source/01215233.pdf"&gt;An Introduction to Super Audio CD and DVD-Audio&lt;/a&gt; Super Audio CD(SACD)なんてあったのか…すでに死んでるが…。OptimFROGでは高級なオーディオの規格として挙げていた。&lt;/li&gt;
&lt;li&gt;A hierarchical lossless/lossy coding system for high quality audio up to 192 kHz sampling 24 bit format: 公開されてない...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.kecl.ntt.co.jp/people/harada.noboru/doc/thesis_noboru_harada_201630173_final.pdf"&gt;Lossless Compression of Speech and Audio Signals, and Its Application&lt;/a&gt; NTTの原田さんの博論。成果は符号化メイン。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://mi.eng.cam.ac.uk/reports/svr-ftp/auto-pdf/robinson_tr156.pdf"&gt;SHORTEN: Simple lossless and near-lossless waveform compression&lt;/a&gt; シンプルで宜しい。うざったるい背景描写ほとんどなし。&lt;ul&gt;
&lt;li&gt;デジタル化した音声ファイルをそのまま保存するとかなりの容量を食う。ZIP等の一般的な圧縮アルゴリズムは、音声の特徴を捉えていないからうまく圧縮できない。一般的な音声データは16bitで、サンプル間に相関がある。これらのファイルに対する圧縮ユーティリティは高速で、移植性があり、多くのデータを処理可能で素晴らしい圧縮率を達成する必要がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jas-audio.or.jp/jas_cms/wp-content/uploads/2017/03/201703_027-033.pdf"&gt;国際標準 MPEG-4 ALS による ハイレゾ音源ロスレス伝送&lt;/a&gt; MPEG4-ALSの分かりやすい説明。飾り言葉がおおいので注意。（「コト」や「モノ」の下りは使えない）&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://elvera.nue.tu-berlin.de/files/1216Liebchen2009.pdf"&gt;MPEG­4 ALS – The Standard for Lossless Audio Coding&lt;/a&gt; MPEG4-ALSのもうちょっと分かりやすい説明。厚すぎず手軽で良い。&lt;ul&gt;
&lt;li&gt;ロッシー符号化は編集やアーカイビングに向かない。歪みを生む。MP3やAACを知覚符号化と言っていた。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/7991/abe1173b7ad06b23d5a51d7e5b5092b2f201.pdf"&gt;予測誤差の Golomb-Rice 符号量を最小化する線形予測分析&lt;/a&gt; これは遊びが無くて良いように見える。というかこれ引用するだろうし、しっかり参考にすべき。&lt;ul&gt;
&lt;li&gt;やはりバックグラウンドにロスレス音声は使える。うまく話を作ろう。&lt;/li&gt;
&lt;li&gt;「最小絶対値推定量がロバスト推定量で あることから線形予測分析に基づく音声分析の耐雑音 性能を向上する目的として応用されている」もよいアイデア。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.eie.polyu.edu.hk/~enyhchan/ce_ac_p1.pdf"&gt;Lossless compression of digital audio&lt;/a&gt; 今の発表につながる概観書。基礎は変わってない。&lt;ul&gt;
&lt;li&gt;デジタル配信で重要な役割を果たす、ミキシングを高い忠実性を保てる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://cs.joensuu.fi/sipu/pub/RLS-LMS_TIP2008.pdf"&gt;Cascaded RLS–LMS Prediction in MPEG-4 Lossless Audio Coding&lt;/a&gt; MPEG4にカスケード接続したLMS+RLSを突っ込むと3%程圧縮率がよくなるという話。MPEG4-ALSも適応フィルタを使っているので、引用する必要はある。そらそうよ。負荷大丈夫か。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;既存研究調査&lt;/h2&gt;
&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3&gt;1回ざっと目を通した論文&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.452.7280&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Natural Gradient Works Efficiently in Learning&lt;/a&gt; LMS界隈からの引用多数。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www2.ee.ic.ac.uk/publications/p3943.pdf"&gt;Adaptive algorithms for sparse echo cancellation&lt;/a&gt; 俯瞰した背景描写もある。&lt;ul&gt;
&lt;li&gt;PNLMSに偏っているか。古い。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://iiav.org/ijav/content/volumes/21_2016_590031458046128/vol_1/835_fullpaper_1207561458214850.pdf"&gt;Review and Comparison of Variable Step-Size LMS Algorithms&lt;/a&gt; 適応ステップサイズ手法の比較。2015年。&lt;ul&gt;
&lt;li&gt;比較について多くの手法を3つの応用例から見ている。結論はNLMSが最高ということだったけど、比較過程については要注目。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/bf3b/fe757d9156cc863ffdde15b1664c337819bd.pdf"&gt;Proportionate Normalized Least-Mean-Squares Adaptation in Echo Cancelers&lt;/a&gt; 頻繁に参照されるPNLMS。係数の絶対値をその最大値で正規化した値を対角要素に持つ対角行列をフィッシャー情報行列の逆行列とする。&lt;ul&gt;
&lt;li&gt;NLMSと比較。DSP実装して実ノイズで試してもいる。理論的解析（定常雑音に対する収束レート解析）もしている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://scholarsmine.mst.edu/cgi/viewcontent.cgi?article=2780&amp;amp;context=ele_comeng_facwork"&gt;Normalized Natural Gradient Adaptive Filtering for Sparse and Nonsparse Systems&lt;/a&gt; フィッシャー情報行列を対角行列で与えている。&lt;ul&gt;
&lt;li&gt;まさに自然勾配をがっつり使う論文。絶対参照すべき。対角行列を計量にしたINLMSを導入し、スパース係数（1つだけ1.0で他全部0）ではPNLMSに負けたけど、非スパース係数（全部1）ではPNLMSよりも結果が良いとか言ってる。&lt;/li&gt;
&lt;li&gt;シミュレーション節が短すぎ。システム同定をやったらしいがよく分からん。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.eurasip.org/Proceedings/Eusipco/Eusipco2017/papers/1570346064.pdf"&gt;Full Proportionate Functional Link Adaptive Filters for Nonlinear Acoustic Echo Cancellation&lt;/a&gt; これも。謎のリーマン計量を作る。&lt;ul&gt;
&lt;li&gt;比較データの生成が恣意的すぎるので無し。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.907.849&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;New Sparse Adaptive Algorithms Based on the Natural Gradient and the l0-Norm&lt;/a&gt; これも謎のリーマン計量を使っている…。損失関数に計量が入っちゃってるけどいいのか？→大丈夫っぽい。損失関数の設計は自由。&lt;ul&gt;
&lt;li&gt;応用が特殊すぎる。オレオレデータセットに対して有効性を示されても困る。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arl.nus.edu.sg/twiki6/pub/ARL/BibEntries/Konstantinos_-_2011_-_Natural_Gradient-Based_Adaptive_Algorithms_For_Spa.pdf"&gt;NATURAL GRADIENT-BASED ADAPTIVE ALGORITHMS FOR SPARSE UNDERWATER ACOUSTIC CHANNEL IDENTIFICATION&lt;/a&gt; L0ノルム最小化に自然勾配法をあわせた。とある。やけに性能が良い。&lt;ul&gt;
&lt;li&gt;↑と著者が同じ。データセットも同じ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1303.2261.pdf"&gt;l0 Norm Constraint LMS Algorithm for Sparse System Identification&lt;/a&gt; 係数l0ノルム最小化。l0ノルムをexpで近似して解析的最小化。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;この論文で相関のあるガウス雑音の作り方が明確に示されている。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ITU-Tのデータを使ってるのは参考になった、&lt;/li&gt;
&lt;li&gt;が、スパースなデータの作り方が恣意的すぎる。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1311.5242.pdf"&gt;AN IMPROVED VARIABLE STEP-SIZE AFFINE PROJECTION SIGN ALGORITHM FOR ECHO CANCELLATION&lt;/a&gt; &lt;strong&gt;これが一番近いかも。&lt;/strong&gt; なんでここまできて自然勾配に至らないのか？こいつの引用を漁ったけど同一の研究なし。&lt;ul&gt;
&lt;li&gt;謎の手順（ガウス雑音に1次のIIRフィルタを通して、しかもベルヌーイ試行で出力判定する）で入力を生成している。よくあるのか？？？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://asl.epfl.ch/wp-content/uploads/publications/journal_articles/spl_feb_2004_b.pdf"&gt;Variable Step-Size NLMS and Affine Projection Algorithms&lt;/a&gt; これもそれなりに近い。affine projection algorithm で情報行列の逆を使っている。&lt;ul&gt;
&lt;li&gt;移動平均フィルタを理想フィルタにしている。ガウス雑音に謎の2次IIRフィルタを通したものをリファレンスとしている…。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1110.2907.pdf"&gt;System Identification Using Reweighted Zero Attracting Least Absolute Deviation Algorithms&lt;/a&gt; ZA-LADの原典。自分のやっている研究に近いかも。残差L1ノルム最小化はロバストだいう主張。&lt;ul&gt;
&lt;li&gt;スパースなときに有利であることを言いたいらしい。&lt;/li&gt;
&lt;li&gt;16タップの係数を使い、最初のXXXXイテレーションでは5番目のタップだけ1（他全部0）、次に奇数タップをすべて1にしてYYYYイテレーション、最後に偶数タップを-1にしてZZZZイテレーション。。。&lt;ul&gt;
&lt;li&gt;ノイズとして非ガウス的（α-stableと言っていた）なものを使用。SNRはGeneralized SNRという尺度を使用。&lt;/li&gt;
&lt;li&gt;他に、白色ガウス雑音に1次のフィルタを通して入力していた。出力に相関をもたせる意図か。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1311.6809.pdf"&gt;A Novel Family of Adaptive Filtering Algorithms Based on The Logarithmic Cost&lt;/a&gt; LLADの原典。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;これのデータよい。採用。&lt;/strong&gt; 単純明快。(理論ばっかりで分かりにくいと思っていたが）&lt;ul&gt;
&lt;li&gt;リファレンス信号 &lt;span class="math"&gt;\(d_{t} = \ve{w}_{0}^{\mathsf{T}} \ve{x}_{t} + n_{t}\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(\ve{w}_{0}\)&lt;/span&gt; はリファレンス係数（論文ではランダム選択にしていた。スパースじゃないならいいかも。）、 &lt;span class="math"&gt;\(\ve{x}_{t}\)&lt;/span&gt; は分散 &lt;span class="math"&gt;\(\sigma_{x}^{2} = 1\)&lt;/span&gt; の i.i.d な平均0ガウス信号系列、 &lt;span class="math"&gt;\(n_{t}\)&lt;/span&gt; はノイズ信号（分散0.01のガウス雑音と分散10000(偏差100)で一定確率(1,2,5%)で発生するインパルス雑音）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一定確率でインパルス雑音が発生するケースはロバスト性を示すために使われていた。LMSは全く等化できずにいた。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://gr.xjtu.edu.cn/c/document_library/get_file?folderId=1540809&amp;amp;name=DLFE-38423.pdf"&gt;Sparse Least Logarithmic Absolute Difference Algorithm with Correntropy-Induced Metric Penalty&lt;/a&gt; 重みによくわからないペナルティを付加したSigned LMS。&lt;ul&gt;
&lt;li&gt;これもしかしたら重要かもしれない。ちゃんと書けてる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Convergence Analysis of Zero Attracting Natural Gradient Non-Parametric Maximum Likelihood Algorithm これ読めないんだけどAbstract読み限り相当やってそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下、日本語論文&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jasj/50/1/50_KJ00001456848/_pdf/-char/ja"&gt;音響エコー経路の変動特性を反映させたRLS適応アルゴリズム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.tara.tsukuba.ac.jp/~maki/reprint/Makino/sm92ieice9-20.pdf"&gt;室内インパルス応答の統計的性質に基づく指数重み付けLMSフィルタ&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;実験としては微妙で、理論と一致しているかどうかの議論で終わっている。比較実験なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cepstrum.co.jp/rd/nlms/nlms_txt.pdf"&gt;エコーキャンセラ向けのNormalizedLMSアルゴリズムの改良&lt;/a&gt; 社内発表資料？&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://leo.ec.t.kanazawa-u.ac.jp/staffs/nakayama/pub/file/dsp_symp03_dougahara.pdf"&gt;適応フィルタにおけるブロック形重み付けステップサイズの制御法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://ir.lib.u-ryukyu.ac.jp/bitstream/20.500.12000/1487/1/No59p107.pdf"&gt;直交ECLMSアルゴリズムを用いたエコーキャンセラーの設計&lt;/a&gt; ダブルトーク問題も入ってきちゃってる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.topic.ad.jp/sice/htdocs/papers/242/242-3.pdf"&gt;エコーキャンセラにおける適応アルゴリズムとダブルトーク検出の関係&lt;/a&gt; これもダブルトーク問題。しっかしNLMSとの比較のみ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3&gt;比較対象にすべき手法&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;NLMS, Signed-LMS, RLS&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/bf3b/fe757d9156cc863ffdde15b1664c337819bd.pdf"&gt;PNLMS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;IPNLMS(Improved PNLMS)&lt;/li&gt;
&lt;li&gt;APA(Affine Projection Algorithm)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3&gt;比較対象にすべきデータ&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;発話音声（ソースがない...）&lt;/li&gt;
&lt;li&gt;理想係数に入力として単位インパルス（雑音源よりもレベルの小さいノイズもあり）をXXXX回繰り返し入れ続け（途中で理想係数を急に変える）、同時にレベルを決めた雑音源を入力。&lt;ul&gt;
&lt;li&gt;シードのみを変えて、XXX回独立した試行を行ってその平均を（残差トレンドの平均も）とる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ITU G.168のエコーパスモデル&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.itu.int/ITU-T/recommendations/rec.aspx?rec=12451&amp;amp;lang=en"&gt;公式&lt;/a&gt; から資料入手可能。&lt;/li&gt;
&lt;li&gt;Annex Dに8つのエコーインパルスのデータが乗っかっている。5番目のインパルスがスパースだから良いらしい。&lt;/li&gt;
&lt;li&gt;また、リファレンスの波形にフィルタを通して使うらしい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ほぼ0で、ランダムに選んだいくつかの係数だけが1になっているリファレンスフィルタの出力
* 入力例1: ガウス雑音に1次（極が1つの）のIIRを通し、さらにベルヌーイ過程として、一定確率pでノイズ、1-pで0となる信号
* 入力例2: ガウス雑音に2次のIIRを通す&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h3&gt;比較基準&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;2乗誤差(misalignmentとか行ったりする)[dB]&lt;/li&gt;
&lt;li&gt;計算量（畳み込み、係数更新における乗算+加算回数）&lt;/li&gt;
&lt;li&gt;定常状態での係数の分散&lt;/li&gt;
&lt;li&gt;理想係数との誤差MSE（MSD(Mean Square Deviationとも言う。Simonの本から来てると思われる)。もし計算できるなら。正規化してdB表示する: &lt;span class="math"&gt;\(10 \log_{10} ( ||h - \hat{h}|| / ||h|| )\)&lt;/span&gt; ）&lt;/li&gt;
&lt;li&gt;定常状態でのMSE&lt;/li&gt;
&lt;li&gt;MSEの和（全実験での）&lt;/li&gt;
&lt;li&gt;可変ステップサイズアルゴリズムの場合は、ステップサイズの変化&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h3&gt;思ったこと&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ブロック線図を書くと良さそう？多くの論文が書いてる。エコーキャンセラーのアーキテクチャは示すべきか。&lt;/li&gt;
&lt;li&gt;提案手法はウィーナー解に収束するか？&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://onsen-mula.org/wp-content/uploads/2017/04/inoue.pdf"&gt;ロバスト適応同定手法によるエコーキャンセラの設計&lt;/a&gt; ここにウィーナー解との関連がある&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.bode.amp.i.kyoto-u.ac.jp/~kashima/lecture/ss/slide17_8.pdf"&gt;信号とシステム&lt;/a&gt; ここにもそれなりにある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;音響データベースがある...&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.nii.ac.jp/dsc/idr/speech/submit/RWCP-SSD.html"&gt;6. RWCP 実環境音声・音響データベース (RWCP-SSD)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sign アルゴリズムの概観については、以下もどっかで見ておきたい。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/essfr/8/4/8_292/_pdf/-char/ja"&gt;再考・適応アルゴリズム&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;実は自然勾配法による適応アルゴリズムは非線形適応アルゴリズムになってる？&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ykw.elec.keio.ac.jp/yukawa/yukawa_tutorial2014.pdf"&gt;非線形適応信号処理技術の新潮流 ──再生核の応用──&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(17) - 中間発表</title><link href="/yan-jiu-hui-nixiang-kete17-zhong-jian-fa-biao.html" rel="alternate"></link><published>2020-07-20T11:00:00+09:00</published><updated>2020-07-20T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-20:/yan-jiu-hui-nixiang-kete17-zhong-jian-fa-biao.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;資料に追い込みを掛けていたので、あまり進捗なし。発表してもらったコメントで大きそうなの …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;資料に追い込みを掛けていたので、あまり進捗なし。発表してもらったコメントで大きそうなのをメモる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;SA、実はヘブ則そのものでは？&lt;ul&gt;
&lt;li&gt;全くその通り。識別タスクにしたらまんまそれ。NN的に見ると〜はヘブ則と言ってもいいくらい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;グラフは正方形にすべし。&lt;ul&gt;
&lt;li&gt;全くその通り。すぐに修正するべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;尤度は独立な観測では不完全。独立同分布な(i.i.d.)な観測や&lt;/li&gt;
&lt;li&gt;NNGSAの最適化問題による定式化ってリッジ回帰に似てる。対角行列を計量にしてる。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\mathrm{E}\left[ \left\{ \frac{\mathrm{sgn}(\varepsilon[n])}{\sigma} \right\}^{2} \ve{x}[n] \ve{x}[n]^{\mathsf{T}} \right] = \frac{1}{\sigma^{2}} \mathrm{E} \left[ \ve{x}[n] \ve{x}[n]^{\mathsf{T}} \right]\)&lt;/span&gt; はほんまか？a.e.では？近似では？ &lt;span class="math"&gt;\(\mathrm{E}\)&lt;/span&gt; だから厳密？&lt;ul&gt;
&lt;li&gt;やっぱり要審査。自分は期待値操作でルベーグ積分するから、測度0の点は抜いても大丈夫だと思っている。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;厳密にいけそう。&lt;/strong&gt; &lt;span class="math"&gt;\(\mathrm{sgn}(x) := \frac{x}{|x|}\)&lt;/span&gt; と定義すると、 &lt;span class="math"&gt;\((\mathrm{sgn}(x))^{2} = \frac{x^{2}}{|x|^{2}} = 1\)&lt;/span&gt; 。 &lt;span class="math"&gt;\(x=0\)&lt;/span&gt; のときが怪しくなるが、これは、 &lt;span class="math"&gt;\(\mathrm{sgn}(x) \approx \frac{x}{\sqrt{x^{2} + \varepsilon}}\)&lt;/span&gt; としてやって（ &lt;span class="math"&gt;\(\varepsilon \to 0\)&lt;/span&gt; とすれば符号関数に一致）、 &lt;span class="math"&gt;\((\mathrm{sgn}(x))^{2} \approx \frac{x^{2}}{x^{2} + \varepsilon}\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(\varepsilon \to 0\)&lt;/span&gt; としてやれば恒等的に1になる。多分、近似を使ったやり方のほうが &lt;span class="math"&gt;\(x=0\)&lt;/span&gt; でややこしくならないから筋がいい。&lt;/li&gt;
&lt;li&gt;答えとしては、 &lt;span class="math"&gt;\(\mathrm{sgn}(x) := \lim_{\varepsilon \to 0} \frac{x}{\sqrt{x^{2} + \varepsilon}}\)&lt;/span&gt; がいいかも。&lt;/li&gt;
&lt;li&gt;いや、まだ怪しい… &lt;span class="math"&gt;\(\mathrm{sgn}(0) = 0\)&lt;/span&gt; という定義だから、絶対 &lt;span class="math"&gt;\((\mathrm{sgn}(0))^{2} = 0\)&lt;/span&gt; になる。積分を絡めて考えないとだめか。至るところ1なんだけど、1点 &lt;span class="math"&gt;\(x=0\)&lt;/span&gt; において &lt;span class="math"&gt;\(0\)&lt;/span&gt; を取る関数の平均。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;グラフのitaration → iteration&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; の計算について。&lt;ul&gt;
&lt;li&gt;低ランク近似、とくに、 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 重対角行列で近似できん？→確かに。相関行列は端っこに近づくほど0になっていくから、有効かも。&lt;/li&gt;
&lt;li&gt;DFTしてなだらかに変化する要素（つまり低域信号）のパワーは切り捨てる近似がオッケーだったりしないか。→まったくそのとおり、&lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; をDFTすると、ウィーナ・ヒンチンが顔を出しそう。&lt;/li&gt;
&lt;li&gt;スレ―ビングというらしい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;（所感）残差がガウス分布に従うとしたLMS ←ちょっと突然すぎる。&lt;ul&gt;
&lt;li&gt;LMS（残差がガウス分布に従う）は… ←こっちのほうがいい。むしろ、ガウス分布の話はいらない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;損失関数はReLuにしても良いのでは→あり。でもどうなるんだろう。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(16)</title><link href="/yan-jiu-hui-nixiang-kete16.html" rel="alternate"></link><published>2020-07-14T11:00:00+09:00</published><updated>2020-07-14T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-14:/yan-jiu-hui-nixiang-kete16.html</id><summary type="html">&lt;p&gt;引き続き資料を作っている。&lt;/p&gt;
&lt;p&gt;昨日気になっていた&lt;/p&gt;
&lt;blockquote&gt;
NNGSAの収束する最適係数はWienner解で間違いないのか検証する必要あり …&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;引き続き資料を作っている。&lt;/p&gt;
&lt;p&gt;昨日気になっていた&lt;/p&gt;
&lt;blockquote&gt;
NNGSAの収束する最適係数はWienner解で間違いないのか検証する必要あり。&lt;/blockquote&gt;
&lt;p&gt;は並行して確認中。直交原理（勾配が0になる解）を満たす解はWienner解に一致するのか？というところ。
怪しいかもしれない。適応ステップサイズがミソで、最適係数時、そいつを含めて平均をとったときにゼロになるとは思えない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://towardsdatascience.com/natural-gradient-ce454b3dcdfa"&gt;Natural Gradient A better gradient for gradient descent?&lt;/a&gt; 面白そうだけどちとタイミングが悪い。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(15)</title><link href="/yan-jiu-hui-nixiang-kete15.html" rel="alternate"></link><published>2020-07-13T11:00:00+09:00</published><updated>2020-07-13T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-13:/yan-jiu-hui-nixiang-kete15.html</id><content type="html">&lt;p&gt;淡々と資料を作っている。
NNGSAの収束する最適係数はWienner解で間違いないのか検証する必要あり。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(14)</title><link href="/yan-jiu-hui-nixiang-kete14.html" rel="alternate"></link><published>2020-07-12T11:00:00+09:00</published><updated>2020-07-12T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-12:/yan-jiu-hui-nixiang-kete14.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand{\parfrac}[2]{{\frac{\partial #1}{\partial #2}}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;今日から発表資料作る。久々にBeamerでやろうかね。&lt;/p&gt;
&lt;p&gt;資料作ってたら、ラグランジュ未 …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand{\parfrac}[2]{{\frac{\partial #1}{\partial #2}}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;今日から発表資料作る。久々にBeamerでやろうかね。&lt;/p&gt;
&lt;p&gt;資料作ってたら、ラグランジュ未定乗数法による定式化で &lt;span class="math"&gt;\((\ve{h} - \ve{h}^{\prime})^{\mathsf{T}}\ve{R}(\ve{h} - \ve{h}^{\prime})\)&lt;/span&gt; の最小化を考えたけど、これってレイリー商の下限すなわち最小固有値が答えでは。もうちょっと考えたくなってきた。 &lt;span class="math"&gt;\(\mu(n)\)&lt;/span&gt; は垂線の長さに対応するんだっけ？&lt;/p&gt;
&lt;p&gt;アフィン写像アルゴリズムへの拡張は、NLMSの制約を増やしたものに過ぎない。ラグランジュの未定乗数法を使って、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mathcal{L} &amp;amp;= (\ve{h} - \ve{h}^{\prime})^{\mathsf{T}}\ve{R}(\ve{h} - \ve{h}^{\prime}) + (\ve{d} - \ve{A}\ve{h}^{\prime})^{\mathsf{T}} \ve{\lambda} \\
\parfrac{\mathcal{L}}{\ve{h}^{\prime}} &amp;amp;= 2\ve{R}(\ve{h} - \ve{h}^{\prime}) - \parfrac{}{\ve{h}^{\prime}} \ve{h}^{\prime\mathsf{T}} \ve{A}^{\mathsf{T}} \ve{\lambda} \\
&amp;amp;= 2\ve{R}(\ve{h} - \ve{h}^{\prime}) - \ve{A}^{\mathsf{T}} \ve{\lambda} \\
\implies \ve{h}^{\prime} &amp;amp;= \ve{h} + \frac{1}{2} \ve{R}^{-1} \ve{A}^{\mathsf{T}} \ve{\lambda} \\
\implies \ve{\lambda} &amp;amp;= 2 (\ve{A} \ve{R}^{-1} \ve{A}^{\mathsf{T}})\ve{e}
\end{align*}
&lt;/div&gt;
&lt;p&gt;から、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{h}^{\prime} &amp;amp;= \ve{h} + \ve{R}^{-1}\ve{A}^{\mathsf{T}}(\ve{A} \ve{R}^{-1} \ve{A}^{\mathsf{T}})^{-1} \ve{e} \\
&amp;amp;= \ve{h} + \ve{R}^{-1}\ve{A}^{\mathsf{T}}(\ve{A} \ve{R}^{-1} \ve{A}^{\mathsf{T}})^{-1}(\ve{d} - \ve{A} \ve{h}) \\
&amp;amp;= \left\{ \ve{I} - \ve{R}^{-1}\ve{A}^{\mathsf{T}}(\ve{A} \ve{R}^{-1} \ve{A}^{\mathsf{T}})^{-1}\ve{A} \right\} \ve{h} + \ve{R}^{-1}\ve{A}^{\mathsf{T}}(\ve{A} \ve{R}^{-1} \ve{A}^{\mathsf{T}})\ve{d}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\ve{P} = \ve{R}^{-1}\ve{A}^{\mathsf{T}}(\ve{A} \ve{R}^{-1} \ve{A}^{\mathsf{T}})^{-1}\ve{A}\)&lt;/span&gt; とすれば &lt;span class="math"&gt;\(\ve{P}^{2} = \ve{P}\)&lt;/span&gt; だから射影行列になっている。&lt;/p&gt;
&lt;p&gt;アルゴリズムを導いたけどあんまりいい考察は出てこない、というか、煩雑。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(13)</title><link href="/yan-jiu-hui-nixiang-kete13.html" rel="alternate"></link><published>2020-07-11T11:00:00+09:00</published><updated>2020-07-11T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-11:/yan-jiu-hui-nixiang-kete13.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;発表向けの脚本を書いてた。&lt;/p&gt;
&lt;p&gt;正規化アルゴリズムに関して、まだしたりない考察がある。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;射影先の …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;発表向けの脚本を書いてた。&lt;/p&gt;
&lt;p&gt;正規化アルゴリズムに関して、まだしたりない考察がある。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;射影先の超平面の曲率はもしかして &lt;span class="math"&gt;\(\ve{R}\)&lt;/span&gt; だったりしない？漠然とした超平面ではなく、何らかの性質がないか？&lt;ul&gt;
&lt;li&gt;これは、制約が一次式だから絶対に超平面になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;アフィン写像アルゴリズムへ拡張するべきでは？&lt;ul&gt;
&lt;li&gt;やってみた。次の日へどうぞ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(12)</title><link href="/yan-jiu-hui-nixiang-kete12.html" rel="alternate"></link><published>2020-07-10T11:00:00+09:00</published><updated>2020-07-10T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-10:/yan-jiu-hui-nixiang-kete12.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;発表に向けてのプロットに集中したい。また、正規化自然勾配SAが事後残差最小化ではなくラグ …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;発表に向けてのプロットに集中したい。また、正規化自然勾配SAが事後残差最小化ではなくラグランジュから導いて同じ結論が得られるか見たい。（もしかしたら、別の更新式が出る可能性がある）&lt;/p&gt;
&lt;p&gt;ラグランジュの結果、かなり良い解釈が得られた。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(11)</title><link href="/yan-jiu-hui-nixiang-kete11.html" rel="alternate"></link><published>2020-07-09T11:00:00+09:00</published><updated>2020-07-09T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-09:/yan-jiu-hui-nixiang-kete11.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;乗せるデータをまとめる。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;自然勾配SA法の有効性を示す。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;人口データに対する実験: SA(ステップサ …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;乗せるデータをまとめる。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;自然勾配SA法の有効性を示す。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;人口データに対する実験: SA(ステップサイズ=0.005,0.01,0.02)と比較して収束が速いことを示す。しかし係数適応は遅いことは同時に指摘。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;正規化自然勾配SA法の有効性を示す。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;人口データに対する実験: RLS(忘却係数=1,0.9,0.99)と比較。収束は遅い場合があるが、定常誤差は小さく、また係数変更時の適応が早い。忘却係数に依存せず安定した収束性能を示す。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;自然勾配法の有効性を示す。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;実データに対する実験: 音楽の一部データに対する比較。SA, RLS(忘却係数=0.99), 正規化自然勾配SA, 自然勾配SAで比較。&lt;/li&gt;
&lt;li&gt;RMSを比較。RLSとほぼ同等の性能を達成している。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(10)</title><link href="/yan-jiu-hui-nixiang-kete10.html" rel="alternate"></link><published>2020-07-08T11:00:00+09:00</published><updated>2020-07-08T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-08:/yan-jiu-hui-nixiang-kete10.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;今日あたりで目処を…というか、デフォルトの自然勾配法に対する言い訳を考えておきたい。
ガチ …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;今日あたりで目処を…というか、デフォルトの自然勾配法に対する言い訳を考えておきたい。
ガチャガチャいじっていると、LMSに &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を掛けたのも強いということが分かってくる…。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{h}^{\prime} \leftarrow \ve{h} + \mu \ve{R}^{-1} \varepsilon(n) \ve{x}(n)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;何度も見てきた通りだが、上式のステップサイズを（事後誤差最小化基準により）適応化すると正規化版の式に一致する。ちなみに、LMSに対してはフィッシャー情報行列が意味のある統計量に結びつかない。Signアルゴリズムの改良から話を初めて、ステップサイズ適応化してまでたどり着くと、初めてLMS版に対応する式が導かれる。&lt;/p&gt;
&lt;p&gt;確かに上は性能が良いが、裏付けが薄く眉唾の感を逃れられない。疑似自然勾配LMSと名付けて実装しておく。名目としては、正規化の簡略版と見れるはず。収束議論もしておきたい。&lt;/p&gt;
&lt;p&gt;と思ったら、疑似自然勾配LMSは実データですっ飛ぶ傾向あり。誤差が急上昇するところで係数が吹っ飛んでしまう。。トレードオフのようで、誤差の符号をとる（自然勾配SA）は適応が遅すぎて、残差をそのまま使う（疑似自然勾配LMS）は適応が敏感すぎてすっ飛ぶ傾向がある。正規化は本質的な働きをしているように見える。&lt;/p&gt;
&lt;p&gt;まとめようか。
勾配を観察すれば分かることだけど、やっぱり自然勾配SAは勾配が平坦になりすぎるきらいがある。どんなに最適値との差があっても同一の勾配になりやすい。
実データでは十分なサンプルが取れて、しかも特性はのんびり変化するから性能が良くなる。
忘却係数は高く取れば定常誤差を小さくできるが、1.0にすると特性追従が遅くなるので、1にほど近い0.997等に設定する。ステップサイズは実験では1.0等大きめに、実データは0.1等にとる。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(9)</title><link href="/yan-jiu-hui-nixiang-kete9.html" rel="alternate"></link><published>2020-07-07T11:00:00+09:00</published><updated>2020-07-07T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-07:/yan-jiu-hui-nixiang-kete9.html</id><summary type="html">&lt;p&gt;トイデータに対する実験をやっているが、色々と悲しい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;自然勾配SignAlgorithmの性能が悪い。下手するとSignAlgorithmとどっこい&lt;ul&gt;
&lt;li&gt;実データに …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;トイデータに対する実験をやっているが、色々と悲しい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;自然勾配SignAlgorithmの性能が悪い。下手するとSignAlgorithmとどっこい&lt;ul&gt;
&lt;li&gt;実データに対しては良い結果を出していた。&lt;/li&gt;
&lt;li&gt;原因を調べていたら、係数の初期値が最適値の近くにあると収束が早いということが分かった。&lt;/li&gt;
&lt;li&gt;トイデータ実験は[-1,1]から一様乱数選択していたので、それだと広すぎるらしく、収束が遅い。勾配が平坦に広がりすぎている可能性がある。&lt;/li&gt;
&lt;li&gt;忘却係数を低く（ステップサイズを大きく）すると応答は良くなるけどオフセットが残る。&lt;/li&gt;
&lt;li&gt;実データはサンプル数が多いのと、係数が大きな値を取りにくいことから性能が良かったものと想像。&lt;ul&gt;
&lt;li&gt;正規化版は自己相関行列の逆行列の二次形式で割ってるから、自己相関の逆数で割ってる、即ち、自己相関を掛けてると見れる。じゃあ、簡易的に入力データのノルムの平均値を掛けてやればいいんじゃねと思ってやってみたらそれなりに安定してきた。&lt;/li&gt;
&lt;li&gt;眉唾だから再度要検証。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RLSが強すぎる。忘却係数付きRLSが一番強い。&lt;ul&gt;
&lt;li&gt;忘却係数はトレードオフという感じ。0.9まで下げると収束は早いけどオフセットが残る。0.99だと係数が変わったときに収束が遅くなる。1.0（普通のRLS）だと係数が変わったときにまったく収束していかない。&lt;/li&gt;
&lt;li&gt;正規化自然勾配SignAlgorithmは忘却係数の値によらずほぼ同じ学習曲線になる。依存するのはステップサイズくらいか。そこは主張できるかも。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NLMSもMSD（係数誤差）の意味ではRLSと同程度まで下げられているが、正規化自然勾配SignAlgorithmは収束ははやいがそこまで誤差が下がらない。&lt;/li&gt;
&lt;li&gt;実装ミスあり。係数更新がFinvの更新前に行われていた。&lt;ul&gt;
&lt;li&gt;普通の自然勾配法は大きな影響あり。あれ？でも正規化自然勾配の方はあまり影響がない。&lt;/li&gt;
&lt;li&gt;実装ミスなのか微妙。。負荷減らしのための方策だった（フィッシャー情報行列の逆との積を使い回せるから）&lt;/li&gt;
&lt;li&gt;性能差が顕著なのでこれはよく考えたほうが良い。アルゴリズムの整合性的にもあやしい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(8)</title><link href="/yan-jiu-hui-nixiang-kete8.html" rel="alternate"></link><published>2020-07-06T11:00:00+09:00</published><updated>2020-07-06T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-06:/yan-jiu-hui-nixiang-kete8.html</id><summary type="html">&lt;p&gt;昨日の結果を受けて、相関があるガウス雑音信号を実験の対象にしたいと思っている。（なぜなら、現実のデータは相関 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;昨日の結果を受けて、相関があるガウス雑音信号を実験の対象にしたいと思っている。（なぜなら、現実のデータは相関があるから。そして、NLMSは相関のあるデータに弱いから。）いろんな論文で構成法が乗っていたので再調査。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1303.2261.pdf"&gt;l0 Norm Constraint LMS Algorithm for Sparse System Identification&lt;/a&gt; に明確に記述あり。v[t]をi.i.dなガウス雑音として、1次の自己回帰(Auto Regressive)フィルタ x[t] = x[t-1] * 0.8 + v[t] で信号に相関をもたせたあとに、正規化（標準偏差で割る）して分散を1にしている。有色雑音と言っていた。&lt;/p&gt;
&lt;p&gt;また、昨日の夜にモデルに係数を状態として持たせるか考えた。係数が途中で変わるケースの結果が取りにくいので。
でも、扱う側でうまく計算すればできそうなのでやめた。モデル側の実装が複雑になるのは避けたい。&lt;/p&gt;
&lt;p&gt;実験ケースを分類しよう。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;人口データ: 観測雑音: -40dBの白色ガウス雑音、MSD（Mean Square Deviations, 係数2乗誤差）とMSE（Mean Square Error, 二乗誤差）を比較&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;入力: i.i.d.ガウス雑音、係数: 一様乱数で選択&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;主張: NLMSと同程度、RLSは収束が早い&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;入力: 相関のあるi.i.d.ガウス雑音、係数: 一様乱数で選択&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;主張: NLMSよりは早い&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;入力: 相関のあるi.i.d.ガウス雑音、係数: 一様乱数で選択、XXXXサンプル後に係数を一様乱数で変更&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;主張: 係数変更後の適応でRLSより収束が早い&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;実データに対する等価実験: MSEを比較。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;音源は著作権切れデータベースから10秒程度を切り出して使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;この通りにコードをまとめていく。水曜日あたりで結果が出ると◎。
人口データについてはまとまったかな。火曜日で実データ選定と実験をやっていく。&lt;/p&gt;
&lt;p&gt;「信号とシステム」にシステムを等価する際の図が描かれている。ロスレス音声ではどうなっているか、資料作りまでに要観察。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(7)</title><link href="/yan-jiu-hui-nixiang-kete7.html" rel="alternate"></link><published>2020-07-05T11:00:00+09:00</published><updated>2020-07-05T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-05:/yan-jiu-hui-nixiang-kete7.html</id><summary type="html">&lt;p&gt;トイデータ対象の実験スクリプトを作ってた。で、RLSが強いことが分かった。
定常的なガウス雑音（ラプラス雑音でも！）環 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;トイデータ対象の実験スクリプトを作ってた。で、RLSが強いことが分かった。
定常的なガウス雑音（ラプラス雑音でも！）環境下では、指数レートよりも早く最適解に入っていく。
途中で最適係数を変えると収束は他よりも鈍くなる。そこを突くべきか。
（RLSの忘却係数を0.8くらいにしないと同等にならない。）&lt;/p&gt;
&lt;p&gt;また、正規化込みの自然勾配法はNLMSと同程度の収束レートだった。ていうか性能ほぼ同じ。
→入力に強い相関をもたせる（x[t] += x[t-1] * 0.97）とNLMSの性能が大幅悪化することを確認した。
入力に相関がない場合は（自己相関行列が等方的になるので）NLMSと同等になるようだ。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(6)</title><link href="/yan-jiu-hui-nixiang-kete6.html" rel="alternate"></link><published>2020-07-04T11:00:00+09:00</published><updated>2020-07-04T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-04:/yan-jiu-hui-nixiang-kete6.html</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="https://www.cs.tut.fi/~tabus/course/ASP/SGN2206LectureNew5.pdf"&gt;Lecture 5: Variants of the LMS algorithm&lt;/a&gt; を見ていたらNLMSをラグランジュ未定乗数法で求める方法があった。今までは事後残差最小化で見て …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a class="reference external" href="https://www.cs.tut.fi/~tabus/course/ASP/SGN2206LectureNew5.pdf"&gt;Lecture 5: Variants of the LMS algorithm&lt;/a&gt; を見ていたらNLMSをラグランジュ未定乗数法で求める方法があった。今までは事後残差最小化で見ていたけど、これは本質かもしれない。持ち帰って再度計算してみるべきかも。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.cs.tut.fi/~tabus/course/ASP/SGN2206LectureNew4.pdf"&gt;Lecture 4: Stochastic gradient based adaptation: Least Mean Square (LMS) Algorithm&lt;/a&gt; にHeykinの簡易まとめあり。有益。&lt;/p&gt;
&lt;p&gt;t-wadaさんのプレゼンテーションで情熱を持って話しているか？をチェックポイントにしている。 &lt;a class="reference external" href="https://www.slideshare.net/t_wada/the-only-one-big-thing-every-programmer-should-know/51"&gt;ここ&lt;/a&gt; 。 全くそのとおりだと思うので思い出しておく。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(5)</title><link href="/yan-jiu-hui-nixiang-kete5.html" rel="alternate"></link><published>2020-07-03T11:00:00+09:00</published><updated>2020-07-03T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-03:/yan-jiu-hui-nixiang-kete5.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;引き続き周辺を見るが、そろそろRLSとPNLMSの実装に入ろうかな。
トイデータの実験条件も整理した …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\ve[1]{\boldsymbol{#1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;引き続き周辺を見るが、そろそろRLSとPNLMSの実装に入ろうかな。
トイデータの実験条件も整理したい。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1311.6809.pdf"&gt;A Novel Family of Adaptive Filtering Algorithms Based on The Logarithmic Cost&lt;/a&gt; のデータの作り方を参考にしようと思う。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;リファレンス信号 &lt;span class="math"&gt;\(d_{t} = \ve{w}_{0}^{\mathsf{T}} \ve{x}_{t} + n_{t}\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(\ve{w}_{0}\)&lt;/span&gt; はリファレンス係数（論文ではランダム選択にしていた。スパースじゃないならいいかも。）、 &lt;span class="math"&gt;\(\ve{x}_{t}\)&lt;/span&gt; は分散 &lt;span class="math"&gt;\(\sigma_{x}^{2} = 1\)&lt;/span&gt; の i.i.d な平均0ガウス信号系列、 &lt;span class="math"&gt;\(n_{t}\)&lt;/span&gt; はノイズ信号（分散0.01のガウス雑音と分散10000(偏差100)で一定確率(1,2,5%)で発生するインパルス雑音）&lt;ul&gt;
&lt;li&gt;一定確率でインパルス雑音が発生するケースはロバスト性を示すために使われていた。LMSは全く等化できずにいた。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;念の為Simon, Heykinを見てから方針を固める。
5.7節(p285)あたりから実験の記述あり。図5.19(p287)は必要になるはず。しかし、入力はベルヌーイ列、フィルタ係数は偶対称。。。
p297あたりに誤差曲面が書いてあった。遅いケースが有るということを、たしかに自分も確認している。&lt;/p&gt;
&lt;p&gt;RLSを実装し、トイデータ向けの実験フレームワークを作ってしまうべきか。
その後にPNLMSを追加できれば良い。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(4)</title><link href="/yan-jiu-hui-nixiang-kete4.html" rel="alternate"></link><published>2020-07-02T11:00:00+09:00</published><updated>2020-07-02T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-02:/yan-jiu-hui-nixiang-kete4.html</id><summary type="html">&lt;p&gt;外出したのであんまり進捗なし。周辺調査してるけど、よい（コンセンサスのとれた）比較方法ないなあ…
実音声でやるの …&lt;/p&gt;</summary><content type="html">&lt;p&gt;外出したのであんまり進捗なし。周辺調査してるけど、よい（コンセンサスのとれた）比較方法ないなあ…
実音声でやるのは確定として、トイデータはどうしようか。再考・適応アルゴリズムにあるように、完全に人工のインパルス応答（指数敵減衰信号）でもいいかも。係数をスパースにするのが目的ではないし。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(3)</title><link href="/yan-jiu-hui-nixiang-kete3.html" rel="alternate"></link><published>2020-07-01T11:00:00+09:00</published><updated>2020-07-01T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-07-01:/yan-jiu-hui-nixiang-kete3.html</id><summary type="html">&lt;p&gt;今日は予定を立てよう。ちょうど良いタイミングでゼミ発表も入った。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.math.titech.ac.jp/~kawahira/courses.html"&gt;Tomoki Kawahira Courses&lt;/a&gt; 東工大の教授の数学の資料集&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.math.titech.ac.jp/~kawahira/courses/kiso.html"&gt;多様体の …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;今日は予定を立てよう。ちょうど良いタイミングでゼミ発表も入った。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.math.titech.ac.jp/~kawahira/courses.html"&gt;Tomoki Kawahira Courses&lt;/a&gt; 東工大の教授の数学の資料集&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.math.titech.ac.jp/~kawahira/courses/kiso.html"&gt;多様体の基礎のキソ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.math.titech.ac.jp/~kawahira/courses/lebesgue.pdf"&gt;ルベーグ積分の基礎のキソ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;係数をスパースにするLMSって、そういえば更新をたまにしか行わない手法もあったな。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>IGおべんきょ(2)</title><link href="/igobenkiyo2.html" rel="alternate"></link><published>2020-06-30T11:00:00+09:00</published><updated>2020-06-30T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-30:/igobenkiyo2.html</id><summary type="html">&lt;p&gt;学会までには3-4章が手一杯に見える。しっかし先に進みたい。Fisher情報行列の意味付けをしないといかん。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.helsinki.fi/pages/viewpage.action?pageId=59051195"&gt;ヘルシンキ大 …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;学会までには3-4章が手一杯に見える。しっかし先に進みたい。Fisher情報行列の意味付けをしないといかん。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.helsinki.fi/pages/viewpage.action?pageId=59051195"&gt;ヘルシンキ大の幾何学講義ノート？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.helsinki.fi/pages/viewpage.action?pageId=59051195&amp;amp;preview=/59051195/67371372/luku3.pdf"&gt;アフィン接続について&lt;/a&gt;
- p79の座標変換則を満たすことを証明するときの切り口として参考になった&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Information Geometry"></category></entry><entry><title>FCMの係数更新式の導出</title><link href="/fcmnoxi-shu-geng-xin-shi-nodao-chu.html" rel="alternate"></link><published>2020-06-29T17:00:00+09:00</published><updated>2020-06-29T17:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-29:/fcmnoxi-shu-geng-xin-shi-nodao-chu.html</id><summary type="html">&lt;p class="first last"&gt;FCMの係数更新式がすぐ出てこなくてムラムラした。&lt;/p&gt;
</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;FCMの目的関数:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
J = \sum_{i = 1}^{N} \sum_{j = 1}^{c} \mu_{ij}^{m} D_{ij}^{2}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで、 &lt;span class="math"&gt;\(N,c\)&lt;/span&gt; はそれぞれデータ数とクラスタ数、 &lt;span class="math"&gt;\(\mu_{ij}\)&lt;/span&gt; はファジイ係数で &lt;span class="math"&gt;\(i\)&lt;/span&gt; 番目のデータがクラスタ &lt;span class="math"&gt;\(j\)&lt;/span&gt; に持つ重みを示す。 &lt;span class="math"&gt;\(m \in [1, \infty)\)&lt;/span&gt; はファジイ度合いを決める係数で大きく取ればよりファジイ（曖昧さを許す）になる。 &lt;span class="math"&gt;\(m = 1\)&lt;/span&gt; のときはハードなクラスタリングになる（らしい）
。 &lt;span class="math"&gt;\(D_{ij}\)&lt;/span&gt; は &lt;span class="math"&gt;\(i\)&lt;/span&gt; 番目のデータと &lt;span class="math"&gt;\(j\)&lt;/span&gt; 番目のクラスタの中心との距離。&lt;/p&gt;
&lt;p&gt;各データの重みの総和は1になるように制約を課す。式で書くと&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\sum_{j = 1}^{c} \mu_{ij} = 1 \quad i = 1, ..., N
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この制約条件下でのラグランジュ関数（ラグランジアン） &lt;span class="math"&gt;\(L\)&lt;/span&gt; は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
L = \sum_{i = 1}^{N} \sum_{j = 1}^{c} \mu_{ij}^{m} D_{ij}^{2} + \sum_{i = 1}^{N} \lambda_{i} \left[ 1 - \sum_{j = 1}^{c} \mu_{ij} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる。偏微分して0とおき、最適条件を求めることを考える。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\parfrac{L}{\mu_{ij}} &amp;amp;= m \mu_{ij}^{m-1} D_{ij}^{2} - \lambda_{j} = 0 \tag{1} \\
\parfrac{L}{\lambda_{i}} &amp;amp;= 1 - \sum_{j = 1}^{c} \mu_{ij} = 0 \tag{2}
\end{align*}
&lt;/div&gt;
&lt;p&gt;より、まず(1)式から &lt;span class="math"&gt;\(\mu_{ij}\)&lt;/span&gt; について解くと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mu_{ij} = \left( \frac{\lambda_{i}}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}} = \lambda_{i}^{\frac{1}{m-1}} \left( \frac{1}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}} \tag{3}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これを(2)式に代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
1 &amp;amp;= \sum_{j=1}^{c} \mu_{ij} = \sum_{j=1}^{c} \left( \frac{\lambda_{i}}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}} \\
&amp;amp;= \lambda_{i}^{\frac{1}{m-1}} \sum_{j=1}^{c} \left( \frac{1}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}} \\
\implies \lambda_{i}^{\frac{1}{m-1}} &amp;amp;= \frac{1}{\sum_{j=1}^{c} \left( \frac{1}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}}}
\end{align*}
&lt;/div&gt;
&lt;p&gt;これを(3)式に代入すれば、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mu_{ij} &amp;amp;= \lambda_{i}^{\frac{1}{m-1}} \left( \frac{1}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}} = \frac{1}{\sum_{k=1}^{c} \left( \frac{1}{mD_{ik}^{2}} \right)^{\frac{1}{m-1}}} \left( \frac{1}{mD_{ij}^{2}} \right)^{\frac{1}{m-1}} \\
&amp;amp;= \frac{1}{\sum_{k=1}^{c} \left( \frac{1}{mD_{ik}^{2}} \right)^{\frac{1}{m-1}} \left( \frac{1}{mD_{ij}^{2}} \right)^{-\frac{1}{m-1}}} = \frac{1}{\sum_{k=1}^{c} \left( \frac{mD_{ij}^{2}}{mD_{ik}^{2}} \right)^{\frac{1}{m-1}}} \\
&amp;amp;= \frac{1}{\sum_{k=1}^{c} \left( \frac{D_{ij}}{D_{ik}} \right)^{\frac{2}{m-1}}}
\end{align*}
&lt;/div&gt;
&lt;p&gt;最後が気持ちよかった（小並感）&lt;/p&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://fuzzy.cs.ovgu.de/ci/fs/fs_ch09_clustering.pdf"&gt;Fuzzy Systems Fuzzy Clustering 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://homes.di.unimi.it/~valentini/SlideCorsi/Bioinformatica05/Fuzzy-Clustering-lecture-Babuska.pdf"&gt;4 FUZZY CLUSTERING&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="Fuzzy Clustering"></category></entry><entry><title>IGおべんきょ(1)</title><link href="/igobenkiyo1.html" rel="alternate"></link><published>2020-06-24T11:00:00+09:00</published><updated>2020-06-24T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-24:/igobenkiyo1.html</id><content type="html">&lt;p&gt;月内は情報幾何重視で行こう。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.grammarly.com/"&gt;英文校正サービス&lt;/a&gt; よさそう。研究会向け原稿もOverleaf上でやるべく整理するか。&lt;/p&gt;
</content><category term="雑記"></category><category term="Information Geometry"></category></entry><entry><title>研究会に向けて(2)</title><link href="/yan-jiu-hui-nixiang-kete2.html" rel="alternate"></link><published>2020-06-22T11:00:00+09:00</published><updated>2020-06-22T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-22:/yan-jiu-hui-nixiang-kete2.html</id><summary type="html">&lt;p&gt;AdaBoostのリスクがexpなのはリスクの上界を与えているから。また、更新式は学習理論p64など以下で。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.iip.ist.i.kyoto-u.ac.jp/member/keisuke/resources/11adaboost.pdf"&gt;AdaBoost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://cmp.felk.cvut.cz/~sochmj1/adaboost_talk.pdf"&gt;AdaBoost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ysk24ok.github.io/2016/09/27/hajipata-boosting.html"&gt;はじめてのパター …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;AdaBoostのリスクがexpなのはリスクの上界を与えているから。また、更新式は学習理論p64など以下で。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.iip.ist.i.kyoto-u.ac.jp/member/keisuke/resources/11adaboost.pdf"&gt;AdaBoost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://cmp.felk.cvut.cz/~sochmj1/adaboost_talk.pdf"&gt;AdaBoost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ysk24ok.github.io/2016/09/27/hajipata-boosting.html"&gt;はじめてのパターン認識 第11章 boosting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=46B996D5722EB4734D3A7381AFBA95CE?doi=10.1.1.56.9855&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;A decision-theoretic generalication of on-line learning and application to boosting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;情報幾何本読み進め中。
美しい結果（曲線上に平行移動はすごいと思った）が次々出てくるが、リーマン曲率テンソルのテンソル性を示すのに手間取ってる。&lt;/p&gt;
&lt;p&gt;研究会に向けては、実験計画を立てておきたい。
既存研究調査を引き続きやっていき、比較対象の手法をまとめる。また、比較対象手法と、対象のデータを纏めていく。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>研究会に向けて(1)</title><link href="/yan-jiu-hui-nixiang-kete1.html" rel="alternate"></link><published>2020-06-19T11:00:00+09:00</published><updated>2020-06-19T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-19:/yan-jiu-hui-nixiang-kete1.html</id><summary type="html">&lt;p&gt;今週前半は休んでいた。流石にイベント中止が連打されて精神的に余裕がなくなった。
イベントレポートをこっちに …&lt;/p&gt;</summary><content type="html">&lt;p&gt;今週前半は休んでいた。流石にイベント中止が連打されて精神的に余裕がなくなった。
イベントレポートをこっちに移動しようか考えている。&lt;/p&gt;
&lt;p&gt;研究の方は、研究会への申込みに着手した。
正則化はタイムアップ。将来の課題に回す。研究会の準備をしていく。
他にも、事故相関行列の計算高速化が色々試せそう。例えば、クロネッカ積に分解したり。&lt;/p&gt;
</content><category term="雑記"></category><category term="Signed LMS"></category><category term="LMS"></category><category term="Natural Gradient"></category></entry><entry><title>逆写像定理までの整理(3)</title><link href="/ni-xie-xiang-ding-li-madenozheng-li-3.html" rel="alternate"></link><published>2020-06-13T11:00:00+09:00</published><updated>2020-06-13T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-13:/ni-xie-xiang-ding-li-madenozheng-li-3.html</id><content type="html">&lt;p&gt;記事に起こしてたら誤りなども見つかって1週間かかってしまった。。
これでようやく情報幾何学に入門できそう。&lt;/p&gt;
</content><category term="雑記"></category><category term="Manifold"></category></entry><entry><title>逆写像定理までの整理(2)</title><link href="/ni-xie-xiang-ding-li-madenozheng-li-2.html" rel="alternate"></link><published>2020-06-07T11:00:00+09:00</published><updated>2020-06-07T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-07:/ni-xie-xiang-ding-li-madenozheng-li-2.html</id><summary type="html">&lt;p&gt;ついでにラグランジュ未定乗数法とKKT条件まで行ってしまった。欲張った。
予定より断然時間かかってしまったけど …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ついでにラグランジュ未定乗数法とKKT条件まで行ってしまった。欲張った。
予定より断然時間かかってしまったけど、だいたい落ち着いたかも。記事に起こす。&lt;/p&gt;
</content><category term="雑記"></category><category term="Manifold"></category></entry><entry><title>陰関数定理とその応用</title><link href="/yin-guan-shu-ding-li-tosonoying-yong.html" rel="alternate"></link><published>2020-06-05T18:00:00+09:00</published><updated>2020-06-05T18:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-05:/yin-guan-shu-ding-li-tosonoying-yong.html</id><summary type="html">&lt;p class="first last"&gt;陰関数定理の成り立ちとその応用として逆写像定理と制約付き極値問題まで。&lt;/p&gt;
</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\dfrac[2]{\frac{\mathrm{d} #1}{\mathrm{d} #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;逆写像定理をちゃんと振り返ろうとしたら、ついでに色々出てきてまとめる必要があるなと感じた。
記述は笠原皓司「微分積分学」を大幅に参考にしている。&lt;/p&gt;
&lt;div class="contents local topic" id="topic-1"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-2" id="toc-entry-1"&gt;準備&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-3" id="toc-entry-2"&gt;多変数関数の微分と偏微分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-4" id="toc-entry-3"&gt;偏導関数の連続性による微分可能性の条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-5" id="toc-entry-4"&gt;写像の微分と偏微分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-6" id="toc-entry-5"&gt;積分公式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-7" id="toc-entry-6"&gt;連続関数の集合の完備性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-8" id="toc-entry-7"&gt;不動点定理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-9" id="toc-entry-8"&gt;陰関数定理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-10" id="toc-entry-9"&gt;多変数の場合&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-11" id="toc-entry-10"&gt;陰関数定理の応用&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-12" id="toc-entry-11"&gt;逆写像定理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-13" id="toc-entry-12"&gt;多変数の場合&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-14" id="toc-entry-13"&gt;制約付き極値問題&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-15" id="toc-entry-14"&gt;ラグランジュの未定乗数法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#kkt" id="toc-entry-15"&gt;KKT条件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-1"&gt;準備&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-2"&gt;多変数関数の微分と偏微分&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;1変数関数のグラフは一般に曲線で、それに接線が引けるときに関数は微分可能と言った。2変数以上を持つ関数のグラフは一般に曲面になる。この関数が微分可能というときは、接平面が構築できれば良い。これを数学的にもう少し詳しく述べると次のようになる。&lt;/p&gt;
&lt;p&gt;2変数関数 &lt;span class="math"&gt;\(z = f(x, y)\)&lt;/span&gt; のグラフの一点 &lt;span class="math"&gt;\(\ve{x}_{0} = (x_{0}, y_{0})\)&lt;/span&gt; における &lt;span class="math"&gt;\(f({x}_{0}, y_{0})\)&lt;/span&gt; の接平面を考える。今、接平面ができたとしてその方程式を考えると、定数 &lt;span class="math"&gt;\(\alpha, \beta\)&lt;/span&gt; を用いて&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
z - f(x_{0}, y_{0}) = \alpha (x - x_{0}) + \beta (y - y_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表せる。点 &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; とその近傍の点 &lt;span class="math"&gt;\(\ve{x} = (x, y)\)&lt;/span&gt; において、この平面上の &lt;span class="math"&gt;\(z\)&lt;/span&gt; の値と &lt;span class="math"&gt;\(f(x, y)\)&lt;/span&gt; の誤差は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
g(x, y) = f(x, y) - z = f(x, y) - \left\{ f(x_{0}, y_{0}) + \alpha (x - x_{0}) + \beta (y - y_{0}) \right\}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる。接平面であるときには、この誤差 &lt;span class="math"&gt;\(g(x, y)\)&lt;/span&gt; が &lt;span class="math"&gt;\(|\ve{x} - \ve{x}_{0}| = \sqrt{(x - x_{0})^{2} + (y - y_{0})^{2}}\)&lt;/span&gt; に対して無視できる程小さいことが必要である。即ち、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\lim_{\ve{x} \to \ve{x}_{0}} \frac{g(x, y)}{|\ve{x} - \ve{x}_{0}|} = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たせば良い。このとき、 &lt;span class="math"&gt;\(f(x, y)\)&lt;/span&gt; は点 &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; において微分可能という。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;2変数関数の微分&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(z = f(x, y)\)&lt;/span&gt; が点 &lt;span class="math"&gt;\(\ve{x}_{0} = (x_{0}, y_{0})\)&lt;/span&gt; で微分可能とは、ある定数 &lt;span class="math"&gt;\(\alpha, \beta\)&lt;/span&gt; があって&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{cases}
f(x, y) = f(x_{0}, y_{0}) + \alpha (x - x_{0}) + \beta (y - y_{0}) + g(x, y) \\
\displaystyle \lim_{\ve{x} \to \ve{x}_{0}} \frac{g(x, y)}{|\ve{x} - \ve{x}_{0}|} = 0 \quad (\ve{x} \neq \ve{x}_{0})
\end{cases}
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;と表せることである。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;2変数関数の偏導関数&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(f(x, y)\)&lt;/span&gt; が &lt;span class="math"&gt;\(\ve{x}_{0} = (x_{0}, y_{0})\)&lt;/span&gt; で微分可能なら、&lt;span class="math"&gt;\(\alpha, \beta\)&lt;/span&gt; はそれぞれ以下の式で求まる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\alpha = \lim_{x \to x_{0}} \frac{f(x, y_{0}) - f(x_{0}, y_{0})}{x - x_{0}} \\
\beta = \lim_{y \to y_{0}} \frac{f(x_{0}, y) - f(x_{0}, y_{0})}{y - y_{0}}
\end{align*}
&lt;/div&gt;
&lt;p&gt;（証明）&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{cases}
f(x, y) = f(x_{0}, y_{0}) + \alpha (x - x_{0}) + \beta (y - y_{0}) + g(x, y) \\
\displaystyle \lim_{\ve{x} \to \ve{x}_{0}} \frac{g(x, y)}{|\ve{x} - \ve{x}_{0}|} = 0 \quad (\ve{x} \neq \ve{x}_{0})
\end{cases}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;だから、 &lt;span class="math"&gt;\(y = y_{0}\)&lt;/span&gt; とすると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(x, y_{0}) = f(x_{0}, y_{0}) + \alpha (x - x_{0}) + g(x, y_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これは、&lt;span class="math"&gt;\(y = y_{0}\)&lt;/span&gt; と固定したときに、 &lt;span class="math"&gt;\(f(x, y_{0})\)&lt;/span&gt; が &lt;span class="math"&gt;\(x\)&lt;/span&gt; で微分可能であることを示している。また、 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; について解くと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\alpha &amp;amp;= \frac{f(x, y_{0}) - f(x_{0}, y_{0})}{x - x_{0}} + \frac{g(x, y_{0})}{x - x_{0}} \\
\implies \lim_{x \to x_{0}} \alpha &amp;amp;= \alpha = \lim_{x \to x_{0}} \frac{f(x, y_{0}) - f(x_{0}, y_{0})}{x - x_{0}}
\end{align*}
&lt;/div&gt;
&lt;p class="last"&gt;&lt;span class="math"&gt;\(\beta\)&lt;/span&gt; についても同様に &lt;span class="math"&gt;\(x = x_{0}\)&lt;/span&gt; として求められる。（証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;この &lt;span class="math"&gt;\(\alpha, \beta\)&lt;/span&gt; を偏微分係数といい、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\alpha = \parfrac{f}{x}(x_{0}, y_{0}) = f_{x}(x_{0}, y_{0}) \\
\beta = \parfrac{f}{y}(x_{0}, y_{0}) = f_{y}(x_{0}, y_{0})
\end{align*}
&lt;/div&gt;
&lt;p&gt;と書く。2変数以上の場合も全く同様の考えにより微分が定義できる。冗長だが述べると、&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;多変数関数の微分&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(z = f(\ve{x}) = f(x_{1}, ..., x_{n})\)&lt;/span&gt; が点 &lt;span class="math"&gt;\(\ve{x}_{0} = (x_{1}^{0}, ..., x_{n}^{0})\)&lt;/span&gt; で微分可能であるとは、ある定数 &lt;span class="math"&gt;\(\alpha_{1}, ..., \alpha_{n}\)&lt;/span&gt; が存在して、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{cases}
\displaystyle f(\ve{x}) = f(\ve{x}_{0}) + \sum_{i = 1}^{n} \alpha_{i} (x_{i} - x_{i}^{0}) + g(\ve{x}) \\
\displaystyle \lim_{\ve{x} \to \ve{x}_{0}} \frac{g(\ve{x})}{|\ve{x} - \ve{x}_{0}|} = 0 \quad (\ve{x} \neq \ve{x}_{0})
\end{cases}
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;と表せることである。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;多変数関数の偏導関数&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(f(\ve{x})\)&lt;/span&gt; が点 &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で微分可能なら、 &lt;span class="math"&gt;\(\alpha_{i}\ (i = 1,...,n)\)&lt;/span&gt; はそれぞれ以下の式で求められる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\alpha_{i} = \lim_{x_{i} \to x_{i}^{0}} \frac{f(x_{1}^{0}, ..., x_{i}, ..., x_{n}^{0}) - f(\ve{x}_{0})}{x_{i} - x_{i}^{0}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（証明）微分可能性の定義式において &lt;span class="math"&gt;\(x_{j} = x_{j}^{0}\ (j \neq i)\)&lt;/span&gt; とおくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
f(x_{1}^{0}, ..., x_{i}, ..., x_{n}^{0}) &amp;amp;= f(\ve{x}_{0}) + \alpha_{i}(x_{i} - x_{i}^{0}) + g(x_{1}^{0}, ..., x_{i}, ..., x_{n}^{0}) \\
\implies \alpha_{i} &amp;amp;= \frac{f(x_{1}^{0}, ..., x_{i}, ..., x_{n}^{0}) - f(\ve{x}_{0})}{x_{i} - x_{i}^{0}} + \frac{g(x_{1}^{0}, ..., x_{i}, ..., x_{n}^{0})}{x_{i} - x_{i}^{0}} \\
\implies \lim_{x_{i} \to x_{i}^{0}} \alpha_{i} = \alpha_{i} &amp;amp;= \lim_{x_{i} \to x_{i}^{0}} \frac{f(x_{1}^{0}, ..., x_{i}, ..., x_{n}^{0}) - f(\ve{x}_{0})}{x_{i} - x_{i}^{0}}
\end{align*}
&lt;/div&gt;
&lt;p class="last"&gt;（証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;やはり、この &lt;span class="math"&gt;\(\alpha_{i}\ (i = 1,...,n)\)&lt;/span&gt; を偏微分係数と呼び、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\alpha_{i} = \parfrac{f}{x_{i}}(\ve{x}_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と書く。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-3"&gt;偏導関数の連続性による微分可能性の条件&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class="math"&gt;\(f(x, y)\)&lt;/span&gt; が &lt;span class="math"&gt;\(\ve{x}_{0} = (x_{0}, y_{0})\)&lt;/span&gt; において微分可能であれば、 &lt;span class="math"&gt;\(x, y\)&lt;/span&gt; によって偏微分可能であるが、その逆（偏微分可能ならば微分可能）は成り立たない。しかし、以下の定理により、偏導関数に連続性を付与すれば、微分可能であることが示せる。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;偏導関数の連続性による微分可能性の条件&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(f(x, y)\)&lt;/span&gt; が点 &lt;span class="math"&gt;\(\ve{x}_{0} = (x_{0}, y_{0})\)&lt;/span&gt; で偏微分可能であり、かつ、&lt;span class="math"&gt;\(x, y\)&lt;/span&gt; どちらかの偏導関数が &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で連続であるならば、 &lt;span class="math"&gt;\(f(x, y)\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で微分可能である。&lt;/p&gt;
&lt;p&gt;（証明） &lt;span class="math"&gt;\(\parfrac{f}{y}(x,y)\)&lt;/span&gt; が &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; の近傍で存在し、かつ &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で連続と仮定して証明する（ &lt;span class="math"&gt;\(\parfrac{f}{x}\)&lt;/span&gt; が &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で連続としても同様に示せる）。 &lt;span class="math"&gt;\(f\)&lt;/span&gt; は &lt;span class="math"&gt;\(x\)&lt;/span&gt; について偏微分可能だから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\parfrac{f}{x}(x_{0}, y_{0}) &amp;amp;= \frac{f(x, y_{0}) - f(x_{0}, y_{0})}{x - x_{0}} + \frac{g(x)}{x - x_{0}} \\
\implies f(x, y_{0}) &amp;amp;= f(x_{0}, y_{0}) + \parfrac{f}{x}(x_{0}, y_{0})(x - x_{0}) + g(x) \tag{1} \\
\lim_{x \to x_{0}} \frac{g(x)}{x - x_{0}} &amp;amp;= 0
\end{align*}
&lt;/div&gt;
&lt;p&gt;なる &lt;span class="math"&gt;\(g(x)\)&lt;/span&gt; が存在する。一方、 &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; の近傍で &lt;span class="math"&gt;\(f\)&lt;/span&gt; は &lt;span class="math"&gt;\(y\)&lt;/span&gt; について偏微分可能だから、平均（中間）値の定理により、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(x, y) - f(x, y_{0}) = \parfrac{f}{y}(x, \eta)(y - y_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たす &lt;span class="math"&gt;\(\eta\)&lt;/span&gt; が &lt;span class="math"&gt;\(y_{0}\)&lt;/span&gt; と &lt;span class="math"&gt;\(y\)&lt;/span&gt; の間に存在する。上式を(1)に代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
f(x, y) &amp;amp;= f(x_{0}, y_{0}) + \parfrac{f}{x}(x_{0}, y_{0})(x - x_{0}) + \parfrac{f}{y}(x, \eta)(y - y_{0}) + g(x) \\
&amp;amp;= f(x_{0}, y_{0}) + \parfrac{f}{x}(x_{0}, y_{0})(x - x_{0}) + \parfrac{f}{y}(x_{0}, y_{0})(y - y_{0}) + \left\{ \parfrac{f}{y}(x, \eta) - \parfrac{f}{y}(x_{0}, y_{0}) \right\} (y - y_{0}) + g(x) \\
&amp;amp;= f(x_{0}, y_{0}) + \parfrac{f}{x}(x_{0}, y_{0})(x - x_{0}) + \parfrac{f}{y}(x_{0}, y_{0})(y - y_{0}) + h(x, y)
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
h(x, y) = \left\{ \parfrac{f}{y}(x, \eta) - \parfrac{f}{y}(x_{0}, y_{0}) \right\} (y - y_{0}) + g(x)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とおいている。そして &lt;span class="math"&gt;\(h(x, y)\)&lt;/span&gt; は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{h(x, y)}{|\ve{x} - \ve{x}_{0}|} = \left\{ \parfrac{f}{y}(x, \eta) - \parfrac{f}{y}(x_{0}, y_{0}) \right\} \frac{y - y_{0}}{|\ve{x} - \ve{x}_{0}|} + \frac{x - x_{0}}{|\ve{x} - \ve{x}_{0}|} \frac{g(x)}{x - x_{0}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と変形でき、 &lt;span class="math"&gt;\(|\ve{x} - \ve{x}_{0}| = \sqrt{(x - x_{0})^{2} + (y - y_{0})^{2}}\)&lt;/span&gt; より &lt;span class="math"&gt;\(\frac{y - y_{0}}{|\ve{x} - \ve{x}_{0}|} \leq \frac{|y - y_{0}|}{|\ve{x} - \ve{x}_{0}|} \leq 1\)&lt;/span&gt; と &lt;span class="math"&gt;\(\frac{x - x_{0}}{|\ve{x} - \ve{x}_{0}|} \leq \frac{|x - x_{0}|}{|\ve{x} - \ve{x}_{0}|} \leq 1\)&lt;/span&gt; が成り立つ。また、 &lt;span class="math"&gt;\(\ve{x} \to \ve{x}_{0}\)&lt;/span&gt; のとき &lt;span class="math"&gt;\((x, \eta) \to (x_{0}, y_{0})\)&lt;/span&gt; となるが、仮定より &lt;span class="math"&gt;\(\parfrac{f}{y}(x, y)\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で連続だから、 &lt;span class="math"&gt;\(\parfrac{f}{y}(x, \eta) - \parfrac{f}{y}(x_{0}, y_{0}) \to 0\)&lt;/span&gt; となる。従って、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\lim_{\ve{x} \to \ve{x}_{0}} \frac{h(x, y)}{|\ve{x} - \ve{x}_{0}|} = 0
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;これは &lt;span class="math"&gt;\(f(x, y)\)&lt;/span&gt; が &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で微分可能であることを示している。（証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;上記は最も単純な2変数の場合の証明だが、一般の多変数においても同様の定理が成り立つ。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;偏導関数の連続性による微分可能性の条件（多変数）&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(\ve{x} = (x_{1}, ..., x_{p}),\ \ve{y} = (y_{1}, ..., y_{n})\)&lt;/span&gt; とするとき、&lt;span class="math"&gt;\(p + n\)&lt;/span&gt; 変数の関数 &lt;span class="math"&gt;\(f(\ve{X}) = f(\ve{x}, \ve{y}) = f(x_{1}, ..., x_{p}, y_{1}, ..., y_{n})\)&lt;/span&gt; が点 &lt;span class="math"&gt;\(\ve{X}_{0} = (\ve{x}_{0}, \ve{y}_{0}) = (x_{1}^{0}, ..., x_{p}^{0}, y_{1}^{0}, ..., y_{n}^{0})\)&lt;/span&gt; で &lt;span class="math"&gt;\(\ve{x}\)&lt;/span&gt; に関して微分可能であり、かつ &lt;span class="math"&gt;\(\ve{y}\)&lt;/span&gt; に関する偏導関数が &lt;span class="math"&gt;\(\ve{X}_{0}\)&lt;/span&gt; の近傍で存在し、しかも偏導関数が &lt;span class="math"&gt;\(\ve{X}_{0}\)&lt;/span&gt; で連続ならば、 &lt;span class="math"&gt;\(f(\ve{x}, \ve{y})\)&lt;/span&gt; は &lt;span class="math"&gt;\((\ve{x}_{0}, \ve{y}_{0})\)&lt;/span&gt; で微分可能である。&lt;/p&gt;
&lt;p&gt;（証明）2変数の場合とほぼ同様。 &lt;span class="math"&gt;\(f\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{x}\)&lt;/span&gt; について微分可能だから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{cases}
  \displaystyle f(\ve{x}, \ve{y}_{0}) = f(\ve{x}_{0}, \ve{y}_{0}) + \sum_{i = 1}^{p} \parfrac{f}{x_{i}}(\ve{x}_{0}, \ve{y}_{0})(x_{i} - x_{i}^{0}) + g(\ve{x}) \tag{2} \\
  \displaystyle \lim_{\ve{x} \to \ve{x}_{0}} \frac{g(\ve{x})}{|\ve{x} - \ve{x}_{0}|} = 0
\end{cases}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;一方、 &lt;span class="math"&gt;\((\ve{x}_{0}, \ve{y}_{0})\)&lt;/span&gt; において、 &lt;span class="math"&gt;\(f\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{y}\)&lt;/span&gt; について偏微分可能だから、平均値の定理より&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(\ve{x}, \ve{y}) - f(\ve{x}, \ve{y}_{0}) = \sum_{i = 0}^{n} \parfrac{f}{y_{i}} (\ve{x}, \ve{\eta}) (y_{i} - y_{i}^{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たす &lt;span class="math"&gt;\(\ve{\eta}\)&lt;/span&gt; が &lt;span class="math"&gt;\(\ve{y}_{0}\)&lt;/span&gt; と &lt;span class="math"&gt;\(\ve{y}\)&lt;/span&gt; の間に存在する。(2)へ代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
f(\ve{x}, \ve{y}) &amp;amp;= f(\ve{x}_{0}, \ve{y}_{0}) + \sum_{i = 1}^{p} \parfrac{f}{x_{i}}(\ve{x}_{0}, \ve{y}_{0})(x_{i} - x_{i}^{0}) + \sum_{i = 1}^{n} \parfrac{f}{y_{i}}(\ve{x}, \ve{\eta})(y_{i} - y_{i}^{0}) + g(\ve{x}) \\
&amp;amp;= f(\ve{x}_{0}, \ve{y}_{0}) + \sum_{i = 1}^{p} \parfrac{f}{x_{i}}(\ve{x}_{0}, \ve{y}_{0})(x_{i} - x_{i}^{0}) + \sum_{i = 1}^{n} \parfrac{f}{y_{i}}(\ve{x}_{0}, \ve{y}_{0})(y_{i} - y_{i}^{0}) + \sum_{i = 1}^{n} \left\{ \parfrac{f}{y_{i}}(\ve{x}, \ve{\eta}) - \parfrac{f}{y_{i}}(\ve{x}_{0}, \ve{y}_{0}) \right\}(y_{i} - y_{i}^{0}) + g(\ve{x}) \\
&amp;amp;= f(\ve{x}_{0}, \ve{y}_{0}) + \sum_{i = 1}^{p} \parfrac{f}{x_{i}}(\ve{x}_{0}, \ve{y}_{0})(x_{i} - x_{i}^{0}) + \sum_{i = 1}^{n} \parfrac{f}{y_{i}}(\ve{x}_{0}, \ve{y}_{0})(y_{i} - y_{i}^{0}) + h(\ve{x}, \ve{y})
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(h(\ve{x}, \ve{y})\)&lt;/span&gt; を &lt;span class="math"&gt;\(|\ve{X} - \ve{X}_{0}| = \sqrt{ \sum_{i = 1}^{p} (x_{i} - x_{i}^{0})^{2} + \sum_{i = 1}^{n} (y_{i} - y_{i}^{0})^{2} }\)&lt;/span&gt; で割ると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{h(\ve{x}, \ve{y})}{|\ve{X} - \ve{X}_{0}|} = \sum_{i = 1}^{n} \left\{ \parfrac{f}{y_{i}}(\ve{x}, \ve{\eta}) - \parfrac{f}{y_{i}}(\ve{x}_{0}, \ve{y}_{0}) \right\} \frac{y_{i} - y_{i}^{0}}{|\ve{X} - \ve{X}_{0}|} + \frac{|\ve{x} - \ve{x}_{0}|}{|\ve{X} - \ve{X}_{0}|}\frac{g(\ve{x})}{|\ve{x} - \ve{x}_{0}|}
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;となる。やはり &lt;span class="math"&gt;\(\ve{X} \to \ve{X}_{0}\)&lt;/span&gt; のとき &lt;span class="math"&gt;\(\lim_{\ve{X} \to \ve{X}_{0}} \frac{h(\ve{x}, \ve{y})}{|\ve{X} - \ve{X}_{0}|} = 0\)&lt;/span&gt; だから、 &lt;span class="math"&gt;\(f\)&lt;/span&gt; は &lt;span class="math"&gt;\((\ve{x}_{0}, \ve{y}_{0})\)&lt;/span&gt; において微分可能である。（証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-4"&gt;写像の微分と偏微分&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\mathbb{R}^{n}\)&lt;/span&gt; の領域 &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; から &lt;span class="math"&gt;\(\mathbb{R}^{m}\)&lt;/span&gt; への写像 &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; を考える。 &lt;span class="math"&gt;\(\ve{x} = [x_{1}, ..., x_{n}]^{\mathsf{T}} \in \Omega\)&lt;/span&gt; に対して &lt;span class="math"&gt;\(\ve{f}(\ve{x}) = [ f_{1}(\ve{x}), ..., f_{m}(\ve{x}) ]^{\mathsf{T}} \in \mathbb{R}^{m}\)&lt;/span&gt; と書けるから、 &lt;span class="math"&gt;\(f_{1}(\ve{x}), ..., f_{m}(\ve{x})\)&lt;/span&gt; が &lt;span class="math"&gt;\(\ve{x}_{0} = [ x_{1}^{0}, ..., x_{n}^{0} ]^{\mathsf{T}}\)&lt;/span&gt; で連続な時、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left\{ \begin{array}{ll}
\displaystyle f_{1}(\ve{x}) = f_{1}(\ve{x}_{0}) + \sum_{i = 1}^{n} \parfrac{f_{1}}{x_{i}} (x_{i} - x_{i}^{0}) + g_{1}(\ve{x}) &amp;amp; \\
\displaystyle f_{2}(\ve{x}) = f_{2}(\ve{x}_{0}) + \sum_{i = 1}^{n} \parfrac{f_{2}}{x_{i}} (x_{i} - x_{i}^{0}) + g_{2}(\ve{x}) &amp;amp; \\
\vdots &amp;amp; \\
\displaystyle f_{m}(\ve{x}) = f_{m}(\ve{x}_{0}) + \sum_{i = 1}^{n} \parfrac{f_{m}}{x_{i}} (x_{i} - x_{i}^{0}) + g_{m}(\ve{x}) &amp;amp; \\
\displaystyle \lim_{\ve{x} \to \ve{x}_{0}} \frac{g_{i}(\ve{x})}{|\ve{x} - \ve{x}_{0}|} = 0 &amp;amp; (i = 1, ..., m)
\end{array} \right.
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成り立つ。ここで、次の &lt;strong&gt;ヤコビ行列（関数行列）&lt;/strong&gt;&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{M}(\ve{x}_{0}) = \parfrac{\ve{f}}{\ve{x}}(\ve{x}_{0}) =
\left[ \begin{array}{cccc}
\parfrac{f_{1}}{x_{1}}(\ve{x}_{0}) &amp;amp; \parfrac{f_{1}}{x_{2}}(\ve{x}_{0}) &amp;amp; \dots  &amp;amp; \parfrac{f_{1}}{x_{n}}(\ve{x}_{0}) \\
\parfrac{f_{2}}{x_{1}}(\ve{x}_{0}) &amp;amp; \parfrac{f_{2}}{x_{2}}(\ve{x}_{0}) &amp;amp; \dots  &amp;amp; \parfrac{f_{2}}{x_{n}}(\ve{x}_{0}) \\
\vdots                             &amp;amp; \vdots                             &amp;amp; \ddots &amp;amp; \vdots                             \\
\parfrac{f_{m}}{x_{n}}(\ve{x}_{0}) &amp;amp; \parfrac{f_{m}}{x_{n}}(\ve{x}_{0}) &amp;amp; \dots  &amp;amp; \parfrac{f_{m}}{x_{n}}(\ve{x}_{0}) \\
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を使えば、次のようにまとめられる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{cases}
\ve{f}(\ve{x}) = \ve{f}(\ve{x}_{0}) + \ve{M}(\ve{x}_{0}) (\ve{x} - \ve{x}_{0}) + \ve{g}(\ve{x}) \\
\displaystyle \lim_{\ve{x} \to \ve{x}_{0}} \frac{\ve{g}(\ve{x})}{|\ve{x} - \ve{x}_{0}|} = \ve{0}
\end{cases}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで、 &lt;span class="math"&gt;\(\ve{g}(\ve{x}) = [ g_{1}(\ve{x}), ..., g_{m}(\ve{x}) ]^{\mathsf{T}}\)&lt;/span&gt; である。そして行列 &lt;span class="math"&gt;\(\ve{M}(\ve{x}_{0})\)&lt;/span&gt; が存在するとき、写像 &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で微分可能であるという。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;写像の微分可能性の必要十分条件&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;写像 &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; が &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で微分可能であるための必要十分条件は、 &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; の近傍で定義され、かつ &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で連続な関数を要素とする行列 &lt;span class="math"&gt;\(\ve{M}(\ve{x})\)&lt;/span&gt; があって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{f}(\ve{x}) = \ve{f}(\ve{x}_{0}) + \ve{M}(\ve{x})(\ve{x} - \ve{x}_{0}) \tag{3}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たすことである。また、このとき &lt;span class="math"&gt;\(\parfrac{\ve{f}}{\ve{x}}(\ve{x}_{0}) = \ve{M}(\ve{x}_{0})\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;（ &lt;span class="math"&gt;\(\Rightarrow\)&lt;/span&gt; の証明） &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; が &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で微分可能とする。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{f}(\ve{x}) &amp;amp;= \ve{f}(\ve{x}_{0}) + \parfrac{\ve{f}}{\ve{x}}(\ve{x}_{0})(\ve{x} - \ve{x}_{0}) + \ve{g}(\ve{x}) \\
&amp;amp;= \ve{f}(\ve{x}_{0}) + \left\{ \parfrac{\ve{f}}{\ve{x}}(\ve{x}_{0}) + \frac{\ve{g}(\ve{x})}{|\ve{x} - \ve{x}_{0}|^{2}} (\ve{x} - \ve{x}_{0})^{\mathsf{T}} \right\} (\ve{x} - \ve{x}_{0})
\end{align*}
&lt;/div&gt;
&lt;p&gt;の観察から、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{M}(\ve{x}) =
\left\{ \begin{array}{ll}
\parfrac{\ve{f}}{\ve{x}}(\ve{x}_{0}) + \frac{\ve{g}(\ve{x})}{|\ve{x} - \ve{x}_{0}|^{2}} (\ve{x} - \ve{x}_{0})^{\mathsf{T}} &amp;amp; (\ve{x} \neq \ve{x}_{0}) \\
\parfrac{\ve{f}}{\ve{x}}(\ve{x}_{0}) &amp;amp; (\ve{x} = \ve{x}_{0})
\end{array} \right.
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とおけば、この &lt;span class="math"&gt;\(\ve{M}(\ve{x})\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で連続であり、(3) 式が得られることがわかる。（ &lt;span class="math"&gt;\(\Rightarrow\)&lt;/span&gt; の証明終）&lt;/p&gt;
&lt;p&gt;（ &lt;span class="math"&gt;\(\Leftarrow\)&lt;/span&gt; の証明） (3) 式から、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{f}(\ve{x}) &amp;amp;= \ve{f}(\ve{x}_{0}) + \ve{M}(\ve{x})(\ve{x} - \ve{x}_{0}) \\
&amp;amp;= \ve{f}(\ve{x}_{0}) + \ve{M}(\ve{x}_{0})(\ve{x} - \ve{x}_{0}) + \left\{ \ve{M}(\ve{x}) - \ve{M}(\ve{x}_{0}) \right\} (\ve{x} - \ve{x}_{0})
\end{align*}
&lt;/div&gt;
&lt;p&gt;となり、今、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{g}(\ve{x}) = \left\{ \ve{M}(\ve{x}) - \ve{M}(\ve{x}_{0}) \right\} (\ve{x} - \ve{x}_{0})
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;とおくと、 &lt;span class="math"&gt;\(\ve{M}(\ve{x})\)&lt;/span&gt; の &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; における連続性から &lt;span class="math"&gt;\(\frac{|\ve{g}(\ve{x})|}{|\ve{x} - \ve{x}_{0}|} = |\ve{M}(\ve{x}) - \ve{M}(\ve{x}_{0})| \to 0\ (\ve{x} \to \ve{x}_{0})\)&lt;/span&gt; より &lt;span class="math"&gt;\(\lim_{\ve{x} \to \ve{x}_{0}} \frac{\ve{g}(\ve{x})}{|\ve{x} - \ve{x}_{0}|} = \ve{0}\)&lt;/span&gt; が成立する。よって &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; において微分可能。（ &lt;span class="math"&gt;\(\Leftarrow\)&lt;/span&gt; の証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;上記の必要十分条件を用いることで、合成写像に対する微分公式が簡単に得られる。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;合成写像の微分&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(\ve{y} = \ve{f}(\ve{x})\)&lt;/span&gt; は &lt;span class="math"&gt;\(\mathbb{R}^{n}\)&lt;/span&gt; から &lt;span class="math"&gt;\(\mathbb{R}^{m}\)&lt;/span&gt; への写像、 &lt;span class="math"&gt;\(\ve{z} = \ve{g}(\ve{y})\)&lt;/span&gt; は &lt;span class="math"&gt;\(\mathbb{R}^{m}\)&lt;/span&gt; から &lt;span class="math"&gt;\(\mathbb{R}^{l}\)&lt;/span&gt; への写像で、 &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; が &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(\ve{g}\)&lt;/span&gt; が &lt;span class="math"&gt;\(\ve{y}_{0} = \ve{f}(\ve{x}_{0})\)&lt;/span&gt; でそれぞれ微分可能なら、 &lt;span class="math"&gt;\(\ve{g}(\ve{f}(\ve{x}))\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で微分可能で、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{\ve{z}}{\ve{x}}(\ve{x}_{0}) = \parfrac{\ve{z}}{\ve{y}} (\ve{y}_{0}) \parfrac{\ve{y}}{\ve{x}}(\ve{x}_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（証明）&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{cases}
  \ve{f}(\ve{x}) = \ve{f}(\ve{x}_{0}) + \ve{M}(\ve{x})(\ve{x} - \ve{x}_{0}) \\
  \ve{g}(\ve{y}) = \ve{g}(\ve{y}_{0}) + \ve{N}(\ve{y})(\ve{y} - \ve{y}_{0})
\end{cases}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と書けるから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{z} = \ve{g}(\ve{f}(\ve{x})) &amp;amp;= \ve{g}(\ve{f}(\ve{x}_{0}) + \ve{M}(\ve{x})(\ve{x} - \ve{x}_{0})) \\
&amp;amp;= \ve{g}(\ve{y}_{0}) + \ve{N}(\ve{f}(\ve{x})) \left\{ \ve{f}(\ve{x}_{0}) + \ve{M}(\ve{x})(\ve{x} - \ve{x}_{0}) - \ve{y}_{0} \right\} \\
&amp;amp;= \ve{g}(\ve{y}_{0}) + \ve{N}(\ve{f}(\ve{x})) \ve{M}(\ve{x})(\ve{x} - \ve{x}_{0})
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで &lt;span class="math"&gt;\(\ve{N}(\ve{f}(\ve{x}))\ve{M}(\ve{x})\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で連続だから、 &lt;span class="math"&gt;\(\ve{g}(\ve{f}(\ve{x}))\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で微分可能で、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{\ve{z}}{\ve{x}}(\ve{x}_{0}) = \ve{N}(\ve{f}(\ve{x}_{0})) \ve{M}(\ve{x}_{0}) = \parfrac{\ve{z}}{\ve{y}}(\ve{y}_{0}) \parfrac{\ve{y}}{\ve{x}}(\ve{x}_{0})
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;（証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-5"&gt;積分公式&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;平均値の定理を応用した便利な公式。以下の証明で頻繁に使用するため証明を与える。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;積分公式&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; を &lt;span class="math"&gt;\(\mathbb{R}^{n}\)&lt;/span&gt; の領域 &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; から &lt;span class="math"&gt;\(\mathbb{R}^{n}\)&lt;/span&gt; への &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級写像とする。 &lt;span class="math"&gt;\(\ve{x}_{0}, \ve{x} \in \Omega\)&lt;/span&gt; とこの2点を結ぶ線分が &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; に属するとき、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{f}(\ve{x}) - \ve{f}(\ve{x}_{0}) = \left\{ \int_{0}^{1} \parfrac{\ve{f}}{\ve{x}} (\ve{x}_{0} + t (\ve{x} - \ve{x}_{0})) \mathrm{d}t \right\} (\ve{x} - \ve{x}_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで、 &lt;span class="math"&gt;\(\{ \}\)&lt;/span&gt; の中身は &lt;span class="math"&gt;\(n \times n\)&lt;/span&gt; の行列になっていることに注意。&lt;/p&gt;
&lt;p&gt;（証明） &lt;span class="math"&gt;\(\ve{\varphi}(t) = \ve{f}(\ve{x}_{0} + t (\ve{x} - \ve{x}_{0}))\)&lt;/span&gt; とおくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{f}(\ve{x}) - \ve{f}(\ve{x}_{0}) &amp;amp;= \ve{\varphi}(1) - \ve{\varphi}(0) = \int_{0}^{1} \dfrac{\ve{\varphi}(t)}{t} \mathrm{d}t \\
&amp;amp;= \int_{0}^{1} \parfrac{\ve{f}}{\ve{x}} (\ve{x}_{0} + t (\ve{x} - \ve{x}_{0})) \dfrac{}{t} \left\{ \ve{x}_{0} + t (\ve{x} - \ve{x}_{0}) \right\} \mathrm{d}t \quad (\because \text{合成関数の微分}) \\
&amp;amp;= \int_{0}^{1} \parfrac{\ve{f}}{\ve{x}} (\ve{x}_{0} + t (\ve{x} - \ve{x}_{0})) (\ve{x} - \ve{x}_{0}) \mathrm{d}t \\
&amp;amp;= \left\{ \int_{0}^{1} \parfrac{\ve{f}}{\ve{x}} (\ve{x}_{0} + t (\ve{x} - \ve{x}_{0})) \mathrm{d}t \right\} (\ve{x} - \ve{x}_{0})
\end{align*}
&lt;/div&gt;
&lt;p class="last"&gt;（証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-6"&gt;連続関数の集合の完備性&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;かなり基礎的だが、以下の証明に必要なため書く。区間 &lt;span class="math"&gt;\(I\)&lt;/span&gt; で連続な関数の集合を &lt;span class="math"&gt;\(C^{0}(I)\)&lt;/span&gt; と書く。 &lt;span class="math"&gt;\(f \in C^{0}(I)\)&lt;/span&gt; に対して、関数の &amp;quot;大きさ&amp;quot; を次のノルムとして定義する。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;関数のノルム&lt;/dt&gt;
&lt;dd&gt;&lt;span class="math"&gt;\(|| f ||_{0} = \sup_{x \in I} |f(x)|\)&lt;/span&gt; を関数 &lt;span class="math"&gt;\(f\)&lt;/span&gt; のノルムという。&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;ノルムは一般に次の3つの満たしている。&lt;/p&gt;
&lt;ol class="lowerroman simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(|| f ||_{0} \geq 0\)&lt;/span&gt; （等号成立は &lt;span class="math"&gt;\(f(x) = 0\ (x \in I)\)&lt;/span&gt; に限る）&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(|| \lambda f ||_{0} = |\lambda| || f ||_{0}\)&lt;/span&gt; （ &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; は定数）&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(|| f + g ||_{0} \leq || f ||_{0} + || g ||_{0}\)&lt;/span&gt; （ &lt;strong&gt;三角不等式&lt;/strong&gt; と呼ぶ）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;関数のノルムにより、&lt;span class="math"&gt;\(C^{0}(I)\)&lt;/span&gt; 上の関数列 &lt;span class="math"&gt;\(\{ f_{n}(x) \}\)&lt;/span&gt; が &lt;span class="math"&gt;\(I\)&lt;/span&gt; において &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; に一様収束することを&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|| f_{n} - f ||_{0} \to 0 \quad (n \to \infty)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表せる。&lt;/p&gt;
&lt;p&gt;次に、連続関数のノルムについて一様収束列とコーシー列が同値であることを見ていく。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;連続関数の一様収束列とコーシー列&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(C^{0}(I)\)&lt;/span&gt; の関数列 &lt;span class="math"&gt;\(\{ f_{n}(x) \}\)&lt;/span&gt; が一様収束列であるための必要十分条件は、 &lt;span class="math"&gt;\(\{ f_{n}(x) \}\)&lt;/span&gt; がノルムに関してコーシー列であることである。ここで、ノルムに関するコーシー列とは、任意の &lt;span class="math"&gt;\(\varepsilon &amp;gt; 0\)&lt;/span&gt; に対して自然数 &lt;span class="math"&gt;\(N\)&lt;/span&gt; を適当に選べば、 &lt;span class="math"&gt;\(p, q \geq N\)&lt;/span&gt; に対して、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|| f_{p} - f_{q} ||_{0} &amp;lt; \varepsilon
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成立することを言う。&lt;/p&gt;
&lt;p&gt;（ &lt;span class="math"&gt;\(\Rightarrow\)&lt;/span&gt; の証明） &lt;span class="math"&gt;\(\{ f_{n}(x) \}\)&lt;/span&gt; が &lt;span class="math"&gt;\(f \in C^{0}(I)\)&lt;/span&gt; に一様収束すれば、任意の &lt;span class="math"&gt;\(\varepsilon &amp;gt; 0\)&lt;/span&gt; に対して自然数 &lt;span class="math"&gt;\(N\)&lt;/span&gt; を適当に大きく選んで &lt;span class="math"&gt;\(|| f_{n} - f ||_{0} &amp;lt; \varepsilon / 2\ (n \geq N)\)&lt;/span&gt; とできるから、 &lt;span class="math"&gt;\(p, q \geq N\)&lt;/span&gt; なる &lt;span class="math"&gt;\(p, q\)&lt;/span&gt; について&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
|| f_{p} - f_{q} ||_{0} &amp;amp;= || f_{p} - f - ( f_{q} - f ) ||_{0} \\
&amp;amp;\leq || f_{p} - f ||_{0} + || -( f_{q} - f ) ||_{0} \quad (\because \text{三角不等式}) \\
&amp;amp;= || f_{p} - f ||_{0} + || f_{q} - f ||_{0} \\
&amp;amp;&amp;lt; \frac{\varepsilon}{2} + \frac{\varepsilon}{2} = \varepsilon
\end{align*}
&lt;/div&gt;
&lt;p&gt;これは &lt;span class="math"&gt;\(\{ f_{n}(x) \}\)&lt;/span&gt; がコーシー列をなしていることを示している。（ &lt;span class="math"&gt;\(\Rightarrow\)&lt;/span&gt; の証明終）&lt;/p&gt;
&lt;p&gt;（ &lt;span class="math"&gt;\(\Leftarrow\)&lt;/span&gt; の証明） コーシー列は収束列（本稿では省略！！）だから、極限値があり、それを &lt;span class="math"&gt;\(f\)&lt;/span&gt; とおく。任意の &lt;span class="math"&gt;\(\varepsilon &amp;gt; 0\)&lt;/span&gt; に対して、自然数 &lt;span class="math"&gt;\(N\)&lt;/span&gt; を適当に大きく選び、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|f_{p}(x) - f_{q}(x)| \leq || f_{p} - f_{q} ||_{0} &amp;lt; \varepsilon \quad (p,q \geq N, \ x \in I)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とできる。ここで、 &lt;span class="math"&gt;\(q \to \infty\)&lt;/span&gt; とすると、 &lt;span class="math"&gt;\(\lim_{q \to \infty} f_{q}(x) = f(x)\)&lt;/span&gt; だから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|f_{p}(x) - f(x)| \leq || f_{p} - f || &amp;lt; \varepsilon \quad (p \geq N)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる。これは、 &lt;span class="math"&gt;\(\{ f_{n}(x) \}\)&lt;/span&gt; が &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; への一様収束列であることを示している。
最後に &lt;span class="math"&gt;\(f \in C^{0}(I)\)&lt;/span&gt;、即ち &lt;span class="math"&gt;\(f\)&lt;/span&gt; が &lt;span class="math"&gt;\(I\)&lt;/span&gt; で連続であることを示す。任意の点 &lt;span class="math"&gt;\(x_{0} \in I\)&lt;/span&gt; に対して、収束列の元 &lt;span class="math"&gt;\(f_{n}\)&lt;/span&gt; を使うと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
|f(x) - f(x_{0})| &amp;amp;= |f(x) - f_{n}(x) + f_{n}(x) - f_{n}(x_{0}) + f_{n}(x_{0}) - f(x_{0}) | \\
&amp;amp;\leq |f(x) - f_{n}(x)| + |f_{n}(x) - f_{n}(x_{0})| + |f_{n}(x_{0}) - f(x)| \\
&amp;amp;\leq || f_{n} - f ||_{0} + |f_{n}(x) - f_{n}(x_{0})| + || f_{n} - f ||_{0}
\end{align*}
&lt;/div&gt;
&lt;p&gt;まず、 &lt;span class="math"&gt;\(\{ f_{n}(x) \}\)&lt;/span&gt; の一様収束性により、任意の &lt;span class="math"&gt;\(\varepsilon &amp;gt; 0\)&lt;/span&gt; に対して &lt;span class="math"&gt;\(n\)&lt;/span&gt; を十分大きく取れば &lt;span class="math"&gt;\(|| f_{n} - f ||_{0} &amp;lt; \varepsilon / 3\)&lt;/span&gt; とできる。また、 &lt;span class="math"&gt;\(f_{n}\)&lt;/span&gt; は &lt;span class="math"&gt;\(I\)&lt;/span&gt; で連続だから、ある &lt;span class="math"&gt;\(\delta &amp;gt; 0\)&lt;/span&gt; があって &lt;span class="math"&gt;\(|f_{n}(x) - f_{n}(x_{0})| &amp;lt; \varepsilon / 3\ (|x - x_{0}| &amp;lt; \delta)\)&lt;/span&gt; とできる。まとめると、任意の &lt;span class="math"&gt;\(\varepsilon &amp;gt; 0\)&lt;/span&gt; と &lt;span class="math"&gt;\(x_{0} \in I\)&lt;/span&gt; に対して、 ある &lt;span class="math"&gt;\(\delta &amp;gt; 0\)&lt;/span&gt; があって、任意の &lt;span class="math"&gt;\(x \in I\)&lt;/span&gt; で&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|f(x) - f(x_{0})| &amp;lt; \frac{\varepsilon}{3} + \frac{\varepsilon}{3} + \frac{\varepsilon}{3} = \varepsilon \quad (|x - x_{0}| &amp;lt; \delta)
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;が成立している。これは、 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; が &lt;span class="math"&gt;\(I\)&lt;/span&gt; で連続であることを示しており、 &lt;span class="math"&gt;\(f \in C^{0}(I)\)&lt;/span&gt; が言える。（ &lt;span class="math"&gt;\(\Leftarrow\)&lt;/span&gt; の証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;一般に、コーシー列が必ず収束列になるとき、その集合を &lt;strong&gt;完備&lt;/strong&gt; であるという。直感的には、集合上にコーシー列を構成したときに、極限値がその集合から飛び出ることがないことを指す。 &lt;span class="math"&gt;\(C^{0}(I)\)&lt;/span&gt; はノルムに関して完備な集合である。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-7"&gt;不動点定理&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本稿では（「微分積分学」を参考に）陰関数の存在を示すために不動点定理を使用する。本節では不動点定理について説明する。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;縮小写像&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;関数集合 &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; から &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; への写像 &lt;span class="math"&gt;\(\Phi(f)\)&lt;/span&gt; がノルム &lt;span class="math"&gt;\(||f||_{0} = \sup_{\ve{x}} |f(\ve{x})|\)&lt;/span&gt; に関して &lt;strong&gt;縮小写像&lt;/strong&gt; であるとは、ある定数 &lt;span class="math"&gt;\(\rho \in [0, 1)\)&lt;/span&gt; があって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
||\Phi(f) - \Phi(g)||_{0} \leq \rho ||f - g||_{0}
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;が任意の &lt;span class="math"&gt;\(f, g \in \mathcal{F}\)&lt;/span&gt; について成立することを言う。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;縮小写像 &lt;span class="math"&gt;\(\Phi\)&lt;/span&gt; によって写像した関数間の距離は、写像する前よりも小さくなることを言っている。この縮小写像を繰り返し適用することで、ある関数（極限関数）に一様収束するとき、それを不動点という。定理の形で述べると次のようになる。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;不動点定理&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(\Phi(f)\)&lt;/span&gt; を &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; から &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; への縮小写像とし、 &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; は &lt;span class="math"&gt;\(C^{0}(\Omega)\)&lt;/span&gt; （定義域 &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; の &lt;span class="math"&gt;\(C^{0}\)&lt;/span&gt; 級すなわち連続関数の集合）において完備な集合とする。このとき、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f = \Phi(f)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たす関数 &lt;span class="math"&gt;\(f \in \mathcal{F}\)&lt;/span&gt; が唯一つ存在する。この様な &lt;span class="math"&gt;\(f\)&lt;/span&gt; を &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; における &lt;span class="math"&gt;\(\Phi\)&lt;/span&gt; の不動点という。&lt;/p&gt;
&lt;p&gt;（証明） &lt;span class="math"&gt;\(f_{0} \in \mathcal{F}\)&lt;/span&gt; を任意に一つ取って、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f_{n} = \Phi(f_{n-1}) \quad n = 1, 2, ...
\end{equation*}
&lt;/div&gt;
&lt;p&gt;によって関数列 &lt;span class="math"&gt;\(\{ f_{n} \}\)&lt;/span&gt; を作り、これがノルム &lt;span class="math"&gt;\(||\cdot||_{0}\)&lt;/span&gt; に関してコーシー列を作っていることを確かめる。 &lt;span class="math"&gt;\(\Phi\)&lt;/span&gt; は縮小写像だから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
|| f_{n + 1} - f_{n} ||_{0} &amp;amp;= || \Phi(f_{n}) - \Phi(f_{n-1}) ||_{0} \\
&amp;amp;\leq \rho || f_{n} - f_{n-1} ||_{0} = \rho || \Phi(f_{n-1}) - \Phi(f_{n-2}) ||_{0} \\
&amp;amp;\leq \rho^{2} || f_{n-1} - f_{n-2} ||_{0} = \rho^{2} || \Phi(f_{n-2}) - \Phi(f_{n-1}) ||_{0} \\
&amp;amp;\vdots \\
&amp;amp;\leq \rho^{n} || f_{1} - f_{0} ||_{0}
\end{align*}
&lt;/div&gt;
&lt;p&gt;従って、&lt;span class="math"&gt;\(p \leq q\)&lt;/span&gt; を満たす任意の添字について、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
|| f_{p} - f_{q} ||_{0} &amp;amp;= || f_{p} - f_{p+1} + f_{p+1} - f_{p+2} + f_{p+2} + ... + f_{q-1} + f_{q} ||_{0} \\
&amp;amp;\leq || f_{p} - f_{p+1} ||_{0} + || f_{p+1} - f_{p+2} ||_{0} +  ... + || f_{q-1} + f_{q} ||_{0} \quad (\because \text{三角不等式}) \\
&amp;amp;\leq \rho^{p} || f_{1} - f_{0} ||_{0} + \rho^{p+1} || f_{1} - f_{0} ||_{0} + ... + \rho^{q-1} || f_{1} - f_{0} ||_{0} \\
&amp;amp;= \rho^{p}(1 + \rho + ... + \rho^{q-1-p}) || f_{1} - f_{0} ||_{0} \\
&amp;amp;= \frac{\rho^{p}(1 - \rho^{q-1-p})}{1 - \rho} || f_{1} - f_{0} ||_{0} \quad (\because \text{等比級数の和の公式}) \\
&amp;amp;\leq \frac{\rho^{p}}{1 - \rho} || f_{1} - f_{0} ||_{0}
\end{align*}
&lt;/div&gt;
&lt;p&gt;最後の式は &lt;span class="math"&gt;\(p\)&lt;/span&gt; を大きくしていくといくらでも小さくなる。従って、 &lt;span class="math"&gt;\(\{ f_{n} \}\)&lt;/span&gt; はコーシー列である。更に、 &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; は完備な集合だから &lt;span class="math"&gt;\(\{ f_{n} \}\)&lt;/span&gt; は収束列であり、ある &lt;span class="math"&gt;\(f \in \mathcal{F}\)&lt;/span&gt; があって、 &lt;span class="math"&gt;\(f_{n}\)&lt;/span&gt; は 領域 &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; において &lt;span class="math"&gt;\(f\)&lt;/span&gt; に一様収束する（ &lt;span class="math"&gt;\(\because\)&lt;/span&gt; コーシーの収束定理）。
従って、 &lt;span class="math"&gt;\(f_{n} = \Phi(f_{n-1})\)&lt;/span&gt; の &lt;span class="math"&gt;\(n\)&lt;/span&gt; を大きくしていくと、極限において&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f = \Phi(f)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成立する。従って、 &lt;span class="math"&gt;\(f\)&lt;/span&gt; は &lt;span class="math"&gt;\(\Phi\)&lt;/span&gt; の不動点である。
次に唯一性を示す。仮に不動点が2つあったとして、それらを &lt;span class="math"&gt;\(f, g\)&lt;/span&gt; を書くと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|| f - g ||_{0} = || \Phi(f) - \Phi(g) ||_{0} \leq \rho || f - g ||_{0} &amp;lt; || f - g ||_{0}
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;となるが、これは &lt;span class="math"&gt;\(|| f - g ||_{0} &amp;gt; 0\)&lt;/span&gt; である限り &lt;span class="math"&gt;\(|| f - g ||_{0} &amp;lt; || f - g ||_{0}\)&lt;/span&gt; となって矛盾。従って &lt;span class="math"&gt;\(|| f - g ||_{0} = 0\)&lt;/span&gt; でなければならず、これは &lt;span class="math"&gt;\(f\)&lt;/span&gt; と &lt;span class="math"&gt;\(g\)&lt;/span&gt; が同一の不動点であることを意味する。（証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-9"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-8"&gt;陰関数定理&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;まずは2変数 &lt;span class="math"&gt;\(x, y\)&lt;/span&gt; で考えてみる。 &lt;span class="math"&gt;\(x^{2} + y^{2} - 2 = 0\)&lt;/span&gt; のように &lt;span class="math"&gt;\(y = f(x)\)&lt;/span&gt; が陽に分からない場合がある。この2変数関数 &lt;span class="math"&gt;\(F(x, y)\)&lt;/span&gt; による等式 &lt;span class="math"&gt;\(F(x, y) = 0\)&lt;/span&gt; を陰関数表示という。 &lt;span class="math"&gt;\(F(x, y) = 0\)&lt;/span&gt; に対して、何らかの関数 &lt;span class="math"&gt;\(y = f(x)\)&lt;/span&gt; （もしくは &lt;span class="math"&gt;\(x = h(y)\)&lt;/span&gt; ）の存在を保証するのが陰関数定理である。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;陰関数定理（2変数）&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(\mathbb{R}^{2}\)&lt;/span&gt; のある領域（開部分集合） &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; で &lt;span class="math"&gt;\(F(x, y)\)&lt;/span&gt; は連続とし、 &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; の1点 &lt;span class="math"&gt;\((x_{0}, y_{0})\)&lt;/span&gt; の近傍 &lt;span class="math"&gt;\(U\)&lt;/span&gt; で &lt;span class="math"&gt;\(y\)&lt;/span&gt; について偏微分可能かつ &lt;span class="math"&gt;\(F_{y}(x, y) = \parfrac{F}{y}(x, y)\)&lt;/span&gt; は &lt;span class="math"&gt;\(U\)&lt;/span&gt; で連続とする。このとき、次の 1 - 4 が成り立つ。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;もし、 &lt;span class="math"&gt;\(F(x_{0}, y_{0}) = 0,\ F_{y}(x_{0}, y_{0}) \neq 0\)&lt;/span&gt; ならば、 &lt;span class="math"&gt;\((x_{0}, y_{0})\)&lt;/span&gt; の十分小さい近傍 &lt;span class="math"&gt;\(V\)&lt;/span&gt; において&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="math"&gt;
\begin{equation*}
y_{0} = f(x_{0}), \ F(x, f(x)) = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たす連続関数 &lt;span class="math"&gt;\(y = f(x)\ ((x, y) \in V)\)&lt;/span&gt; が唯一つ存在する。（ &lt;span class="math"&gt;\(x\)&lt;/span&gt; と &lt;span class="math"&gt;\(y\)&lt;/span&gt; の関係を入れ替えても成立する。即ち &lt;span class="math"&gt;\(F(x_{0}, y_{0}) = 0,\ F_{x}(x_{0}, y_{0}) \neq 0\)&lt;/span&gt; ならば、 &lt;span class="math"&gt;\((x_{0}, y_{0})\)&lt;/span&gt; の近傍で &lt;span class="math"&gt;\(x_{0} = h(y_{0}), \ F(h(y), y) = 0\)&lt;/span&gt; を満たす連続関数 &lt;span class="math"&gt;\(h\)&lt;/span&gt; が存在する）。&lt;/p&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;1が成り立つとき、 &lt;span class="math"&gt;\(F\)&lt;/span&gt; が &lt;span class="math"&gt;\((x_{0}, y_{0})\)&lt;/span&gt; において &lt;span class="math"&gt;\(x\)&lt;/span&gt; について偏微分可能なら、 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; は &lt;span class="math"&gt;\(x_{0}\)&lt;/span&gt; において微分可能で、&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="math"&gt;
\begin{equation*}
\dfrac{f}{x}(x_{0}) = - \frac{F_{x}(x_{0}, y_{0})}{F_{y}(x_{0}, y_{0})}
\end{equation*}
&lt;/div&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;2が成り立つとき、 &lt;span class="math"&gt;\(F\)&lt;/span&gt; が &lt;span class="math"&gt;\(U\)&lt;/span&gt; 上で &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級なら、 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; も &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級で、&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="math"&gt;
\begin{equation*}
\dfrac{f}{x}(x) = - \frac{F_{x}(x, y)}{F_{y}(x, y)} \quad (x, f(x)) \in V
\end{equation*}
&lt;/div&gt;
&lt;ol class="arabic simple" start="4"&gt;
&lt;li&gt;3が成り立つとき、 &lt;span class="math"&gt;\(F\)&lt;/span&gt; が &lt;span class="math"&gt;\(U\)&lt;/span&gt; 上で &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級なら、 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; も &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1.の証明） &lt;span class="math"&gt;\(x_{0}\)&lt;/span&gt; の近傍 &lt;span class="math"&gt;\(U_{1}\)&lt;/span&gt; と &lt;span class="math"&gt;\(y_{0}\)&lt;/span&gt; の近傍 &lt;span class="math"&gt;\(U_{2}\)&lt;/span&gt; を適当に選んで &lt;span class="math"&gt;\(U_{1} \times U_{2} \subset U\)&lt;/span&gt; となるようにしておく。 &lt;span class="math"&gt;\(M = F_{y}(x_{0}, y_{0})\)&lt;/span&gt; とおく。 &lt;span class="math"&gt;\(F_{y}\)&lt;/span&gt; は仮定より連続だから、 &lt;span class="math"&gt;\(\rho \in (0, 1)\)&lt;/span&gt; なる &lt;span class="math"&gt;\(\rho\)&lt;/span&gt; を1つ取り、これに応じて &lt;span class="math"&gt;\(U_{1}, U_{2}\)&lt;/span&gt; を小さく取り直して&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|M - F_{y}(x, y)| &amp;lt; \rho |M| \quad (x \in U_{1}, y \in U_{2})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とできる。更に、 &lt;span class="math"&gt;\(F\)&lt;/span&gt; は連続だから、 &lt;span class="math"&gt;\(U_{2} = [ y_{0} - \delta, y_{0} + \delta ]\)&lt;/span&gt; と閉区間を取ったとき、 &lt;span class="math"&gt;\(\delta\)&lt;/span&gt; に応じて &lt;span class="math"&gt;\(U_{1}\)&lt;/span&gt; を小さく取り直し、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|F(x, y_{0}) - F(x_{0}, y_{0})| = |F(x, y_{0})| &amp;lt; (1 - \rho)|M|\delta \quad (x \in U_{1})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とできる。次に、関数の集合 &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; として、 &lt;span class="math"&gt;\(U_{1}\)&lt;/span&gt; 上で連続で、 &lt;span class="math"&gt;\(y_{0} = \varphi(x_{0})\)&lt;/span&gt; となり、かつ &lt;span class="math"&gt;\(x \in U_{1}\)&lt;/span&gt; において &lt;span class="math"&gt;\(\varphi(x) \in U_{2}\)&lt;/span&gt; となるような関数 &lt;span class="math"&gt;\(\varphi\)&lt;/span&gt; の全体をとる。 &lt;span class="math"&gt;\(U_{1}\)&lt;/span&gt; 上で連続な関数の集合を &lt;span class="math"&gt;\(C^{0}(U_{1})\)&lt;/span&gt; とかくと、&lt;span class="math"&gt;\(\mathcal{F} \subset C^{0}(U_{1})\)&lt;/span&gt; が成立する。今、写像 &lt;span class="math"&gt;\(\Phi(\varphi)\)&lt;/span&gt; として、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\Phi(\varphi)(x) = \varphi(x) - \frac{1}{M} F(x, \varphi(x))
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とおいた時、これが &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; から &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; への縮小写像であって、かつ &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; が完備であることを示す。まず、 &lt;span class="math"&gt;\(\varphi \in \mathcal{F}\)&lt;/span&gt; を任意に取ったときに、 &lt;span class="math"&gt;\(\Phi(\varphi) \in \mathcal{F}\)&lt;/span&gt; となることを示す。平均値の定理により、 &lt;span class="math"&gt;\(\varphi(x)\)&lt;/span&gt; と &lt;span class="math"&gt;\(y_{0}\)&lt;/span&gt; の間に &lt;span class="math"&gt;\(\xi_{1}(x)\)&lt;/span&gt; を適当に選び、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F(x, \varphi(x)) = F(x, y_{0}) + F_{y}(x, \xi_{1}(x))(\varphi(x) - y_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とできるから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
|\Phi(\varphi)(x) - y_{0}| &amp;amp;= |\varphi(x) - \frac{1}{M}F(x, \varphi(x)) - y_{0}| \\
&amp;amp;= |\varphi(x) - y_{0} - \frac{1}{M}F(x, y_{0}) - \frac{1}{M}F(x, \xi_{1}(x))(\varphi(x) - y_{0})| \\
&amp;amp;= \left| \left\{ \varphi(x) - y_{0} \right\} \left\{ 1 - \frac{1}{M}F(x, \xi_{1}(x)) \right\} - \frac{1}{M}F(x, \varphi(x)) \right| \\
&amp;amp;\leq |\varphi(x) - y_{0}|\left| 1 - \frac{1}{M}F(x, \xi_{1}(x)) \right| + \left| \frac{1}{M}F(x, \varphi(x)) \right| \quad (\because \text{三角不等式}) \\
&amp;amp;&amp;lt; \rho |\varphi(x) - y_{0}| + (1 - \rho)\delta \\
&amp;amp;\leq \rho \delta + (1 - \rho)\delta \quad (\because \varphi(x) \in U_{2} = [y_{0} - \delta, y_{0} + \delta]) \\
&amp;amp;= \delta
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって、 &lt;span class="math"&gt;\(\Phi(\varphi)(x) \in U_{2}\)&lt;/span&gt; だから、 &lt;span class="math"&gt;\(\Phi(\varphi) \in \mathcal{F}\)&lt;/span&gt; 。次に、 &lt;span class="math"&gt;\(\varphi, \psi \in \mathcal{F}\)&lt;/span&gt; をとると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\Phi(\varphi)(x) - \Phi(\psi)(x) &amp;amp;= \varphi(x) - \frac{1}{M} F(x, \varphi(x)) - \left\{ \psi(x) - \frac{1}{M} F(x, \psi(x)) \right\} \\
&amp;amp;= \varphi(x) - \psi(x) - \frac{1}{M} \left\{ F(x, \varphi(x)) - F(x, \psi(x)) \right\}
\end{align*}
&lt;/div&gt;
&lt;p&gt;再び平均値の定理より、 &lt;span class="math"&gt;\(\varphi(x)\)&lt;/span&gt; と &lt;span class="math"&gt;\(\psi(x)\)&lt;/span&gt; の間に &lt;span class="math"&gt;\(\xi_{2}(x)\)&lt;/span&gt; を適当に選び、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F(x, \varphi(x)) = F(x, \psi(x)) + F_{y}(x, \xi_{2}(x))(\varphi(x) - \psi(x))
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とできるから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\Phi(\varphi)(x) - \Phi(\psi)(x) &amp;amp;= \varphi(x) - \psi(x) - \frac{1}{M} \left\{ F_{y}(x, \xi_{2}(x))(\varphi(x) - \psi(x)) \right\} \\
&amp;amp;= \left\{ 1 - \frac{1}{M} F_{y} (x, \xi_{2}(x)) \right\} (\varphi(x) - \psi(x))
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。 &lt;span class="math"&gt;\(\xi_{2}(x) \in U_{2}\)&lt;/span&gt; だから、 &lt;span class="math"&gt;\(|M - F_{y}(x, \xi_{2}(x))| &amp;lt; \rho |M|\)&lt;/span&gt; が成り立ち、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|\Phi(\varphi)(x) - \Phi(\psi)(x)| &amp;lt; \rho |\varphi(x) - \psi(x)| \leq \rho || \varphi - \psi ||_{0}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これが任意の &lt;span class="math"&gt;\(x \in U_{1}\)&lt;/span&gt; で成り立つから、&lt;span class="math"&gt;\(\rho || \varphi - \psi ||_{0}\)&lt;/span&gt; は &lt;span class="math"&gt;\(|\Phi(\varphi)(\ve{x}) - \Phi(\psi)(\ve{x})|\)&lt;/span&gt; の上限を与えており、 &lt;span class="math"&gt;\(|| \Phi(\varphi) - \Phi(\psi) ||_{0} \leq \rho || \varphi - \psi ||_{0}\)&lt;/span&gt; が言える。従って &lt;span class="math"&gt;\(\Phi\)&lt;/span&gt; は縮小写像である。&lt;/p&gt;
&lt;p&gt;次に、 &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; が完備であることを示す。 &lt;span class="math"&gt;\(\mathcal{F} \subset C^{0}(U_{1})\)&lt;/span&gt; で &lt;span class="math"&gt;\(C^{0}(U_{1})\)&lt;/span&gt; は完備だから、 &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; の中のコーシー列は &lt;span class="math"&gt;\(C^{0}(U_{1})\)&lt;/span&gt; の中での収束列である。写像 &lt;span class="math"&gt;\(\Phi\)&lt;/span&gt; による極限関数 &lt;span class="math"&gt;\(f\)&lt;/span&gt; は、 &lt;span class="math"&gt;\(\Phi\)&lt;/span&gt; の作り方により、 &lt;span class="math"&gt;\(U_{1}\)&lt;/span&gt; 上で連続で、 &lt;span class="math"&gt;\(y_{0} = f(x_{0})\)&lt;/span&gt; を満たす。また、各点収束として考えると（コーシー列は一様収束性を述べているので可能）、極限関数 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; は閉区間 &lt;span class="math"&gt;\(U_{2}\)&lt;/span&gt; に属するから、 &lt;span class="math"&gt;\(f \in \mathcal{F}\)&lt;/span&gt; である。即ち &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; は完備。&lt;/p&gt;
&lt;p&gt;以上より不動点定理が使える。即ち、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(x) = \Phi(f)(x) \quad (x \in U_{1})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たす関数が &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; の中に唯一存在する。これは、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\Phi(f)(x) = f(x) - \frac{1}{M} F(x, f(x))
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と合わせると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F(x, f(x)) = 0 \quad (x \in U_{1})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が得られるから、定理1が示された。（1.の証明終）&lt;/p&gt;
&lt;p&gt;（2.の証明） &lt;span class="math"&gt;\(F\)&lt;/span&gt; は &lt;span class="math"&gt;\((x_{0}, y_{0})\)&lt;/span&gt; で偏微分可能で &lt;span class="math"&gt;\(F_{y}(x, y)\)&lt;/span&gt; は &lt;span class="math"&gt;\(U\)&lt;/span&gt; で連続だから、 &lt;span class="math"&gt;\(F(x, y)\)&lt;/span&gt; は全微分可能である（ &lt;span class="math"&gt;\(\because\)&lt;/span&gt; 準備）。従って &lt;span class="math"&gt;\(U\)&lt;/span&gt; において、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F(x, y) = F(x_{0}, y_{0}) + \alpha(x, y)(x - x_{0}) + \beta(x, y)(y - y_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とかける（ &lt;span class="math"&gt;\(\alpha, \beta\)&lt;/span&gt; は &lt;span class="math"&gt;\((x_{0}, y_{0})\)&lt;/span&gt; で連続な関数で、かつ &lt;span class="math"&gt;\(\alpha(x_{0}, y_{0}) = F_{x}(x_{0}, y_{0}), \beta(x_{0},\ y_{0}) = F_{y}(x_{0}, y_{0}) \neq 0\)&lt;/span&gt;）。&lt;span class="math"&gt;\(x \in V\)&lt;/span&gt; に対して &lt;span class="math"&gt;\(y = f(x)\)&lt;/span&gt; を代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
F(x, f(x)) = 0 &amp;amp;= F(x_{0}, f(x_{0})) + \alpha(x, f(x))(x - x_{0}) + \beta(x, f(x))(f(x) - y_{0}) \\
&amp;amp;= \alpha(x, f(x))(x - x_{0}) + \beta(x, f(x))(f(x) - y_{0}) \\
\implies f(x) &amp;amp;= y_{0} - \frac{\alpha(x, f(x))}{\beta(x, f(x))}(x - x_{0})
\end{align*}
&lt;/div&gt;
&lt;p&gt;両辺を &lt;span class="math"&gt;\(x - x_{0}\)&lt;/span&gt; で割ってから &lt;span class="math"&gt;\(x \to x_{0}\)&lt;/span&gt; としてみると、&lt;span class="math"&gt;\(-\alpha(x, f(x)) / \beta(x, f(x))\)&lt;/span&gt; は &lt;span class="math"&gt;\(x_{0}\)&lt;/span&gt; において（連続関数の商になっているので）連続だから極限値をもつ。即ち &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; は &lt;span class="math"&gt;\(x_{0}\)&lt;/span&gt; で微分可能で、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\dfrac{f}{x}(x_{0}) = - \frac{\alpha(x_{0}, f(x_{0}))}{\beta(x_{0}, f(x_{0}))} = - \frac{F_{x}(x_{0}, y_{0})}{F_{y}(x_{0}, y_{0})} \tag{4}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（2.の証明終）&lt;/p&gt;
&lt;p&gt;（3.の証明） &lt;span class="math"&gt;\(F\)&lt;/span&gt; が &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級ならば (4) の右辺は &lt;span class="math"&gt;\((x_{0}, y_{0})\)&lt;/span&gt; で連続だから、 &lt;span class="math"&gt;\(y_{0} = f(x_{0})\)&lt;/span&gt; を代入したものも &lt;span class="math"&gt;\(x_{0}\)&lt;/span&gt; で連続である。即ち、 &lt;span class="math"&gt;\(\dfrac{f}{x}(x)\)&lt;/span&gt; は連続関数（ &lt;span class="math"&gt;\(C^{0}\)&lt;/span&gt; 級）だから、 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; は &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級。（3.の証明終）&lt;/p&gt;
&lt;p&gt;（4.の証明） &lt;span class="math"&gt;\(F\)&lt;/span&gt; が &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級ならば &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; も &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級であることを示す。 &lt;span class="math"&gt;\(m = 1\)&lt;/span&gt; の場合は 3. より成立する。 &lt;span class="math"&gt;\(m - 1\)&lt;/span&gt; の場合に成立すると仮定して、もし、 &lt;span class="math"&gt;\(F\)&lt;/span&gt; が &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級ならば、同時に &lt;span class="math"&gt;\(F\)&lt;/span&gt; は &lt;span class="math"&gt;\(C^{m-1}\)&lt;/span&gt; 級だから、 仮定より &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; も &lt;span class="math"&gt;\(C^{m-1}\)&lt;/span&gt; 級である。従って、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\dfrac{f}{x}(x) = - \frac{F_{x}(x, f(x))}{F_{y}(x, f(x))}
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;の右辺は &lt;span class="math"&gt;\(C^{m-1}\)&lt;/span&gt; 級の関数 &lt;span class="math"&gt;\(F_{x}, F_{y}\)&lt;/span&gt; に &lt;span class="math"&gt;\(C^{m-1}\)&lt;/span&gt; 級の関数 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; を代入したもので、合成関数の微分法から右辺は &lt;span class="math"&gt;\(C^{m-1}\)&lt;/span&gt; 級である。 &lt;span class="math"&gt;\(\dfrac{f}{x}(x)\)&lt;/span&gt; が &lt;span class="math"&gt;\(C^{m-1}\)&lt;/span&gt; 級だから、 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; は &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級。（4.の証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;div class="section" id="section-10"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-9"&gt;多変数の場合&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;3変数 &lt;span class="math"&gt;\(x, y, z\)&lt;/span&gt; による連立陰関数&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{cases}
  F(x, y, z) = 0 \\
  G(x, y, z) = 0
\end{cases}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たす連続関数 &lt;span class="math"&gt;\(y=f(x),\ z = g(x)\)&lt;/span&gt; を求める問題を考える。 &lt;span class="math"&gt;\(F(x_{0}, y_{0}, z_{0}) = 0,\ F_{y}(x_{0}, y_{0}, z_{0}) \neq 0\)&lt;/span&gt; とすると、陰関数定理により、 &lt;span class="math"&gt;\((x_{0}, y_{0}, z_{0})\)&lt;/span&gt; の近傍で &lt;span class="math"&gt;\(y = Y(x, z)\)&lt;/span&gt; という陰関数が存在する。これを &lt;span class="math"&gt;\(G\)&lt;/span&gt; に代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
G(x, Y(x, z), z) = H(x, z) = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となるが、もし、 &lt;span class="math"&gt;\(G(x_{0}, y_{0}, z_{0}) = 0,\ H_{z}(x_{0}, z_{0}) \neq 0\)&lt;/span&gt; ならば、これから &lt;span class="math"&gt;\(z = g(x)\)&lt;/span&gt; という陰関数が存在する。これを &lt;span class="math"&gt;\(y = Y(x, z)\)&lt;/span&gt; に代入して、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
y = f(x) = Y(x, g(x))
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とおけば、2つの陰関数が求められる。今、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
H_{z}(x, z) &amp;amp;= G_{z}(x, Y(x, z), z) \\
&amp;amp;= \parfrac{G}{z} + \parfrac{G}{y} \dfrac{Y}{z} \quad (\because \text{合成関数の微分}) \\
&amp;amp;= G_{z} - G_{y}\frac{F_{z}}{F_{y}} \quad (\because \text{陰関数定理}) \\
&amp;amp;= \frac{1}{F_{y}} \det
\left[
\begin{array}{cc}
  F_{y} &amp;amp; F_{z} \\
  G_{y} &amp;amp; G_{z}
\end{array}
\right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;だから、 &lt;span class="math"&gt;\(H_{z}(x_{0}, z_{0}) \neq 0\)&lt;/span&gt; は、行列&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{F}{\ve{y}} =
\left[
\begin{array}{cc}
  F_{y} &amp;amp; F_{z} \\
  G_{y} &amp;amp; G_{z}
\end{array}
\right]
\quad
\left(
\ve{F} =
\left[
\begin{array}{c}
F \\
G
\end{array}
\right],\
\ve{y} =
\left[
\begin{array}{c}
y \\
z
\end{array}
\right]
\right)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が &lt;span class="math"&gt;\((x_{0}, y_{0}, z_{0})\)&lt;/span&gt; で正則という条件と同値になる。従って、&lt;span class="math"&gt;\(\parfrac{F}{\ve{y}}\)&lt;/span&gt; が正則であれば陰関数を持つことが分かる（ &lt;span class="math"&gt;\(\parfrac{F}{\ve{y}}\)&lt;/span&gt; が正則ならば、 &lt;span class="math"&gt;\(F_{y}, F_{z}\)&lt;/span&gt; のいずれかは &lt;span class="math"&gt;\(0\)&lt;/span&gt; ではないから、 &lt;span class="math"&gt;\(F_{y}(x_{0}, y_{0}, z_{0}) \neq 0\)&lt;/span&gt; という条件をおいても良い）。これを一般化した定理を以下に示す。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;陰関数定理（多変数）&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(\mathbb{R}^{p} \times \mathbb{R}^{n}\)&lt;/span&gt; の領域 &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 次元写像&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{F}(\ve{x}, \ve{y}) =
\left[ \begin{array}{c}
F_{1}(x_{1}, ..., x_{p}, y_{1}, ..., y_{n}) \\
F_{2}(x_{1}, ..., x_{p}, y_{1}, ..., y_{n}) \\
\vdots \\
F_{n}(x_{1}, ..., x_{p}, y_{1}, ..., y_{n})
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;は連続として、1点 &lt;span class="math"&gt;\((\ve{x}_{0}, \ve{y}_{0})^{\mathsf{T}} = (x_{1}^{0}, ..., x_{p}^{0}, y_{1}^{0}, ..., y_{n}^{0})^{\mathsf{T}}\)&lt;/span&gt; の近傍 &lt;span class="math"&gt;\(U\)&lt;/span&gt; でサイズ &lt;span class="math"&gt;\(n \times n\)&lt;/span&gt; の正方行列関数&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{\ve{F}}{\ve{y}}(\ve{x}, \ve{y}) =
\left[ \begin{array}{cccc}
\parfrac{F_{1}}{y_{1}} &amp;amp; \parfrac{F_{1}}{y_{2}} &amp;amp;  \dots &amp;amp; \parfrac{F_{1}}{y_{n}} \\
\parfrac{F_{2}}{y_{1}} &amp;amp; \parfrac{F_{2}}{y_{2}} &amp;amp;  \dots &amp;amp; \parfrac{F_{2}}{y_{n}} \\
\vdots                 &amp;amp; \vdots                 &amp;amp; \ddots &amp;amp; \vdots                 \\
\parfrac{F_{n}}{y_{1}} &amp;amp; \parfrac{F_{n}}{y_{2}} &amp;amp;  \dots &amp;amp; \parfrac{F_{n}}{y_{n}}
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;は連続な正則行列とする。とのとき、次の 1 - 4 が成り立つ。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;もし &lt;span class="math"&gt;\(\ve{F}(\ve{x}_{0}, \ve{y}_{0}) = \ve{0}\)&lt;/span&gt; ならば、 &lt;span class="math"&gt;\((\ve{x}_{0}, \ve{y}_{0})\)&lt;/span&gt; の十分小さい近傍 &lt;span class="math"&gt;\(V\)&lt;/span&gt; があって&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{y}_{0} = \ve{f}(\ve{x}_{0}), \ \ve{F}(\ve{x}, \ve{f}(\ve{x})) = \ve{0} \quad (\ve{x}, \ve{f}(\ve{x})) \in V
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たす &lt;span class="math"&gt;\(n\)&lt;/span&gt; 次元ベクトル値連続関数 &lt;span class="math"&gt;\(\ve{f}(\ve{x})\)&lt;/span&gt; が唯一存在する。&lt;/p&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;1が成り立つとき、 &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; が &lt;span class="math"&gt;\((\ve{x}_{0}, \ve{y}_{0})\)&lt;/span&gt; において &lt;span class="math"&gt;\(\ve{x}\)&lt;/span&gt; について微分可能なら、 &lt;span class="math"&gt;\(\ve{f}(\ve{x})\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; において微分可能で、&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{\ve{f}}{\ve{x}}(\ve{x}_{0}) = - \left[ \parfrac{\ve{F}}{\ve{y}}(\ve{x}_{0}, \ve{y}_{0}) \right]^{-1} \parfrac{\ve{F}}{\ve{x}}(\ve{x}_{0}, \ve{y}_{0})
\end{equation*}
&lt;/div&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;2が成り立つとき、 &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; が &lt;span class="math"&gt;\(U\)&lt;/span&gt; 上で &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級なら、 &lt;span class="math"&gt;\(\ve{f}(\ve{x})\)&lt;/span&gt; も &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級で、&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{\ve{f}}{\ve{x}}(\ve{x}) = - \left[ \parfrac{\ve{F}}{\ve{y}}(\ve{x}, \ve{y}) \right]^{-1} \parfrac{\ve{F}}{\ve{x}}(\ve{x}, \ve{y})
\end{equation*}
&lt;/div&gt;
&lt;ol class="arabic simple" start="4"&gt;
&lt;li&gt;3が成り立つとき、 &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; が &lt;span class="math"&gt;\(U\)&lt;/span&gt; 上で &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級なら、 &lt;span class="math"&gt;\(\ve{f}(\ve{x})\)&lt;/span&gt; も &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級である。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;証明については2変数と同様に考える。&lt;/p&gt;
&lt;p&gt;（1.の証明） &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; の近傍 &lt;span class="math"&gt;\(U_{1}\)&lt;/span&gt; と &lt;span class="math"&gt;\(\ve{y}_{0}\)&lt;/span&gt; の近傍 &lt;span class="math"&gt;\(U_{2}\)&lt;/span&gt; を適当に選んで &lt;span class="math"&gt;\(U_{1} \times U_{2} \subset U\)&lt;/span&gt; となるようにしておく。次に、行列 &lt;span class="math"&gt;\(\ve{M}\)&lt;/span&gt; として&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{M} = \parfrac{\ve{F}}{\ve{y}}(\ve{x}_{0}, \ve{y}_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とおく。 &lt;span class="math"&gt;\(\ve{M}\)&lt;/span&gt; は仮定より正則行列である。 &lt;span class="math"&gt;\(\rho \in (0, 1)\)&lt;/span&gt; なる &lt;span class="math"&gt;\(\rho\)&lt;/span&gt; を1つ取り、これに応じて &lt;span class="math"&gt;\(U_{1}, U_{2}\)&lt;/span&gt; を小さく取り直して&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left| \ve{M} - \parfrac{\ve{F}}{\ve{y}}(\ve{x}, \ve{y}) \right| &amp;lt; \frac{\rho}{|\ve{M}^{-1}|} \quad (\ve{x}, \ve{y}) \in U_{1} \times U_{2}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる様にしておく（ &lt;span class="math"&gt;\(|\ve{M}| = \sup_{|\ve{x}| = 1} |\ve{M}\ve{x}|\)&lt;/span&gt; : 行列ノルム）。 &lt;span class="math"&gt;\(U_{2}\)&lt;/span&gt; は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
U_{2} = \left\{ \ve{y} | |\ve{y} - \ve{y}_{0}| \leq \delta \right\}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と閉集合にとり、この &lt;span class="math"&gt;\(\delta\)&lt;/span&gt; に応じて &lt;span class="math"&gt;\(U_{1}\)&lt;/span&gt; を更に小さく取り直し、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|\ve{F}(\ve{x}, \ve{y}_{0})| &amp;lt; (1 - \rho)\frac{\delta}{|\ve{M}^{-1}|} \quad \ve{x} \in U_{1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成り立つようにしておく（これは、&lt;span class="math"&gt;\(\ve{F}(\ve{x}_{0}, \ve{y}_{0}) = \ve{0}\)&lt;/span&gt; かつ &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; の連続性により可能）。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\ve{x}\)&lt;/span&gt; の関数の集合 &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; として、 &lt;span class="math"&gt;\(U_{1}\)&lt;/span&gt; 上で連続で、 &lt;span class="math"&gt;\(\ve{y}_{0} = \ve{\varphi}(\ve{x}_{0})\)&lt;/span&gt; となり、かつ、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{\varphi}(\ve{x}) \in U_{2} \quad \ve{x} \in U_{1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となるような写像 &lt;span class="math"&gt;\(\ve{\varphi}(\ve{x})\)&lt;/span&gt; の全体をとる。そして写像 &lt;span class="math"&gt;\(\ve{\Phi}(\ve{\varphi})\)&lt;/span&gt; として、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{\Phi}(\ve{\varphi})(\ve{x}) = \ve{\varphi}(\ve{x}) - \ve{M}^{-1} \ve{F}(\ve{x}, \ve{\varphi}(\ve{x}))
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とおく。上で述べた積分公式より、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{F}(\ve{x}, \ve{\varphi}(\ve{x})) = \ve{F}(\ve{x}, \ve{y}_{0}) + \int_{0}^{1} \parfrac{\ve{F}}{\ve{y}} (\ve{x}, \ve{y}_{0} + t (\ve{\varphi}(\ve{x}) - \ve{y}_{0})) \mathrm{d} t (\ve{\varphi}(\ve{x}) - \ve{y}_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;だから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{\Phi}(\ve{\varphi})(\ve{x}) - \ve{y}_{0} &amp;amp;= \ve{\varphi}(\ve{x}) - \ve{y}_{0} - \ve{M}^{-1} \ve{F}(\ve{x}, \ve{\varphi}(\ve{x})) \\
&amp;amp;= \ve{\varphi}(\ve{x}) - \ve{y}_{0} - \ve{M}^{-1} \ve{F}(\ve{x}, \ve{y}_{0}) - \ve{M}^{-1} \int_{0}^{1} \parfrac{\ve{F}}{\ve{y}} (\ve{x}, \ve{y}_{0} + t (\ve{\varphi}(\ve{x}) - \ve{y}_{0})) \mathrm{d} t (\ve{\varphi}(\ve{x}) - \ve{y}_{0}) \\
&amp;amp;= \left\{ \ve{I} - \ve{M}^{-1} \int_{0}^{1} \parfrac{\ve{F}}{\ve{y}} (\ve{x}, \ve{y}_{0} + t (\ve{\varphi}(\ve{x}) - \ve{y}_{0})) \mathrm{d} t \right\} \left\{ \ve{\varphi}(\ve{x}) - \ve{y}_{0} \right\} - \ve{M}^{-1}\ve{F}(\ve{x}, \ve{y}_{0}) \\
\implies |\ve{\Phi}(\ve{\varphi})(\ve{x}) - \ve{y}_{0}| &amp;amp;\leq \left| \ve{I} - \ve{M}^{-1} \int_{0}^{1} \parfrac{\ve{F}}{\ve{y}} (\ve{x}, \ve{y}_{0} + t (\ve{\varphi}(\ve{x}) - \ve{y}_{0})) \mathrm{d} t \right||\ve{\varphi}(\ve{x}) - \ve{y}_{0}| + |\ve{M}^{-1}\ve{F}(\ve{x}, \ve{y}_{0})|
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。ここで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\left| \ve{I} - \ve{M}^{-1} \int_{0}^{1} \parfrac{\ve{F}}{\ve{y}} \mathrm{d} t \right| &amp;amp;= \left| \ve{M}^{-1}\left( \ve{M} - \int_{0}^{1} \parfrac{\ve{F}}{\ve{y}} \mathrm{d} t \right) \right| \\
&amp;amp;\leq |\ve{M}^{-1}| \int_{0}^{1} \left| \ve{M} - \parfrac{\ve{F}}{\ve{y}} \right| \mathrm{d} t \\
&amp;amp;&amp;lt; |\ve{M}^{-1}| \int_{0}^{1} \frac{\rho}{|\ve{M}^{-1}|} \mathrm{d} t = \rho
\end{align*}
&lt;/div&gt;
&lt;p&gt;が成り立つ。更に、 &lt;span class="math"&gt;\(\ve{\varphi}(\ve{x}) \in U_{2}\)&lt;/span&gt; より、 &lt;span class="math"&gt;\(|\ve{\varphi}(\ve{x}) - \ve{y}_{0}| \leq \delta\)&lt;/span&gt; 。しかも、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|\ve{M}^{-1}\ve{F}(\ve{x}, \ve{y}_{0})| \leq |\ve{M}^{-1}||\ve{F}(\ve{x}, \ve{y}_{0})| &amp;lt; (1 - \rho) \delta
\end{equation*}
&lt;/div&gt;
&lt;p&gt;だから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|\ve{\Phi}(\ve{\varphi})(\ve{x}) - \ve{y}_{0}| &amp;lt; \rho \delta + (1 - \rho) \delta = \delta
\end{equation*}
&lt;/div&gt;
&lt;p&gt;従って &lt;span class="math"&gt;\(\ve{\Phi}(\ve{\varphi}) \in \mathcal{F}\)&lt;/span&gt; である。&lt;/p&gt;
&lt;p&gt;次に、 &lt;span class="math"&gt;\(\ve{\varphi}, \ve{\psi} \in \mathcal{F}\)&lt;/span&gt; に対し、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{\Phi}(\ve{\varphi})(\ve{x}) - \ve{\Phi}(\ve{\psi})(\ve{x}) = \ve{\varphi}(\ve{x}) - \ve{\psi}(\ve{x}) - \ve{M}^{-1} ( \ve{F}(\ve{x}, \ve{\varphi}(\ve{x})) - \ve{F}(\ve{x}, \ve{\psi}(\ve{x})) )
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成立するが、ここで積分公式&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{F}(\ve{x}, \ve{\varphi}(\ve{x})) - \ve{F}(\ve{x}, \ve{\psi}(\ve{x})) = \int_{0}^{1} \parfrac{\ve{F}}{\ve{y}} (\ve{x}, \ve{y}_{0} + t (\ve{\varphi}(\ve{x}) - \ve{\psi}(\ve{x}))) \mathrm{d} t (\ve{\varphi}(\ve{x}) - \ve{\psi}(\ve{x}))
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を用いると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{\Phi}(\ve{\varphi})(\ve{x}) - \ve{\Phi}(\ve{\psi})(\ve{x}) &amp;amp;= \ve{\varphi}(\ve{x}) - \ve{\psi}(\ve{x}) - \ve{M}^{-1} \int_{0}^{1} \parfrac{\ve{F}}{\ve{y}} (\ve{x}, \ve{\varphi}(\ve{x}) + t (\ve{\varphi}(\ve{x}) - \ve{\psi}(\ve{x}))) \mathrm{d} t (\ve{\varphi}(\ve{x}) - \ve{\psi}(\ve{x})) \\
&amp;amp;= \left\{ \ve{I} - \ve{M}^{-1} \int_{0}^{1} \parfrac{\ve{F}}{\ve{y}} (\ve{x}, \ve{\varphi}(\ve{x}) + t (\ve{\varphi}(\ve{x}) - \ve{\psi}(\ve{x}))) \mathrm{d} t \right\} (\ve{\varphi}(\ve{x}) - \ve{\psi}(\ve{x})) \\
\implies |\ve{\Phi}(\ve{\varphi})(\ve{x}) - \ve{\Phi}(\ve{\psi})(\ve{x})| &amp;amp;= \left| \ve{I} - \ve{M}^{-1} \int_{0}^{1} \parfrac{\ve{F}}{\ve{y}} (\ve{x}, \ve{\varphi}(\ve{x}) + t (\ve{\varphi}(\ve{x}) - \ve{\psi}(\ve{x}))) \mathrm{d} t \right| |\ve{\varphi}(\ve{x}) - \ve{\psi}(\ve{x})| \\
&amp;amp;&amp;lt; \rho |\ve{\varphi}(\ve{x}) - \ve{\psi}(\ve{x})| \leq \rho ||\ve{\varphi}(\ve{x}) - \ve{\psi}(\ve{x})||_{0}
\end{align*}
&lt;/div&gt;
&lt;p&gt;が任意の &lt;span class="math"&gt;\(\ve{x} \in U_{1}\)&lt;/span&gt; で成り立つから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
||\ve{\Phi}(\ve{\varphi})(\ve{x}) - \ve{\Phi}(\ve{\psi})(\ve{x})||_{0} \leq \rho ||\ve{\varphi}(\ve{x}) - \ve{\psi}(\ve{x})||_{0}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;よって &lt;span class="math"&gt;\(\ve{\Phi}\)&lt;/span&gt; は縮小写像。&lt;/p&gt;
&lt;p&gt;次に &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; が完備であることを示す。まず、 &lt;span class="math"&gt;\(\mathcal{F} \subset C^{0}(U_{1})\)&lt;/span&gt; で &lt;span class="math"&gt;\(C^{0}(U_{1})\)&lt;/span&gt; は完備だから、 &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; の中で作ったコーシー列は &lt;span class="math"&gt;\(C^{0}(U_{1})\)&lt;/span&gt; の中で収束列となる。極限関数 &lt;span class="math"&gt;\(\ve{f} = \lim_{n \to \infty} \ve{\Phi}(\ve{f}_{n})\)&lt;/span&gt; が &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; に属することを示す。 &lt;span class="math"&gt;\(\ve{\Phi}\)&lt;/span&gt; の定義より、 &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; は &lt;span class="math"&gt;\(U_{1}\)&lt;/span&gt; 上で連続で、 &lt;span class="math"&gt;\(\ve{y}_{0} = \ve{f}(\ve{x}_{0})\)&lt;/span&gt; を満たす。各点収束としてみると、 &lt;span class="math"&gt;\(\ve{f}(\ve{x})\)&lt;/span&gt; は 区間 &lt;span class="math"&gt;\(U_{1}\)&lt;/span&gt; で閉区間 &lt;span class="math"&gt;\(U_{2}\)&lt;/span&gt; に属するから、 &lt;span class="math"&gt;\(\ve{f} \in \mathcal{F}\)&lt;/span&gt; である。即ち &lt;span class="math"&gt;\(\mathcal{F}\)&lt;/span&gt; は完備。&lt;/p&gt;
&lt;p&gt;不動点定理により、 &lt;span class="math"&gt;\(\ve{f}(\ve{x}) = \ve{\Phi}(\ve{f})(\ve{x})\)&lt;/span&gt; を満たす &lt;span class="math"&gt;\(\ve{f}(\ve{x}) \in \mathcal{F}\)&lt;/span&gt; が唯一存在する。この写像 &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{f}(\ve{x}) = \ve{\Phi}(\ve{f})(\ve{x}) = \ve{f}(\ve{x}) - \ve{M}^{-1}\ve{F}(\ve{x}, \ve{f}(\ve{x}))\)&lt;/span&gt; を満たすので、&lt;span class="math"&gt;\(\ve{F}(\ve{x}, \ve{f}(\ve{x})) = \ve{0}\)&lt;/span&gt; が成り立っている。（1. の証明終）&lt;/p&gt;
&lt;p&gt;（2.の証明） &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; は &lt;span class="math"&gt;\((\ve{x}_{0}, \ve{y}_{0})\)&lt;/span&gt; で偏微分可能で、しかも連続だから微分可能で（ &lt;span class="math"&gt;\(\because\)&lt;/span&gt; 上述）であり、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{F}(\ve{x}, \ve{y}) = \ve{F}(\ve{x}_{0}, \ve{y}_{0}) + \ve{A}(\ve{x}, \ve{y})(\ve{x} - \ve{x}_{0}) + \ve{B}(\ve{x}, \ve{y})(\ve{y} - \ve{y}_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と書ける（ &lt;span class="math"&gt;\(\ve{A}, \ve{B}\)&lt;/span&gt; は &lt;span class="math"&gt;\((\ve{x}_{0}, \ve{y}_{0})\)&lt;/span&gt; で連続な行列関数で、 &lt;span class="math"&gt;\(\ve{A}(\ve{x}_{0}, \ve{y}_{0}) = \parfrac{\ve{F}}{\ve{x}}(\ve{x}_{0}, \ve{y}_{0}),\ \ve{B}(\ve{x}_{0}, \ve{y}_{0}) = \parfrac{\ve{F}}{\ve{y}}(\ve{x}_{0}, \ve{y}_{0})\)&lt;/span&gt; ）。この式に &lt;span class="math"&gt;\(\ve{y} = \ve{f}(\ve{x})\)&lt;/span&gt; を代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{F}(\ve{x}, \ve{f}(\ve{x})) = \ve{0} &amp;amp;= \ve{F}(\ve{x}_{0}, \ve{f}(\ve{x}_{0})) + \ve{A}(\ve{x}, \ve{f}(\ve{x}))(\ve{x} - \ve{x}_{0}) + \ve{B}(\ve{x}, \ve{f}(\ve{x}))(\ve{f}(\ve{x}) - \ve{f}(\ve{x}_{0})) \\
\implies \ve{B}(\ve{x}, \ve{f}(\ve{x})) \ve{f}(\ve{x}) &amp;amp;= \ve{B}(\ve{x}, \ve{f}(\ve{x})) \ve{f}(\ve{x}_{0}) - \ve{A}(\ve{x}, \ve{f}(\ve{x}))(\ve{x} - \ve{x}_{0}) \\
\implies \ve{f}(\ve{x}) &amp;amp;= \ve{f}(\ve{x}_{0}) - \ve{B}(\ve{x}, \ve{f}(\ve{x}))^{-1} \ve{A}(\ve{x}, \ve{f}(\ve{x}))(\ve{x} - \ve{x}_{0}) \quad (\because \parfrac{\ve{F}}{\ve{y}} \text{は正則})
\end{align*}
&lt;/div&gt;
&lt;p&gt;行列 &lt;span class="math"&gt;\(\ve{B}(\ve{x}, \ve{f}(\ve{x}))^{-1} \ve{A}(\ve{x}, \ve{f}(\ve{x}))\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; において連続だから、 &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; において微分可能で、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{\ve{f}}{\ve{x}}(\ve{x}_{0}) = \ve{B}(\ve{x}_{0}, \ve{f}(\ve{x}_{0}))^{-1} \ve{A}(\ve{x}_{0}, \ve{f}(\ve{x}_{0})) = -\left[ \parfrac{\ve{F}}{\ve{y}} (\ve{x}_{0}, \ve{y}_{0}) \right]^{-1} \parfrac{\ve{F}}{\ve{x}} (\ve{x}_{0}, \ve{y}_{0}) \tag{5}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（2.の証明終）&lt;/p&gt;
&lt;p&gt;（3.の証明） &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; が &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級ならば(5)式の右辺は &lt;span class="math"&gt;\((\ve{x}_{0}, \ve{y}_{0})\)&lt;/span&gt; で連続だから、 &lt;span class="math"&gt;\(\ve{y}_{0} = \ve{f}(\ve{x}_{0})\)&lt;/span&gt; を代入したものも &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; で連続である。即ち、 &lt;span class="math"&gt;\(\parfrac{\ve{f}}{\ve{x}}(\ve{x})\)&lt;/span&gt; は &lt;span class="math"&gt;\(U\)&lt;/span&gt; で連続であり、 &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; は &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級。（3.の証明終）&lt;/p&gt;
&lt;p&gt;（4.の証明） &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; が &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級ならば、 &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; も &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級であることを示す。 &lt;span class="math"&gt;\(m = 1\)&lt;/span&gt; の場合は、3.により成立する。 &lt;span class="math"&gt;\(m-1\)&lt;/span&gt; の場合に成立するとして、もし、 &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; が &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級ならば、同時に &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; は &lt;span class="math"&gt;\(C^{m-1}\)&lt;/span&gt; 級だから、仮定より &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; も &lt;span class="math"&gt;\(C^{m-1}\)&lt;/span&gt; 級である。よって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{\ve{f}}{\ve{x}}(\ve{x}) = \ve{B}(\ve{x}, \ve{f}(\ve{x}))^{-1} \ve{A}(\ve{x}, \ve{f}(\ve{x})) = -\left[ \parfrac{\ve{F}}{\ve{y}} (\ve{x}, \ve{y}) \right]^{-1} \parfrac{\ve{F}}{\ve{x}} (\ve{x}, \ve{y})
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;の右辺は &lt;span class="math"&gt;\(C^{m-1}\)&lt;/span&gt; 級の写像 &lt;span class="math"&gt;\(\parfrac{\ve{F}}{\ve{y}},\ \parfrac{\ve{F}}{\ve{x}}\)&lt;/span&gt; に &lt;span class="math"&gt;\(C^{m-1}\)&lt;/span&gt; 級の写像 &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; を代入したものだから、合成関数の微分法により、右辺は &lt;span class="math"&gt;\(C^{m-1}\)&lt;/span&gt; 級になる。 &lt;span class="math"&gt;\(\parfrac{f}{x}(\ve{x})\)&lt;/span&gt; が &lt;span class="math"&gt;\(C^{m-1}\)&lt;/span&gt; 級だから、 &lt;span class="math"&gt;\(\ve{f}(\ve{x})\)&lt;/span&gt; は &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級。（4.の証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-11"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-10"&gt;陰関数定理の応用&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="section-12"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-11"&gt;逆写像定理&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;2変数を例に取って考える。 &lt;span class="math"&gt;\(\mathbb{R}^{2}\)&lt;/span&gt; から &lt;span class="math"&gt;\(\mathbb{R}^{2}\)&lt;/span&gt; への写像&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{cases}
  x = f(s, t) \\
  y = g(s, t)
\end{cases}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が与えられたとき、その逆写像が存在するかどうかを考える。今、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{cases}
  F(x, y, s, t) = f(s, t) - x \\
  G(x, y, s, t) = g(s, t) - y
\end{cases}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とおくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F(x, y, s, t) = G(x, y, s, t) = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;から陰関数 &lt;span class="math"&gt;\(s = h(x, y),\ t = k(x, y)\)&lt;/span&gt; が決まるか？という問題に帰着できる。
この問題は陰関数定理より解決できる。すなわち、行列&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left[ \begin{array}{cc}
  \parfrac{F}{s} &amp;amp; \parfrac{F}{t} \\
  \parfrac{G}{s} &amp;amp; \parfrac{G}{t}
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;がある点 &lt;span class="math"&gt;\((x_{0}, y_{0}, s_{0}, t_{0})\)&lt;/span&gt; の近傍で連続かつ正則であればよい。また、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{F}{s} = \parfrac{f}{s},\ \parfrac{F}{t} = \parfrac{f}{t},\ \parfrac{G}{s} = \parfrac{g}{s},\ \parfrac{G}{t} = \parfrac{g}{t}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;だから、上の条件は写像 &lt;span class="math"&gt;\((f(s, t), g(s, t))^{\mathsf{T}}\)&lt;/span&gt; のヤコビ行列&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left[ \begin{array}{cc}
  \parfrac{f}{s} &amp;amp; \parfrac{f}{t} \\
  \parfrac{g}{s} &amp;amp; \parfrac{g}{t}
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が &lt;span class="math"&gt;\((s_{0}, t_{0})\)&lt;/span&gt; の近傍で連続かつ正則であることを示している。&lt;/p&gt;
&lt;div class="section" id="section-13"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-12"&gt;多変数の場合&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;上記の議論を一般の &lt;span class="math"&gt;\(n\)&lt;/span&gt; 変数に拡張したのが次の &lt;strong&gt;逆写像定理&lt;/strong&gt; である。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;逆写像定理&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(\mathbb{R}^{n}\)&lt;/span&gt; の領域 &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; から &lt;span class="math"&gt;\(\mathbb{R}^{n}\)&lt;/span&gt; への写像 &lt;span class="math"&gt;\(\ve{y} = \ve{f}(\ve{x})\)&lt;/span&gt; が &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; の1点 &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; の近傍で &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級かつヤコビ行列 &lt;span class="math"&gt;\(\parfrac{\ve{f}}{\ve{x}}(\ve{x})\)&lt;/span&gt; が正則ならば、逆写像 &lt;span class="math"&gt;\(\ve{x} = \ve{h}(\ve{y})\)&lt;/span&gt; が &lt;span class="math"&gt;\(\ve{y}_{0} = \ve{f}(\ve{x}_{0})\)&lt;/span&gt; の十分小さい近傍で存在し &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級である。その導関数は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{\ve{h}}{\ve{y}}(\ve{y}) = \left[ \parfrac{\ve{f}}{\ve{x}}(\ve{h}(\ve{y})) \right]^{-1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;である。また、 &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; が &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級ならば &lt;span class="math"&gt;\(\ve{h}\)&lt;/span&gt; も &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級である。&lt;/p&gt;
&lt;p&gt;（証明）陰関数定理を &lt;span class="math"&gt;\(\ve{F}(\ve{x}, \ve{y}) = \ve{f}(\ve{x}) - \ve{y}\)&lt;/span&gt; に適用すれば良い。 &lt;span class="math"&gt;\(\ve{F}(\ve{x}, \ve{y})\)&lt;/span&gt; は連続で、 &lt;span class="math"&gt;\(\parfrac{\ve{F}}{\ve{x}} = \parfrac{\ve{f}}{\ve{x}}\)&lt;/span&gt; は &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; の近傍で連続な正則関数だから、陰関数定理により &lt;span class="math"&gt;\(\ve{y}_{0}\)&lt;/span&gt; の近傍で &lt;span class="math"&gt;\(\ve{x}_{0} = \ve{h}(\ve{y}_{0}),\ \ve{F}(\ve{h}(\ve{y}), \ve{y}) = \ve{0}\)&lt;/span&gt; を満たす連続な写像 &lt;span class="math"&gt;\(\ve{h}\)&lt;/span&gt; が唯一存在する。 &lt;span class="math"&gt;\(\ve{h}(\ve{y})\)&lt;/span&gt; の導関数は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\parfrac{\ve{h}}{\ve{y}}(\ve{y}) &amp;amp;= - \left[ \parfrac{\ve{F}}{\ve{x}} (\ve{x}, \ve{y}) \right]^{-1} \parfrac{\ve{F}}{\ve{y}}(\ve{x}, \ve{y}) \\
&amp;amp;= - \left[ \parfrac{\ve{f}}{\ve{x}} (\ve{x}, \ve{y}) \right]^{-1} (- \ve{I}) \\
&amp;amp;= \left[ \parfrac{\ve{f}}{\ve{x}}(\ve{h}(\ve{y})) \right]^{-1}
\end{align*}
&lt;/div&gt;
&lt;p class="last"&gt;また、 &lt;span class="math"&gt;\(\ve{f}\)&lt;/span&gt; が &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級であれば、 &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; も &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級であり、陰関数定理の4.より &lt;span class="math"&gt;\(\ve{h}\)&lt;/span&gt; も &lt;span class="math"&gt;\(C^{m}\)&lt;/span&gt; 級となる。（証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-14"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-13"&gt;制約付き極値問題&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="section-15"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-14"&gt;ラグランジュの未定乗数法&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;ラグランジュの未定乗数法も、勾配の図を用いた直感に頼るのではなく陰関数定理により説明が可能である。&lt;/p&gt;
&lt;p&gt;やはり例として2変数 &lt;span class="math"&gt;\(x, y\)&lt;/span&gt; で考える。 &lt;span class="math"&gt;\(\mathbb{R}^{2}\)&lt;/span&gt; のある領域 &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; 上で、2つの2変数関数 &lt;span class="math"&gt;\(f(x, y),\ g(x, y)\)&lt;/span&gt; が与えたられたとき、 &lt;span class="math"&gt;\(g(x, y) = 0\)&lt;/span&gt; という条件下で &lt;span class="math"&gt;\(f(x, y)\)&lt;/span&gt; の極値を求めることを考える。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(g(x, y) = 0\)&lt;/span&gt; と交わる &lt;span class="math"&gt;\(f(x, y) = a\)&lt;/span&gt; の交点が極値をとるならば、その点で &lt;span class="math"&gt;\(f(x, y) = a\)&lt;/span&gt; と &lt;span class="math"&gt;\(g(x, y) = 0\)&lt;/span&gt; のグラフは接しなければならない。その様な点では、法線ベクトル &lt;span class="math"&gt;\(\parfrac{f}{\ve{x}}, \parfrac{f}{\ve{x}}\)&lt;/span&gt; は同じ方向を向いているから、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{f}{\ve{x}} = \lambda \parfrac{f}{\ve{x}} \iff \parfrac{f}{x} - \lambda \parfrac{g}{x} = 0,\ \parfrac{f}{y} - \lambda \parfrac{g}{y} = 0,\ g(x, y) = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たす定数 &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; が存在する。この式は形式上、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F(x, y, \lambda) = f(x, y) - \lambda g(x, y)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;の3変数関数の極値問題と同様の形をしている。より詳しい証明は以下。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;ラグランジュの未定乗数法&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;領域 &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; 上で2つの関数 &lt;span class="math"&gt;\(f(x, y),\ g(x, y)\)&lt;/span&gt; は &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級とし、曲線 &lt;span class="math"&gt;\(g(x, y) = 0\)&lt;/span&gt; 上で &lt;span class="math"&gt;\(\parfrac{g}{\ve{x}} \neq \ve{0}\)&lt;/span&gt; とする。 &lt;span class="math"&gt;\(g(x, y) = 0\)&lt;/span&gt; 上の点 &lt;span class="math"&gt;\(\ve{x}_{0} = (x_{0}, y_{0})\)&lt;/span&gt; が条件付き極値問題における極値点ならば、ある定数 &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; が存在して、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{f}{\ve{x}}(\ve{x}_{0}) = \lambda \parfrac{g}{\ve{x}}(\ve{x}_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（証明） 仮定の &lt;span class="math"&gt;\(\parfrac{g}{\ve{x}} \neq \ve{0}\)&lt;/span&gt; より &lt;span class="math"&gt;\(\parfrac{g}{y}(\ve{x}_{0}) \neq 0\)&lt;/span&gt; が成立している。 &lt;span class="math"&gt;\(g(x, y) = 0\)&lt;/span&gt; を陰関数表示だと思うと、陰関数定理により、 &lt;span class="math"&gt;\(\ve{x}_{0} = (x_{0}, y_{0})\)&lt;/span&gt; の近傍において &lt;span class="math"&gt;\(y_{0} = \varphi(x_{0}),\ \dfrac{\varphi}{x}(x) = -g_{x}(x, \varphi(x)) / g_{y}(x, \varphi(x))\)&lt;/span&gt; を満たす &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級の関数 &lt;span class="math"&gt;\(y = \varphi(x)\)&lt;/span&gt; が存在する。 &lt;span class="math"&gt;\(z = f(x, \varphi(x))\)&lt;/span&gt; の導関数を考えると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\dfrac{z}{x} &amp;amp;= \parfrac{f}{x} (x, \varphi(x)) + \parfrac{f}{y}(x, \varphi(x)) \dfrac{\varphi}{x}(x) \quad (\because \text{合成関数の微分}) \\
&amp;amp;= f_{x}(x, \varphi(x)) + f_{y}(x, \varphi(x)) \left\{ - \frac{g_{x}(x, \varphi(x))}{g_{y}(x, \varphi(x))} \right\} \\
&amp;amp;= \frac{1}{g_{y}} (f_{x} g_{y} - f_{y} g_{x})
\end{align*}
&lt;/div&gt;
&lt;p class="last"&gt;点 &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; においてこれが &lt;span class="math"&gt;\(0\)&lt;/span&gt; になるから、 &lt;span class="math"&gt;\(f_{x}g_{y} - f_{y}g_{x} = 0\)&lt;/span&gt; 。従って &lt;span class="math"&gt;\(f_{x}/g_{x} = f_{y}/g_{y} = \lambda\)&lt;/span&gt; とおくと、&lt;span class="math"&gt;\(f_{x} = \lambda g_{x},\ f_{y} = \lambda g_{y}\)&lt;/span&gt; が得られ、まとめると &lt;span class="math"&gt;\(\parfrac{f}{\ve{x}}(\ve{x}_{0}) = \lambda \parfrac{g}{\ve{x}}(\ve{x}_{0})\)&lt;/span&gt; が得られる。（証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;制約条件が &lt;span class="math"&gt;\(g_{i}(\ve{x}) = 0\ (i = 1, ..., m)\)&lt;/span&gt; と増えた場合も同様に考えられる。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;ラグランジュの未定乗数法（複数制約）&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(\mathbb{R}^{n}\)&lt;/span&gt; の領域 &lt;span class="math"&gt;\(\Omega\)&lt;/span&gt; 上で &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級の関数 &lt;span class="math"&gt;\(f(\ve{x}),\ g_{i}(\ve{x})\ (i = 1, ..., m)\)&lt;/span&gt; が与えられ、 &lt;span class="math"&gt;\(n-m\)&lt;/span&gt; 次元曲面 &lt;span class="math"&gt;\(S = \{ \ve{x} | g_{i}(\ve{x}) = 0, \ i = 1,...,m \}\)&lt;/span&gt; 上で行列 &lt;span class="math"&gt;\(\parfrac{\ve{g}}{\ve{x}} = \left( \parfrac{g_{i}}{x_{j}} \right)\)&lt;/span&gt; の階数（行列ランク）は常に &lt;span class="math"&gt;\(m\)&lt;/span&gt; であるとする。&lt;span class="math"&gt;\(S\)&lt;/span&gt; 上の点 &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; が &lt;span class="math"&gt;\(f(\ve{x})\)&lt;/span&gt; の &lt;span class="math"&gt;\(S\)&lt;/span&gt; の極値点ならば、 &lt;span class="math"&gt;\(m\)&lt;/span&gt; 個の定数 &lt;span class="math"&gt;\(\lambda_{1}, ..., \lambda_{m}\)&lt;/span&gt; があって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{f}{\ve{x}}(\ve{x}_{0}) = \sum_{i = 1}^{m} \lambda_{i} \parfrac{g_{i}}{\ve{x}}(\ve{x}_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（証明） &lt;span class="math"&gt;\(\parfrac{\ve{g}}{\ve{x}}\)&lt;/span&gt; の階数は &lt;span class="math"&gt;\(m\)&lt;/span&gt; だから、 &lt;span class="math"&gt;\(\ve{x}^{\prime} = [x_{1}, ..., x_{n - m}],\ \ve{x}^{\prime\prime} = [x_{n - m + 1}, ..., x_{n}]\)&lt;/span&gt; として、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{\ve{g}}{\ve{x}^{\prime\prime}} =
\left[ \begin{array}{cccc}
\parfrac{g_{1}}{x_{n-m+1}} &amp;amp; \parfrac{g_{1}}{x_{n-m+2}} &amp;amp; \dots  &amp;amp; \parfrac{g_{1}}{x_{n}} \\
\parfrac{g_{2}}{x_{n-m+1}} &amp;amp; \parfrac{g_{2}}{x_{n-m+2}} &amp;amp; \dots  &amp;amp; \parfrac{g_{2}}{x_{n}} \\
\vdots                     &amp;amp; \vdots                     &amp;amp; \ddots &amp;amp; \vdots                 \\
\parfrac{g_{m}}{x_{n-m+1}} &amp;amp; \parfrac{g_{m}}{x_{n-m+2}} &amp;amp; \dots  &amp;amp; \parfrac{g_{m}}{x_{n}} \\
\end{array} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;は正則であると仮定して良い（正則になるように &lt;span class="math"&gt;\(\ve{x}^{\prime\prime}\)&lt;/span&gt; を選べば良い）。 &lt;span class="math"&gt;\(\ve{g}(\ve{x}) = \ve{0}\)&lt;/span&gt; を陰関数表示と見ると、陰関数定理により &lt;span class="math"&gt;\(x_{n-m+1} = \varphi_{1}(\ve{x}^{\prime}), ..., x_{n} = \varphi_{m}(\ve{x}^{\prime})\)&lt;/span&gt; 、即ち &lt;span class="math"&gt;\(\ve{x}^{\prime\prime} = \ve{\varphi}(\ve{x}^{\prime})\)&lt;/span&gt; を満たす &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級の写像 &lt;span class="math"&gt;\(\ve{\varphi} = [\varphi_{1}, ..., \varphi_{m}]\)&lt;/span&gt; が存在し、また、 &lt;span class="math"&gt;\(\parfrac{\ve{\varphi}}{\ve{x}^{\prime}} = -\left(\parfrac{\ve{g}}{\ve{x}^{\prime\prime}}\right)^{-1}\left(\parfrac{\ve{g}}{\ve{x}^{\prime}}\right)\)&lt;/span&gt; が成り立つ。&lt;span class="math"&gt;\(\ve{\varphi}\)&lt;/span&gt; を &lt;span class="math"&gt;\(y = f(\ve{x}) = f(\ve{x}^{\prime}, \ve{x}^{\prime\prime})\)&lt;/span&gt; に代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
y = F(\ve{x}^{\prime}) = f(\ve{x}^{\prime}, \ve{\varphi}(\ve{x}^{\prime}))
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が得られる。上記 &lt;span class="math"&gt;\(y\)&lt;/span&gt; についての極値問題を考える。 &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; において、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\parfrac{F}{\ve{x}^{\prime}} &amp;amp;= \parfrac{f}{\ve{x}^{\prime}} + \parfrac{f}{\ve{x}^{\prime\prime}} \parfrac{\ve{\varphi}}{\ve{x}^{\prime}} \quad (\because \text{連鎖律}) \\
&amp;amp;= \parfrac{f}{\ve{x}^{\prime}} - \parfrac{f}{\ve{x}^{\prime\prime}} \left(\parfrac{\ve{g}}{\ve{x}^{\prime\prime}}\right)^{-1} \parfrac{\ve{g}}{\ve{x}^{\prime}} = \ve{0}
\end{align*}
&lt;/div&gt;
&lt;p&gt;が極値となるための必要条件だから、今、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
[\lambda_{1}, ..., \lambda_{m}] = \parfrac{f}{\ve{x}^{\prime\prime}} \left(\parfrac{\ve{g}}{\ve{x}^{\prime\prime}}\right)^{-1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とおけば、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{f}{\ve{x}^{\prime\prime}}(\ve{x}_{0}) = [\lambda_{1}, ..., \lambda_{m}] \parfrac{\ve{g}}{\ve{x}^{\prime\prime}}(\ve{x}_{0}),\ \parfrac{f}{\ve{x}^{\prime}}(\ve{x}_{0}) = [\lambda_{1}, ..., \lambda_{m}] \parfrac{\ve{g}}{\ve{x}^{\prime}}(\ve{x}_{0})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成立しているから、まとめると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{f}{\ve{x}}(\ve{x}_{0}) = [\lambda_{1}, ..., \lambda_{m}] \parfrac{\ve{g}}{\ve{x}}(\ve{x}_{0}) = \sum_{i = 1}^{m} \lambda_{i} \parfrac{g_{i}}{\ve{x}}(\ve{x}_{0})
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;が得られる。（証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class="section" id="kkt"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-15"&gt;KKT条件&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;不等式制約 &lt;span class="math"&gt;\(g(x, y) \geq 0\)&lt;/span&gt; の条件下で &lt;span class="math"&gt;\(f(x, y)\)&lt;/span&gt; の極値を見つける問題を考える。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;簡単な例: &lt;span class="math"&gt;\(g(x, y) = y \geq 0\)&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(y \geq 0\)&lt;/span&gt; の領域の内部であれば、極大点の候補は &lt;span class="math"&gt;\(\parfrac{f}{x} = \parfrac{f}{y} = 0\)&lt;/span&gt; で求められる。一方、境界上（ &lt;span class="math"&gt;\(y = 0\)&lt;/span&gt; ）では、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{f}{x}(x_{0}, 0) = 0,\ \parfrac{f}{y}(x_{0}, 0) \leq 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たす &lt;span class="math"&gt;\(x_{0}\)&lt;/span&gt; が候補となる（ &lt;span class="math"&gt;\(\parfrac{f}{y}(x_{0}, 0) &amp;gt; 0\)&lt;/span&gt; とすると、それは &lt;span class="math"&gt;\(y\)&lt;/span&gt; を正方向に増やしたときに &lt;span class="math"&gt;\(f\)&lt;/span&gt; が更に増加することを意味するから、その点は極大点ではない）。これらの条件をまとめると、極点 &lt;span class="math"&gt;\((x_{0}, y_{0})\)&lt;/span&gt; は次の条件を満たす必要がある。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{f}{x}(x_{0}, y_{0}) = 0,\ \parfrac{f}{y}(x_{0}, y_{0}) \leq 0,\ y_{0} \parfrac{f}{y}(x_{0}, y_{0}) = 0
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;最後の条件は、 &lt;span class="math"&gt;\(y_{0} = 0\)&lt;/span&gt; あるいは &lt;span class="math"&gt;\(\parfrac{f}{y}(x_{0}, y_{0}) = 0\)&lt;/span&gt; を要請している。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;次に一般の条件式 &lt;span class="math"&gt;\(g(x, y) \leq 0\)&lt;/span&gt; を考える。今、新しい変数 &lt;span class="math"&gt;\(z\)&lt;/span&gt; として&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
g(x, y) = z,\ z \geq 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;をおけば、元の問題を &lt;span class="math"&gt;\(z \geq 0\)&lt;/span&gt; における等式制約の条件付き極値問題に変換できる。よって、ラグランジュの未定乗数法により、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F(x, y, z, \lambda) = f(x, y) - \lambda (g(x, y) - z)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;の &lt;span class="math"&gt;\(z \geq 0\)&lt;/span&gt; における極値を求めれば良い。これは、簡単な例の観察を元に、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{F}{x} = 0,\ \parfrac{F}{y} = 0,\ \parfrac{F}{\lambda} = 0,\ \parfrac{F}{z} \leq 0,\ z\parfrac{F}{z} = 0,\ z \geq 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たす &lt;span class="math"&gt;\((x, y, z, \lambda)\)&lt;/span&gt; を求める問題になる。偏微分を行うと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{f}{x} = \lambda \parfrac{g}{x},\ \parfrac{f}{y} = \lambda \parfrac{g}{y},\ g(x, y) = z,\ \lambda \leq 0,\ \lambda z = 0,\ z \geq 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となり、後ろの4条件をまとめると、以下の条件が得られる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{f}{x} = \lambda \parfrac{g}{x},\ \parfrac{f}{y} = \lambda \parfrac{g}{y},\ g(x, y) \geq 0,\ \lambda \leq 0,\ \lambda g(x, y) = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とまとめられる。極小値を求める場合は、 &lt;span class="math"&gt;\(-f(x, y)\)&lt;/span&gt; の極大値を求めれば良い。この場合の条件は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{f}{x} = -\lambda \parfrac{g}{x},\ \parfrac{f}{y} = -\lambda \parfrac{g}{y},\ g(x, y) = z,\ \lambda \leq 0,\ \lambda z = 0,\ z \geq 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となり、 &lt;span class="math"&gt;\(-\lambda\)&lt;/span&gt; を &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; に置き換えることで必要条件が得られる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{f}{x} = \lambda \parfrac{g}{x},\ \parfrac{f}{y} = \lambda \parfrac{g}{y},\ g(x, y) \geq 0,\ \lambda \geq 0,\ \lambda g(x, y) = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;制約条件が増えても同様に考えれば良いから、次の定理が成立する。これを一般にKKT条件（Karush-Kuhn-Tucker condition）と呼ぶ。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;KKT条件&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(f(\ve{x}), g_{i}(\ve{x})\ (i = 1, ..., m)\)&lt;/span&gt; は &lt;span class="math"&gt;\(C^{1}\)&lt;/span&gt; 級とする。 &lt;span class="math"&gt;\(g_{i}(\ve{x}) \geq 0\ (i = 1,...,m)\)&lt;/span&gt; という条件の下で、 &lt;span class="math"&gt;\(f(\ve{x})\)&lt;/span&gt; の極大点 &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; は次の条件を満たさなければならない:&lt;/p&gt;
&lt;p&gt;ある定数 &lt;span class="math"&gt;\(\lambda_{1}, ..., \lambda_{m}\)&lt;/span&gt; があって、 &lt;span class="math"&gt;\(\ve{x}_{0}\)&lt;/span&gt; において&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{cases}
\displaystyle \parfrac{f}{\ve{x}}(\ve{x}_{0}) = \sum_{i = 1}^{m} \lambda_{i} \parfrac{g_{i}}{\ve{x}}(\ve{x}_{0}) \\
\lambda_{i} g_{i}(\ve{x}_{0}) = 0,\ g_{i}(\ve{x}_{0}) \geq 0,\ \lambda_{i} \leq 0 \quad (i = 1, ..., m)
\end{cases}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（証明）変数 &lt;span class="math"&gt;\(z_{i}\ (i = 1, ..., m)\)&lt;/span&gt; を用いて&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
g_{i}(\ve{x}) = z_{i},\ z_{i} \geq 0 \quad (i = 1,...,m)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とおく。定数を &lt;span class="math"&gt;\(\lambda_{1}, ..., \lambda_{m}\)&lt;/span&gt; としてラグランジュの未定乗数法を適用すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F(\ve{x}, \ve{z}, \ve{\lambda}) = f(\ve{x}) - \sum_{i = 1}^{m} \lambda_{i} \left\{ g_{i}(\ve{x}) - z_{i} \right\}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;であり、極値条件は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left\{ \begin{array}{ll}
\displaystyle \parfrac{F}{\ve{x}}(\ve{x}_{0}, \ve{z}, \ve{\lambda}) = \parfrac{f}{\ve{x}}(\ve{x}_{0}) - \sum_{i = 1}^{m} \lambda_{i} \parfrac{g_{i}}{\ve{x}}(\ve{x}_{0}) = \ve{0} &amp;amp; \\
\displaystyle \parfrac{F}{z_{i}}(\ve{x}_{0}, \ve{z}, \ve{\lambda}) = \lambda_{i} \leq 0 &amp;amp; (i = 1,...,m) \\
\displaystyle \parfrac{F}{\lambda_{i}}(\ve{x}_{0}, \ve{z}, \ve{\lambda}) = -g_{i}(\ve{x}_{0}) + z_{i} = 0 &amp;amp; (i = 1,...,m) \\
\displaystyle z_{i} \parfrac{F}{z_{i}}(\ve{x}_{0}, \ve{z}, \ve{\lambda}) = z_{i}\lambda_{i} = 0 &amp;amp; (i = 1,...,m) \\
z_{i} \geq 0 &amp;amp; (i = 1,...,m)
\end{array} \right.
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(z_{i} = g_{i}(\ve{x})\)&lt;/span&gt; を元に条件をまとめ直すと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{cases}
\displaystyle \parfrac{f}{\ve{x}}(\ve{x}_{0}) = \sum_{i = 1}^{m} \lambda_{i} \parfrac{g_{i}}{\ve{x}}(\ve{x}_{0}) \\
\lambda_{i} g_{i}(\ve{x}_{0}) = 0,\ g_{i}(\ve{x}_{0}) \geq 0,\ \lambda_{i} \leq 0 \quad (i = 1, ..., m)
\end{cases}
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;（証明終）&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="記事"></category><category term="基礎"></category></entry><entry><title>逆写像定理までの整理</title><link href="/ni-xie-xiang-ding-li-madenozheng-li.html" rel="alternate"></link><published>2020-06-05T11:00:00+09:00</published><updated>2020-06-05T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-05:/ni-xie-xiang-ding-li-madenozheng-li.html</id><summary type="html">&lt;p&gt;評価を待つ間逆写像定理までを写経中。だいたい飲み込めてるが、やっぱ基礎の抜けがある…。
陰関数定理はだいたいOK …&lt;/p&gt;</summary><content type="html">&lt;p&gt;評価を待つ間逆写像定理までを写経中。だいたい飲み込めてるが、やっぱ基礎の抜けがある…。
陰関数定理はだいたいOK。ついでにラグランジュ未定乗数法の厳密な証明を与えたい。（いままでなんとなくで済ませていたので止めを刺す。）&lt;/p&gt;
</content><category term="雑記"></category><category term="Manifold"></category></entry><entry><title>正則化(8)</title><link href="/zheng-ze-hua-8.html" rel="alternate"></link><published>2020-06-04T11:00:00+09:00</published><updated>2020-06-04T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-04:/zheng-ze-hua-8.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;前日思い立っ …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;前日思い立った内容って既に試していて、だめなところまで見えてた。すなわち直接 &lt;span class="math"&gt;\(\mathrm{E}[(\ve{x} + \ve{a})(\ve{x} + \ve{a})^{\mathsf{T}}]\)&lt;/span&gt; を計算する方針は試行済み。&lt;/p&gt;
&lt;p&gt;色々探しているうちに、K-FACという自然勾配学習法の近似手法を見つける。クロネッカ積を使ってフィッシャー情報行列を分解しようというアイデアだ。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://medium.com/&amp;#64;osawa1021/k-fac%E3%81%A8%E3%81%AF-de30537f7096"&gt;K-FACとは？ 大規模深層学習のための二次最適化の実現&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;これはすごい。少し前にクロネッカ積で計算できるんじゃないの？とは指摘もらってたけど、普通にメジャーな手法だ。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/pjsai/JSAI2017/0/JSAI2017_1A2OS05b4/_pdf/-char/ja"&gt;自然勾配近似法を起点としたバッチ正規化の数理的理解&lt;/a&gt; に近似手法が挙げられている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1810.12281.pdf"&gt;THREE MECHANISMS OF WEIGHT DECAY REGULARIZATION&lt;/a&gt; でWeight Decayの文脈でL2正則化学習則が示されている。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1512.04202.pdf"&gt;Preconditioned Stochastic Gradient Descent&lt;/a&gt; Precondition行列で勾配を更新する方法。ちょっと待て、自然勾配とちょっと違う。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.mdpi.com/2076-3417/9/21/4568/pdf"&gt;Adaptive Natural Gradient Method for Learning of Stochastic Neural Networks in Mini-Batch Mode&lt;/a&gt; ではMatrix cookbookの(191)を使って行列に対する正則化を行っている。&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\((\ve{Q} + \sigma^{2}\ve{M})^{-1} \approx \ve{Q}^{-1} - \sigma^{2}\ve{Q}^{-1}\ve{M}\ve{Q}^{-1}\ (\sigma\text{ is small})\)&lt;/span&gt; という近似。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;逆写像定理までをおべんきょ中。まだ陰関数定理の途中。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(7)</title><link href="/zheng-ze-hua-7.html" rel="alternate"></link><published>2020-06-03T11:00:00+09:00</published><updated>2020-06-03T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-06-03:/zheng-ze-hua-7.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.math.uwaterloo.ca/~hwolkowi/matrixcookbook.pdf"&gt;Matrix cookbook&lt;/a&gt; を眺めて …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.math.uwaterloo.ca/~hwolkowi/matrixcookbook.pdf"&gt;Matrix cookbook&lt;/a&gt; を眺めていたら有益そうな等式を見つける。 &lt;span class="math"&gt;\(E[\ve{x}] = \ve{m}\)&lt;/span&gt; として、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mathrm{E}[(\ve{x} + \ve{a})(\ve{x} + \ve{a})^{\mathsf{T}}] &amp;amp;= \mathrm{E}[\ve{x}\ve{x}^{\mathsf{T}} + \ve{x}\ve{a}^{\mathsf{T}} + \ve{a}\ve{x}^{\mathsf{T}} + \ve{a}\ve{a}^{\mathsf{T}}] \\
&amp;amp;= \mathrm{E}[\ve{x}\ve{x}^{\mathsf{T}} - \ve{x}\ve{m}^{\mathsf{T}} - \ve{m}\ve{x}^{\mathsf{T}} + \ve{m}\ve{m}^{\mathsf{T}} + \ve{x}\ve{m}^{\mathsf{T}} + \ve{m}\ve{x}^{\mathsf{T}} - \ve{m}\ve{m}^{\mathsf{T}} + \ve{x}\ve{a}^{\mathsf{T}} + \ve{a}\ve{x}^{\mathsf{T}} + \ve{a}\ve{a}^{\mathsf{T}}] \\
&amp;amp;= \mathrm{E}[\ve{x}\ve{x}^{\mathsf{T}} - \ve{x}\ve{m}^{\mathsf{T}} - \ve{m}\ve{x}^{\mathsf{T}} + \ve{m}\ve{m}^{\mathsf{T}}] + \ve{m}\ve{m}^{\mathsf{T}} + \ve{m}\ve{m}^{\mathsf{T}} - \ve{m}\ve{m}^{\mathsf{T}} + \ve{m}\ve{a}^{\mathsf{T}} + \ve{a}\ve{m}^{\mathsf{T}} + \ve{a}\ve{a}^{\mathsf{T}} \\
&amp;amp;= \mathrm{E}[(\ve{x} - \ve{m})(\ve{x} - \ve{m})^{\mathsf{T}}] + \ve{m}\ve{m}^{\mathsf{T}} + \ve{m}\ve{a}^{\mathsf{T}} + \ve{a}\ve{m}^{\mathsf{T}} + \ve{a}\ve{a}^{\mathsf{T}} \\
&amp;amp;= \mathrm{E}[(\ve{x} - \ve{m})(\ve{x} - \ve{m})^{\mathsf{T}}] + (\ve{m} + \ve{a})(\ve{m} + \ve{a})^{\mathsf{T}} \\
&amp;amp;= \mathrm{E}[\ve{x}\ve{x}^{\mathsf{T}}] - \ve{m}\ve{m}^{\mathsf{T}} + (\ve{m} + \ve{a})(\ve{m} + \ve{a})^{\mathsf{T}}
\end{align*}
&lt;/div&gt;
&lt;p&gt;が成立する。 &lt;span class="math"&gt;\(\ve{a}\)&lt;/span&gt; を正則化で出てくるベクトルとすると、割と有益に見える。しかも &lt;span class="math"&gt;\(\ve{m} = \ve{0}\)&lt;/span&gt; とできるならばもっとさっぱりする。&lt;/p&gt;
&lt;p&gt;早速手元のデータで &lt;span class="math"&gt;\(\ve{m} = \ve{0}\)&lt;/span&gt; とならないか、つまり、勾配 &lt;span class="math"&gt;\(\mathrm{sign}[\varepsilon(n)]\ve{x}(n)\)&lt;/span&gt; の平均が &lt;span class="math"&gt;\(\ve{0}\)&lt;/span&gt; にならないか観察したけど、成り立っていなそう。。。長時間平均をとっても収束している感じはしない。（自然勾配は、当然 &lt;span class="math"&gt;\(\ve{0}\)&lt;/span&gt; に漸近する傾向あり。学習が進んでいるから当然。）&lt;/p&gt;
&lt;p&gt;平均 &lt;span class="math"&gt;\(\ve{m}\)&lt;/span&gt; を逐次推定すれば良さそうで、試してみたい。しかし今は情報幾何もやるのだ。明日やる。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(6)</title><link href="/zheng-ze-hua-6.html" rel="alternate"></link><published>2020-05-31T11:00:00+09:00</published><updated>2020-05-31T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-31:/zheng-ze-hua-6.html</id><summary type="html">&lt;p&gt;残った課題をやってたら土日が飛ぶ。ついでにカサゴ本を読み切る。
6月からは英語のおべんきょうをしようかと思 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;残った課題をやってたら土日が飛ぶ。ついでにカサゴ本を読み切る。
6月からは英語のおべんきょうをしようかと思っている。同時に情報幾何も進める。
早いところ進捗を見てもらいたいが、まだ無理っぽい。。。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://solid4.mech.okayama-u.ac.jp/%E3%83%86%E3%83%B3%E3%82%BD%E3%83%AB.pdf"&gt;テンソル&lt;/a&gt; テンソルの定義。分かりやすい説明。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(5)</title><link href="/zheng-ze-hua-5.html" rel="alternate"></link><published>2020-05-30T11:00:00+09:00</published><updated>2020-05-30T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-30:/zheng-ze-hua-5.html</id><summary type="html">&lt;p&gt;課題やってたら木金が飛んだ。。。&lt;/p&gt;
&lt;p&gt;古い資料を漁ってたら、SPSA（Simultaneous perturbation stochastic approximation）が掘り返された。たしかシステム同定で使ったよな …&lt;/p&gt;</summary><content type="html">&lt;p&gt;課題やってたら木金が飛んだ。。。&lt;/p&gt;
&lt;p&gt;古い資料を漁ってたら、SPSA（Simultaneous perturbation stochastic approximation）が掘り返された。たしかシステム同定で使ったよな。なんか面白いかも知んない。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(4)</title><link href="/zheng-ze-hua-4.html" rel="alternate"></link><published>2020-05-27T11:00:00+09:00</published><updated>2020-05-27T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-27:/zheng-ze-hua-4.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;引き続きMAP推 …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;引き続きMAP推定における自然勾配を調査する。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1712.02390.pdf"&gt;Noisy Natural Gradient as Variational Inference&lt;/a&gt; の式(5)からスタートするも…はっきりしたことを言ってないように見える。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bsi-ni.brain.riken.jp/database/file/215/221.pdf"&gt;Adaptive natural gradient learning algorithms for various stochastic models&lt;/a&gt; これの式(5)も参考になりそう。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1803.09151.pdf"&gt;Natural Gradients in Practice: Non-Conjugate Variational Inference in Gaussian Process Models&lt;/a&gt; 指数族の事後確率最大化を考える。フィッシャー情報行列を計算するための平均のとり方が妙。もうちょっと読みたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(3)</title><link href="/zheng-ze-hua-3.html" rel="alternate"></link><published>2020-05-26T11:00:00+09:00</published><updated>2020-05-26T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-26:/zheng-ze-hua-3.html</id><summary type="html">&lt;p&gt;実装の整理できて、正則化込で動かしているけど芳しくない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;正則化入れたらRMSが悪化。しかも、正則化係数を十分小さ …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;実装の整理できて、正則化込で動かしているけど芳しくない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;正則化入れたらRMSが悪化。しかも、正則化係数を十分小さく取らないと誤差が大きくなる。&lt;/li&gt;
&lt;li&gt;タップ数が多い場合は多少の効果あり。&lt;ul&gt;
&lt;li&gt;タップ数が少ない（〜16個）のときは旨味が無いように思える。係数がスパースじゃないのでは。&lt;/li&gt;
&lt;li&gt;試しに128個とかにしたら少しの改善が見られた。けど適応が遅くて正則化なしでもRMSが悪い。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;フィッシャー情報行列固定で、勾配だけ正則化かける方は発散していく。&lt;/li&gt;
&lt;li&gt;ついでにLMSでも自然勾配法試してみたけど、SignedLMSの自然勾配よりもRMSが悪い。&lt;/li&gt;
&lt;li&gt;もう一度適応的自然勾配学習法を試したけど、十分に係数を小さく取らないと発散するし、小さくとっても性能が悪い。フィッシャー情報行列はちゃんと更新するべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なんで正則化したら性能落ちるのか？をもっと考えていたら、パラメータの事前分布を入れた瞬間に計量がさらに歪んでいそう（単純な残差の分散ではダメそう）。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1712.02390.pdf"&gt;Noisy Natural Gradient as Variational Inference&lt;/a&gt; の式(5)。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.luigimalago.it/papers/2013GSI.pdf"&gt;Robust Estimation of Natural Gradient in Optimization by Regularized Linear Regression&lt;/a&gt; 線形回帰における正則化に触れている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ipvs.informatik.uni-stuttgart.de/mlr/papers/05-igel-Rprop.pdf"&gt;Rprop Using the Natural Gradient&lt;/a&gt; パラメータの正則化ではない。フィッシャー情報行列に正則化パラメータを乗じた単位行列を足して逆行列を求めている。なんでも、正則化パラメータが大きければ普通の勾配法に近づくとのこと。そのとおりだが、一体どういう発想なんだろう。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1703.00209.pdf"&gt;Online Natural Gradient as a Kalman Filter&lt;/a&gt; ドンピシャであった（Proposition 4）けどだいぶ複雑。しかも、自然勾配法とカルマンフィルタの関係性を示している。カルマンフィルタのノイズの事前分布を取り入れている。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あがいてたら適応的自然勾配の近似計算があった。計算負荷削減に有益そう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://papers.nips.cc/paper/3234-topmoumoute-online-natural-gradient-algorithm.pdf"&gt;Topmoumoute online natural gradient algorithm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(2)</title><link href="/zheng-ze-hua-2.html" rel="alternate"></link><published>2020-05-25T11:00:00+09:00</published><updated>2020-05-25T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-25:/zheng-ze-hua-2.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;まだ悩んでい …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;まだ悩んでいる。今は &lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; を直接計算してるので、正則化込みの結果（ &lt;span class="math"&gt;\((\ve{R} + \lambda\ve{I})^{-1}\)&lt;/span&gt; ）になっていない。この式を近似でもいいから計算できないか？&lt;/p&gt;
&lt;p&gt;なんかうまくいきそうなんだけど、定式化にあたって一つ疑問が： &lt;strong&gt;自然勾配って一般の損失関数にも使えるのか？&lt;/strong&gt;
対数尤度を損失関数に使った場合は、無論自然勾配になるけど、一般の損失関数の場合、フィッシャー情報行列と損失関数の勾配が噛み合わない気がする。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1808.07172.pdf"&gt;Fisher Information and Natural Gradient Learning of Random Deep Networks&lt;/a&gt; 甘利先生の論文だけど一般の損失に適用しているように見える&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.76.7538&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Why Natural Gradient?&lt;/a&gt; &lt;strong&gt;→大丈夫っぽい。ちゃんと読もう。&lt;/strong&gt; 簡単な例（極座標系）で示している。普通の勾配はユークリッド空間上になるけど、極座標の逆行列を乗じて自然勾配を得ている。&lt;ul&gt;
&lt;li&gt;とは言っても目的関数の構造を適切に表していないと、性能が悪そうに見える。対数尤度以外でどういうときに有効なんだ？&lt;/li&gt;
&lt;li&gt;試してみるしかない？つまり、勾配分散を毎回求める必要があるのか、それとも、一つの計量を複数の損失関数で使い回せるかやってみる。&lt;/li&gt;
&lt;li&gt;もう少し考えた。やっぱり正則化項を入れると損失関数の勾配は歪んでくると思う。だから、正則化項も含めてフィッシャー情報行列を計算しなければいかんと思う。ていうか、もはやフィッシャー情報行列は勾配の分散でしか無いように見えてきた。やり方としては、パラメータの事前分布にガウスorラプラス分布を入れて、そいつの対数尤度をとって最適化問題を考える。フィッシャー情報行列の式変形が難しくなるけど、そんなことは無視して（考察の余地はあるけど）逆行列補題でストレートにフィッシャー情報行列の逆行列を計算できる。&lt;ul&gt;
&lt;li&gt;ようはMAP推定。 &lt;span class="math"&gt;\(\max p(\ve{x} | \ve{\theta}) p(\ve{\theta})\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(p(\ve{x} | \ve{\theta})\)&lt;/span&gt; は誤差分布、 &lt;span class="math"&gt;\(p(\ve{\theta})\)&lt;/span&gt; はパラメータ事前分布。&lt;span class="math"&gt;\(p(\ve{\theta}) = \exp(-\beta ||\ve{\theta}||_{2}), \exp(-\beta ||\ve{\theta}||_{1})\)&lt;/span&gt; なり何でもあり。対数とって勾配の分散をとればフィッシャー情報行列が求まる。&lt;/li&gt;
&lt;li&gt;試すこともできると思うのでやってみたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>正則化(1)</title><link href="/zheng-ze-hua-1.html" rel="alternate"></link><published>2020-05-24T11:00:00+09:00</published><updated>2020-05-24T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-24:/zheng-ze-hua-1.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;逆行列補題を …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;逆行列補題を使えば、どんな自然勾配法でも上手く動きそうな気がしてきた…。
勾配の分散行列を逐次的に求められるから相当強い。
自己相関行列であることはそんなに重要でもないかも。。。。でも評価待ちましょう。。。&lt;/p&gt;
&lt;p&gt;一方で今日から正則化をどうすればいいか考えている。答えはフィッシャー情報行列に &lt;span class="math"&gt;\(\lambda \ve{I}\)&lt;/span&gt; を足すだけなんだが、意味づけというか解釈が上手くできない。どういう損失関数ならばフィッシャー情報行列に単位行列を足す形になるのか。。。&lt;/p&gt;
&lt;p&gt;SignedLMSで試したけど難航中。どうしても &lt;span class="math"&gt;\(\mathrm{sign}[\varepsilon(n)]\ve{x}(n)\)&lt;/span&gt; との積をとる項が出てきて、その平均がどうなるかわからない。。。&lt;/p&gt;
&lt;p&gt;実験的に勾配に係数ベクトルを足すなり係数の符号ベクトルを足すなりしてるけど、
正則化パラメータをめちゃくちゃ小さく取らないと結果が発散する…。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category><category term="Regularization"></category></entry><entry><title>自然勾配法の概観</title><link href="/zi-ran-gou-pei-fa-nogai-guan.html" rel="alternate"></link><published>2020-05-23T11:40:00+09:00</published><updated>2020-05-23T11:40:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-23:/zi-ran-gou-pei-fa-nogai-guan.html</id><summary type="html">&lt;p class="first last"&gt;自然勾配法の概略。だいたい &lt;a class="reference external" href="https://wiseodd.github.io/techblog/2018/03/11/fisher-information/"&gt;Fisher Information Matrix&lt;/a&gt; と &lt;a class="reference external" href="https://wiseodd.github.io/techblog/2018/03/14/natural-gradient/"&gt;Natural Gradient Descent&lt;/a&gt; から持ってきている。&lt;/p&gt;
</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\mean[2]{\mathrm{E}_{#1} \left[ #2 \right]}
\newcommand\KL[2]{\mathrm{KL} \left[ #1 \ \middle| \middle| \ #2 \right]}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;自然勾配法の概略。だいたい &lt;a class="reference external" href="https://wiseodd.github.io/techblog/2018/03/11/fisher-information/"&gt;Fisher Information Matrix&lt;/a&gt; と &lt;a class="reference external" href="https://wiseodd.github.io/techblog/2018/03/14/natural-gradient/"&gt;Natural Gradient Descent&lt;/a&gt; から持ってきている。&lt;/p&gt;
&lt;p&gt;パラメタベクトル &lt;span class="math"&gt;\(\ve{\theta}\)&lt;/span&gt; を持つ確率密度関数 &lt;span class="math"&gt;\(p(\ve{x}|\ve{\theta})\)&lt;/span&gt; を考える。対数尤度関数 &lt;span class="math"&gt;\(\log p(\ve{x}|\ve{\theta})\)&lt;/span&gt; の &lt;span class="math"&gt;\(\ve{\theta}\)&lt;/span&gt; におけるへッシアン &lt;span class="math"&gt;\(\ve{H}_{\ve{\theta}}\)&lt;/span&gt; は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{H}_{\ve{\theta}} \log p(\ve{x} | \ve{\theta}) &amp;amp;= \left(\parfrac{}{\ve{\theta}} \right) \left(\parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} \log p(\ve{x} | \ve{\theta}) \\
&amp;amp;= \left(\parfrac{}{\ve{\theta}} \right) \frac{\left(\parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} p(\ve{x} | \ve{\theta})}{p(\ve{x} | \ve{\theta})} \\
&amp;amp;= \frac{\left\{ \left(\parfrac{}{\ve{\theta}} \right) \left(\parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} p(\ve{x} | \ve{\theta}) \right\} p(\ve{x} | \ve{\theta}) - \left(\parfrac{}{\ve{\theta}} \right) p(\ve{x} | \ve{\theta}) \left(\parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} p(\ve{x} | \ve{\theta}) }{p(\ve{x} | \ve{\theta})^{2}} \\
&amp;amp;= \frac{\ve{H}_{\ve{\theta}} p(\ve{x} | \ve{\theta})}{p(\ve{x} | \ve{\theta})} - \left\{ \frac{\left(\parfrac{}{\ve{\theta}} \right) p(\ve{x} | \ve{\theta})}{p(\ve{x} | \ve{\theta})} \right\} \left\{ \frac{\left(\parfrac{}{\ve{\theta}} \right) p(\ve{x} | \ve{\theta})}{p(\ve{x} | \ve{\theta})} \right\}^{\mathsf{T}} \\
&amp;amp;= \frac{\ve{H}_{\ve{\theta}} p(\ve{x} | \ve{\theta})}{p(\ve{x} | \ve{\theta})} - \left( \parfrac{}{\ve{\theta}} \log p(\ve{x} | \ve{\theta}) \right) \left( \parfrac{}{\ve{\theta}} \log p(\ve{x} | \ve{\theta}) \right)^{\mathsf{T}}
\end{align*}
&lt;/div&gt;
&lt;p&gt;両辺分布 &lt;span class="math"&gt;\(p(\ve{x}|\ve{\theta})\)&lt;/span&gt; について平均をとる。このとき右辺第二項はスコア関数の分散になりフィッシャー情報行列 &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; そのものになることに注意すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mean{p(\ve{x}|\ve{\theta})}{\ve{H}_{\ve{\theta}} \log p(\ve{x} | \ve{\theta})} &amp;amp;= \mean{p(\ve{x}|\ve{\theta})}{\frac{\ve{H}_{\ve{\theta}} p(\ve{x} | \ve{\theta})}{p(\ve{x} | \ve{\theta})}} - \mean{p(\ve{x}|\ve{\theta})}{\left( \parfrac{}{\ve{\theta}} \log p(\ve{x} | \ve{\theta}) \right) \left( \parfrac{}{\ve{\theta}} \log p(\ve{x} | \ve{\theta}) \right)^{\mathsf{T}}} \\
&amp;amp;= \mean{p(\ve{x}|\ve{\theta})}{\frac{\ve{H}_{\ve{\theta}} p(\ve{x} | \ve{\theta})}{p(\ve{x} | \ve{\theta})}} - \ve{F} \\
&amp;amp;= \int p(\ve{x}|\ve{\theta}) \frac{\ve{H}_{\ve{\theta}} p(\ve{x} | \ve{\theta})}{p(\ve{x} | \ve{\theta})} \mathrm{d}\ve{x} - \ve{F} = \int \ve{H}_{\ve{\theta}} p(\ve{x} | \ve{\theta}) \mathrm{d}\ve{x} - \ve{F} \\
&amp;amp;= \ve{H}_{\ve{\theta}} \int p(\ve{x} | \ve{\theta}) \mathrm{d}\ve{x} - \ve{F} \quad(\because \text{微分と積分の入れ替えを可能（正則条件）とする}) \\
&amp;amp;= \ve{H}_{\ve{\theta}} 1 - \ve{F} \\
&amp;amp;= - \ve{F}
\end{align*}
&lt;/div&gt;
&lt;p&gt;従って、 &lt;strong&gt;対数尤度関数のへッシアンの平均に負号をつけるとフィッシャー情報行列に一致する。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;つぎに、異なるパラメタ &lt;span class="math"&gt;\(\ve{\theta}, \ve{\theta}^{\prime}\)&lt;/span&gt; をもつ確率分布 &lt;span class="math"&gt;\(p(\ve{x}|\ve{\theta}), p(\ve{x}|\ve{\theta}^{\prime})\)&lt;/span&gt; 間の違いを測るダイバージェンスとしてKLダイバージェンスを使ったとき、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\KL{p(\ve{x}|\ve{\theta})}{p(\ve{x}|\ve{\theta}^{\prime})} &amp;amp;= \int p(\ve{x}|\ve{\theta}) \log \left( \frac{p(\ve{x}|\ve{\theta})}{p(\ve{x}|\ve{\theta}^{\prime})} \right) \mathrm{d}\ve{x} \\
&amp;amp;= \mean{p(\ve{x}|\ve{\theta})}{\log p(\ve{x}|\ve{\theta})} - \mean{p(\ve{x}|\ve{\theta})}{\log p(\ve{x}|\ve{\theta}^{\prime})}
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。 &lt;span class="math"&gt;\(\ve{\theta}\)&lt;/span&gt; を固定し、パラメタ &lt;span class="math"&gt;\(\ve{\theta}^{\prime}\)&lt;/span&gt; に関するへッシアン &lt;span class="math"&gt;\(\ve{H}_{\ve{\theta}^{\prime}}\)&lt;/span&gt; を求めると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{H}_{\ve{\theta}^{\prime}} \KL{p(\ve{x}|\ve{\theta})}{p(\ve{x}|\ve{\theta}^{\prime})} &amp;amp;= \left( \parfrac{}{\ve{\theta}^{\prime}} \right) \left( \parfrac{}{\ve{\theta}^{\prime}} \right)^{\mathsf{T}} \KL{p(\ve{x}|\ve{\theta})}{p(\ve{x}|\ve{\theta}^{\prime})} \\
&amp;amp;= \left( \parfrac{}{\ve{\theta}^{\prime}} \right) \left\{ \left( \parfrac{}{\ve{\theta}^{\prime}} \right)^{\mathsf{T}} \mean{p(\ve{x}|\ve{\theta})}{\log p(\ve{x}|\ve{\theta})} - \left( \parfrac{}{\ve{\theta}^{\prime}} \right)^{\mathsf{T}} \mean{p(\ve{x}|\ve{\theta})}{\log p(\ve{x}|\ve{\theta}^{\prime})}\right\} \\
&amp;amp;= - \left( \parfrac{}{\ve{\theta}^{\prime}} \right) \mean{p(\ve{x}|\ve{\theta})}{\left( \parfrac{}{\ve{\theta}^{\prime}} \right)^{\mathsf{T}} \log p(\ve{x}|\ve{\theta}^{\prime})} = - \mean{p(\ve{x}|\ve{\theta})}{\left( \parfrac{}{\ve{\theta}^{\prime}} \right)\left( \parfrac{}{\ve{\theta}^{\prime}} \right)^{\mathsf{T}} \log p(\ve{x}|\ve{\theta}^{\prime})} \\
&amp;amp;= -\mean{p(\ve{x}|\ve{\theta})}{\ve{H}_{\ve{\theta}^{\prime}} \log p(\ve{x}|\ve{\theta}^{\prime})}
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで &lt;span class="math"&gt;\(\ve{\theta}^{\prime} \to \ve{\theta}\)&lt;/span&gt; と近づけていくと、最後の式はフィッシャー情報行列 &lt;span class="math"&gt;\(\ve{F}\)&lt;/span&gt; にいくらでも近づく。よって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\lim_{\ve{\theta}^{\prime} \to \ve{\theta}} \ve{H}_{\ve{\theta}^{\prime}} \KL{p(\ve{x}|\ve{\theta})}{p(\ve{x}|\ve{\theta}^{\prime})} = \ve{F}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;次に、 &lt;span class="math"&gt;\(\ve{\theta}\)&lt;/span&gt; 近傍での対数尤度関数の挙動を見ていく。 &lt;span class="math"&gt;\(\ve{h}\)&lt;/span&gt; を微小なベクトルとして、 &lt;span class="math"&gt;\(\log p(\ve{x}|\ve{\theta} + \ve{h})\)&lt;/span&gt; を2次の項までテイラー展開すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\log p(\ve{x}|\ve{\theta} + \ve{h}) &amp;amp;\approx \log p(\ve{x} | \ve{\theta}) + \left( \parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} \log p(\ve{x} | \ve{\theta})  \ve{h} + \frac{1}{2} \ve{h}^{\mathsf{T}} \left( \parfrac{}{\ve{\theta}} \right) \left( \parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} \log p(\ve{x} | \ve{\theta}) \ve{h} \\
\Rightarrow \log p(\ve{x}|\ve{\theta} + \ve{h}) - \log p(\ve{x} | \ve{\theta}) &amp;amp;\approx \left( \parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} \log p(\ve{x} | \ve{\theta})  \ve{h} + \frac{1}{2} \ve{h}^{\mathsf{T}} \left( \parfrac{}{\ve{\theta}} \right) \left( \parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} \log p(\ve{x} | \ve{\theta}) \ve{h} \\
&amp;amp;= \left( \parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} \log p(\ve{x} | \ve{\theta}) \ve{h} + \frac{1}{2} \ve{h}^{\mathsf{T}} \ve{H}_{\ve{\theta}} \log p(\ve{x} | \ve{\theta}) \ve{h}
\end{align*}
&lt;/div&gt;
&lt;p&gt;両辺 &lt;span class="math"&gt;\(p(\ve{x}|\ve{\theta})\)&lt;/span&gt; について平均をとると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mean{p(\ve{x}|\ve{\theta})}{\log p(\ve{x}|\ve{\theta} + \ve{h}) - \log p(\ve{x} | \ve{\theta})} &amp;amp;= \mean{p(\ve{x}|\ve{\theta})}{\log\left( \frac{p(\ve{x}|\ve{\theta} + \ve{h})}{p(\ve{x} | \ve{\theta})} \right)} \\
&amp;amp;= \int p(\ve{x}|\ve{\theta}) \log\left[ \frac{p(\ve{x}|\ve{\theta} + \ve{h})}{p(\ve{x} | \ve{\theta})} \right] \mathrm{d}\ve{x} = -\int p(\ve{x}|\ve{\theta}) \log\left[ \frac{p(\ve{x} | \ve{\theta})}{p(\ve{x}|\ve{\theta} + \ve{h})} \right] \mathrm{d}\ve{x} \\
&amp;amp;= -\KL{p(\ve{x}|\ve{\theta})}{p(\ve{x}|\ve{\theta} + \ve{h})} \\
\mean{p(\ve{x}|\ve{\theta})}{\left( \parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} \log p(\ve{x} | \ve{\theta}) \ve{h}} &amp;amp;= \int p(\ve{x}|\ve{\theta}) \frac{\left( \parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} p(\ve{x}|\ve{\theta})}{p(\ve{x}|\ve{\theta})} \mathrm{d}\ve{x}\ \ve{h} \\
&amp;amp;= \int \left( \parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} p(\ve{x}|\ve{\theta}) \mathrm{d}\ve{x}\  \ve{h} = \left( \parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} \int p(\ve{x}|\ve{\theta}) \mathrm{d}\ve{x}\  \ve{h} \quad (\because \text{正則条件}) \\
&amp;amp;= \left( \parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} 1 \ve{h} \\
&amp;amp;= 0 \\
\mean{p(\ve{x}|\ve{\theta})}{\frac{1}{2} \ve{h}^{\mathsf{T}} \ve{H}_{\ve{\theta}} \log p(\ve{x} | \ve{\theta}) \ve{h}} &amp;amp;= \frac{1}{2} \ve{h}^{\mathsf{T}} \mean{p(\ve{x}|\ve{\theta})}{\ve{H}_{\ve{\theta}} \log p(\ve{x} | \ve{\theta})} \ve{h} \\
&amp;amp;= -\frac{1}{2} \ve{h}^{\mathsf{T}} \ve{F} \ve{h}
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\KL{p(\ve{x}|\ve{\theta})}{p(\ve{x}|\ve{\theta} + \ve{h})} \approx \frac{1}{2} \ve{h}^{\mathsf{T}} \ve{F} \ve{h}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\ve{\theta}\)&lt;/span&gt; の近傍においてはフィッシャー情報行列が支配的になっていることがわかる。また、これにより確率分布のなす多様体のリーマン計量はフィッシャー情報行列であることがわかり、ここから情報幾何学が始まっていく。&lt;/p&gt;
&lt;p&gt;以上の議論を基に、確率分布間の違いをKLダイバージェンスで測ったとき、損失関数 &lt;span class="math"&gt;\(l(\ve{\theta})\)&lt;/span&gt; を最も減らす方向を考える。それは次の方向 &lt;span class="math"&gt;\(\ve{h}^{\ast}\)&lt;/span&gt; を見つけることに等しい：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{h}^{\ast} = \underset{\ve{h}\ \mathrm{s.t.} \KL{p(\ve{x}|\ve{\theta})}{p(\ve{x}|\ve{\theta} + \ve{h})} = c}{\mathrm{argmin}} l(\ve{\theta} + \ve{h})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;式の気持ちとしては、「KLダイバージェンスが定数 &lt;span class="math"&gt;\(c\)&lt;/span&gt; を取る中で、最も &lt;span class="math"&gt;\(l(\ve{\theta})\)&lt;/span&gt; を減らすベクトル &lt;span class="math"&gt;\(\ve{h}\)&lt;/span&gt; 」 である。これは制約付き最適化問題だから、ラグランジェの未定定数法により解くことを考える。ラグランジアン &lt;span class="math"&gt;\(\mathcal{L}\)&lt;/span&gt; は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mathcal{L} &amp;amp;= l(\ve{\theta} + \ve{h}) + \lambda \left\{ \KL{p(\ve{x}|\ve{\theta})}{p(\ve{x}|\ve{\theta} + \ve{h})} - c \right\} \\
&amp;amp;\approx l(\ve{\theta}) + \left( \parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} l(\ve{\theta}) \ve{h} + \lambda \left\{ \KL{p(\ve{x}|\ve{\theta})}{p(\ve{x}|\ve{\theta} + \ve{h})} - c \right\} \quad \text{（1次の項までテイラー展開）} \\
&amp;amp;\approx l(\ve{\theta}) + \left( \parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} l(\ve{\theta}) \ve{h} + \lambda \left\{ \frac{1}{2} \ve{h}^{\mathsf{T}} \ve{F} \ve{h} - c \right\}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\mathcal{L}\)&lt;/span&gt; を &lt;span class="math"&gt;\(\ve{h}\)&lt;/span&gt; で偏微分すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\parfrac{}{\ve{h}} \mathcal{L} &amp;amp;\approx \parfrac{}{\ve{h}} l(\ve{\theta}) + \parfrac{}{\ve{h}} \left( \parfrac{}{\ve{\theta}} \right)^{\mathsf{T}} l(\ve{\theta}) \ve{h} + \lambda  \left\{ \parfrac{}{\ve{h}} \frac{1}{2} \ve{h}^{\mathsf{T}} \ve{F} \ve{h} - \parfrac{}{\ve{h}} c \right\} \\
&amp;amp;= \parfrac{}{\ve{\theta}} l(\ve{\theta}) + \lambda \ve{F} \ve{h}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\parfrac{}{\ve{h}} \mathcal{L} = \ve{0}\)&lt;/span&gt; とおいて &lt;span class="math"&gt;\(\ve{h}\)&lt;/span&gt; について解くと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{h}^{\ast} = - \frac{1}{\lambda} \ve{F}^{-1} \parfrac{}{\ve{\theta}} l(\ve{\theta})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が得られる。 &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; はスカラーだからベクトルの方向を変えない。よって、 &lt;span class="math"&gt;\(\ve{F}^{-1} \parfrac{}{\ve{\theta}} l(\ve{\theta})\)&lt;/span&gt; が最急勾配であることが分かる。この勾配を &lt;strong&gt;自然勾配(Natural Gradient)&lt;/strong&gt; という。&lt;/p&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;ニュートン法と何が違うのか？&lt;/h2&gt;
&lt;p&gt;「 &lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.8668&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Adaptive Method of Realizing Natural Gradient Learning for Multilayer Perceptrons&lt;/a&gt; 」によると、
ニュートン法は教師信号を明示的に含んだ損失関数のへッシアンを使うが、自然勾配法は近似対象の標的関数とは独立した確率分布の空間Sの計量を使っているところが違うらしい。しかし一方で、対数尤度を損失関数、かつモデルが最適パラメタによって生成された教師信号yを生成するときはフィッシャー情報行列はヘッセ行列に一致する。このため、最適点において自然勾配法はニュートン法に一致する。とある。&lt;/p&gt;
&lt;p&gt;自分なりの解釈として線形回帰問題を考える。
誤差が◯◯分布に従って発生すると考えた瞬間に確率分布の空間が定まり、この空間の計量たるフィッシャー情報行列に従って学習するのが自然勾配学習法。一方、各点の損失関数のヘッセ行列（2階微分）を求めて最適化を進めるのがニュートン法。でいいのか？
恐らく、各点の損失関数を計算できるのならばニュートン法の方が優れている。&lt;/p&gt;
&lt;p&gt;発想としても差異があって、ニュートン法は損失関数の2次のテイラー展開から最適な勾配を求めるのに対し、自然勾配法はKLダイバージェンスが一定という制約のもとで最適な勾配を求めている（自然勾配法を導出するとき、損失関数の1次の項までしかテイラー展開していないのがミソ。2次まで展開すると損失関数のへッシアンが出てきてニュートン法と変わらない）。&lt;/p&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="記事"></category><category term="機械学習"></category><category term="情報幾何"></category></entry><entry><title>成果まとめ中(5) / 自然勾配法の概観</title><link href="/cheng-guo-matomezhong-5-zi-ran-gou-pei-fa-nogai-guan.html" rel="alternate"></link><published>2020-05-23T11:00:00+09:00</published><updated>2020-05-23T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-23:/cheng-guo-matomezhong-5-zi-ran-gou-pei-fa-nogai-guan.html</id><summary type="html">&lt;p&gt;昨日まで苦悩しつつ収束条件をまとめた（運良く見つけることができた。同時にNLMSの収束条件も掴んだ。）
でも、同時に新 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;昨日まで苦悩しつつ収束条件をまとめた（運良く見つけることができた。同時にNLMSの収束条件も掴んだ。）
でも、同時に新規性が無い気がしてきた。発見となるのは、SignedLMSのフィッシャー情報行列が自己相関行列になっているくらいか？
適応ステップサイズ導出後は、普通のフィッシャー情報行列込みのNLMSと全く同じだし。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>成果まとめ中(4)</title><link href="/cheng-guo-matomezhong-4.html" rel="alternate"></link><published>2020-05-21T23:00:00+09:00</published><updated>2020-05-21T23:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-21:/cheng-guo-matomezhong-4.html</id><summary type="html">&lt;p&gt;AdaptiveFilterの本見てNLMSの議論を色々見てる。が、いい結果が出てこない。
本の内容も掴みかねてる。NLMSは係数誤差ベクトルのL2ノル …&lt;/p&gt;</summary><content type="html">&lt;p&gt;AdaptiveFilterの本見てNLMSの議論を色々見てる。が、いい結果が出てこない。
本の内容も掴みかねてる。NLMSは係数誤差ベクトルのL2ノルムが指数的に減少するようだが本当か…？&lt;/p&gt;
&lt;p&gt;LMSの収束条件が分かっていないことに気づく。
「Adaptive Filter Theory」では式4.22に、「Adaptive Signal Processing」では式4.45で示されているので確認中。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>成果まとめ中(3)</title><link href="/cheng-guo-matomezhong-3.html" rel="alternate"></link><published>2020-05-20T23:00:00+09:00</published><updated>2020-05-20T23:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-20:/cheng-guo-matomezhong-3.html</id><summary type="html">&lt;p&gt;SGD（確率的最急勾配法）の収束レートが少し気になったのちょっと観察。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/bjsiam/28/3/28_27/_pdf"&gt;機械学習における確率的最適化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もっと初等的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;SGD（確率的最急勾配法）の収束レートが少し気になったのちょっと観察。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/bjsiam/28/3/28_27/_pdf"&gt;機械学習における確率的最適化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もっと初等的な説明があると良いなあ。確率1で極値に収束したような気がしている…。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;適応ステップサイズの分母の &lt;span class="math"&gt;\(\ve{x}(n)^{\mathsf{T}}\ve{R}^{-1}\ve{x}(n)\)&lt;/span&gt; がめちゃくちゃ気になって止まる。学習理論に「例えばパラメタ空間上のベクトル &lt;span class="math"&gt;\(x(\theta)\)&lt;/span&gt; の内積 &lt;span class="math"&gt;\(\innerp{x}{x}\)&lt;/span&gt; は、座標変換により不変な量として定義するならば &lt;span class="math"&gt;\(x^{\prime}(g_{ij}(\theta))^{-1}x\)&lt;/span&gt; となる。」（なるべく原文ママ）と言ってて、まさにこの不変な量を指していると思っている。&lt;/p&gt;
&lt;p&gt;これどういうこと？と思って探し始めたら沼。相対性理論にぶつかる。わかりやすかったのは下くらいか？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://yuru2physics.blog.fc2.com/blog-entry-99.html"&gt;内積が不変という意味&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://fnorio.com/0180covariant_contravariant/covariant_contravariant.html#3-6"&gt;(6)ベクトル内積の座標変換不変性の確認&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;情報幾何の観点からすると、幾何的に微小線素は座標変換によって値を全く変えないことが重要らしい。&lt;span class="math"&gt;\(\ve{x}(n)\)&lt;/span&gt; をパラメタ空間上のベクトルと捉えると、&lt;span class="math"&gt;\(\ve{R}^{-1}\)&lt;/span&gt; はパラメタ空間上の計量（元の空間の計量は:math:&lt;cite&gt;ve{R}&lt;/cite&gt; ）を定め、&lt;span class="math"&gt;\(\ve{x}(n)^{\mathsf{T}}\ve{R}^{-1}\ve{x}(n)\)&lt;/span&gt; はパラメタ空間上のノルムを計算していて、ノルムだから不変でしょっていう議論になる？まだピンとこない。&lt;/p&gt;
&lt;p&gt;あと、AdaptiveFilterの本見てNLMSの議論を色々見てる。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>成果まとめ中(2)</title><link href="/cheng-guo-matomezhong-2.html" rel="alternate"></link><published>2020-05-19T11:00:00+09:00</published><updated>2020-05-19T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-19:/cheng-guo-matomezhong-2.html</id><content type="html">&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://dsl4.eee.u-ryukyu.ac.jp/DOCS/DSP/p10.pdf"&gt;ディジタル信号処理 第 10 回 適応信号処理&lt;/a&gt; 少し詳しく書いてある。やはり適応フィルタの原典を当たりたい。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>書類整理終わり、復帰 / 成果まとめ中(1)</title><link href="/shu-lei-zheng-li-zhong-wari-fu-gui-cheng-guo-matomezhong-1.html" rel="alternate"></link><published>2020-05-18T11:00:00+09:00</published><updated>2020-05-18T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-18:/shu-lei-zheng-li-zhong-wari-fu-gui-cheng-guo-matomezhong-1.html</id><summary type="html">&lt;p&gt;諸々の提出書類で実験できず。1週間空けて復帰。&lt;/p&gt;
&lt;p&gt;報告書類を書いていたら、やっぱりフィッシャー情報行列とヘッセ行 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;諸々の提出書類で実験できず。1週間空けて復帰。&lt;/p&gt;
&lt;p&gt;報告書類を書いていたら、やっぱりフィッシャー情報行列とヘッセ行列の違いがよくわからなくなってきた。
対数尤度のヘッセ行列とフィッシャー情報行列に何かしらの共通点があるはず。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.inference.vc/on-empirical-fisher-information/"&gt;Notes on the Limitations of the Empirical Fisher Approximation&lt;/a&gt; 経験フィッシャー行列の性能限界について。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ヘッセ行列のくだりから自然勾配の導出まで、紙に証明をまとめた。明日辺りに記事に起こす。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>LMS Filterの挙動観察中(10)</title><link href="/lms-filternoju-dong-guan-cha-zhong-10.html" rel="alternate"></link><published>2020-05-06T11:00:00+09:00</published><updated>2020-05-06T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-06:/lms-filternoju-dong-guan-cha-zhong-10.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Normalizeするやつの意味付けを追っている。非常にRLS(Recursive Least Square)に近い …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Normalizeするやつの意味付けを追っている。非常にRLS(Recursive Least Square)に近い、下手するとRLSそのものかも知れない。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>書類整理中</title><link href="/shu-lei-zheng-li-zhong.html" rel="alternate"></link><published>2020-05-06T11:00:00+09:00</published><updated>2020-05-06T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-06:/shu-lei-zheng-li-zhong.html</id><summary type="html">&lt;p&gt;色々と書類整理しているためあんまり実験が進んでいない。でも、既存研究がありそうでヒヤヒヤする毎日。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://scholarsmine.mst.edu/cgi/viewcontent.cgi?article=2780&amp;amp;context=ele_comeng_facwork"&gt;Normalized Natural Gradient Adaptive Filtering …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;色々と書類整理しているためあんまり実験が進んでいない。でも、既存研究がありそうでヒヤヒヤする毎日。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://scholarsmine.mst.edu/cgi/viewcontent.cgi?article=2780&amp;amp;context=ele_comeng_facwork"&gt;Normalized Natural Gradient Adaptive Filtering for Sparse and Nonsparse Systems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;かなり近い。が、LMSベースの計量を自ら設計している。コスト関数に、2乗誤差項に何か変換のL2ノルムを加算しており、それに対しての自然勾配を求めている。そうか、コスト関数の自然勾配を考えればいいのか。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pdfs.semanticscholar.org/bf3b/fe757d9156cc863ffdde15b1664c337819bd.pdf"&gt;Proportionate Normalized Least-Mean-Squares Adaptation in Echo Cancelers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自然勾配の発想に近づいていたPNLMSの実装&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.eecs.umich.edu/global/data/hero/images/7/7b/Yilun-icassp2-09.pdf"&gt;SPARSE LMS FOR SYSTEM IDENTIFICATION&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;スパースLMS(ZA-LMS)の最初の論文。定式化が明確。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>LMS Filterの挙動観察中(9)</title><link href="/lms-filternoju-dong-guan-cha-zhong-9.html" rel="alternate"></link><published>2020-05-05T11:00:00+09:00</published><updated>2020-05-05T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-05:/lms-filternoju-dong-guan-cha-zhong-9.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;実装誤りを見直しながらもう一度。&lt;/p&gt;
&lt;p&gt;やはり、自然勾配法が何故 …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;実装誤りを見直しながらもう一度。&lt;/p&gt;
&lt;p&gt;やはり、自然勾配法が何故うまくいくのか、更新式の導出までやったほうが宜しい。実装間違いするから。適応的自然勾配の更新式は微小量の近似を使っている。微小量の近似は今まで何度も避けてきたが、この際おさらいする。ようはテイラー展開して2次以降の項を打ち切れば良し。高校数学レベルの話。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://physnotes.jp/foundations/approximation/"&gt;近似式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://w3e.kanazawa-it.ac.jp/math/category/suuretu/maclaurin/henkan-tex.cgi?target=/math/category/suuretu/maclaurin/maclaurin_1-x.html"&gt;1/(1-x)のマクローリン展開&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実験が落ち着いたら書いていきたい。&lt;/p&gt;
&lt;p&gt;→実験OK。ステップサイズの設定が難しかったけど、ナイーブなものよりは性能がよいはず。&lt;/p&gt;
&lt;p&gt;また、軽く見た感じでも自然勾配学習法は発散しやすい。以下の記事にあるように、正則化を掛けたほうが良さそう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://tfjgeorge.github.io/articles/note/2018/11/09/empirical-fisher.html"&gt;What is the empirical Fisher ?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ヘッセ行列の計算は少し回り道になったが、理論的最適値との比較において議論できそう。&lt;/p&gt;
&lt;p&gt;逆行列補題を使っていて、最早カルマンフィルタやRLSに近いんでないかと思えてきた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.bode.amp.i.kyoto-u.ac.jp/~kashima/lecture/ss/slide17_8.pdf"&gt;信号とシステム 第6章 適応フィルタ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cs.tut.fi/~tabus/course/ASP/LectureNew10.pdf"&gt;Recursive Least Squares Estimation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;にLMSからRLSまで記述あり。&lt;/p&gt;
&lt;p&gt;上の「信号とシステム」を眺めていたら、NLMSにおける適応的ステップサイズ決定則が使えそうな印象。NLMSは事後誤差 &lt;span class="math"&gt;\(e^{+}(k)\)&lt;/span&gt; を0にするように適応的なステップサイズ &lt;span class="math"&gt;\(\alpha(k)\)&lt;/span&gt; を定める。普通のSigned-LMSでは、リファレンス信号 &lt;span class="math"&gt;\(d(k)\)&lt;/span&gt;, フィルタ係数 &lt;span class="math"&gt;\(\ve{h}(k)\)&lt;/span&gt;, 入力データ &lt;span class="math"&gt;\(\ve{x}(k)\)&lt;/span&gt; に対し、事後誤差は次のように展開できる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
e^{+}(k) &amp;amp;= d(k) - \innerp{\ve{h}(k+1)}{\ve{x}(k)} \\
&amp;amp;= d(k) - \innerp{\ve{h}(k) + \alpha(k) \mathrm{sign}[e(k)] \ve{x}(k)}{\ve{x}(k)} \\
&amp;amp;= d(k) - \innerp{\ve{h}(k)}{\ve{x}(k)} - \alpha(k) \mathrm{sign}[e(k)] \innerp{\ve{x}(k)}{\ve{x}(k)} \\
&amp;amp;= e(k) - \alpha(k) \mathrm{sign}[e(k)] ||\ve{x}(k)||_{2}^{2}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(e^{+}(k) = 0\)&lt;/span&gt; となるように &lt;span class="math"&gt;\(\alpha(k)\)&lt;/span&gt; を選ぶと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\alpha(k) = \frac{e(k)}{\mathrm{sign}[e(k)] ||\ve{x}(k)||_{2}^{2}} = \frac{|e(k)|}{||\ve{x}(k)||_{2}^{2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;として、事後誤差を最小にするステップサイズが求まった。（Signed-LMSでこういう議論があんまり見られないのはなぜだ？&lt;strong&gt;この&lt;/strong&gt; &lt;span class="math"&gt;\(\alpha(k)\)&lt;/span&gt; &lt;strong&gt;をSigned-LMSの更新則に突っ込むとNLMSになる&lt;/strong&gt; ）&lt;/p&gt;
&lt;p&gt;自然勾配を使った場合が有益（ステップサイズ設定つらい）なので、求めてみると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
e^{+}(k) &amp;amp;= d(k) - \innerp{\ve{h}(k+1)}{\ve{x}(k)} \\
&amp;amp;= d(k) - \innerp{\ve{h}(k) + \alpha(k) \mathrm{sign}[e(k)] \ve{F}(k)^{-1} \ve{x}(k)}{\ve{x}(k)} \\
&amp;amp;= d(k) - \innerp{\ve{h}(k)}{\ve{x}(k)} - \alpha(k) \mathrm{sign}[e(k)] \innerp{\ve{F}(k)^{-1}\ve{x}(k)}{\ve{x}(k)} \\
&amp;amp;= e(k) - \alpha(k) \mathrm{sign}[e(k)] \innerp{\ve{x}(k)}{\ve{F}(k)^{-1}\ve{x}(k)}
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\alpha(k) = \frac{e(k)}{\mathrm{sign}[e(k)] \innerp{\ve{x}}{\ve{F}(k)^{-1}\ve{x}(k)}} = \frac{|e(k)|}{\innerp{\ve{x}(k)}{\ve{F}(k)^{-1}\ve{x}(k)}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が得られる。これは計量としてフィッシャー情報行列の逆行列を使った時の &lt;span class="math"&gt;\(\ve{x}(k)\)&lt;/span&gt; のノルムによる正規化に対応する。すると残差の絶対値が外れる。NLMSとかなり近いけど計量が入っているところが違う。&lt;/p&gt;
&lt;p&gt;実装してみたら実験でも音源に依存せず安定している印象（注意！ノイズのない正弦波で発散した！おそらく、情報行列の要素が全て同一で特異になっている。）。&lt;/p&gt;
&lt;p&gt;結果の意味付けが非常に大事な気がする。資料35pあたりの議論を当てはまると、何か幾何的な解釈が出てくるはずだ。改めて、ここらへんの議論って誰かやっていないか、気になる。明日はそこを考えてみる。改めて既存研究が無いか見て、報告に移そうか。&lt;/p&gt;
&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Normalizeするやつの結果の意味付け&lt;/li&gt;
&lt;li&gt;忘却係数として捉えれば式が簡単にならんか？ &lt;span class="math"&gt;\((\lambda \ve{F} + \ve{x}\ve{x}^{\mathsf{T}})^{-1}\)&lt;/span&gt; で &lt;span class="math"&gt;\(0 &amp;lt; \lambda &amp;lt; 1\)&lt;/span&gt; は1に近い係数。&lt;/li&gt;
&lt;li&gt;自然勾配法がなんでうまくいくのか &lt;a class="reference external" href="https://wiseodd.github.io/techblog/2018/03/14/natural-gradient/"&gt;Natural Gradient Descent&lt;/a&gt; を訳しながら理解していく。 &lt;a class="reference external" href="https://arxiv.org/pdf/1412.1193.pdf"&gt;New insights and perspectives on the natural gradient method&lt;/a&gt; も参考になりそう。&lt;/li&gt;
&lt;li&gt;RLS(Recursive Least Square)の更新式の誤差に符号関数を被せたものが、自分が導いているものかも知れないと思い立つ。確認。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="RLS"></category><category term="Natural Gradient"></category><category term="Empirical Fisher"></category></entry><entry><title>LMS Filterの挙動観察中(8)</title><link href="/lms-filternoju-dong-guan-cha-zhong-8.html" rel="alternate"></link><published>2020-05-04T11:00:00+09:00</published><updated>2020-05-04T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-04:/lms-filternoju-dong-guan-cha-zhong-8.html</id><summary type="html">&lt;p&gt;まだ粘る。GW終わるまでには何らかのアウトプットがほしい。&lt;/p&gt;
&lt;p&gt;指数移動平均のαを増やすと性能（誤差、エントロピー）が悪 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;まだ粘る。GW終わるまでには何らかのアウトプットがほしい。&lt;/p&gt;
&lt;p&gt;指数移動平均のαを増やすと性能（誤差、エントロピー）が悪化する傾向あり。特に0.5以上（瞬間値の重みを大きく）すると、悪化が顕著。&lt;/p&gt;
&lt;p&gt;分散行列の逆行列を見てみると、非常に大きい値を取っていることが分かる。これは特異にかなり近いのではないかと予測している。&lt;/p&gt;
&lt;p&gt;また、指数移動平均で求めた分散行列の対角要素は経験分散に漸近するはずで、対角要素は時間遅延が加わった自分自身との2乗和で、全てが同じ値になることを期待していたが、なっていなかった。これは、指数移動平均は入力の順序により最終結果が異なるという状態が現れていると思う。（例：1,1,1,0 という系列と 0,1,1,1 という系列では指数移動平均の結果が異なる。）&lt;/p&gt;
&lt;p&gt;学習率の設定も音源依存でだいぶ変わってしまう印象。ボイスでは 0.0001 が、ピアノでは 0.00001、50Hzサイン波では発散した（恐らくこれはほぼ定常な信号になっているからと思われる。定常な信号では全ての分散と共分散が同じ値になって、行列が特異になる。正則化（分散行列に定数を掛けた単位行列を加算）を行ったら安定した...）&lt;/p&gt;
&lt;p&gt;行き詰まりを感じ、適応的自然勾配の更新式を逆行列補題（Woodburyの恒等式）から導いていた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mathtrain.jp/woodbury"&gt;逆行列の補助定理（Woodburyの恒等式）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://sigmagic.net/math/inverse-mat/"&gt;逆行列の公式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そのときに、論文では勾配ベクトルの分散行列を求めていることに気づく。そして自分が間違っている事がわかった。
情報行列は勾配ベクトルの分散行列だった。（データベクトルの分散行列ではない...）
いままで入力データの分散行列を計算していたので、これは明確な誤り。&lt;/p&gt;
&lt;p&gt;フィッシャー情報行列はスコア関数（対数尤度関数の勾配）の分散行列で定義される。よって、情報行列とデータの分散行列は一般に一致しない。&lt;/p&gt;
&lt;p&gt;もう一つ自然勾配とフィッシャー情報行列に関する有益な情報源あり:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://tfjgeorge.github.io/articles/note/2018/11/09/empirical-fisher.html"&gt;What is the empirical Fisher ?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今一度Jupyterから出戻りしてみる。
思ったけど、今考えているのは絶対値誤差最小化のためにSigned-LMSだけど、データ側を符号とするLMSや、Sign-SignLMSの解析もありじゃないかと思ってきた。データ側を符号とするLMSは何を最小化しているのか？などが気になる。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category></entry><entry><title>LMS Filterの挙動観察中(7)</title><link href="/lms-filternoju-dong-guan-cha-zhong-7.html" rel="alternate"></link><published>2020-05-03T11:00:00+09:00</published><updated>2020-05-03T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-03:/lms-filternoju-dong-guan-cha-zhong-7.html</id><summary type="html">&lt;p&gt;実データ適用で、どうも上手く行かない。やっぱり分散行列の逆行列が発散している。&lt;/p&gt;
&lt;p&gt;適応的自然勾配をやめて、真面目 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;実データ適用で、どうも上手く行かない。やっぱり分散行列の逆行列が発散している。&lt;/p&gt;
&lt;p&gt;適応的自然勾配をやめて、真面目に（毎サンプル平均を求めて）計算するようにしているけども結果がよろしくない。分散行列を標本平均ではなくて指数移動平均（α=0.1）に置き換えたらそれなりの性能が出ることを確認。しかし、ラプラス分布の計量を取り入れていない...。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category></entry><entry><title>LMS Filterの挙動観察中(6)</title><link href="/lms-filternoju-dong-guan-cha-zhong-6.html" rel="alternate"></link><published>2020-05-02T11:00:00+09:00</published><updated>2020-05-02T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-02:/lms-filternoju-dong-guan-cha-zhong-6.html</id><summary type="html">&lt;p&gt;今日は実装整理して実データへ適用してみる。気になってるのが適応的自然勾配の更新式。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;確率の重み付けは正規化 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;今日は実装整理して実データへ適用してみる。気になってるのが適応的自然勾配の更新式。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;確率の重み付けは正規化しないと使えそうにないということ。&lt;/li&gt;
&lt;li&gt;確率の重み付けをしても問題ないか？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実データ適用、うーん性能が良くない！発散する！実装を確認しながら進行中。情報行列の逆行列を正規化すると発散はしないけど、逆行列がほぼ単位行列とほぼ同一で、元のSignedLMSと性能が同等。。。
まずは、適応的自然勾配じゃなくて負荷でかいけど真面目に計算する方針で行ってみる。&lt;/p&gt;
&lt;p&gt;また、フィルタ処理をfor文でやるよりnumpyの演算にした方が格段に早かった。numpy大事。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category></entry><entry><title>LMS Filterの挙動観察中(5)</title><link href="/lms-filternoju-dong-guan-cha-zhong-5.html" rel="alternate"></link><published>2020-05-01T11:00:00+09:00</published><updated>2020-05-01T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-05-01:/lms-filternoju-dong-guan-cha-zhong-5.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;別のことをしているときに、ふと適応的自然勾配学習法を弄 …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;別のことをしているときに、ふと適応的自然勾配学習法を弄ってて、なんとなくIRLSに応用できそうな印象が。
以下のような式でヘッセ行列（というか、重み付きの分散行列）を更新する。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{H} \leftarrow \ve{H} + \frac{1}{|y_{i} - \ve{\beta}^{\mathsf{T}} \ve{x}|} \ve{x} \ve{x}^{\mathsf{T}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;他にも、ICA（独立成分分析）の尖度最大化（優ガウス分布化）の学習がなんか使えないかと考えつつある。でもこれはICAによるノイズ除去にだいぶ近い話になりそう。&lt;/p&gt;
&lt;p&gt;分散行列と自己相関行列、だいぶ定義が近いな…間違ってないかなと思って再確認。分散行列と言ってるものはもしかしたら自己相関行列の誤りかもしれない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mathtrain.jp/correlationmatrix"&gt;相関行列の定義と分散共分散行列との関係&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ip.info.eng.osaka-cu.ac.jp/~kazunori/paper/rcs201610_handout.pdf"&gt;初学者のための無線通信信号処理入門&lt;/a&gt; に明確に定義されてる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;平均0化していたら分散行列と自己相関行列は同一になりそうな雰囲気。雰囲気じゃだめでちゃんと確認すべき。&lt;/p&gt;
&lt;p&gt;寄り道しすぎたので、改めて結果をまとめていく。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category></entry><entry><title>LMS Filterの挙動観察中(4)</title><link href="/lms-filternoju-dong-guan-cha-zhong-4.html" rel="alternate"></link><published>2020-04-30T11:00:00+09:00</published><updated>2020-04-30T11:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-30:/lms-filternoju-dong-guan-cha-zhong-4.html</id><summary type="html">&lt;p&gt;本日も引き続き発散の原因を追う。
→ステップサイズを小さくしたら発散しなくなった…。職人芸じゃないかこんなの。NLMS …&lt;/p&gt;</summary><content type="html">&lt;p&gt;本日も引き続き発散の原因を追う。
→ステップサイズを小さくしたら発散しなくなった…。職人芸じゃないかこんなの。NLMSみたく発散しない条件がほしいな。&lt;/p&gt;
&lt;p&gt;本当に既存研究がないか、再度調査。&lt;/p&gt;
&lt;p&gt;自然勾配を適応的に計算する方法を試している。無論、定義式通りに計算するのは問題ないことは確かめているが、計算量が気になるのです。&lt;/p&gt;
&lt;p&gt;パラメータを色々といじりつつ、論文も参照してそれなりのパラメータを見つける。
パラメータについては &lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=5&amp;amp;ved=2ahUKEwi4ufHi4o_pAhUY_GEKHd-gDBwQFjAEegQIBRAB&amp;amp;url=https%3A%2F%2Fwww.mdpi.com%2F2076-3417%2F9%2F21%2F4568%2Fpdf&amp;amp;usg=AOvVaw0KgakdcC8U_T71ks8hZKDW"&gt;Adaptive Natural Gradient Method for Learning of Stochastic Neural Networks in Mini-Batch Mode&lt;/a&gt; を皮切りに調査開始。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.8668&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Adaptive Method of Realizing Natural Gradient Learning for Multilayer Perceptrons&lt;/a&gt; が甘利先生。（福水先生もいるぞ）&lt;ul&gt;
&lt;li&gt;この論文で適応的更新式の導出が述べられる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bsi-ni.brain.riken.jp/database/file/215/221.pdf"&gt;Adaptive natural gradient learning algorithms for various stochastic models&lt;/a&gt; も甘利先生。（福水先生もいるぞ）&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://downloads.hindawi.com/archive/2011/407497.pdf"&gt;A Simplified Natural Gradient Learning Algorithm&lt;/a&gt; 更にシンプルにしたもの。2011年。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Toy-problemとして中央値の逐次推定とかアリではと、少しだけ思った。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="LAD"></category></entry><entry><title>LMS Filterの挙動観察中(3)</title><link href="/lms-filternoju-dong-guan-cha-zhong-3.html" rel="alternate"></link><published>2020-04-29T23:40:00+09:00</published><updated>2020-04-29T23:40:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-29:/lms-filternoju-dong-guan-cha-zhong-3.html</id><summary type="html">&lt;p&gt;LMSはヘッセ行列の逆行列込みの学習ができているが、Signed-LMSは上手く行かない。分散行列が特異になったり、要素が大きく …&lt;/p&gt;</summary><content type="html">&lt;p&gt;LMSはヘッセ行列の逆行列込みの学習ができているが、Signed-LMSは上手く行かない。分散行列が特異になったり、要素が大きくなりすぎて発散してしまう。。。&lt;/p&gt;
</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="LAD"></category></entry><entry><title>LMS Filterの挙動観察中(2)</title><link href="/lms-filternoju-dong-guan-cha-zhong-2.html" rel="alternate"></link><published>2020-04-28T23:40:00+09:00</published><updated>2020-04-28T23:40:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-28:/lms-filternoju-dong-guan-cha-zhong-2.html</id><summary type="html">&lt;p&gt;つまるところ、以下の計算をどうやるか？に尽きる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right] = \lim_{N \to \infty} \frac{1}{N} \sum_{n = 1, \varepsilon(n) = 0}^{N …&lt;/div&gt;</summary><content type="html">&lt;p&gt;つまるところ、以下の計算をどうやるか？に尽きる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right] = \lim_{N \to \infty} \frac{1}{N} \sum_{n = 1, \varepsilon(n) = 0}^{N} x(n - m) x(n - k)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\varepsilon(n)\)&lt;/span&gt; はi.i.d.（独立に同一の分布）から発生しているので、&lt;span class="math"&gt;\(x(n-m), x(n-k)\)&lt;/span&gt; には依存しない（予測係数にも依らず）で勝手に揺れると考える。&lt;/p&gt;
&lt;p&gt;でもそんな計算は見たことがない。そもそもLADの文脈でこの話は出ているはずで、「Laplace Distribution linear regression」で検索掛けていたら、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://downloads.hindawi.com/journals/jam/2014/856350.pdf"&gt;Robust Mean Change-Point Detecting through Laplace Linear Regression Using EM Algorithm&lt;/a&gt; を見つけた。&lt;ul&gt;
&lt;li&gt;イントロで「 &lt;strong&gt;ラプラス分布は正規分布の混合で表せる&lt;/strong&gt; 」と「 &lt;strong&gt;混合を前提にしたEMアルゴリズムが存在する&lt;/strong&gt; 」というのを見つけて、論文探しが改めて動く。混合ガウス分布をEMアルゴリズムで学習する話はよく聞くから、本質的なのは正規分布の混合で表せていることか。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://core.ac.uk/download/pdf/16705381.pdf"&gt;ROBUST MIXTURE REGRESSION MODEL FITTING BY LAPLACE DISTRIBUTION&lt;/a&gt; は2013年の論文。印象的なのは、 &lt;strong&gt;IRLSはEMアルゴリズムの一種だということ。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=2ahUKEwi287j_j4rpAhXKA4gKHUlmAIUQFjAAegQIBBAB&amp;amp;url=https%3A%2F%2Fkwansei.repo.nii.ac.jp%2Findex.php%3Faction%3Dpages_view_main%26active_action%3Drepository_action_common_download%26item_id%3D26097%26item_no%3D1%26attribute_id%3D22%26file_no%3D1%26page_id%3D30%26block_id%3D85&amp;amp;usg=AOvVaw0TY8ejg2Duf0nYYdMvrVD_"&gt;ラプラス確率的フロンティアモデルのベイズ推定&lt;/a&gt; は日本語でラプラス分布の混合について述べた論文&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.math.chalmers.se/Stat/Grundutb/GU/MSA220/S16/bayeslasso.pdf"&gt;The Bayesian Lasso&lt;/a&gt; はLASSOを、パラメータの事前分布をラプラス分布としたものとして定式化している。ラプラス分布は直接扱わず、混合を考えている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実験で試している、勾配ベクトルに分散行列（ヘッセ行列）の逆行列を掛ける行為は、ウィーナーフィルタに等しい。しかしウィーナーフィルタは観測分散行列 &lt;span class="math"&gt;\(\ve{XX}^{\mathsf{T}}\)&lt;/span&gt; が正則でないと計算できない。そこで、観測分散行列の低ランク近似を行ってその擬似逆行列を使ってフィルタ係数を更新していく手法がある。それを Reduced rank adaptive filters というらしい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1504.06054.pdf"&gt;A New Approach to Adaptive Signal Processing&lt;/a&gt; で触れていた。この論文は適応フィルタを広汎的に見ており、有益。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www-users.york.ac.uk/~rcdl500/SPL_JIO_2007.pdf"&gt;Reduced-Rank Adaptive Filtering Based on Joint Iterative Optimization of Adaptive Filters&lt;/a&gt; ではReduced rank adaptive filtersのフィルタバンク版&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;邪念が動いて、パーティクルフィルター（粒子フィルター）でパラメータ決められんか考えてる。でも、LMSは状態空間モデルの範疇に入るのだろうか？（カルマンフィルタの一部だから当てはまったはず）。また、一般の状態空間モデルと違って状態は常に観測できるよな。またパーティクルフィルターもシミュレーションベースなので負荷が高そう。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.allisone.co.jp/html/Notes/DSP/Filter/particle-filter/index.html"&gt;パーティクル・フィルタをやさしく解説&lt;/a&gt; が確かに優しい。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.terrapub.co.jp/journals/jjssj/pdf/4401/44010189.pdf"&gt;粒子フィルタの基礎と応用: フィルタ・平滑化・パラメータ推定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="mathrm-e-left-delta-varepsilon-n-x-n-m-x-n-k-right"&gt;
&lt;h2&gt;&lt;span class="math"&gt;\(\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right]\)&lt;/span&gt; の解釈&lt;/h2&gt;
&lt;p&gt;結局 &lt;span class="math"&gt;\(\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right]\)&lt;/span&gt; の解釈から逃げている...。もう少し考えていたら、残差 &lt;span class="math"&gt;\(\varepsilon\)&lt;/span&gt; は入力ベクトル &lt;span class="math"&gt;\(x\)&lt;/span&gt; と独立であることを思い出した。ここから、次が言える。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mathrm{E} \left[\delta(\varepsilon(n)) x(n - m) x(n - k) \right] = \mathrm{E} \left[ \delta(\varepsilon(n)) \right] \mathrm{E} \left[ x(n - m) x(n - k) \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで、 &lt;span class="math"&gt;\(\mathrm{E} \left[ \delta(\varepsilon(n)) \right]\)&lt;/span&gt; はお察しの通りで、以下の通りに、やはり残差が0となる確率が出てくる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mathrm{E} \left[ \delta(\varepsilon(n)) \right] &amp;amp;= \lim_{N \to \infty} \frac{1}{N} \sum_{n = 1}^{N} \delta(\varepsilon(n)) = \lim_{N \to \infty} \frac{1}{N} \sum_{n = 1, \varepsilon(n) = 0}^{N} 1 \\
&amp;amp;= P(\varepsilon = 0)
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mathrm{E} \left[\delta(\varepsilon(n)) x(n - m) x(n - k) \right] = P(\varepsilon = 0) \mathrm{E} \left[ x(n - m) x(n - k) \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(P(\varepsilon = 0)\)&lt;/span&gt; を考える。まず注意したいのは、連続型確率分布においては一点0をとる確率は0ということ（測度0だから）。近似するしかなく、方針としては、&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;残差の閾値を定めて、それ以下の数値を残差0とみなして確率を求める&lt;/li&gt;
&lt;li&gt;離散型確率分布で考える&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ラプラス分布の基本的なことをおさらいすると、確率密度関数 &lt;span class="math"&gt;\(f(x, \mu, \sigma)\)&lt;/span&gt; は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(x, \mu, \sigma) = \frac{1}{2 \sigma} \exp\left( - \frac{|x - \mu|}{\sigma} \right)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;で、観測 &lt;span class="math"&gt;\(x_{1}, ..., x_{N}\)&lt;/span&gt; が得られた時の尤度関数 &lt;span class="math"&gt;\(L(\mu, \sigma)\)&lt;/span&gt; と対数尤度関数は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
L(\mu, \sigma) &amp;amp;= \prod_{i = 1}^{N} \frac{1}{2 \sigma} \exp\left( - \frac{|x_{i} - \mu|}{\sigma} \right) = \frac{1}{(2 \sigma)^{N}} \prod_{i = 1}^{N} \exp\left( - \frac{|x_{i} - \mu|}{\sigma} \right) \\
\log L(\mu, \sigma) &amp;amp;= -N\log(2\sigma) -\sum_{i = 1}^{N} \frac{|x_{i} - \mu|}{\sigma} = -N\log(2\sigma) - \frac{1}{\sigma}\sum_{i = 1}^{N} |x_{i} - \mu|
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\mu\)&lt;/span&gt; の最尤推定量は標本中央値となる。&lt;span class="math"&gt;\(\mu\)&lt;/span&gt; が求まったとして、次は &lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; の最尤推定値を考える。対数尤度関数を &lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; で偏微分すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\partial}{\partial \sigma} \log L(\mu, \sigma) = -2 \frac{N}{2\sigma} + \frac{1}{\sigma^{2}} \sum_{i = 1}^{N} |x_{i} - \mu| = -\frac{N}{\sigma} + \frac{1}{\sigma^{2}} \sum_{i = 1}^{N} |x_{i} - \mu|
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\frac{\partial}{\partial \sigma} \log L(\mu, \sigma) = 0\)&lt;/span&gt; とおいて &lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; について解くと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{N}{\sigma} = \frac{1}{\sigma^{2}} \sum_{i = 1}^{N} |x_{i} - \mu| \Rightarrow \sigma = \frac{1}{N} \sum_{i = 1}^{N} |x_{i} - \mu|
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; の最尤推定値は偏差の絶対値の標本平均となる。次に離散ラプラス分布を考える（ &lt;a class="reference external" href="https://shodhganga.inflibnet.ac.in/bitstream/10603/30871/11/11_chapter%206.pdf"&gt;ここ&lt;/a&gt; を参考にしている）。離散ラプラス分布は次の確率（質量）関数 &lt;span class="math"&gt;\(P\)&lt;/span&gt; を持つ:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
P(X = k) &amp;amp;= \frac{f(k, 0, \sigma)}{\sum_{j = -\infty}^{\infty} f(j, 0, \sigma)} = \frac{\exp\left( -\frac{|k|}{\sigma} \right)}{\sum_{j = -\infty}^{\infty} \exp\left( -\frac{|j|}{\sigma} \right)} \\
&amp;amp;= \frac{\exp\left( -\frac{|k|}{\sigma} \right)}{1 + 2 \sum_{j = 1}^{\infty} \exp\left( -\frac{j}{\sigma} \right)}
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\sum_{j = 1}^{\infty} \exp\left( -\frac{j}{\sigma} \right) = \lim_{n \to \infty} \frac{\exp(-1/\sigma)(1 - \exp(-n/\sigma))}{1 - \exp(-1/\sigma)} = \frac{\exp(-1/\sigma)}{1 - \exp(-1/\sigma)}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;よって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
P(X = k) &amp;amp;= \frac{\exp\left( -\frac{|k|}{\sigma} \right)}{1 + 2 \frac{\exp(-1/\sigma)}{1 - \exp(-1/\sigma)}} = \frac{1 - \exp(-1/\sigma)}{1 + \exp(-1/\sigma)} \exp\left(-\frac{|k|}{\sigma}\right) \\
&amp;amp;= \frac{1 - p}{1 + p} p^{|k|}, \quad p = \exp(-1/\sigma)
\end{align*}
&lt;/div&gt;
&lt;p&gt;これは離散型確率分布であることに注意。&lt;/p&gt;
&lt;p&gt;連続版かつ &lt;span class="math"&gt;\(\mu=0\)&lt;/span&gt; で、 &lt;span class="math"&gt;\(|x|\)&lt;/span&gt; がある閾値 &lt;span class="math"&gt;\(\delta &amp;gt; 0\)&lt;/span&gt; 以下となる確率は次のように計算できる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
P(|x| \leq \delta) &amp;amp;= \int^{\delta}_{-\delta} f(x, \mu, \sigma) dx = \frac{1}{2 \sigma} \int^{\delta}_{-\delta} \exp\left(-\frac{|x|}{\sigma} \right) dx \\
&amp;amp;= \frac{2}{2\sigma} \int^{\delta}_{0} \exp\left(-\frac{x}{\sigma} \right) dx = \frac{1}{\sigma} (-\sigma) \int^{\delta}_{0} \left\{ \exp\left(-\frac{x}{\sigma} \right) \right\}^{\prime} dx \\
&amp;amp;= -\left[ \exp\left(-\frac{x}{\sigma} \right) \right]^{\delta}_{0} = \exp(0) - \exp\left( - \frac{\delta}{\sigma} \right) \\
&amp;amp;= 1 - \exp\left( - \frac{\delta}{\sigma} \right)
\end{align*}
&lt;/div&gt;
&lt;p&gt;この式により分散行列にかける係数を決めることを考えると、次が考察される。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\delta\)&lt;/span&gt; が大きい（分散 &lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; が小さい）と確率が1に近づき、分散行列はLMSのそれと近くなる。&lt;/li&gt;
&lt;li&gt;逆に &lt;span class="math"&gt;\(\delta\)&lt;/span&gt; が小さい（分散 &lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; が大きい）と分散行列に小さいスカラーを乗じる。分散行列の逆行列をとると、大きいスカラーを乗じることになり、勾配ベクトルのノルムが大きくなりそう。&lt;/li&gt;
&lt;li&gt;ノイズレベル（&lt;span class="math"&gt;\(\approx\)&lt;/span&gt; 分散）が小さいときは勾配が小さくなり極値付近を精密に調べ、大きい場合は勾配が大きくなりダイナミックに探索空間を動き回りそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="lms"&gt;
&lt;h2&gt;LMSの性能解析に関する文献&lt;/h2&gt;
&lt;p&gt;色々さまよっているうちに出てきた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ee.cityu.edu.hk/~hcso/it6303_4.pdf"&gt;Adaptive Filter Theory and Applications&lt;/a&gt; にLMSのステップサイズのとり方に関する記述あり。証明に有益。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.dsp-book.narod.ru/DSPMW/19.PDF"&gt;Convergence Issues in the LMS Adaptive Filter&lt;/a&gt; も結構有益。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="todo"&gt;
&lt;h3&gt;TODO&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;評価を続ける。評価がまとまったら結果共有に入りたい。&lt;ul&gt;
&lt;li&gt;LMSの適応動作は、単層パーセプトロンの学習にも該当する。NNの観点からも引き続き論文調査を行うべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OMPを使う。&lt;/li&gt;
&lt;li&gt;メッセージパッシング使えない？&lt;ul&gt;
&lt;li&gt;何らかの確率モデル化をせよ、というふうに受け取った。&lt;/li&gt;
&lt;li&gt;AMP, Survay-Propagation（三村さん、樺島さん）がありえる。&lt;/li&gt;
&lt;li&gt;→ AMP, Survay-Propagationについて調査すべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;いろんな論文で自然勾配をどうやって定義しているか要観察。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;優先度低&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;パーティクルフィルター使えない？&lt;ul&gt;
&lt;li&gt;今日検討した結果、ちょっと今は保留。大量のサンプルが必要そうに見える。計算負荷を気にした結果、優先度を低くした。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="LAD"></category><category term="IRLS"></category></entry><entry><title>LMS Filterの挙動観察中(1)</title><link href="/lms-filternoju-dong-guan-cha-zhong-1.html" rel="alternate"></link><published>2020-04-27T23:40:00+09:00</published><updated>2020-04-27T23:40:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-27:/lms-filternoju-dong-guan-cha-zhong-1.html</id><summary type="html">&lt;p&gt;引き続き観察中。勾配の計算ミスがあったりして厳しかった。&lt;/p&gt;
&lt;p&gt;問題は、やはりというかSignLMSでのヘッセ行列。&lt;span class="math"&gt;\(\mathrm{E}[\varepsilon((n))x(n-m …&lt;/span&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;引き続き観察中。勾配の計算ミスがあったりして厳しかった。&lt;/p&gt;
&lt;p&gt;問題は、やはりというかSignLMSでのヘッセ行列。&lt;span class="math"&gt;\(\mathrm{E}[\varepsilon((n))x(n-m)x(n-k)]\)&lt;/span&gt; の計算でインパルス応答の扱いをどうするのか...連続信号では厳密に0を取る確率は0だ。だからといって離散的に考えていいのか？&lt;/p&gt;
&lt;p&gt;誤差の絶対値を取って閾値以下ならば分散行列に加算する処理を入れたが、分散行列が特異になること多し。&lt;/p&gt;
&lt;p&gt;デジタル的に考えれば、残差が0になる確率で重み付けしていいのでは無いかと思う。 またデジタル的に考えた時
残差が0になる確率は、離散ラプラス分布（ &lt;a class="reference external" href="https://shodhganga.inflibnet.ac.in/bitstream/10603/30871/11/11_chapter%206.pdf"&gt;参考資料&lt;/a&gt; ）を元にサンプリング/もしくは重み付けで求める。（サンプリングの場合は[0,1]乱数を発生させて残差が0になる確率よりも小さければ採択する。まじのMC。というか、サンプリングしても重み付けしても同じでは？）分散パラメータは観測分散で求める。&lt;/p&gt;
&lt;p&gt;一旦残差0の重み付けで実験を進めているが、まだ残差0確率が怪しい感じ。（0.93とかいう現実離れした数値。実際の音声では約0.09とかそんなん）&lt;/p&gt;
&lt;p&gt;見やすいようにパラメータを2つにしている。2つにした時でも同じ出力を与える組み合わせがあり、それが直線上に並んでいる事がわかっている。&lt;/p&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category></entry><entry><title>LMS Filterの挙動観察</title><link href="/lms-filternoju-dong-guan-cha.html" rel="alternate"></link><published>2020-04-24T11:40:00+09:00</published><updated>2020-04-24T11:40:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-24:/lms-filternoju-dong-guan-cha.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;今日はJupyterを使って残差・残差勾配を観察していく。もう夜遅 …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;今日はJupyterを使って残差・残差勾配を観察していく。もう夜遅いのでnotebook上げるの挑戦できず。
勾配の計算にミスがあり、残差分布と勾配の結果が一致していなかった…3時間ほど飛ばす。&lt;/p&gt;
&lt;p&gt;ラプラス分布の観測分散が怪しい...&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://math.stackexchange.com/questions/922521/deriving-mean-and-variance-of-laplace-distribution"&gt;Deriving Mean and Variance of Laplace Distribution&lt;/a&gt; に1次元の場合がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="Hessian"></category></entry><entry><title>古い記事の移行/Jupyterの環境整備</title><link href="/gu-iji-shi-noyi-xing-jupyternohuan-jing-zheng-bei.html" rel="alternate"></link><published>2020-04-23T23:00:00+09:00</published><updated>2020-04-23T23:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-23:/gu-iji-shi-noyi-xing-jupyternohuan-jing-zheng-bei.html</id><summary type="html">&lt;p&gt;評価の前に古い記事の移行とPythonの環境整備。
PythonはJupyterを使う。Vimキーバインドで。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/nakasan/items/ec7741f075f1062350f4#jupyterコマンドモードのショートカットキーまとめ"&gt;Jupyterコマンドモードのショートカットキ …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;評価の前に古い記事の移行とPythonの環境整備。
PythonはJupyterを使う。Vimキーバインドで。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/nakasan/items/ec7741f075f1062350f4#jupyterコマンドモードのショートカットキーまとめ"&gt;Jupyterコマンドモードのショートカットキーまとめ&lt;/a&gt; がよくまとまっていた。これ読んで進めていく。&lt;/li&gt;
&lt;/ul&gt;
</content><category term="雑記"></category><category term="Jupyter"></category></entry><entry><title>デジタル信号処理の礎</title><link href="/dezitaruxin-hao-chu-li-nochu.html" rel="alternate"></link><published>2020-04-23T18:00:00+09:00</published><updated>2020-04-23T18:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-23:/dezitaruxin-hao-chu-li-nochu.html</id><summary type="html">&lt;p class="first last"&gt;デジタル信号処理の基礎理論をグダグダ述べたポエム。&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;まえがき&lt;/h2&gt;
&lt;p&gt;本稿はデジタル信号処理の礎となる理論を固めるべく書かれた。&lt;/p&gt;
&lt;!-- デジタル信号処理は以下の分野を包括している:

.. - 集合論
.. - 線型代数
.. - 関数解析
.. - 複素関数
.. - 確率・統計 --&gt;
&lt;!-- 実用の工学上では、これらの分野の理論を深く扱うことはない。しかし、その基礎は確かに以上の分野の深い知識を動員している。 --&gt;
&lt;div class="math"&gt;
\begin{equation*}
\def\vector#1{\mbox{\boldmath $#1$}}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand{\rev}[1]{\frac{1}{#1}}
\newcommand{\pdiff}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\ddiff}[2]{\frac{d#1}{d#2}}
\newcommand{\vvec}[1]{\left[\begin{array}{c}#1\end{array}\right]}
\newcommand{\dmatrix}[2]{\left|\begin{array}{#1}#2\end{array}\right|}
\newcommand{\inversion}[1]{#1^{\!\mbox{\sf\tiny T}}}
\newcommand{\ifdiv}[2]{\left\{\begin{array}{#1}#2\end{array}\right.}
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;フーリエ変換について&lt;/h2&gt;
&lt;p&gt;フーリエ変換が天下りに与えられて次の言明に対して違和感を抱いたことは無いだろうか？&lt;/p&gt;
&lt;pre class="literal-block"&gt;
任意の周期関数は三角関数の和で表現できる
&lt;/pre&gt;
&lt;p&gt;といった手合いである。この言明に対しては、次の疑問が浮かぶかもしれない:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;任意の周期関数に対して成り立つのか？&lt;/li&gt;
&lt;li&gt;何故三角関数を用いる必要があるのか？三角関数である必然性は？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本稿では、この疑問に対して数学的に一応の解答を与えたい。細かい解説は後にして、解答としては次の様になる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;任意の区分的になめらかな周期関数は三角関数の和で表現できる&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;三角関数は連続関数を表現できる能力を持っている&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下、これらの項目の証明を試みる。&lt;/p&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3&gt;関数はベクトル&lt;/h3&gt;
&lt;p&gt;形式的に見れば、 &lt;strong&gt;関数はベクトル&lt;/strong&gt; である。関数は入力と出力を決める規則であることから、 &lt;a class="reference internal" href="#math-block-1"&gt;式1&lt;/a&gt; の様に、その出力を並べることで、関数をベクトルとして見ることが出来る。&lt;/p&gt;
&lt;div class="math" id="math-block-1"&gt;
\begin{align*}
 f(x) = \vvec{ f(-\infty) \\ \vdots \\ f(0) \\ \vdots \\ f(\infty) } \tag{1}
\end{align*}
&lt;/div&gt;
&lt;p&gt;関数をベクトルとみなすと、そこに線型代数の知見を持ち込むことができる。まず、関数による基底（関数基底）によって空間を張ることができる。関数によって張られた空間は特に &lt;strong&gt;関数空間&lt;/strong&gt; と呼ばれる。
また、2つの関数 &lt;span class="math"&gt;\(f,g\)&lt;/span&gt; の &lt;strong&gt;内積&lt;/strong&gt; &lt;span class="math"&gt;\(\innerp{f}{g}\)&lt;/span&gt; を式 &lt;a class="reference internal" href="#math-block-2"&gt;式2&lt;/a&gt; の様に積分を用いて表すことが出来る。&lt;/p&gt;
&lt;div class="math" id="math-block-2"&gt;
\begin{align*}
 \innerp{f}{g} &amp;amp;=
   \left[ f(-L) \dots f(0) \dots f(L) \right]
   \vvec{ g(-L) \\ \vdots \\ g(0) \\ \vdots \\ g(L) } \\
 &amp;amp;= f(-L)g(-L) + \dots + f(0)g(0) + \dots + f(L)g(L) \\
 &amp;amp;= \int_{-L}^{L} f(x)g(x) dx \tag{2}
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで &lt;span class="math"&gt;\(L\)&lt;/span&gt; は積分範囲を決める定数である &lt;a class="footnote-reference" href="#functioninnerprodrange" id="footnote-reference-1"&gt;[1]&lt;/a&gt;。また、関数自分自身の内積 &lt;span class="math"&gt;\(\innerp{f}{f}\)&lt;/span&gt; を &lt;strong&gt;ノルム&lt;/strong&gt; という &lt;a class="footnote-reference" href="#functioninnerprodnorm" id="footnote-reference-2"&gt;[2]&lt;/a&gt;。&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="functioninnerprodrange" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;形式的に見た際には積分範囲は無限 &lt;span class="math"&gt;\([-\infty,\infty]\)&lt;/span&gt; になることが多いが、定数関数同士の内積を考えれば分かるように、内積値が発散してしまう場合がある。その場合は、積分範囲を限定して議論を行う。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="functioninnerprodnorm" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;span class="math"&gt;\(L\)&lt;/span&gt; に基づいてノルム値を &lt;span class="math"&gt;\(1\)&lt;/span&gt; にする操作を行うことがある。この操作を &lt;strong&gt;正規化&lt;/strong&gt; という。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3&gt;三角関数の直交性&lt;/h3&gt;
&lt;p&gt;関数をベクトルとして考えた時、異なる周波数を持つ三角関数は互いに直交（&lt;span class="math"&gt;\(\iff\)&lt;/span&gt; 内積値が &lt;span class="math"&gt;\(0\)&lt;/span&gt; になる）する。この事を計算により確かめていく。&lt;/p&gt;
&lt;p&gt;尚、内積計算時の積分範囲は全て &lt;span class="math"&gt;\([-\pi, \pi]\)&lt;/span&gt; とする。何故なら、周期関数が直交しているかどうかを判定するには1周期分の内積を取り、その結果が &lt;span class="math"&gt;\(0\)&lt;/span&gt; になるかどうかを見れば良いからである。またその周期は、周波数を決める定数は全て整数であることにより決まり、最長の周波数は &lt;span class="math"&gt;\(\sin(x), \cos(x)\)&lt;/span&gt; が持つ &lt;span class="math"&gt;\(2\pi\)&lt;/span&gt; である。積分範囲を &lt;span class="math"&gt;\([-\pi, \pi]\)&lt;/span&gt; とすれば、一番長い周期を加味して内積を計算できる。&lt;/p&gt;
&lt;div class="section" id="sin"&gt;
&lt;h4&gt;正弦波（sin）の直交性&lt;/h4&gt;
&lt;p&gt;素直に内積を計算する。三角関数の和の公式&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\cos\{(n+m)x\} &amp;amp;= \cos(nx)\cos(mx) - \sin(nx)\sin(mx) \\
\cos\{(n-m)x\} &amp;amp;= \cos(nx)\cos(mx) + \sin(nx)\sin(mx) \\
\implies \sin(nx)\sin(mx) &amp;amp;= \frac{\cos\{(n-m)x\} - \cos\{(n+m)x\}}{2}
\end{align*}
&lt;/div&gt;
&lt;p&gt;を用いて &lt;span class="math"&gt;\(\sin\)&lt;/span&gt; の積を &lt;span class="math"&gt;\(\cos\)&lt;/span&gt; の和に分割して積分を行うのがポイントである。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\innerp{\sin(nx)}{\sin(mx)}
&amp;amp;= \int_{-\pi}^{\pi} \sin(nx) \sin(mx) dx \\
&amp;amp;= \int_{-\pi}^{\pi} \frac{\cos\{(n-m)x\} - \cos\{(n+m)x\}}{2} dx \\
&amp;amp;= \frac{1}{2(n-m)} \left[ \sin\{(n-m)x\} \right]_{-\pi}^{\pi} - \frac{1}{2(n+m)} \left[ \sin\{(n+m)x\} \right]_{-\pi}^{\pi} \\
&amp;amp;= \frac{1}{2(n-m)} \left[ \sin\{(n-m)\pi\} - \sin\{-(n-m)\pi\} \right] - \frac{1}{2(n+m)} \left[ \sin\{(n+m)\pi\} - \sin\{-(n+m)\pi\} \right] \\
&amp;amp;= \frac{\sin\{(n-m)\pi\}}{n-m} - \frac{\sin\{(n+m)\pi\}}{n+m}
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、最後の結果の右辺第二項は、&lt;span class="math"&gt;\(n+m\)&lt;/span&gt; が整数になることから &lt;span class="math"&gt;\(0\)&lt;/span&gt; になる。一方の右辺第一項は &lt;span class="math"&gt;\(n \neq m\)&lt;/span&gt; の時は右辺第二項と同様に &lt;span class="math"&gt;\(0\)&lt;/span&gt; となる。 &lt;span class="math"&gt;\(n = m\)&lt;/span&gt; の時は、 &lt;span class="math"&gt;\(n-m \to 0\)&lt;/span&gt; なる極限を考えることで計算結果が確かめられる:&lt;/p&gt;
&lt;div class="math" id="math-block-3"&gt;
\begin{align*}
\lim_{(n-m) \to 0} \frac{\sin\{(n-m)\pi\}}{n-m}
&amp;amp;= \lim_{\alpha \to 0} \frac{\sin\alpha\pi}{\alpha} \\
&amp;amp;= \lim_{\alpha \to 0} \frac{\ddiff{\sin\alpha\pi}{\alpha}}{\ddiff{\alpha}{\alpha}} = \lim_{\alpha \to 0} \pi \cos\alpha\pi \\
&amp;amp;= \pi \tag{3}
\end{align*}
&lt;/div&gt;
&lt;p&gt;以上の結果をまとめると、&lt;/p&gt;
&lt;div class="math" id="math-block-4"&gt;
\begin{align*}
\innerp{\sin(nx)}{\sin(mx)} = \ifdiv{cc}{ 0 &amp;amp; (n \neq m) \\ \pi &amp;amp; (n = m) } \tag{4}
\end{align*}
&lt;/div&gt;
&lt;p&gt;この結果は、2つの意味で重要である。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;（今確かめている様に、）異なる周波数を持つ正弦波は互いに直交する。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(n=m\)&lt;/span&gt; の時の結果は、 &lt;span class="math"&gt;\(\sin\)&lt;/span&gt; のノルム値は &lt;span class="math"&gt;\(\pi\)&lt;/span&gt; であることを示している。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="cos"&gt;
&lt;h4&gt;余弦波（cos）の直交性&lt;/h4&gt;
&lt;p&gt;計算方針は &lt;span class="math"&gt;\(\sin\)&lt;/span&gt; の時と同様である。三角関数の和の公式より、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\cos(mx)\cos(nx) = \frac{\cos\{(n-m)x\} + \cos\{(n+m)x\}}{2}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成立するため、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\innerp{\cos(nx)}{\cos(mx)}
&amp;amp;= \int_{-\pi}^{\pi} \cos(nx) \cos(mx) dx \\
&amp;amp;= \int_{-\pi}^{\pi} \frac{\cos\{(n-m)x\} + \cos\{(n+m)x\}}{2} dx \\
&amp;amp;= \frac{1}{2(n-m)} \left[ \sin\{(n-m)\pi\} - \sin\{-(n-m)\pi\} \right] + \frac{1}{2(n+m)} \left[ \sin\{(n+m)\pi\} - \sin\{-(n+m)\pi\} \right] \\
&amp;amp;= \frac{\sin\{(n-m)\pi\}}{n-m} + \frac{\sin\{(n+m)\pi\}}{n+m}
\end{align*}
&lt;/div&gt;
&lt;p&gt;と、&lt;span class="math"&gt;\(\sin\)&lt;/span&gt; の内積計算時とほぼ同様の結果が得られる。最終結果の第一項に関しては式 &lt;a class="reference internal" href="#math-block-3"&gt;式3&lt;/a&gt; と同様に考えることで、次の結果が得られる。&lt;/p&gt;
&lt;div class="math" id="math-block-5"&gt;
\begin{align*}
\innerp{\cos(nx)}{\cos(mx)} = \ifdiv{cc}{ 0 &amp;amp; (n \neq m) \\ \pi &amp;amp; (n = m) } \tag{5}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\cos\)&lt;/span&gt; のノルムも &lt;span class="math"&gt;\(\sin\)&lt;/span&gt; と同様 &lt;span class="math"&gt;\(\pi\)&lt;/span&gt; であることが示されている。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h4&gt;正弦波と余弦波の直交性&lt;/h4&gt;
&lt;p&gt;最後に &lt;span class="math"&gt;\(\sin\)&lt;/span&gt; と &lt;span class="math"&gt;\(\cos\)&lt;/span&gt; の直交性を確かめる。
三角関数の和の公式により、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\sin\{(n+m)x\} &amp;amp;= \sin(nx)\cos(mx) + \cos(nx)\sin(mx) \\
\sin\{(n-m)x\} &amp;amp;= \sin(nx)\cos(mx) - \cos(nx)\sin(mx) \\
\implies \sin(nx)\cos(mx) &amp;amp;= \frac{\sin\{(n+m)x\} + \sin\{(n-m)x\}}{2}
\end{align*}
&lt;/div&gt;
&lt;p&gt;が成立するため、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\innerp{\sin(mx)}{\cos(mx)}
&amp;amp;= \int_{-\pi}^{\pi} \sin(nx) \cos(mx) dx \\
&amp;amp;= \int_{-\pi}^{\pi} \frac{\sin\{(n+m)x\} + \sin\{(n-m)x\}}{2} dx \\
&amp;amp;= \frac{1}{2(n+m)} \left[ \cos\{(n+m)\pi\} - \cos\{-(n+m)\pi\} \right] + \frac{1}{2(n-m)} \left[ \cos\{(n-m)\pi\} - \cos\{-(n-m)\pi\} \right] \\
&amp;amp;= 0
\end{align*}
&lt;/div&gt;
&lt;p&gt;従って、如何なる周波数に対しても正弦波と余弦波は直交していること&lt;/p&gt;
&lt;div class="math" id="math-block-6"&gt;
\begin{equation*}
\innerp{\sin(nx)}{\cos(mx)} = 0 \tag{6}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が確かめられた。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h3&gt;フーリエ係数&lt;/h3&gt;
&lt;p&gt;次の様に信号 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; がフーリエ級数展開されていたとする。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(x) = \frac{1}{2} a_{0} + \sum_{k=1}^{\infty} a_{k} \cos(kx) + \sum_{k=1}^{\infty} b_{k} \sin(kx)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;上式における係数 &lt;span class="math"&gt;\(a_{0}, a_{1}, ..., b_{1}, b_{2}, ...\)&lt;/span&gt; はフーリエ級数と呼ばれる。
フーリエ係数は、周波数成分への重み付けと説明される事が多い。一方、上記のように関数をベクトルとみなすと、信号を三角関数基底で表した際の一次結合係数とも捉え直す事ができる。&lt;/p&gt;
&lt;p&gt;係数を取り出すには、上記の直交性（ &lt;a class="reference internal" href="#math-block-4"&gt;式4&lt;/a&gt;, &lt;a class="reference internal" href="#math-block-5"&gt;式5&lt;/a&gt;, &lt;a class="reference internal" href="#math-block-6"&gt;式6&lt;/a&gt; ）を使用すれば良い。&lt;span class="math"&gt;\(\innerp{f(x)}{\sin(nx)} \ n \in \mathbb{N}\)&lt;/span&gt; を計算すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\innerp{f(x)}{\sin(nx)}
&amp;amp;= \innerp{\frac{1}{2} a_{0} + \sum_{k=1}^{\infty} a_{k} \cos(kx) + \sum_{k=1}^{\infty} b_{k}\sin(kx)}{\sin(nx)} \\
&amp;amp;= \innerp{\frac{1}{2} a_{0}}{\sin(nx)} + \innerp{\sum_{k=1}^{\infty} a_{k} \cos(kx)}{\sin(nx)} + \innerp{\sum_{k=1}^{\infty} b_{k}\sin(kx)}{\sin(nx)} \quad (\because 内積の線形性) \\
&amp;amp;= \frac{1}{2} a_{0} \innerp{1}{\sin(nx)} + \sum_{k=1}^{\infty} \innerp{a_{k}\cos(kx)}{\sin(nx)} + \sum_{k=1}^{\infty} \innerp{b_{k}\sin(kx)}{\sin(nx)} \quad (\because 内積の線形性) \\
&amp;amp;= \frac{1}{2} a_{0} \innerp{\cos(0)}{\sin(nx)} + \sum_{k=1}^{\infty} a_{k} \innerp{\cos(kx)}{\sin(nx)} + \sum_{k=1}^{\infty} b_{k} \innerp{\sin(kx)}{\sin(nx)} \\
&amp;amp;= \pi b_{n} \quad (\because 三角関数の直交性)
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって、&lt;/p&gt;
&lt;div class="math" id="math-block-7"&gt;
\begin{equation*}
b_{n} = \frac{1}{\pi} \innerp{f(x)}{\sin(nx)} \tag{7}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;全く同様にして &lt;span class="math"&gt;\(\innerp{f(x)}{\cos(nx)} \ n \in \mathbb{N}\)&lt;/span&gt; を計算することで、次の結果が得られる &lt;a class="footnote-reference" href="#fouriorcoefwhendc" id="footnote-reference-3"&gt;[3]&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="math" id="math-block-8"&gt;
\begin{equation*}
a_{n} = \frac{1}{\pi} \innerp{f(x)}{\cos(nx)}  \tag{8}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference internal" href="#math-block-7"&gt;式7&lt;/a&gt;, &lt;a class="reference internal" href="#math-block-8"&gt;式8&lt;/a&gt; の結果を見ると、 &lt;strong&gt;係数を取り出すには、関数基底と内積を取って、基底のノルムで割れば良い&lt;/strong&gt; 事が分かる。&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="fouriorcoefwhendc" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;span class="math"&gt;\(a_{0}\)&lt;/span&gt; を求める際には、&lt;span class="math"&gt;\(\cos(0)=1\)&lt;/span&gt; と &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; の内積を取れば良い。&lt;span class="math"&gt;\(\int_{-\pi}^{\pi} {1} dx = 2\pi\)&lt;/span&gt; により、&lt;span class="math"&gt;\(a_{0}\)&lt;/span&gt; に乗じられている &lt;span class="math"&gt;\(\frac{1}{2}\)&lt;/span&gt; が実は無意味では無いことが分かるだろう。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h3&gt;収束定理&lt;/h3&gt;
&lt;p&gt;いよいよ問題の核心について考えることが出来る。上記までの議論で、三角関数は基底をなすことが示された &lt;a class="footnote-reference" href="#abouttrianglefuncorthonarity" id="footnote-reference-4"&gt;[4]&lt;/a&gt;。それでは、三角関数によって構築された基底（三角関数基底）は、如何なる関数でも表現できるのだろうか？というのが次の疑問となる。&lt;/p&gt;
&lt;p&gt;この疑問に対する答えがフーリエ級数の &lt;strong&gt;収束定理&lt;/strong&gt; （以下、単純に収束定理）である。収束定理とは、次の有限項のフーリエ級数展開&lt;/p&gt;
&lt;div class="math" id="math-block-9"&gt;
\begin{equation*}
S_{N}(x) = \frac{1}{2} a_{0} + \sum_{n=1}^{N} \left\{ a_{n} \cos(nx) + b_{n} \sin(nx) \right\} \tag{9}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を用いて信号 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; を近似（&lt;span class="math"&gt;\(S_{N}(x) \approx f(x)\)&lt;/span&gt; ）することを考え、&lt;span class="math"&gt;\(N\)&lt;/span&gt; の極限 &lt;span class="math"&gt;\(N \to \infty\)&lt;/span&gt; を取った時に、&lt;span class="math"&gt;\(S_{N}(x)\)&lt;/span&gt; と &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; が一致する、というものである。&lt;/p&gt;
&lt;div class="math" id="math-block-10"&gt;
\begin{equation*}
\lim_{N \to \infty} \left\{ S_{N}(x) - f(x) \right\} = 0 \tag{10}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;cite&gt;式10&lt;/cite&gt; が証明されれば、理論的観点から、安心してフーリエ級数を使用できると言って良い。ここで、予め注意してほしいのが、&lt;cite&gt;式10&lt;/cite&gt; の &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; は任意の関数では成立せず、定理が成り立つための制約条件が存在することである。&lt;/p&gt;
&lt;p&gt;以下、収束定理の証明及び、 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; に課すべき制約条件を見ていく。&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="abouttrianglefuncorthonarity" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;この事実は自明ではない。全く適当に選んだ関数の集合（関数族）が基底になることはまず無い。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="section" id="section-9"&gt;
&lt;h4&gt;ディリクレ核&lt;/h4&gt;
&lt;p&gt;収束定理 &lt;a class="reference internal" href="#math-block-10"&gt;式10&lt;/a&gt; が成立することを示すため、まず有限項のフーリエ級数展開の &lt;a class="reference internal" href="#math-block-9"&gt;式9&lt;/a&gt; に注目する。 &lt;a class="reference internal" href="#math-block-9"&gt;式9&lt;/a&gt; の各フーリエ係数 &lt;span class="math"&gt;\(a_{0}, a_{1}, ..., b_{1}, b_{2}, ...\)&lt;/span&gt; は、 &lt;a class="reference internal" href="#math-block-7"&gt;式7&lt;/a&gt;, &lt;a class="reference internal" href="#math-block-8"&gt;式8&lt;/a&gt; により、近似対象の関数 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; によって表すことが出来る。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
S_{N}(x)
&amp;amp;= \frac{1}{2} a_{0} + \sum_{n=1}^{N} \left\{ a_{n} \cos(nx) + b_{n} \sin(nx) \right\} \\
&amp;amp;= \frac{1}{2} \frac{1}{\pi} \innerp{1}{f(x)} + \sum_{n=1}^{N} \left\{ \frac{1}{\pi} \innerp{\cos(ny)}{f(y)} \cos(nx) + \frac{1}{\pi} \innerp{\sin(ny)}{f(y)} \sin(nx) \right\} \\
&amp;amp;= \frac{1}{2\pi} \int_{-\pi}^{\pi} f(y) dy + \sum_{n=1}^{N} \left\{ \frac{1}{\pi} \int_{-\pi}^{\pi} \cos(ny)f(y) dy \cos(nx) + \frac{1}{\pi} \int_{-\pi}^{\pi} \sin(ny)f(y) dy \sin(nx) \right\} \\
&amp;amp;= \frac{1}{\pi} \int_{-\pi}^{\pi} f(y) \left[ \frac{1}{2} + \sum_{n=1}^{N} \left\{ \cos(ny)\cos(nx) + \sin(ny)\sin(nx) \right\} \right] dy \\
&amp;amp;= \frac{1}{\pi} \int_{-\pi}^{\pi} f(y) \left[ \frac{1}{2} + \sum_{n=1}^{N} \cos\left\{n(y-x)\right\} \right] dy \quad (\because \cos の加法定理を使用)
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、 &lt;span class="math"&gt;\(z=y-x\)&lt;/span&gt; と積分の変数変換を行う。積分範囲は &lt;span class="math"&gt;\([-\pi,\pi]\)&lt;/span&gt; から &lt;span class="math"&gt;\([-\pi-x,\pi-x]\)&lt;/span&gt; に変化するが、周期関数を1周期分積分している状態で、積分範囲を左右にずらしても積分の結果は変わらないため、次の結果が得られる。&lt;/p&gt;
&lt;div class="math" id="math-block-11"&gt;
\begin{align*}
S_{N}(x)
&amp;amp;= \frac{1}{\pi} \int_{-\pi}^{\pi} f(z+x) \left[ \frac{1}{2} + \sum_{n=1}^{N} \cos(nz) \right] dz \\
&amp;amp;= \frac{1}{\pi} \int_{-\pi}^{\pi} f(z+x) D_{N}(z) dz \tag{11}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;cite&gt;式11&lt;/cite&gt; で導入した&lt;/p&gt;
&lt;div class="math" id="math-block-12"&gt;
\begin{equation*}
D_{N}(x) = \frac{1}{2} + \sum_{n=1}^{N} \cos(nx) \tag{12}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を &lt;strong&gt;ディリクレ核(Dirichlet kernel)&lt;/strong&gt; という。以下に述べるように、ディリクレ核にはいくつか重要な性質がある。&lt;/p&gt;
&lt;div class="section" id="section-10"&gt;
&lt;h5&gt;ディリクレ核の一周期分の積分&lt;/h5&gt;
&lt;p&gt;定義 &lt;a class="reference internal" href="#math-block-12"&gt;式12&lt;/a&gt; より明らかにディリクレ核は周期関数である。周期 &lt;span class="math"&gt;\(2\pi\)&lt;/span&gt; の積分を実行すると、&lt;/p&gt;
&lt;div class="math" id="math-block-13"&gt;
\begin{align*}
\int_{-\pi}^{\pi} D_{N}(x) dx
&amp;amp;= \int_{-\pi}^{\pi} \left\{ \frac{1}{2} + \sum_{n=1}^{N} \cos(nx) \right\} dx \\
&amp;amp;= \int_{-\pi}^{\pi} \frac{1}{2} dx + \int_{-\pi}^{\pi} \sum_{n=1}^{N} \cos(nx) dx
= \int_{-\pi}^{\pi} \frac{1}{2} dx + \sum_{n=1}^{N} \int_{-\pi}^{\pi} \cos(nx) dx \\
&amp;amp;= \int_{-\pi}^{\pi} \frac{1}{2} dx \quad (\because 三角関数の一周期分の積分値は0) \\
&amp;amp;= \frac{2\pi}{2} = \pi \tag{13}
\end{align*}
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="sin-1"&gt;
&lt;h5&gt;ディリクレ核のsin関数による表現&lt;/h5&gt;
&lt;p&gt;ディリクレ核は、若干技巧的ではあるが、和を持たない形式に変形することができる。&lt;span class="math"&gt;\(D_{N}(x)\)&lt;/span&gt; の左から &lt;span class="math"&gt;\(2\sin\left(\frac{1}{2}x\right)\)&lt;/span&gt; を乗じると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
2\sin\left(\frac{1}{2}x\right) D_{N}(x)
&amp;amp;= 2\sin\left(\frac{1}{2}x\right) \left[ \frac{1}{2} + \sum_{n=1}^{N} \cos(nx) \right] \\
&amp;amp;= \sin\left(\frac{1}{2}x\right) + 2\sin\left(\frac{1}{2}x\right) \cos(x) + 2\sin\left(\frac{1}{2}x\right) \cos(2x) + ... + 2\sin\left(\frac{1}{2}x\right) \cos(Nx)
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、三角関数の和の公式 &lt;span class="math"&gt;\(\sin(nx)\cos(mx) = \frac{\sin\{(n+m)x\} + \sin\{(n-m)x\}}{2}\)&lt;/span&gt; を用いれば、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
2\sin\left(\frac{1}{2}x\right) D_{N}(x)
&amp;amp;= \sin\left(\frac{1}{2}x\right) + \left[ \sin\left\{\left(\frac{1}{2} - 1\right)x\right\} + \sin\left\{\left(\frac{1}{2} + 1\right)x\right\} \right] \\
&amp;amp;\quad + \left[ \sin\left\{\left(\frac{1}{2} - 2\right)x\right\} + \sin\left\{\left(\frac{1}{2} + 2\right)x\right\} \right] + ... + \left[ \sin\left\{\left(\frac{1}{2} - N\right)x\right\} + \sin\left\{\left(\frac{1}{2} + N\right)x\right\} \right] \\
&amp;amp;= \sin\left(\frac{1}{2}x\right) + \sin\left(-\frac{1}{2}x\right) + \sin\left(\frac{3}{2}x\right) \\
&amp;amp;\quad + \sin\left(-\frac{3}{2}x\right) + \sin\left(\frac{5}{2}x\right) + ... + \sin\left\{\left(\frac{1}{2} - N\right)x\right\} + \sin\left\{\left(\frac{1}{2} + N\right)x\right\} \\
&amp;amp;= \sin\left\{\left(\frac{1}{2} + N\right)x\right\}
\end{align*}
&lt;/div&gt;
&lt;p&gt;従って、ディリクレ核を &lt;span class="math"&gt;\(\sin\)&lt;/span&gt; のみで表現することが出来る:&lt;/p&gt;
&lt;div class="math" id="math-block-14"&gt;
\begin{equation*}
D_{N}(x) = \frac{\sin\left\{\left(\frac{1}{2} + N\right)x\right\}}{2\sin\left(\frac{1}{2}x\right)} \tag{14}
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-11"&gt;
&lt;h5&gt;ディリクレ核の畳み込み&lt;/h5&gt;
&lt;p&gt;&lt;cite&gt;式11&lt;/cite&gt; を改めて眺めると、この式は積分範囲 &lt;span class="math"&gt;\([-\pi,\pi]\)&lt;/span&gt; において &lt;strong&gt;関数にディリクレ核を畳み込んでいる&lt;/strong&gt; 式に捉え直せる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
S_{N}(x) = \frac{1}{\pi} \ f(x) \ast D_{N}(x)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;先取りして収束定理が成り立つと仮定すると、&lt;span class="math"&gt;\(N\)&lt;/span&gt; の極限 &lt;span class="math"&gt;\(N \to \infty\)&lt;/span&gt; に於いて次が成り立つ:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\lim_{N \to \infty} S_{N}(x) &amp;amp;= \lim_{N \to \infty} \frac{1}{\pi} \ f(x) \ast D_{N}(x) = f(x) \\
\therefore \lim_{N \to \infty} f(x) \ast D_{N}(x) &amp;amp;= \pi f(x)
\end{align*}
&lt;/div&gt;
&lt;p&gt;畳み込みの結果、畳込み対象の関数 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; が表れている。即ちこの結果は、 &lt;span class="math"&gt;\(N\)&lt;/span&gt; の極限においてディリクレ関数はインパルス関数に近い振る舞いをすることを示している。&lt;/p&gt;
&lt;!-- 他にもディリクレ核には種々の性質が成り立つため、後に補足を行う。 --&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-12"&gt;
&lt;h4&gt;リーマン・ルベーグの補題&lt;/h4&gt;
&lt;p&gt;収束定理の証明のためには、もう一つ &lt;strong&gt;リーマン・ルベーグの補題&lt;/strong&gt; なる命題が必要である。この節では、リーマン・ルベーグの補題の証明を行う。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;リーマン・ルベーグの補題&lt;/dt&gt;
&lt;dd&gt;&lt;blockquote class="first"&gt;
区分的に連続な関数 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; と &lt;span class="math"&gt;\(\sin(Nx)\)&lt;/span&gt; の積を積分区間  &lt;span class="math"&gt;\([a,b]\)&lt;/span&gt; で積分したものは、&lt;span class="math"&gt;\(N \to \infty\)&lt;/span&gt; とすると &lt;span class="math"&gt;\(0\)&lt;/span&gt; に収束する。&lt;/blockquote&gt;
&lt;div class="last math" id="math-block-15"&gt;
\begin{equation*}
\lim_{N \to \infty} \int_{a}^{b} f(x) \sin(Nx) dx = 0 \tag{15}
\end{equation*}
&lt;/div&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;（証明）部分積分を用いることにより、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\int_{a}^{b} f(x) \sin(Nx) dx
&amp;amp;= \int_{a}^{b} f(x) \left\{ -\frac{1}{N} \cos(Nx) \right\}^{\prime} dx \\
&amp;amp;= \left[ -\frac{1}{N} f(x) \cos(Nx) \right]_{a}^{b} - \int_{a}^{b} -\frac{1}{N} f^{\prime}(x) \cos(Nx) dx \quad (\because 部分積分) \\
&amp;amp;= -\frac{1}{N} \left[ f(x) \cos(Nx) \right]_{a}^{b} + \frac{1}{N} \int_{a}^{b} f^{\prime}(x) \cos(Nx) dx
\end{align*}
&lt;/div&gt;
&lt;p&gt;と変形できる。このまま &lt;span class="math"&gt;\(N \to \infty\)&lt;/span&gt; なる極限をとれば、いずれの項も &lt;span class="math"&gt;\(0\)&lt;/span&gt; に収束するように見える。しかしそれは &lt;strong&gt;関数&lt;/strong&gt; &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; &lt;strong&gt;の微分&lt;/strong&gt; &lt;span class="math"&gt;\(f^{\prime}(x)\)&lt;/span&gt; &lt;strong&gt;が区間&lt;/strong&gt; &lt;span class="math"&gt;\([a,b]\)&lt;/span&gt; &lt;strong&gt;で発散しない（区分的なめらかな）ときのみ&lt;/strong&gt; 真である。この条件を関数 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; に付加した時、命題は成立する。&lt;/p&gt;
&lt;p&gt;では一般に、 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; が区分的に連続であること &lt;strong&gt;のみ&lt;/strong&gt; を仮定して証明を行う。この時は区分的なめらかな関数 &lt;span class="math"&gt;\(g(x)\)&lt;/span&gt; を用いて命題が成立することを用いて、&lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; を &lt;span class="math"&gt;\(g(x)\)&lt;/span&gt; に近づけることで命題の成立を示す。積分区間 &lt;span class="math"&gt;\([a,b]\)&lt;/span&gt; を &lt;span class="math"&gt;\(M\)&lt;/span&gt; 分割し、区間の小さい方から順に &lt;span class="math"&gt;\(x_{1}, x_{2}, ..., x_{M}\)&lt;/span&gt; となるようにする（当然 &lt;span class="math"&gt;\(x_{1} = a, x_{M} = b\)&lt;/span&gt; が成立する）。この上で &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; を次のように構成する:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(x) = g(x_{k+1}) \quad (k = 1,...,M-1, \ x_{k} \leq x \leq x_{k+1})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;構成法から見えるように、分割数 &lt;span class="math"&gt;\(M\)&lt;/span&gt; を増やしていけば、&lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; と &lt;span class="math"&gt;\(g(x)\)&lt;/span&gt; の差は小さくなっていくのが分かる（TODO:図を書こう）。即ち、任意の &lt;span class="math"&gt;\(\varepsilon &amp;gt; 0\)&lt;/span&gt; に対して、 &lt;span class="math"&gt;\(|f(x) - g(x)| &amp;lt; \varepsilon\)&lt;/span&gt; を成立させる &lt;span class="math"&gt;\(M\)&lt;/span&gt; が存在する。&lt;/p&gt;
&lt;p&gt;そしてこの &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; を用いたとき、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\left| \int_{a}^{b} f(x) \sin(Nx) dx \right|
&amp;amp;= \left| \int_{a}^{b} \left\{ f(x) - g(x) + g(x) \right\} \sin(Nx) dx \right| \\
&amp;amp;\leq \left| \int_{a}^{b} \left\{ f(x) - g(x) \right\} \sin(Nx) dx \right| + \left| \int_{a}^{b} g(x) \sin(Nx) dx \right| \\
&amp;amp;\leq \int_{a}^{b} \left| f(x) - g(x) \right| \left| \sin(Nx) \right| dx + \left| \int_{a}^{b} g(x) \sin(Nx) dx \right| \\
&amp;amp;\leq \int_{a}^{b} \left| f(x) - g(x) \right| dx + \left| \int_{a}^{b} g(x) \sin(Nx) dx \right| \\
&amp;amp;&amp;lt; \int_{a}^{b} \varepsilon dx + \left| \int_{a}^{b} g(x) \sin(Nx) dx \right| = \varepsilon(b - a) + \left| \int_{a}^{b} g(x) \sin(Nx) dx \right|
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、 &lt;span class="math"&gt;\(\displaystyle\left| \int_{a}^{b} g(x) \sin(Nx) dx \right| &amp;lt; \varepsilon\)&lt;/span&gt; となる様に &lt;span class="math"&gt;\(N\)&lt;/span&gt; を十分大きく取る（ &lt;span class="math"&gt;\(g(x)\)&lt;/span&gt; は区分的なめらかなので成立する）と、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left| \int_{a}^{b} f(x) \sin(Nx) dx \right|  &amp;lt; \varepsilon(b-a) + \varepsilon = \varepsilon(b - a + 1)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;即ち、任意の &lt;span class="math"&gt;\(\varepsilon\)&lt;/span&gt; に対して上式を成り立たせる &lt;span class="math"&gt;\(N\)&lt;/span&gt; が存在するので、 &lt;a class="reference internal" href="#math-block-16"&gt;式16&lt;/a&gt; が成り立つ。&lt;/p&gt;
&lt;div class="math" id="math-block-16"&gt;
\begin{equation*}
\lim_{N \to \infty} \left| \int_{a}^{b} f(x) \sin(Nx) dx \right| = 0 \tag{16}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;a class="reference internal" href="#math-block-16"&gt;式16&lt;/a&gt; は、リーマン・ルベーグの補題（ &lt;a class="reference internal" href="#math-block-15"&gt;式15&lt;/a&gt; ）が成立していることをそのまま示している。何故なら、ある関数の絶対値が &lt;span class="math"&gt;\(0\)&lt;/span&gt; に収束することと、関数が &lt;span class="math"&gt;\(0\)&lt;/span&gt; に収束することは同値だからである。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-13"&gt;
&lt;h4&gt;収束定理の証明&lt;/h4&gt;
&lt;p&gt;ここまでの結果を利用して、収束定理を示そう。まず &lt;a class="reference internal" href="#math-block-11"&gt;式11&lt;/a&gt; より、ディリクレ核を使用して &lt;span class="math"&gt;\(S_{N}(x)\)&lt;/span&gt; を書き直すと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
S_{N}(x) - f(x) = \frac{1}{\pi} \int_{-\pi}^{\pi} f(x+z) D_{N}(x) dx - f(x)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで、ディリクレ核の性質（ &lt;a class="reference internal" href="#math-block-13"&gt;式13&lt;/a&gt;, &lt;a class="reference internal" href="#math-block-14"&gt;式14&lt;/a&gt; ）を用いると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
S_{N}(x) - f(x)
&amp;amp;= \frac{1}{\pi} \int_{-\pi}^{\pi} f(x+z) D_{N}(z) dz - 1 \times f(x) \\
&amp;amp;= \frac{1}{\pi} \int_{-\pi}^{\pi} f(x+z) D_{N}(z) dz - \frac{1}{\pi} \int_{-\pi}^{\pi} D_{N}(z) dz f(x) \\
&amp;amp;= \frac{1}{\pi} \int_{-\pi}^{\pi} \left\{ f(x+z) - f(x) \right\} D_{N}(z) dz \\
&amp;amp;= \frac{1}{\pi} \int_{-\pi}^{\pi} \left\{ f(x+z) - f(x) \right\} \frac{\sin\left\{\left( \frac{1}{2} + N \right)z\right\}}{2\sin\left(\frac{1}{2}z\right)} dz \\
&amp;amp;= \frac{1}{\pi} \int_{-\pi}^{\pi} \frac{ f(x+z) - f(x) }{2\sin\left(\frac{1}{2}z\right)} \sin\left\{\left( \frac{1}{2} + N \right)z\right\} dz
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここでリーマン・ルベーグの補題を用いる。ただし、そのためには、&lt;span class="math"&gt;\(\displaystyle\frac{ f(x+z) - f(x) }{2\sin\left(\frac{1}{2}z\right)}\)&lt;/span&gt; が区分的に連続でなければならない。この分数は &lt;span class="math"&gt;\(z = 0\)&lt;/span&gt; の時、分母 &lt;span class="math"&gt;\(2\sin\left(\frac{1}{2}z\right)\)&lt;/span&gt; が &lt;span class="math"&gt;\(0\)&lt;/span&gt; になるので、&lt;span class="math"&gt;\(z=0\)&lt;/span&gt; においても発散しないことを示す必要がある。以下の極限を考えると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\lim_{z \to 0} \frac{ f(x+z) - f(x) }{2\sin\left(\frac{1}{2}z\right)}
&amp;amp;= \lim_{z \to 0} \frac{ f(x+z) - f(x) }{z} \frac{z}{2\sin\left(\frac{1}{2}z\right)} \\
&amp;amp;= \lim_{z \to 0} \frac{ f(x+z) - f(x) }{z} \lim_{z \to 0} \frac{\ddiff{z}{z}}{\ddiff{2\sin\left(\frac{1}{2}z\right)}{z}} \quad (\because ロピタルの定理) \\
&amp;amp;= \lim_{z \to 0} \frac{ f(x+z) - f(x) }{z} \frac{1}{2\frac{1}{2}} \\
&amp;amp;= f^{\prime}(x)
\end{align*}
&lt;/div&gt;
&lt;p&gt;より、 &lt;span class="math"&gt;\(f^{\prime}(x)\)&lt;/span&gt; が発散しない、即ち &lt;strong&gt;関数&lt;/strong&gt; &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; &lt;strong&gt;が区分的になめらか&lt;/strong&gt; であれば、リーマン・ルベーグの補題を使用することで、収束定理&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\lim_{N \to \infty} \left\{ S_{N}(x) - f(x) \right\} = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成立する。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-14"&gt;
&lt;h3&gt;三角関数の完全性&lt;/h3&gt;
&lt;p&gt;フーリエ級数の収束定理を用いることで、三角関数基底によって基底は全て揃うのか？という問に答えを与える事ができる。この性質を、 &lt;strong&gt;三角関数の完全性&lt;/strong&gt; という。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;三角関数の完全性&lt;/dt&gt;
&lt;dd&gt;定数、&lt;span class="math"&gt;\(\sin\)&lt;/span&gt; 、&lt;span class="math"&gt;\(\cos\)&lt;/span&gt; によって全ての関数基底が揃っている。&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;証明は背理法による。&lt;/p&gt;
&lt;p&gt;（証明）基底が揃っていない場合には次の仮定が成り立つ。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;仮定&lt;/dt&gt;
&lt;dd&gt;定数、&lt;span class="math"&gt;\(\sin\)&lt;/span&gt; 、&lt;span class="math"&gt;\(\cos\)&lt;/span&gt; の全てに直交している連続関数基底が存在する。&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;この命題の矛盾を導くことで、三角関数基底の完全性を示す。&lt;/p&gt;
&lt;p&gt;まず、「定数、sin、cosの全てに直交している連続関数」を &lt;span class="math"&gt;\(h(x)\)&lt;/span&gt; とおく。その定義から、以下が成り立つ：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ifdiv{ll}{
   \innerp{h(x)}{1} = \displaystyle\int_{-\pi}^{\pi} h(x) dx = 0 &amp;amp; \\
   \innerp{h(x)}{\cos(nx)} = \displaystyle\int_{-\pi}^{\pi} h(x) \cos(nx) dx = 0 &amp;amp; (n \in \mathbb{N}) \\
   \innerp{h(x)}{\sin(nx)} = \displaystyle\int_{-\pi}^{\pi} h(x) \sin(nx) dx = 0 &amp;amp; (n \in \mathbb{N})
}
\end{align*}
&lt;/div&gt;
&lt;p&gt;これらの条件を満たす自明な関数に &lt;span class="math"&gt;\(h(x) = 0\)&lt;/span&gt; があるが、 &lt;span class="math"&gt;\(h(x) = 0\)&lt;/span&gt; は関数空間の零ベクトルに対応し空間を生成しない（この関数をスカラー倍しても同じ関数しか出てこない）ため、基底とはならない。従って、 &lt;span class="math"&gt;\(h(x) = 0\)&lt;/span&gt; 以外の関数で考える。&lt;/p&gt;
&lt;p&gt;この前提の上で、&lt;span class="math"&gt;\(h(x)\)&lt;/span&gt; をフーリエ係数展開 &lt;span class="math"&gt;\(S_{N}(x)\)&lt;/span&gt; によって表現すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
S_{N}(x)
&amp;amp;= \frac{1}{2} a_{0} + \sum_{n=1}^{N} \left\{ a_{n} \cos(nx) + b_{n} \sin(nx) \right\} \\
&amp;amp;= \frac{1}{2} \frac{1}{\pi} \innerp{1}{h(x)} + \sum_{n=1}^{N} \left\{ \frac{1}{\pi} \innerp{\cos(ny)}{h(y)} \cos(nx) + \frac{1}{\pi} \innerp{\sin(ny)}{h(y)} \sin(nx) \right\} \\
&amp;amp;= \frac{1}{2\pi} \int_{-\pi}^{\pi} h(y) dy + \sum_{n=1}^{N} \left\{ \frac{1}{\pi} \int_{-\pi}^{\pi} \cos(ny)h(y) dy \cos(nx) + \frac{1}{\pi} \int_{-\pi}^{\pi} \sin(ny)h(y) dy \sin(nx) \right\} \\
&amp;amp;= 0
\end{align*}
&lt;/div&gt;
&lt;p&gt;フーリエ級数の収束定理を用いると、 &lt;span class="math"&gt;\(\displaystyle\lim_{N \to \infty} S_{N} = h(x) = 0\)&lt;/span&gt; 。この結果は、 &lt;span class="math"&gt;\(h(x) = 0\)&lt;/span&gt; 以外の関数で考えていることに矛盾する。従って、冒頭で述べた三角関数の完全性が成り立つ。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-15"&gt;
&lt;h3&gt;フーリエ変換&lt;/h3&gt;
&lt;p&gt;周期 &lt;span class="math"&gt;\(T\)&lt;/span&gt; の実関数 &lt;span class="math"&gt;\(f : \mathbb{R} \to \mathbb{R}\)&lt;/span&gt; に対して、 （複素）フーリエ級数展開は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left\{ \begin{array}{l}
  f(t)  = \displaystyle\sum_{n = -\infty}^{\infty} c_{n} \exp(j n\omega_{0}t) \\
  c_{n} = \displaystyle\frac{1}{T} \int^{T/2}_{-T/2} f(t) \exp(-j n\omega_{0} t) dt
  \end{array} \right.
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる。 ここで &lt;span class="math"&gt;\(j\)&lt;/span&gt; は虚数単位（&lt;span class="math"&gt;\(j = \sqrt{-1}\)&lt;/span&gt; ）、 &lt;span class="math"&gt;\(\omega_{0} = 2\pi/T\)&lt;/span&gt; である。 フーリエ級数展開により、 様々な周期関数 &lt;span class="math"&gt;\(f\)&lt;/span&gt; は周波数領域（異なる周波数を持つ三角関数の和）で表現できることは周知である。 今、 &lt;span class="math"&gt;\(c_{n}\)&lt;/span&gt; を消去すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(t) = \sum_{n=-\infty}^{\infty} \frac{1}{T} \left\{ \int^{T/2}_{-T/2} f(t) \exp(-jn\omega_{0}t)dt \right\} \exp(jn\omega_{0}t)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;更に、 &lt;span class="math"&gt;\(F(n\omega_{0}) = \displaystyle\int^{T/2}_{-T/2} f(t) \exp(-jn\omega_{0}t) dt\)&lt;/span&gt; とおくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(t) = \sum_{n=-\infty}^{\infty} \frac{1}{T} F(n\omega_{0}) \exp(jn\omega_{0}t) = \frac{1}{2\pi} \sum_{n=-\infty}^{\infty} \omega_{0} F(n\omega_{0}) \exp(j n \omega_{0}t)
\end{equation*}
&lt;/div&gt;
&lt;!-- &amp;=&amp; \frac{1}{2\pi} \sum^{\infty}_{n = -\infty} \omega_{0} F(\omega) \exp(j \omega t) \quad (\omega = n \omega_{0}) --&gt;
&lt;p&gt;となる。 今、 &lt;span class="math"&gt;\(T \to \infty\)&lt;/span&gt; ならしめ周期を無限大にすると &lt;span class="math"&gt;\(\omega_{0}\)&lt;/span&gt; は &lt;span class="math"&gt;\(0\)&lt;/span&gt; に収束するので、&lt;span class="math"&gt;\(\omega_{0}\)&lt;/span&gt; を区間幅とした区分求積法により、 次の積分と等しくなる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left\{ \begin{array}{l}
  f(t)  = \displaystyle\frac{1}{2\pi}\int_{-\infty}^{\infty} F(\omega) \exp(j \omega t) d\omega \\
  F(\omega) = \displaystyle \int^{\infty}_{-\infty} f(t) \exp(-j\omega t) dt
  \end{array} \right.
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで &lt;span class="math"&gt;\(F(\omega)\)&lt;/span&gt; は &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; のフーリエ変換、 &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; は &lt;span class="math"&gt;\(F(\omega)\)&lt;/span&gt; のフーリエ逆変換（逆フーリエ変換）と呼ばれる。 非周期的な関数は周期無限の関数とも考えられるので、 フーリエ変換によって、 様々な関数の周波数領域表現を得る事ができる。 但し、&lt;span class="math"&gt;\(F(\omega)\)&lt;/span&gt; の収束を保証するため、 &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; は絶対可積分:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\int_{-\infty}^{\infty} |f(t)| dt &amp;lt; \infty \quad （(-\infty、 \infty)における積分値が有界）
\end{equation*}
&lt;/div&gt;
&lt;p&gt;でなくてはならない。 もし、 上の積分が有界な値を取るならば、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
F(\omega)
&amp;amp;= \int^{\infty}_{-\infty} f(t) \exp(-j\omega t) dt \\
&amp;amp;&amp;lt; \int^{\infty}_{-\infty} |f(t) \exp(-j\omega t)| dt &amp;lt; \int^{\infty}_{-\infty} |f(t)||\exp(-j\omega t)| dt \\
&amp;amp;= \int^{\infty}_{-\infty} |f(t)| dt \quad （\because オイラーの公式より |\exp(-j\omega t)| = \sqrt{\cos^{2} \omega t + \sin^{2} \omega t} = 1）
\end{align*}
&lt;/div&gt;
&lt;p&gt;となって &lt;span class="math"&gt;\(F(\omega)\)&lt;/span&gt; もまた有界である事が分かる。&lt;/p&gt;
&lt;div class="section" id="section-16"&gt;
&lt;h4&gt;ラプラス変換&lt;/h4&gt;
&lt;p&gt;実関数 &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; に収束因子 &lt;span class="math"&gt;\(\exp(-\sigma t)\)&lt;/span&gt; （&lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; は非負実数）を乗じた関数 &lt;span class="math"&gt;\(f(t)\exp(-\sigma t)\)&lt;/span&gt; のフーリエ変換&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\int^{\infty}_{-\infty} f(t)\exp(-\sigma t) \exp(-j\omega t) dt = \displaystyle \int^{\infty}_{-\infty} f(t)\exp(-st) dt = F(s) \quad （s = \sigma + j\omega）
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を &lt;strong&gt;（両側）ラプラス変換&lt;/strong&gt; と呼ぶ。 ラプラス変換は、 &lt;span class="math"&gt;\(s\)&lt;/span&gt; が複素数であることにより、 周波数領域だけ（&lt;span class="math"&gt;\(\sigma = 0\)&lt;/span&gt; とした時。 フーリエ変換と等価となる）でなく、 複素数領域で過渡的な（振動の減衰/増大）現象をも解析の対象とすることができる。 また、&lt;span class="math"&gt;\(F(s)\)&lt;/span&gt; から &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; に変換するラプラス逆変換（逆ラプラス変換）は、 次の式で定義される:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(t) = \frac{1}{2\pi j} \lim_{\omega \to \infty} \int^{c + j\omega}_{c - j\omega} F(s) \exp(st) ds
\end{equation*}
&lt;/div&gt;
&lt;p&gt;以後、 実関数 &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; のラプラス変換を &lt;span class="math"&gt;\(\mathcal{L}[f(t)]( = F(s))\)&lt;/span&gt; 、&lt;span class="math"&gt;\(F(s)\)&lt;/span&gt; のラプラス逆変換を &lt;span class="math"&gt;\(\mathcal{L}^{-1}[F(s)]( = f(t))\)&lt;/span&gt; と表す。&lt;/p&gt;
&lt;p&gt;工学的な応用の場面では、 ラプラス変換の積分範囲は &lt;span class="math"&gt;\([0, \infty)\)&lt;/span&gt; とする事が多い:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F(s) = \int^{\infty}_{0} f(t)\exp(-st) dt
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これを特に片側ラプラス変換と呼ぶ。 ラプラス変換は演算子法の一種であり、 様々な関数の変換結果（ラプラス変換対）をまとめたラプラス変換表を参照しながら、 微分方程式を代数的、 かつ簡易に解くことができる。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-17"&gt;
&lt;h4&gt;伝達関数&lt;/h4&gt;
&lt;p&gt;1つの入力かつ1つの出力があるシステム（一入力一出力システム）を考える。 入力の振る舞いを表す実関数を &lt;span class="math"&gt;\(x(t)\)&lt;/span&gt; 、 それに対する出力も実関数 &lt;span class="math"&gt;\(y(t)\)&lt;/span&gt; と表せるとする。 ここで``振る舞いを表す実関数''とは、 線形微分方程式で記述されているラプラス変換可能な関数を意味する。 従って &lt;span class="math"&gt;\(x(t), y(t)\)&lt;/span&gt; のラプラス変換 &lt;span class="math"&gt;\(X(s)、 Y(s)\)&lt;/span&gt; は、 微分演算子の存在によりそれぞれ &lt;span class="math"&gt;\(s\)&lt;/span&gt; の多項式で表現できる事が分かる。&lt;/p&gt;
&lt;!-- :math:`x(t), y(t)` それぞれのラプラス変換の結果を :math:`{\cal L}[x(t)] = X(s)` 、 :math:`{\cal L}[y(t)] = Y(s)` とした時、 --&gt;
&lt;p&gt;そして、 出力と入力のラプラス変換の比を &lt;strong&gt;伝達関数(Transfer function)&lt;/strong&gt; と呼ぶ。  伝達関数を &lt;span class="math"&gt;\(G(s)\)&lt;/span&gt; とすると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
G(s) = \frac{Y(s)}{X(s)}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表すことができる。 伝達関数 &lt;span class="math"&gt;\(G(s)\)&lt;/span&gt; は入力と出力の関係をひとまとめにし、 システムの特性（性質）を代表している事が分かる。 出力 &lt;span class="math"&gt;\(y(t)\)&lt;/span&gt; の振る舞いは &lt;span class="math"&gt;\(Y(s) = G(s)X(s)\)&lt;/span&gt; から両辺ラプラス逆変換を施すことにより求めることができる。 また、 &lt;span class="math"&gt;\(G(s)\)&lt;/span&gt; 自体の様子（分母分子の多項式の係数）から、 システムの安定性を判定することもできる。 この様に、 伝達関数はシステムの特性を観察する際に大いに役立ち、 古典制御理論の中心をなす概念となっている。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-18"&gt;
&lt;h4&gt;安定性解析の概要&lt;/h4&gt;
&lt;p&gt;伝達関数からシステムの安定性を解析する事を考える。 まず、 システムが &lt;strong&gt;安定(stable)&lt;/strong&gt; であるとは、 任意の時間で有界な任意の入力 &lt;span class="math"&gt;\(x(t)\)&lt;/span&gt; （&lt;span class="math"&gt;\({}^{\forall} t. |x(t)| &amp;lt; \infty\)&lt;/span&gt; ）に対して、 その出力 &lt;span class="math"&gt;\(y(t)\)&lt;/span&gt; もまた任意の時間で有界である時を言う &lt;a class="footnote-reference" href="#aboutstatibility" id="footnote-reference-5"&gt;[5]&lt;/a&gt; 。&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="aboutstatibility" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;厳密には、 リペアノフの意味で安定と言う。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;逆に安定で無い、 即ち出力が有界でない時間がある（&lt;span class="math"&gt;\({}^{\exists} t. |y(t)| = \infty\)&lt;/span&gt; ）システムを不安定(unstable)と言う。 任意の入力 &lt;span class="math"&gt;\(x(t)\)&lt;/span&gt; に対してその出力 &lt;span class="math"&gt;\(y(t)\)&lt;/span&gt; の挙動を調べる事は不可能だが、 実際には、 入力 &lt;span class="math"&gt;\(x(t)\)&lt;/span&gt; を単位ステップ関数&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
x(t) =
\left\{ \begin{array}{ll}
  0 &amp;amp; t &amp;lt; 0 \\
  1 &amp;amp; t \geq 0
\end{array} \right.
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とした時の出力 &lt;span class="math"&gt;\(y(t)\)&lt;/span&gt; が有界な値に収束すれば安定となる事が示されている。&lt;/p&gt;
&lt;p&gt;それでは伝達関数 &lt;span class="math"&gt;\(G(s)\)&lt;/span&gt; からシステムの安定性を判定する事を考える。 入力 &lt;span class="math"&gt;\(x(t)\)&lt;/span&gt; 、 出力 &lt;span class="math"&gt;\(y(t)\)&lt;/span&gt; それぞれのラプラス変換の結果を &lt;span class="math"&gt;\(\mathcal{L}[x(t)] = X(s)\)&lt;/span&gt; 、 &lt;span class="math"&gt;\({\cal L}[y(t)] = Y(s)\)&lt;/span&gt; とした時、 伝達関数は &lt;span class="math"&gt;\(s\)&lt;/span&gt; の多項式の比なので、一般に次の形で表せる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
G(s)
&amp;amp;= \frac{Y(s)}{X(s)} = \frac{b_{m}s^{m} + b_{m-1}s^{m-1} + \dots + b_{1}s + b_{0}}{s^{n} + a_{n-1}s^{n-1} + \dots + a_{1}s + a_{0}} \\
&amp;amp;= \frac{b_{m}(s-z_{1})(s-z_{2})\dots(s-z_{m})}{(s-p_{1})(s-p_{2})\dots(s-p_{n})}
\end{align*}
&lt;/div&gt;
&lt;p&gt;（現実には &lt;span class="math"&gt;\(n \geq m\)&lt;/span&gt; であることが多く、 その場合 &lt;strong&gt;プロパー&lt;/strong&gt; であると呼ばれる）。 ここで、 &lt;span class="math"&gt;\(Y(s) = 0\)&lt;/span&gt; の根 &lt;span class="math"&gt;\(z_{1}, \dots, z_{m}\)&lt;/span&gt; をこのシステムの零点(zero)、 &lt;span class="math"&gt;\(X(s)=0\)&lt;/span&gt; の根 &lt;span class="math"&gt;\(p_{1}、\dots、p_{n}\)&lt;/span&gt; をこのシステムの極(pole)と呼ぶ &lt;a class="footnote-reference" href="#aboutsystemcharapoly" id="footnote-reference-6"&gt;[6]&lt;/a&gt; 。&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="aboutsystemcharapoly" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;span class="math"&gt;\(X(s)\)&lt;/span&gt; 自身をそのシステムの特性多項式(characteristic polynominal)、 また &lt;span class="math"&gt;\(X(s)=0\)&lt;/span&gt; を特性方程式(characteristic equation)と呼ぶ&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;安定性の判定の為入力を単位ステップ関数とすると、 出力のラプラス変換 &lt;span class="math"&gt;\(Y(s)\)&lt;/span&gt; は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
Y(s) = G(s)X(s) = G(s)\frac{1}{s} = \frac{b_{m}(s-z_{1})(s-z_{2})\dots(s-z_{m})}{s(s-p_{1})(s-p_{2})\dots(s-p_{n})}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となり、 この式を部分分数分解すると、 一般に&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
Y(s) = \frac{A}{s} + \sum_{k=1}^{n} \frac{B_{k}}{s-p_{k}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表わすことができ（&lt;span class="math"&gt;\(A、 B_{k}\)&lt;/span&gt; :係数）、 これを両辺ラプラス逆変換することで、 出力の一般解&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
y(t) = A + \sum_{k=1}^{n} B_{k} \exp(p_{k}t)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を得る。 更に &lt;span class="math"&gt;\(p_{k}\)&lt;/span&gt; は一般に複素数なので、 実数係数 &lt;span class="math"&gt;\(\sigma_{k}, \omega_{k}\)&lt;/span&gt; を用いて &lt;span class="math"&gt;\(p_{k} = \sigma_{k} + j \omega_{k}\)&lt;/span&gt; と表し &lt;span class="math"&gt;\(y(t)\)&lt;/span&gt; を変形すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
y(t)
&amp;amp;= A + \sum_{k=1}^{n} B_{k} \exp[(\sigma_{k} + j \omega_{k})t] \\
&amp;amp;= A + \sum_{k=1}^{n} B_{k} \exp(\sigma_{k}t) (\cos\omega_{k}t + j\sin\omega_{k}t) \quad （\because オイラーの公式）
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。 今、 ある &lt;span class="math"&gt;\(\sigma_{i}\ (i=1, \dots, n)\)&lt;/span&gt; が一つでも正ならば、 時間の極限 &lt;span class="math"&gt;\(t\to \infty\)&lt;/span&gt; をとると &lt;span class="math"&gt;\(y(t)\)&lt;/span&gt; は発散してしまい、 システムが不安定となることが分かる。
従って &lt;strong&gt;システムが安定となる為には全ての極の実数部が負&lt;/strong&gt; （&lt;span class="math"&gt;\({}^{\forall} k. \sigma_{k} &amp;lt; 0\)&lt;/span&gt; ） &lt;strong&gt;となる事が必要十分&lt;/strong&gt; であることが分かる。この時は特に &lt;span class="math"&gt;\(y(t)\)&lt;/span&gt; は &lt;span class="math"&gt;\(A\)&lt;/span&gt; に収束する（&lt;span class="math"&gt;\(\displaystyle\lim_{t \to \infty} y(t) = A\)&lt;/span&gt; ）ので、 システムは &lt;strong&gt;漸近安定&lt;/strong&gt; であると言う。&lt;/p&gt;
&lt;p&gt;伝達関数に基づくシステムの安定性解析は、 本質的には以上の様に極の実部を調べることにより行われる。 しかし実際複雑な（&lt;span class="math"&gt;\(n, m\)&lt;/span&gt; が大きい）システムでは方程式を解き極を計算するのが困難となるので、 方程式を解かずともシステムの安定/不安定を判別する手法が存在する &lt;a class="footnote-reference" href="#aboutstatibilitycheck" id="footnote-reference-7"&gt;[7]&lt;/a&gt; 。&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="aboutstatibilitycheck" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-7"&gt;[7]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;伝達関数の係数から判定する手法として、 ラウスの安定判別法や、 フルビッツの安定判別法がある&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-19"&gt;
&lt;h3&gt;ギブス現象&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ギブス現象(Gibbs phenomenon)&lt;/strong&gt; とは、 不連続な点を含む周期関数のフーリエ級数近似において、 不連続点付近では級数和の絶対値が原関数のとる値の絶対値よりも大きくなってしまう現象のことである。 その原因は、 不連続な関数を連続な関数基底で近似してしまう事による。&lt;/p&gt;
&lt;p&gt;ギブス現象の例を数式で観察してみる。 今、不連続点を含む、区分的に連続微分可能な周期 &lt;span class="math"&gt;\(T\)&lt;/span&gt; の実関数 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; を考える。 その &lt;span class="math"&gt;\(N\)&lt;/span&gt; 次までの複素フーリエ級数近似 &lt;span class="math"&gt;\(S_{N}(x)\)&lt;/span&gt; は:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
S_{N}(x)
&amp;amp;= \sum^{N}_{n = -N} c_{n} \exp(jn\omega_{0}x)\quad (\omega_{0} = \frac{2\pi}{T}) \\
c_{n}
&amp;amp;= \frac{1}{T} \int^{T/2}_{-T/2} f(t)\exp(-jn\omega_{0}t) {\rm dt}
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。 ところで、 ギブス現象は不連続点付近で &lt;span class="math"&gt;\(S_{N}(x)\)&lt;/span&gt; が飛び出る事によって認知される。 &lt;span class="math"&gt;\(S_{N}(x)\)&lt;/span&gt; が三角関数の和で表現されている事に注目すると、 その飛び出た点は、&lt;span class="math"&gt;\(S_{N}(x)\)&lt;/span&gt; の極値であると捉える事ができる。 従って、 &lt;span class="math"&gt;\(S_{N}(x)\)&lt;/span&gt; を &lt;span class="math"&gt;\(x\)&lt;/span&gt; によって微分すると:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ddiff{}{x}S_{N}(x)
&amp;amp;= \sum_{n = -N}^{N} c_{n} \ddiff{}{x}\exp(jn\omega_{0}x) \quad (\because 項別微分) \\
&amp;amp;= j \omega_{0} \sum^{N}_{n = -N} n c_{n} \exp(jn\omega_{0}x) \\
&amp;amp;= j \omega_{0} \sum^{N}_{n = -N} n c_{n} \left\{ \cos(n\omega_{0}x) + j \sin(n\omega_{0}x) \right\} \quad (\because オイラーの公式) \\
&amp;amp;= j \omega_{0} \sum^{N}_{n = -N} n c_{n} \cos(n\omega_{0}x) - \omega_{0} \sum^{N}_{n = -N} n c_{n} \sin(n\omega_{0}x)
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(c_{n}\)&lt;/span&gt; の実部を &lt;span class="math"&gt;\({\rm Re}[c_{n}]\)&lt;/span&gt; 、 虚部を &lt;span class="math"&gt;\({\rm Im}[c_{n}]\)&lt;/span&gt; と表すと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ddiff{}{x}S_{N}(x)
&amp;amp;= - \omega_{0} \left[ \sum^{N}_{n = -N} n \left\{ {\rm Im}[c_{n}]\cos(n\omega_{0}x) + {\rm Re}[c_{n}]\sin(n\omega_{0}x) \right\} \right. \\
\ &amp;amp; \quad - \left. j \sum^{N}_{n = -N} n \left\{ {\rm Re}[c_{n}]\cos(n\omega_{0}x) + {\rm Im}[c_{n}]\sin(n\omega_{0}x) \right\} \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、 &lt;span class="math"&gt;\(c_{-n} = c_{n}^{\ast}\)&lt;/span&gt; (&lt;span class="math"&gt;\(c_{n}\)&lt;/span&gt; の複素共役)を用いると、 &lt;span class="math"&gt;\({\rm Im}[c_{-n}] = -{\rm Im}[c_{n}]\)&lt;/span&gt; 、 &lt;span class="math"&gt;\({\rm Re}[c_{-n}] = {\rm Re}[c_{n}]\)&lt;/span&gt; であることより、 以下の様に、 虚部を含まない形に整理できる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ddiff{}{x}S_{N}(x)
&amp;amp;= - \omega_{0} \left[ \sum^{N}_{n = 1} n \left\{ {\rm Im}[c_{n}]\cos(n\omega_{0}x) + {\rm Re}[c_{n}]\sin(n\omega_{0}x) \right\} \right. \\
\ &amp;amp; \quad + \sum^{N}_{k = 1} (-k) \left\{ {\rm Im}[c_{-k}]\cos(k\omega_{0}x) - {\rm Re}[c_{-k}]\sin(k\omega_{0}x) \right\} \\
\ &amp;amp; \quad - j \sum^{N}_{n = 1} n    \left\{ {\rm Re}[c_{n}]\cos(n\omega_{0}x) - {\rm Im}[c_{n}]\sin(n\omega_{0}x) \right\} \\
\ &amp;amp; \quad - j \left. \sum^{N}_{k = 1} (-k) \left\{ {\rm Re}[c_{-k}]\cos(k\omega_{0}x) + {\rm Im}[c_{-k}]\sin(k\omega_{0}x) \right\} \right] \\
&amp;amp;= -2\omega_{0} \sum^{N}_{n=1} n \left\{ {\rm Im}[c_{n}]\cos(n\omega_{0}x) + {\rm Re}[c_{n}]\sin(n\omega_{0}x) \right\}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\displaystyle\ddiff{}{x}S_{N}(x)\)&lt;/span&gt; を &lt;span class="math"&gt;\(0\)&lt;/span&gt; とおくと、 &lt;span class="math"&gt;\(n &amp;gt; 0\)&lt;/span&gt; より、 極値条件の一つとして&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
{\rm Im}[c_{n}]\cos(n\omega_{0}x) + {\rm Re}[c_{n}]\sin(n\omega_{0}x) = 0 \quad (n = 1, \cdots, N)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;があり、 これを &lt;span class="math"&gt;\(x\)&lt;/span&gt; について解くと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
x = -\frac{1}{n\omega_{0}} \tan^{-1}\left( \frac{ {\rm Im}[c_{n}] }{ {\rm Re}[c_{n}] } \right) \quad (n = 1, \cdots, N)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が得られる。&lt;/p&gt;
&lt;p&gt;ギブス現象の例として、 今、&lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; として周期 &lt;span class="math"&gt;\(2\pi\)&lt;/span&gt; の矩形波を仮定する:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(t) =
\left\{
  \begin{array}{ll}
    1  &amp;amp; (0 \leq x &amp;lt; \pi) \\
    -1 &amp;amp; (\pi \leq x &amp;lt; 2\pi)
  \end{array}
\right.
\end{equation*}
&lt;/div&gt;
&lt;p&gt;定義のとおり、&lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; は奇関数であるため &lt;span class="math"&gt;\({\rm Re}[c_{n}] = 0\)&lt;/span&gt; であり、 また &lt;span class="math"&gt;\({\rm Im}[c_{n}]\)&lt;/span&gt; は:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
{\rm Im}[c_{n}]
&amp;amp;= - \frac{1}{2\pi} \int^{\pi}_{-\pi} f(t) \sin(nt) {\rm dt} \quad (\omega_{0} = \frac{2\pi}{2\pi} = 1) \\
&amp;amp;= \frac{1}{n\pi} \left[ \cos(nx) \right]^{\pi}_{0} = - \frac{1}{n\pi} \left\{ 1 - (-1)^{n} \right\}
\end{align*}
&lt;/div&gt;
&lt;p&gt;この結果より &lt;span class="math"&gt;\(\tan^{-1}({\rm Im}[c_{n}]/{\rm Re}[c_{n}])\)&lt;/span&gt; を考えると、 &lt;span class="math"&gt;\({\rm Im}[c_{n}]/{\rm Re}[c_{n}] \to -\infty\)&lt;/span&gt; より、 極値条件は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
x = - \frac{1}{n} \left( - \frac{\pi}{2} \right) = \frac{\pi}{2n} \quad (n = 1、\cdots、N)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる。 この結果を用いて、 不連続点 &lt;span class="math"&gt;\(x = 0\)&lt;/span&gt; における近似 &lt;span class="math"&gt;\(S_{N}(x)\)&lt;/span&gt; の値を計算する事を考える。 &lt;span class="math"&gt;\(x = 0\)&lt;/span&gt; に最も近い極値を与える &lt;span class="math"&gt;\(x\)&lt;/span&gt; の値は、 &lt;span class="math"&gt;\(n = N\)&lt;/span&gt; の時、 即ち &lt;span class="math"&gt;\(x = \displaystyle\frac{\pi}{2N}\)&lt;/span&gt; となるので、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
S_{N}\left(\frac{\pi}{2N}\right)
&amp;amp;= \sum_{n = -N}^{N} c_{n} \exp\left(j\frac{n\pi}{2N}\right) \\
&amp;amp;= \frac{2}{\pi} \sum_{n = 1}^{N} \frac{1}{n} \{ 1 - (-1)^{n} \} \sin\left(\frac{n\pi}{2N}\right) \\
&amp;amp;= \frac{4}{\pi} \sum_{k = 1}^{N} \frac{1}{2k-1} \sin\left(\frac{2k-1}{2N}\pi \right) \quad(n = 2k - 1) \\
&amp;amp;= \frac{2}{\pi} \frac{\pi}{N} \sum_{k = 1}^{N} \frac{1}{\frac{2k-1}{2N}\pi} \sin\left(\frac{2k-1}{2N}\pi \right)
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで区分求積法を用いる。 分割幅 &lt;span class="math"&gt;\(|\Delta|\)&lt;/span&gt; を &lt;span class="math"&gt;\(\displaystyle\frac{\pi}{N}\)&lt;/span&gt; とすると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
S_{N}\left(\frac{\pi}{2N}\right)
&amp;amp;= \frac{2}{\pi} |\Delta| \sum_{k=1}^{N}\frac{1}{\frac{2k-1}{2}|\Delta|}\sin\left(\frac{2k-1}{2}|\Delta|\right) \\
\therefore \lim_{N\to \infty} S_{N}\left( \frac{\pi}{2N} \right)
&amp;amp;= \frac{2}{\pi} \int^{\pi}_{0} \frac{\sin(y)}{y} {\rm dy} \approx 1.17834\cdots
\end{align*}
&lt;/div&gt;
&lt;p&gt;従って、 &lt;span class="math"&gt;\(N\)&lt;/span&gt; の極限をとっても目標値 &lt;span class="math"&gt;\(1\)&lt;/span&gt; に収束できない事が確認できた。  ここで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\int^{\pi}_{0} \frac{\sin(y)}{y} {\rm dy} = 1.851937052\cdots
\end{equation*}
&lt;/div&gt;
&lt;p&gt;の結果はギブス定数を用いている。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-20"&gt;
&lt;h3&gt;エイリアシング（折り返し歪み）&lt;/h3&gt;
&lt;p&gt;エイリアシングは、 連続値（アナログ）信号をPCで扱うために離散（デジタル）化するA/D変換を行った際や、 デジタル化した画像に縮小処理などのフィルターに掛けた際に発生しうる現象であり、
本来音声や画像には見られなかった干渉縞（偽解像、 モアレ）が発生してしまう。&lt;/p&gt;
&lt;p&gt;この現象は、 A/D変換においては標本化（サンプリング）の周波数設定、 フィルター処理においてはフィルターそのものが原因である。&lt;/p&gt;
&lt;p&gt;A/D変換におけるエイリアシングの発生の概要を見ていく。 そもそも標本化とは、 連続値信号 &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; をある間隔（サンプリング周期） &lt;span class="math"&gt;\(T\)&lt;/span&gt; での（ディラック）インパルス関数で表現する事を指す（ &lt;a class="reference internal" href="#image-1"&gt;図1&lt;/a&gt; ）。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="sampling.png" id="image-1" src="images/sampling.png" /&gt;
&lt;p class="caption"&gt;周期インパルス関数による標本化&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;インパルス関数 &lt;span class="math"&gt;\(\delta(t)\)&lt;/span&gt; は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\int^{\infty}_{-\infty} f(t)\delta(t) {\rm dt} = f(0)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たす超関数であり、 標本化信号 &lt;span class="math"&gt;\(g(t)\)&lt;/span&gt; は、 &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; とインパルス関数を周期 &lt;span class="math"&gt;\(T\)&lt;/span&gt; で並べた周期的デルタ関数 &lt;span class="math"&gt;\(\delta_{T}(t)\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\delta_{T}(t) = \sum^{\infty}_{n = -\infty} \delta(t - nT)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;との積で表現できる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
g(t) = f(t)\delta_{T}(t) = \sum^{\infty}_{n=-\infty}f(t)\delta(t-nT)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;数値計算上、 和の無限は扱うことができないので、 ここで信号 &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; は、 標本化する区間で周期性を持つと仮定する。 ここでは、 &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; はサンプリング間隔の &lt;span class="math"&gt;\(N\)&lt;/span&gt; 倍の周期 &lt;span class="math"&gt;\(NT\)&lt;/span&gt; を持つとする:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
g(t) = \sum^{N-1}_{n=0}f(t)\delta(t-nT)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;その仮定の基で、 標本化信号 &lt;span class="math"&gt;\(g(t)\)&lt;/span&gt; のフーリエ変換 &lt;span class="math"&gt;\(\mathcal{F}[g(t)]\)&lt;/span&gt; を求めると:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mathcal{F}[g(t)]
&amp;amp;= \int^{\infty}_{-\infty} f(t) \delta_{T}(t) \exp(-j\omega t) {\rm dt} \\
&amp;amp;= \sum^{N-1}_{n = 0} \int^{\infty}_{-\infty} f(t)\delta(t - nT) \exp(-j\omega t) {\rm dt} \\
&amp;amp;= \sum^{N-1}_{n = 0} f(nT) \exp(-jn\omega T)
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで$j$は虚数単位、 &lt;span class="math"&gt;\(\omega\)&lt;/span&gt; は角周波数であり、 この式は離散フーリエ変換(DFT)の式に他ならない。&lt;/p&gt;
&lt;p&gt;また、 &lt;span class="math"&gt;\(g(t)\)&lt;/span&gt; の周波数特性を見やすくするために、 &lt;span class="math"&gt;\(\delta_{T}(t)\)&lt;/span&gt; をフーリエ級数展開する。 &lt;span class="math"&gt;\(\delta_{T}(t)\)&lt;/span&gt; の複素フーリエ級数展開の式は:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\delta_{T}(t)
&amp;amp;= \sum^{\infty}_{n = -\infty} c_{n} \exp(jn\omega_{0}t) \quad (\omega_{0} = \frac{2\pi}{T}) \\
c_{n}
&amp;amp;= \frac{1}{T} \int^{T/2}_{-T/2} \delta_{T}(t)\exp(-jn\omega_{0}t) {\rm dt}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(c_{n}\)&lt;/span&gt; を計算するとき、 積分範囲には唯一つのインパルスが存在する事に留意すると、 次のようになる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
c_{n}
&amp;amp;= \frac{1}{T} \int^{T/2}_{-T/2} \delta(t)\exp(-jn\omega_{0}t) {\rm dt} \\
&amp;amp;= \frac{1}{T} \exp(0) = \frac{1}{T} \\
\therefore \delta_{T}(t) &amp;amp;=
\frac{1}{T} \sum^{\infty}_{n = -\infty} \exp(jn\omega_{0} t)
\end{align*}
&lt;/div&gt;
&lt;p&gt;この結果から &lt;span class="math"&gt;\(g(t)\)&lt;/span&gt; の周波数特性を計算する。 &lt;span class="math"&gt;\(\mathcal{F}[f(t)] = F(\omega)\)&lt;/span&gt; と書くと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\mathcal{F}[g(t)]
&amp;amp;= \mathcal{F}[f(t) \frac{1}{T} \sum^{\infty}_{n = -\infty} \exp(jn\omega_{0} t)] \\
&amp;amp;= \frac{1}{T} \sum^{\infty}_{n = -\infty} \mathcal{F}[f(t)\exp(jn\omega_{0}t)] \quad (\because フーリエ変換の線形性) \\
&amp;amp;= \frac{1}{T} \sum^{\infty}_{n = -\infty} \int^{\infty}_{-\infty} f(t) \exp\left[ -j(\omega - n\omega_{0})t \right] {\rm dt} \\
&amp;amp;= \frac{1}{T} \sum^{\infty}_{n = -\infty} F(\omega - n\omega_{0})
\end{align*}
&lt;/div&gt;
&lt;p&gt;従って、 &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; の周波数特性 &lt;span class="math"&gt;\(F(\omega)\)&lt;/span&gt; を &lt;span class="math"&gt;\(\omega_{0}\)&lt;/span&gt; ずつずらして和をとったものとなる。 典型的な信号の周波数は高周波成分になるに従って振幅（パワー、 ゲイン）が減衰する事が知られているので、 原信号と離散化信号の周波数スペクトル &lt;span class="math"&gt;\(|F(\omega)|\)&lt;/span&gt; の概要図は &lt;a class="reference internal" href="#image-2"&gt;図2&lt;/a&gt; のようになる。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="tenkei_spectral.png" id="image-2" src="images/tenkei_spectral.png" /&gt;
&lt;p class="caption"&gt;典型的な信号のスペクトルの例&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(|F(\omega)|\)&lt;/span&gt; は明らかに偶関数であり、 この時、 &lt;span class="math"&gt;\(|{\cal F}[g(t)]|\)&lt;/span&gt; のある山 &lt;span class="math"&gt;\(|F(\omega - i\omega_{0})|(i \in \mathbb{Z})\)&lt;/span&gt; において、 隣の山 &lt;span class="math"&gt;\(|F(\omega - (i \pm 1) \omega_{0})|\)&lt;/span&gt; と交差する周波数は &lt;span class="math"&gt;\(\displaystyle \frac{\omega_{0}}{2}k (k:奇数)\)&lt;/span&gt; となる。&lt;/p&gt;
&lt;p&gt;すると、 &lt;span class="math"&gt;\(|{\cal F}[g(t)]|\)&lt;/span&gt; はそれらの山の和を取るので、 結果 &lt;span class="math"&gt;\(\displaystyle \frac{\omega_{0}}{2}k \pm \beta\)&lt;/span&gt; の周波数成分のパワーが隣の山のスペクトルと区別できなくなってしまう（ &lt;a class="reference internal" href="#image-3"&gt;図3&lt;/a&gt; ）。 特に、原信号 &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; では弱かった高周波成分のスペクトルが強調されてしまい、 離散化後の信号においてそれが干渉縞等によって現れてしまう。 この現象をエイリアシングと呼ぶ。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="aliasing_occur.png" id="image-3" src="images/aliasing_occur.png" /&gt;
&lt;p class="caption"&gt;エイリアシングが発生してしまうサンプリングの例&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;エイリアシングを防ぐには、原理的には、原信号 &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; の周波数 &lt;span class="math"&gt;\(\omega_{f} = \displaystyle\frac{2\pi}{NT}\)&lt;/span&gt; の2倍以上の周波数成分をローパスフィルターなどでカットし、かつ、サンプリング周波数を &lt;span class="math"&gt;\(2\omega_{f}\)&lt;/span&gt; （ナイキストレート）より大きくとれば良い（ &lt;a class="reference internal" href="#image-4"&gt;図4&lt;/a&gt; ）&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="escape_aliasing.png" id="image-4" src="images/escape_aliasing.png" /&gt;
&lt;p class="caption"&gt;エイリアシングを回避したサンプリングの例&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-21"&gt;
&lt;h3&gt;信号の復元&lt;/h3&gt;
&lt;p&gt;フーリエ変換対の結果から、標本化した波形をアナログ信号に一意に復元する結果が得られる。
改めてフーリエ逆変換の結果&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(t) = \frac{1}{2\pi} \int^{\infty}_{-\infty} F(\omega) \exp(j\omega t) d\omega
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を眺め、その意味をもう一度立ち戻って考えてみると、これは無限の周波数帯域を使用して信号を復元している式にも見える。
この式をサンプリング周波数で帯域制限して信号を復元する事を考えることで、標本化した信号をアナログ信号に復元する式が得られる。&lt;/p&gt;
&lt;p&gt;まず フーリエ変換の結果 &lt;span class="math"&gt;\(F(\omega)\)&lt;/span&gt; を標本化信号によって表すことを考える。区分求積法の援用により、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
F(\omega) &amp;amp;= \int^{\infty}_{-\infty} f(t) \exp(-j\omega t) dt \\
&amp;amp;= \lim_{f_{s} \to \infty} \sum_{n=-\infty}^{\infty} \frac{1}{f_{s}} f\left(\frac{n}{f_{s}}\right) \exp\left(-j\omega\frac{n}{f_{s}}\right)
\end{align*}
&lt;/div&gt;
&lt;p&gt;と形式的に表すことが出来る。ここで、&lt;span class="math"&gt;\(f_{s}\)&lt;/span&gt; はサンプリング周波数（サンプリングレート）である。この結果をフーリエ逆変換の式に代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
f(t) &amp;amp;= \frac{1}{2\pi} \int^{\infty}_{-\infty} F(\omega) \exp(j\omega t) d\omega \\
&amp;amp;= \frac{1}{2\pi} \int^{\infty}_{-\infty} \left\{ \lim_{f_{s} \to \infty} \sum_{n=-\infty}^{\infty} \frac{1}{f_{s}} f\left(\frac{n}{f_{s}}\right) \exp\left(-j\omega\frac{n}{f_{s}}\right) \right\} \exp(j\omega t) d\omega \\
&amp;amp;= \frac{1}{2\pi} \lim_{f_{s} \to \infty} \sum_{n=-\infty}^{\infty} \frac{1}{f_{s}} f\left(\frac{n}{f_{s}}\right) \int^{\infty}_{-\infty} \exp\left[j\omega \left( t - \frac{n}{f_{s}} \right) \right] d\omega
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、最後の式変形の所で積分演算の線形性を用いて、和の順序を交換している。得られた最後の結果の積分&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\int^{\infty}_{-\infty} \exp\left[j\omega \left( t - \frac{n}{f_{s}} \right) \right] d\omega
\end{equation*}
&lt;/div&gt;
&lt;p&gt;に注目する。積分範囲 &lt;span class="math"&gt;\([-\infty, \infty]\)&lt;/span&gt; は無限になっているが、実際に得られるスペクトルは、標本化の結果 &lt;span class="math"&gt;\([-\omega_{0}/2, \omega_{0}/2]\)&lt;/span&gt; の範囲に制限されていなければならない。従って、帯域制限を加味して積分を計算すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\int^{\omega_{0}/2}_{-\omega_{0}/2} \exp\left[j\omega \left( t - \frac{n}{f_{s}} \right) \right] d\omega &amp;amp;= \frac{1}{j\left( t - \frac{n}{f_{s}} \right)} \left[ \exp \left\{ j\omega\left( t - \frac{n}{f_{s}} \right) \right\} \right]^{\omega_{0}/2}_{-\omega_{0}/2} \\
&amp;amp;= \frac{1}{j\left( t - \frac{n}{f_{s}} \right)} \left[ \exp \left\{ j\frac{\omega_{0}}{2} \left( t - \frac{n}{f_{s}} \right) \right\} - \exp \left\{ -j\frac{\omega_{0}}{2} \left( t - \frac{n}{f_{s}} \right) \right\} \right] \\
&amp;amp;= \frac{1}{j\left( t - \frac{n}{f_{s}} \right)} j2 \sin \left[ \frac{\omega_{0}}{2} \left( t - \frac{n}{f_{s}} \right) \right] = \frac{2 \sin \left[ \pi f_{s} \left( t - \frac{n}{f_{s}} \right) \right]}{t - \frac{n}{f_{s}}}
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、最後の式変形の所でオイラーの公式&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\exp(jx) - \exp(-jx) = \cos(x) + j\sin(x) - \left\{ \cos(x) - j\sin(x) \right\} = j2\sin(x)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を用いている。続けて、帯域制限を加味した積分結果を代入する。 極限 &lt;span class="math"&gt;\(\displaystyle\lim_{f_{s} \to \infty}\)&lt;/span&gt; は帯域制限の結果考慮する必要が無くなる事に留意すると、&lt;/p&gt;
&lt;div class="math" id="math-block-17"&gt;
\begin{align*}
f(t) &amp;amp;= \frac{1}{2\pi} \sum_{n=-\infty}^{\infty} \frac{1}{f_{s}} f\left(\frac{n}{f_{s}}\right) \frac{2 \sin \left[ \pi f_{s} \left( t - \frac{n}{f_{s}} \right) \right]}{t - \frac{n}{f_{s}}} \\
&amp;amp;= \sum_{n=-\infty}^{\infty} f\left(\frac{n}{f_{s}}\right) \frac{\sin \left[ \pi f_{s} \left( t - \frac{n}{f_{s}} \right) \right]}{ \pi f_{s} \left( t - \frac{n}{f_{s}} \right)} \\
&amp;amp;= \sum_{n=-\infty}^{\infty} f\left(\frac{n}{f_{s}}\right) \mathrm{sinc} \left[ f_{s} \left( t - \frac{n}{f_{s}} \right) \right] \tag{17}
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mathrm{sinc}(x) = \frac{\sin(\pi x)}{\pi x}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;は &lt;strong&gt;シンク関数(Sinc function)&lt;/strong&gt; と呼ばれる。シンク関数の概形は次のようになっており、 &lt;span class="math"&gt;\(x=0\)&lt;/span&gt; で最大値 &lt;span class="math"&gt;\(1\)&lt;/span&gt; をとる（ &lt;span class="math"&gt;\(\because\)&lt;/span&gt; ロピタルの定理より、 &lt;span class="math"&gt;\(\displaystyle \lim_{x \to 0} \frac{\sin(\pi x)}{\pi x} = \lim_{x \to 0} \frac{\frac{d \sin(\pi x)}{dx}}{\frac{d \pi x}{dx}} = \lim_{x \to 0} \frac{\pi \cos(\pi x)}{\pi} = 1\)&lt;/span&gt; ）。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference internal" href="#math-block-17"&gt;式17&lt;/a&gt; の結果から、 元のアナログ信号 &lt;span class="math"&gt;\(f(t)\)&lt;/span&gt; はシンク関数の畳み込み演算によって完全に復元される事 &lt;a class="footnote-reference" href="#noteonsignalreconstruction" id="footnote-reference-8"&gt;[8]&lt;/a&gt; が示された。&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="noteonsignalreconstruction" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-8"&gt;[8]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;と言っても、無限和 &lt;span class="math"&gt;\(\sum_{n=-\infty}^{\infty}\)&lt;/span&gt; は計算機で計算できないため、現実的には完全な復元は不可能である。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-22"&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;『フーリエ変換・FFT入門』 &lt;a class="reference external" href="http://www.maroon.dti.ne.jp/koten-kairo/works/fft/fft_start.html"&gt;http://www.maroon.dti.ne.jp/koten-kairo/works/fft/fft_start.html&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;この記事は、上記記事の補足に過ぎないと思われる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="記事"></category><category term="ポエム"></category></entry><entry><title>パーセプトロン昔話</title><link href="/paseputoronxi-hua.html" rel="alternate"></link><published>2020-04-23T15:30:00+09:00</published><updated>2020-04-23T15:30:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-23:/paseputoronxi-hua.html</id><summary type="html">&lt;p class="first last"&gt;パーセプトロンについての昔話。形式ニューロンからはじめ、単層パーセプトロンと、逆誤差伝播法による学習まで。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;strong&gt;ニューラルネットワーク（Neural Network,
以下NN）&lt;/strong&gt;は機械学習の歴史と共に歩んできたと言っても過言ではない.
戦後間もないウィーナーの時代 &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt; からモデルが構築され始め,
幾つかの冬の時代（挫折）を超えて,
そして現在流行りのディープラーニング（深層学習）は多層構造のNNによって構成されている.
ここでは, NNの歴史に少しずつ触れながら,
多層パーセプトロンの学習則（逆誤差伝搬）までを解説していく.
本稿は主に &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;, &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt; を参照している.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\newcommand{\bvec}[1]{\boldsymbol{#1}}
\newcommand{\tvec}[1]{\bvec{#1}^{\mathsf{T}}}
\newcommand{\ve}[1]{\bvec{#1}}
\newcommand{\inpro}[2]{{\left\langle #1 , #2 \right\rangle}}
\newcommand{\norm}[1]{{\left\| #1 \right\|}}
\newcommand{\dint}[2]{\int\!\!\!\int_{#1} #2 }
\newcommand{\tint}[2]{\int\!\!\!\int\!\!\!\int_{#1} #2 }
\newcommand{\dif}[3]{\frac{d^{#1}#2}{d #3^{#1}}}
\newcommand{\pard}[3]{\frac{\partial^{#1}#2}{\partial #3^{#1}}}
\newcommand{\difrac}[2]{{\frac{d #1}{d #2}}}
\newcommand{\parfrac}[2]{{\frac{\partial #1}{\partial #2}}}
\newcommand{\tparfrac}[2]{{\tfrac{\partial #1}{\partial #2}}}
\newcommand{\Div}{{\rm div}}
\newcommand{\Rot}{{\rm rot}}
\newcommand{\Curl}{{\rm curl}}
\newcommand{\innprod}[2]{\langle #1, #2 \rangle}
\newcommand{\n}{\ \\}
\newcommand{\cm}{{\  , \ }}
\def\diag{\mathop{\rm diag}\nolimits}
\def\sign{\mathop{\rm sign}\nolimits}
\end{align*}
&lt;/div&gt;
&lt;div class="contents local topic" id="topic-1"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-2" id="toc-entry-1"&gt;脳機能のモデル化&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-3" id="toc-entry-2"&gt;活性化関数の例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-4" id="toc-entry-3"&gt;形式ニューロン&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-5" id="toc-entry-4"&gt;単純パーセプトロンと単層パーセプトロン（パーセプトロン）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-6" id="toc-entry-5"&gt;単層パーセプトロンの学習則 - ヘブ則とデルタ則&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-7" id="toc-entry-6"&gt;ヘブ則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-8" id="toc-entry-7"&gt;デルタ則&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-9" id="toc-entry-8"&gt;多層パーセプトロン&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-10" id="toc-entry-9"&gt;多層パーセプトロンの学習則 - 逆誤差伝搬法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-1"&gt;脳機能のモデル化&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;NNは脳の神経回路網を数学的なモデルで表現したものである. その為,
理論の出発点は生理学となる. その知識によると,
神経回路の構成要素であるニューロン（神経細胞）はシナプスを介して他の細胞と結合しており,
電気信号によって情報を伝達しあっている.
1つのニューロンは外部からの電気的刺激を受けると膜電位（細胞内外の電位差）を上昇させていき,
刺激の総量がある一定値（閾値）を超えると瞬間的に電位パルス（インパルス,
スパイク）を放出する.
放出したパルスは他のニューロンに影響を与えることができる.
この相互作用を大域的に見ることで脳活動が実現されると考えられている.&lt;/p&gt;
&lt;p&gt;上記の生理学の知見をを事実として受け入れてみると,
次の単純なモデル化が考えられる. 1つのニューロンにおいて,
他のニューロンからの刺激（入力）の総量を&lt;span class="math"&gt;\(u\)&lt;/span&gt;と表し,
その入力を受けて出力を決める&lt;strong&gt;活性化関数（activation
function）&lt;/strong&gt;&lt;span class="math"&gt;\(f\)&lt;/span&gt;をおき, 出力を&lt;span class="math"&gt;\(y = f(u)\)&lt;/span&gt;と表す.
また総入力&lt;span class="math"&gt;\(u\)&lt;/span&gt;は他のニューロンからの刺激の重ねあわせによって決まるので,
単純に入力に重みを掛け合わせ和をとった総量と考えられる. 即ち,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  u = \sum_{i=1}^{n} w_{i}x_{i} + b = \ve{w}^{\mathsf{T}} \ve{x} + b\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表せるものとする. ここで,
&lt;span class="math"&gt;\(\ve{x} = [x_{1},\dots,x_{n}]^{\mathsf{T}}\)&lt;/span&gt;は入力（他のニューロンからの出力）ベクトル,
&lt;span class="math"&gt;\(\ve{w} = [w_{1},\dots,w_{n}]^{\mathsf{T}}\)&lt;/span&gt;は入力の重み（係数）ベクトルであり,
生理学的にはシナプスの結合の強さ（影響の度合い）を表している.
そして&lt;span class="math"&gt;\(-b\)&lt;/span&gt;はニューロン発火の条件を与える&lt;strong&gt;しきい値（bias,
threshold）&lt;/strong&gt;を表している.
以上によってモデル化されるニューロンの機能の単位は図にまとめられ,
&lt;strong&gt;ユニット（unit）&lt;/strong&gt;と呼ばれる &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt; .&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="NNを構成する単位：ユニット" src="./images/unit.eps" /&gt;
&lt;p class="caption"&gt;NNを構成する単位：ユニット&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-2"&gt;活性化関数の例&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;実際に良く使われる活性化関数&lt;span class="math"&gt;\(f\)&lt;/span&gt;としては, 次が挙げられる:&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;単位ステップ関数（ハードリミタ）&lt;span class="math"&gt;\(U(u)\)&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(0\)&lt;/span&gt;か&lt;span class="math"&gt;\(1\)&lt;/span&gt;かを出力し, 決定的な識別を行う:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
      f(u) =
      \left\{ \begin{array}{ll}
        0 &amp;amp; u &amp;lt; 0 \\
        1 &amp;amp; u &amp;gt; 0
      \end{array} \right.
    \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;&lt;span class="math"&gt;\(u=0\)&lt;/span&gt;で不連続となり, &lt;span class="math"&gt;\(U(u)\)&lt;/span&gt;等で参照される事がある.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;符号関数&lt;span class="math"&gt;\(\sign(u)\)&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;二値のみを出力するのは単位ステップ関数と同じだが,
&lt;span class="math"&gt;\(-1\)&lt;/span&gt;か&lt;span class="math"&gt;\(1\)&lt;/span&gt;を出力する:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
      f(u) =
      \left\{ \begin{array}{ll}
        -1 &amp;amp; u &amp;lt; 0 \\
        1  &amp;amp; u &amp;gt; 0
      \end{array} \right.
    \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;単位ステップ関数とは表現を変えたい文脈で用いられる.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;線形関数&lt;span class="math"&gt;\(u\)&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;入力をそのまま出力する線形関数も活性化関数に用いられる事がある:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
      f(u) = u
    \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;入力が有界でない場合出力が発散する場合がある.
線形関数は微分可能なので学習規則の導出の際に役立つ.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;シグモイド（ロジスティック）関数&lt;span class="math"&gt;\(\varphi(u)\)&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;div class="first math"&gt;
\begin{equation*}
\begin{aligned}
      f(u) = \frac{1}{1 + \exp(-u)}
    \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;明らかに&lt;span class="math"&gt;\((0,1)\)&lt;/span&gt;で単調増加する関数である.
グラフが単位ステップ関数に類似し, 関数の形が単純であり,
しかも微分可能である事から非常に重要な関数である. 実際,
&lt;span class="math"&gt;\(u\)&lt;/span&gt;で微分してみると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
       \difrac{ }{u} f(u) &amp;amp;= - \frac{-\exp(-u)}{\{1+\exp(-u)\}^{2}} = \frac{1}{1 + \exp(-u)}\left( 1 - \frac{1}{1 + \exp(-u)} \right)  \\
       &amp;amp;= f(u) (1-f(u))
     \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;となって微分も簡易に計算できることも高評価の理由である.
シグモイド関数は文献によっては&lt;span class="math"&gt;\(\varphi(u)\)&lt;/span&gt;で参照される事がある.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;&lt;span class="math"&gt;\(\tanh\)&lt;/span&gt;（タンジェントハイパボリック）関数&lt;span class="math"&gt;\(\tanh(u)\)&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;div class="first math"&gt;
\begin{equation*}
\begin{aligned}
      f(u) = \tanh(u) = \frac{\exp(u) - \exp(-u)}{\exp(u) + \exp(-u)}
    \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これは&lt;span class="math"&gt;\((-1,1)\)&lt;/span&gt;で単調増加する関数であり,
値域を&lt;span class="math"&gt;\((0,1)\)&lt;/span&gt;とする為に&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
      f(u) = \frac{\tanh(u) + 1}{2}
    \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とする場合がある. &lt;span class="math"&gt;\(\tanh\)&lt;/span&gt;の微分値も簡潔に表現できる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
      \difrac{ }{u} f(u) &amp;amp;= \frac{\{\exp(u)+\exp(-u)\}^{2} - \{\exp(u)-\exp(-u)\}^{2}}{\{\exp(u)+\exp(-u)\}^{2}} \\
      &amp;amp;= 1 - \tanh^{2}(u) = 1 - f^{2}(u)
    \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;また,
上述のシグモイド関数は&lt;span class="math"&gt;\(\tanh\)&lt;/span&gt;を用いて表すこともできる:&lt;/p&gt;
&lt;div class="last math"&gt;
\begin{equation*}
\begin{aligned}
      \frac{1}{1 + \exp(-u)} &amp;amp;= \frac{1}{2} \frac{2 \exp(u/2)}{\exp(u/2) + \exp(-u/2)} \\
      &amp;amp;= \frac{1}{2} \left( \frac{\exp(u/2) + \exp(-u/2)}{\exp(u/2) + \exp(-u/2)} + \frac{\exp(u/2) - \exp(-u/2)}{\exp(u/2) + \exp(-u/2)} \right) \\
      &amp;amp;= \frac{1}{2} (1 + \tanh(u/2))
    \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;図に関数のグラフを示す.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="よく使われる活性化関数のグラフ" src="./images/act_funcs.eps" /&gt;
&lt;p class="caption"&gt;よく使われる活性化関数のグラフ&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-3"&gt;形式ニューロン&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;最初にニューロンをモデル化して研究を行ったのはMcCulloch-Pitts（ウォーレン・マカロック-ウォルター・ピッツ）であり,
彼らは1943年に&lt;strong&gt;形式ニューロン（formal neuron）&lt;/strong&gt;を提案した.
形式ニューロンでは活性化関数は単にステップ関数&lt;span class="math"&gt;\(U(u)\)&lt;/span&gt;となる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  U(u) =
  \left\{ \begin{array}{ll}
    1 &amp;amp; u &amp;gt; 0 \\
    0 &amp;amp; u &amp;lt; 0
  \end{array} \right.\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これによって入力および出力は&lt;span class="math"&gt;\(0\)&lt;/span&gt;か&lt;span class="math"&gt;\(1\)&lt;/span&gt;（all-or-none）となる.
形式ニューロンでは, 重みと閾値の組み合わせによって論理素子を実現できる:&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;NOT&lt;/dt&gt;
&lt;dd&gt;&lt;span class="math"&gt;\(U(-x_{1} + 0.5)\)&lt;/span&gt;&lt;/dd&gt;
&lt;dt&gt;AND&lt;/dt&gt;
&lt;dd&gt;&lt;span class="math"&gt;\(U(x_{1} + x_{2} - 1.5)\)&lt;/span&gt;&lt;/dd&gt;
&lt;dt&gt;OR&lt;/dt&gt;
&lt;dd&gt;&lt;span class="math"&gt;\(U(x_{1} + x_{2} - 0.5)\)&lt;/span&gt;&lt;/dd&gt;
&lt;dt&gt;NAND&lt;/dt&gt;
&lt;dd&gt;&lt;span class="math"&gt;\(U(-x_{1} -x_{2} + 1.5)\)&lt;/span&gt;&lt;/dd&gt;
&lt;dt&gt;XOR&lt;/dt&gt;
&lt;dd&gt;&lt;span class="math"&gt;\(U(x_{1} + x_{2} - 2U(x_{1} + x_{2} - 1.5) - 0.5)\)&lt;/span&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;実際に入力値に値を代入して真理値表U 作ると,
ユニットが正しく動作する事を確かめられる.
この素子の組み合わせによって任意の（フリップフロップを含めた）論理回路が実現できるのはもちろんのこと,
形式ニューロンはチューリングマシンと同等の計算能力（チューリング完全）を持つ事が示されている.
形式ニューロンはニューロンの最初のモデルとしてNNの大本の基礎となったが,
現在のNNにあるような学習能力を持ちあわせてはいない. しかし,
重みや閾値を変更することでユニットの動作が変わるという観察から,
それらを能動的に変更することで学習が実現されうるという示唆は既に生まれていたものと考えられる.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-4"&gt;単純パーセプトロンと単層パーセプトロン（パーセプトロン）&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;1957年にRosenblatt（ローゼンブラッド）は形式ニューロンを入力層（Sensory
Layer, S層）, 中間層（Associative Layer, A層）, 出力層（Response Layer,
R層）の3つに分けて階層的に結合し,
図&lt;a class="reference external" href="#fig:simple_perceptron"&gt;1&lt;/a&gt;の構造を持つ&lt;strong&gt;単純パーセプトロン（simple
perceptron）&lt;/strong&gt;を提案した. ここで,
S層とA層の間の重みはランダムに固定し,
A層とR層の間の重みは&lt;strong&gt;学習&lt;/strong&gt;によって決めるようになっている.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="単純パーセプトロン" id="fig-simple-perceptron" src="./images/simple_perceptron.eps" /&gt;
&lt;p class="caption"&gt;単純パーセプトロン&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;単純パーセプトロンの学習は,
微積分といった解析的な知見ではなく&lt;strong&gt;ヘブ則（Hebbian
rule）&lt;/strong&gt;と呼ばれる生理学の法則を用いている.
即ちそれは&lt;strong&gt;「同時に発火したニューロン間のシナプス結合は強められる」&lt;/strong&gt;という法則であり,
多くの神経学者及び心理学者が受け入れている事実である. 後に述べるが,
ヘブ則による学習は解が存在すれば有限回数の学習で正しい解に収束することが示されており,
次節に述べるデルタ則（これは数値解析的に学習する）と併せて有用な学習法と言える.
単純パーセプトロンはNNの学習可能性を初めて示し,
史上初のNN研究ブームを引き起こすきっかけとなった.&lt;/p&gt;
&lt;p&gt;ところで, 単純パーセプトロンは3層の階層構造をなしているが,
重みの学習の際に本質的に関与するのは中間層と出力層の間だけである.
この学習する部分のみを抜き出すと,
図&lt;a class="reference external" href="#fig:single_layer_perceptron"&gt;2&lt;/a&gt;の様に,
学習するニューロンの単純な入出力関係が得られる.
これを&lt;strong&gt;単層パーセプトロン（single-layer
perceptron）&lt;/strong&gt;あるいは単に&lt;strong&gt;パーセプトロン（perceptron）&lt;/strong&gt;と呼ぶ.
そして単純パーセプトロンの学習の際には,
S層とA層間の重みをランダムに決定した後は単層パーセプトロンの学習だけを考えば良い事になる.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="単層パーセプトロン（パーセプトロン）" id="fig-single-layer-perceptron" src="./images/single_layer_perceptron.eps" /&gt;
&lt;p class="caption"&gt;単層パーセプトロン（パーセプトロン）&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-5"&gt;単層パーセプトロンの学習則 - ヘブ則とデルタ則&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;単層パーセプトロンの学習にはサンプルが必要となるため,
まずはサンプルの表記から行う. 学習の中でも特に教師あり学習（supervised
learning）はサンプルのデータにラベルが付いている.
ラベルは一般的にはなんでも良いが,
基本的にはデータがある性質を満たす場合（正例）はラベルを&lt;span class="math"&gt;\(1\)&lt;/span&gt;に,
満たさない場合（負例）はラベルを&lt;span class="math"&gt;\(-1\)&lt;/span&gt;とする &lt;a class="footnote-reference" href="#footnote-5" id="footnote-reference-5"&gt;[5]&lt;/a&gt; .
そして&lt;span class="math"&gt;\(N\)&lt;/span&gt;個のデータからなるサンプルの集合&lt;span class="math"&gt;\(Z\)&lt;/span&gt;は,
データ&lt;span class="math"&gt;\(\ve{x}\)&lt;/span&gt;とその（教師）ラベル&lt;span class="math"&gt;\(t\)&lt;/span&gt;の組の集合で表される:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  Z = \{ (\ve{x}_{1}, t_{1}), (\ve{x}_{2}, t_{2}), \dots, (\ve{x}_{N}, t_{N}) \}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;以下,
出力層が1つのユニットだけからなる単層パーセプトロン（図式的には図と等価）の学習を考える.
ユニットが複数存在する場合でも出力層の内部でユニットは互いに独立に動作する（&lt;span class="math"&gt;\(\because\)&lt;/span&gt;結合が無いため）ので拡張は容易である.
また, 表記を簡単にするため,
ユニットへの入力&lt;span class="math"&gt;\(u\)&lt;/span&gt;はしきい値&lt;span class="math"&gt;\(b\)&lt;/span&gt;を省き,
重みと入力の内積&lt;span class="math"&gt;\(\ve{w}^{\mathsf{T}}\ve{x}\)&lt;/span&gt;のみで表現する:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  u &amp;amp;= \sum_{i=1}^{n} w_{i} x_{i} + b = \sum_{i=1}^{n+1} w_{i} x_{i} \quad (w_{n+1} = b,\ x_{n+1} = 1) \\
  &amp;amp;\equiv \ve{w}^{\mathsf{T}}\ve{x}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これは常に&lt;span class="math"&gt;\(1\)&lt;/span&gt;を入力するユニットを仮定し,
その結合重みを&lt;span class="math"&gt;\(b\)&lt;/span&gt;とすることで説明できる.&lt;/p&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-6"&gt;ヘブ則&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;前節で述べたとおり,
ヘブ則は「同時に発火したニューロン間のシナプス結合は強められる」というものであった.
これはラベルを&lt;span class="math"&gt;\(t_{l} \in \{ 1, 0 \}\ (l=1,\dots,N)\)&lt;/span&gt;（正例を1,
負例を0）,
サンプルデータ&lt;span class="math"&gt;\(\ve{x}_{l}\)&lt;/span&gt;を入力した時の出力を&lt;span class="math"&gt;\(y_{l} = U(u_{l}) = U\left( \ve{w}^{\mathsf{T}} \ve{x}_{l}\right)\)&lt;/span&gt;とすれば,
重み（シナプス結合）の更新量&lt;span class="math"&gt;\(\Delta w_{i}\)&lt;/span&gt;は次の様に表せる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \Delta w_{i} &amp;amp;=
  \left\{ \begin{array}{ll}
    \eta (\ve{x}_{l})_{i} &amp;amp; \text{if}\ t_{l} = y_{l} = 1 \\
    0          &amp;amp; \text{otherwise}
  \end{array} \right. \\
  &amp;amp;= \eta t_{l}y_{l}(\ve{x}_{l})_{i}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで,
&lt;span class="math"&gt;\((\ve{x}_{l})_{i}\)&lt;/span&gt;はベクトル&lt;span class="math"&gt;\(\ve{x}_{l}\)&lt;/span&gt;の第&lt;span class="math"&gt;\(i\)&lt;/span&gt;要素,
&lt;span class="math"&gt;\(\eta &amp;gt; 0\)&lt;/span&gt;は学習の早さを決める係数であり, &lt;strong&gt;学習率（learning
rate）&lt;/strong&gt;と呼ばれる.
学習の際には&lt;span class="math"&gt;\(\ve{w} = \ve{0}\)&lt;/span&gt;で初期化してサンプルを順次入力し,
上の更新量に沿って重みを更新していけば良い.
第&lt;span class="math"&gt;\(s\)&lt;/span&gt;ステップの時の重みベクトルを&lt;span class="math"&gt;\(\ve{w}^{(s)}\)&lt;/span&gt;と表すと,
更新規則は,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \ve{w}^{(s+1)} = \ve{w}^{(s)} + \Delta \ve{w} = \ve{w}^{(s)} + \eta t_{l} y_{l} \ve{x}_{l}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表せる. ここで,
&lt;span class="math"&gt;\(\Delta \ve{w}\)&lt;/span&gt;更新量を並べたベクトル&lt;span class="math"&gt;\(\Delta \ve{w} = [\Delta w_{1},\dots,\Delta w_{n}]^{\mathsf{T}}\)&lt;/span&gt;である.&lt;/p&gt;
&lt;p&gt;素朴なヘブ則の実装では,
上の&lt;span class="math"&gt;\(\Delta w_{i}\)&lt;/span&gt;を観察すれば即座に分かるように,
重みが際限なく大きくなって発散してしまって学習が停止しない場合がある.
従って, 重みの発散を防ぐために重みは抑制する方向に更新するようにとる.
即ち, ラベルを&lt;span class="math"&gt;\(\{ 1, -1 \}\)&lt;/span&gt;,
活性化関数を符号関数&lt;span class="math"&gt;\(\sign\)&lt;/span&gt;とし,
出力&lt;span class="math"&gt;\(y_{l} = \sign(u_{l})\)&lt;/span&gt;とラベル&lt;span class="math"&gt;\(t_{l}\)&lt;/span&gt;が異なる（サンプルを誤識別した）場合にのみ重みを更新する:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \Delta w_{i} &amp;amp;=
  \left\{ \begin{array}{ll}
    -\eta (\ve{x}_{l})_{i} = \eta t_{l}y_{l}(\ve{x}_{l})_{i} &amp;amp; \text{if}\ t_{l} \neq y_{l} \\
    0           &amp;amp; \text{otherwise}
  \end{array} \right.\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この更新規則もヘブ則と呼ばれる事がある.&lt;/p&gt;
&lt;p&gt;ヘブ則の重要な性質に,
最適な重みが存在するならば有限ステップで学習が停止（サンプルの誤識別がなくなる）する事が示されている.
ここでは,  &lt;a class="footnote-reference" href="#footnote-6" id="footnote-reference-6"&gt;[6]&lt;/a&gt; に従ってその証明を行う. まず,
存在が仮定された最適な重みを&lt;span class="math"&gt;\(\ve{w}^{\ast}\)&lt;/span&gt;と表し,
&lt;span class="math"&gt;\(||\ve{w}^{\ast}||^{2} = \ve{w}^{\ast\mathsf{T}}\ve{w}^{\ast} = \sum_{i=1}^{n} w_{i}^{\ast 2} = 1\)&lt;/span&gt;となる様に正規化しておく &lt;a class="footnote-reference" href="#footnote-7" id="footnote-reference-7"&gt;[7]&lt;/a&gt; .
ここで,
&lt;span class="math"&gt;\(||\ve{v}||\)&lt;/span&gt;はベクトル&lt;span class="math"&gt;\(\ve{v}\)&lt;/span&gt;の2乗ノルムである. また,
&lt;span class="math"&gt;\(\gamma = \displaystyle \min_{l} y_{l} u_{l} = \min_{l} y_{l} \ve{w}^{\ast\mathsf{T}} \ve{x}_{l}\)&lt;/span&gt;なる定数 &lt;a class="footnote-reference" href="#footnote-8" id="footnote-reference-8"&gt;[8]&lt;/a&gt; をおき,
&lt;span class="math"&gt;\(\gamma &amp;gt; 0\)&lt;/span&gt;とする. この時, 更新式により,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  ||\ve{w}^{(s+1)}||^{2} &amp;amp;= \ve{w}^{(s+1)\mathsf{T}} \ve{w}^{(s+1)} \\
  &amp;amp;= (\ve{w}^{(s)} + \Delta \ve{w})^{\mathsf{T}}(\ve{w}^{(s)} + \Delta \ve{w}) \\
  &amp;amp;= (\ve{w}^{(s)} + \eta t_{l} y_{l} \ve{x}_{l})^{\mathsf{T}}(\ve{w}^{(s)} + \eta t_{l} y_{l} \ve{x}_{l}) \\
  &amp;amp;= \ve{w}^{(s)\mathsf{T}} \ve{w}^{(s)} + 2\eta t_{l} y_{l} \ve{w}^{(s)\mathsf{T}} \ve{x}_{l} + \eta^{2} \ve{x}_{l}^{\mathsf{T}}\ve{x}_{l} \quad (\because t_{l}^{2} = y_{l}^{2} = 1) \\
  &amp;amp;\leq ||\ve{w}^{(s)}||^{2} + \eta^{2} ||\ve{x}_{l}||^{2} \quad (\because \eta t_{l} y_{l} (\ve{x}_{l})_{i} = \Delta w_{i} \leq 0)\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が任意の&lt;span class="math"&gt;\(l \in \{ 1,\dots,N \}\)&lt;/span&gt;で成り立つ.
この関係式をステップ毎に繰り返し適用すれば,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  ||\ve{w}^{(s)}||^{2} &amp;amp;\leq ||\ve{w}^{(s-1)}||^{2} + \eta^{2}||\ve{x}_{l^{(s-1)}}||^{2} \\
  &amp;amp;\leq ||\ve{w}^{(s-2)}||^{2} + \eta^{2}(||\ve{x}_{l^{(s-1)}}||^{2} + ||\ve{x}_{l^{(s-2)}}||^{2}) \\
  &amp;amp;\dots \\
  &amp;amp;\leq ||\ve{w}^{(0)}||^{2} + \eta^{2} \sum_{k=0}^{s-1} ||\ve{x}_{l^{(k)}}||^{2} \\
  &amp;amp;\leq s\eta^{2} \max_{l} ||\ve{x}_{l}||^{2} \quad (\because \ve{w}^{(0)} = \ve{0})\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を得る. ここで,
&lt;span class="math"&gt;\(l^{(s)}\)&lt;/span&gt;はステップ&lt;span class="math"&gt;\(s\)&lt;/span&gt;の更新の時に選ばれたサンプルの番号（インデックス）を表している.
また,
全ての&lt;span class="math"&gt;\(\ve{x}_{l}\ (l=1,\dots,N)\)&lt;/span&gt;は現実的に有界（いずれの要素も&lt;span class="math"&gt;\((-\infty, \infty)\)&lt;/span&gt;にある）と考えられるので,
全てのデータを包む事ができる球（超球）の最小の半径を&lt;span class="math"&gt;\(R\)&lt;/span&gt;とおけば,
&lt;span class="math"&gt;\(\displaystyle \max_{l} ||\ve{x}_{l}||^{2} \leq R^{2}\)&lt;/span&gt;が成り立つので,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  ||\ve{w}^{(s)}||^{2} \leq s\eta^{2} \max_{l} ||\ve{x}_{l}||^{2} \leq s \eta^{2} R^{2}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる. 一方,
&lt;span class="math"&gt;\(\ve{w}^{\ast}\)&lt;/span&gt;と&lt;span class="math"&gt;\(\ve{w}^{(s+1)}\)&lt;/span&gt;の内積をとると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \ve{w}^{\ast \mathsf{T}} \ve{w}^{(s+1)} &amp;amp;= \ve{w}^{\ast \mathsf{T}} ( \ve{w}^{(s)} + \eta t_{l} y_{l} \ve{x}_{l}) \\
  &amp;amp;= \ve{w}^{\ast \mathsf{T}} \ve{w}^{(s)} + \eta t_{l} y_{l} \ve{w}^{\ast \mathsf{T}} \ve{x}_{l} \\
  &amp;amp;\geq \ve{w}^{\ast \mathsf{T}} \ve{w}^{(s)} + \eta \gamma\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成立し, この関係式もステップ毎に繰り返し適用すると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \ve{w}^{\ast \mathsf{T}} \ve{w}^{(s)} &amp;amp;\geq \ve{w}^{\ast \mathsf{T}} \ve{w}^{(s-1)} + \eta \gamma \\
  &amp;amp;\geq \ve{w}^{\ast \mathsf{T}} \ve{w}^{(s-2)} + 2\eta \gamma \\
  &amp;amp;\dots \\
  &amp;amp;\geq \ve{w}^{\ast \mathsf{T}} \ve{w}^{(0)} + s\eta \gamma = s\eta \gamma\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を得て, この式の両辺を二乗すると次の結果を得る:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  s^{2} \eta^{2} \gamma^{2} &amp;amp;\leq (\ve{w}^{\ast \mathsf{T}}\ve{w}^{(s)})^{2} \\
  &amp;amp;\leq (\ve{w}^{\ast \mathsf{T}} \ve{w}^{\ast}) (\ve{w}^{(s) \mathsf{T}} \ve{w}^{(s)}) \quad (\because シュワルツの不等式) \\
  &amp;amp;= ||\ve{w}^{\ast}||^{2} ||\ve{w}^{(s)}||^{2} = ||\ve{w}^{(s)}||^{2} \\
  &amp;amp;\leq s\eta^{2}R^{2}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで,
不等式中央の内積&lt;span class="math"&gt;\(\ve{w}^{\ast \mathsf{T}}\ve{w}^{(s)}\)&lt;/span&gt;は最適解&lt;span class="math"&gt;\(\ve{w}^{\ast}\)&lt;/span&gt;と現在の重み&lt;span class="math"&gt;\(\ve{w}^{(s)}\)&lt;/span&gt;との類似度とも捉えられる &lt;a class="footnote-reference" href="#footnote-9" id="footnote-reference-9"&gt;[9]&lt;/a&gt; ので,
この不等式によりステップ数&lt;span class="math"&gt;\(s\)&lt;/span&gt;増加の度に類似度の下限&lt;span class="math"&gt;\(s^{2}\eta^{2}\gamma^{2}\)&lt;/span&gt;が上限&lt;span class="math"&gt;\(s\eta^{2}R^{2}\)&lt;/span&gt;よりも早く増加する事が観察できる.
即ち類似度は単調増加し, 重みは最適解に近づいて行くことが分かる.
またステップ数&lt;span class="math"&gt;\(s\)&lt;/span&gt;について解くと&lt;span class="math"&gt;\(\displaystyle s \leq \frac{R^{2}}{\gamma^{2}}\)&lt;/span&gt;が成立し,
&lt;span class="math"&gt;\(\gamma, R\)&lt;/span&gt;は有限のために&lt;span class="math"&gt;\(s\)&lt;/span&gt;もまた有限となる.
これらの結果により, 有限ステップで&lt;span class="math"&gt;\(\ve{w}^{\ast}\)&lt;/span&gt;が得られ,
学習が停止することが示された.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-7"&gt;デルタ則&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;デルタ則（デルタルール）は現在の重み&lt;span class="math"&gt;\(\ve{w}\)&lt;/span&gt;でのサンプルによる出力とラベルの誤差（経験誤差）&lt;span class="math"&gt;\(E(\ve{w})\)&lt;/span&gt;を定義し,
&lt;span class="math"&gt;\(E(\ve{w})\)&lt;/span&gt;を極小にする様に重みを更新していく学習則である.
誤差&lt;span class="math"&gt;\(E(\ve{w})\)&lt;/span&gt;の&lt;span class="math"&gt;\(\ve{w}\)&lt;/span&gt;による偏微分&lt;span class="math"&gt;\(\displaystyle\parfrac{E(\ve{w})}{\ve{w}}\)&lt;/span&gt;は勾配,
即ち最も&lt;span class="math"&gt;\(E(\ve{w})\)&lt;/span&gt;の変化する方向（最急勾配）を表すので,
重みの更新量&lt;span class="math"&gt;\(\Delta \ve{w}\)&lt;/span&gt;は学習率&lt;span class="math"&gt;\(\eta &amp;gt; 0\)&lt;/span&gt;を用いて&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \Delta \ve{w} = - \eta \parfrac{E(\ve{w})}{\ve{w}}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とすれば,
更新の度に誤差を最小にする様に重み&lt;span class="math"&gt;\(\ve{w}\)&lt;/span&gt;を更新することができる.
学習の収束は,
&lt;span class="math"&gt;\(\Delta \ve{w}\)&lt;/span&gt;の大きさ（&lt;span class="math"&gt;\(||\Delta \ve{w}||^{2}\)&lt;/span&gt;等）が十分に小さくなった時とすれば良く,
そのときは極小解 &lt;a class="footnote-reference" href="#footnote-10" id="footnote-reference-10"&gt;[10]&lt;/a&gt; が得られている. この手法は&lt;strong&gt;最急勾配法（steepest
gradient method）&lt;/strong&gt;と呼ばれる基本的な数値最適化の手法の一種である.
ここでは, ユニットの活性化関数を単位ステップ関数&lt;span class="math"&gt;\(U(u)\)&lt;/span&gt;,
ラベルを&lt;span class="math"&gt;\(\{ 1, 0 \}\)&lt;/span&gt;として考える.&lt;/p&gt;
&lt;p&gt;さて, 誤差は様々なものが考えられるが, 単純に二乗誤差&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  E(\ve{w}) = \frac{1}{2} \sum_{l=1}^{N} (t_{l} - y_{l})^{2} = \frac{1}{2} \sum_{l=1}^{N} \left\{ t_{l} - U(\ve{w}^{\mathsf{T}}\ve{x}_{l}) \right\}^{2}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とする &lt;a class="footnote-reference" href="#footnote-11" id="footnote-reference-11"&gt;[11]&lt;/a&gt; と, 後に示す様に局所最適解に嵌ってしまう可能性がある. 第一,
単位ステップ関数&lt;span class="math"&gt;\(U(u)\)&lt;/span&gt;はもとより微分可能では無く,
このままでは学習則を導出できない. そこで, まず,
ユニットの活性化関数を一旦微分可能なシグモイド関数&lt;span class="math"&gt;\(\varphi\)&lt;/span&gt;とし,
その出力を&lt;span class="math"&gt;\(y_{l}=1\)&lt;/span&gt;となる確率&lt;span class="math"&gt;\(p(y_{l}=1)\)&lt;/span&gt;として定義する:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  p(y_{l} = 1) = \varphi(u_{l}/T) = \frac{1}{1+\exp(-u_{l}/T)}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで, &lt;span class="math"&gt;\(T \geq 0\)&lt;/span&gt;は温度パラメタと呼ばれ,
図のグラフで見れるように&lt;span class="math"&gt;\(T \to 0\)&lt;/span&gt;とすると単位ステップ関数に漸近することが分かる.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="様々な温度パラメタ\ :math:`T`\ におけるシグモイド関数\ :math:`\varphi(u/T)`\ のグラフ" src="./images/sigmoids.eps" /&gt;
&lt;p class="caption"&gt;様々な温度パラメタ&lt;span class="math"&gt;\(T\)&lt;/span&gt;におけるシグモイド関数&lt;span class="math"&gt;\(\varphi(u/T)\)&lt;/span&gt;のグラフ&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;同時にラベル&lt;span class="math"&gt;\(t_{l}\)&lt;/span&gt;もある確率分布&lt;span class="math"&gt;\(q\)&lt;/span&gt;に従って生成される確率変数と考える事ができ,
&lt;span class="math"&gt;\(t_{l}\)&lt;/span&gt;が&lt;span class="math"&gt;\(1\)&lt;/span&gt;を取る確率は&lt;span class="math"&gt;\(q(t_{l}=1) = t_{l}\)&lt;/span&gt;で定義することができる.
この様に定義した出力とラベルの確率分布&lt;span class="math"&gt;\(q,p\)&lt;/span&gt;間の“違い”を誤差&lt;span class="math"&gt;\(E(\ve{w})\)&lt;/span&gt;とする.
特に機械学習では,
確率分布間の違いを測る尺度として非常に重要な&lt;strong&gt;KLダイバージェンス（Kullback-Leibler
divergence）&lt;/strong&gt;&lt;span class="math"&gt;\(KL(q||p)\)&lt;/span&gt;がある:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  KL(q||p) = \sum_{l=1}^{N} q(t_{l}) \log\left[ \frac{q(t_{l})}{p(t_{l})} \right]\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;すぐに分かるように&lt;span class="math"&gt;\(KL(q||p) = 0\)&lt;/span&gt;となるのは&lt;span class="math"&gt;\(q\)&lt;/span&gt;と&lt;span class="math"&gt;\(p\)&lt;/span&gt;が完全に一致する時（&lt;span class="math"&gt;\(q(t_{l}) = p(t_{l})\ (l=1,\dots,N)\)&lt;/span&gt;）のみである.&lt;/p&gt;
&lt;p&gt;それでは誤差&lt;span class="math"&gt;\(E(\ve{w})\)&lt;/span&gt;をKLダイバージェンスとして,
その&lt;span class="math"&gt;\(\ve{w}\)&lt;/span&gt;による偏微分を計算する事を考える. まず,
&lt;span class="math"&gt;\(KL(q||p)\)&lt;/span&gt;は定義式から次の様に展開できる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  E(\ve{w}) &amp;amp;= KL(q||p) = \sum_{l=1}^{N} q(t_{l}) \log\left[ \frac{q(t_{l})}{p(t_{l})} \right] \\
  &amp;amp;= \sum_{l=1}^{N} \left\{ q(t_{l}=0) \log\left[ \frac{q(t_{l}=0)}{p(t_{l}=0)} \right] + q(t_{l}=1) \log\left[ \frac{q(t_{l}=1)}{p(t_{l}=1)} \right] \right\} \\
  &amp;amp;= \sum_{l=1}^{N} \left\{ (1-t_{l}) \log\left( \frac{1-t_{l}}{1-\varphi(u_{l}/T)} \right) + t_{l} \log \left( \frac{t_{l}}{\varphi(u_{l}/T)} \right) \right\}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;見通しを良くする為に和の内部を&lt;span class="math"&gt;\(e_{l}(\ve{w})\)&lt;/span&gt;とおき,
&lt;span class="math"&gt;\(e_{l}(\ve{w})\)&lt;/span&gt;を&lt;span class="math"&gt;\(w_{i}\)&lt;/span&gt;で偏微分すると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \parfrac{}{w_{i}} e_{l}(\ve{w}) &amp;amp;= \parfrac{e_{l}(\ve{w})}{\varphi(u_{l}/T)} \parfrac{\varphi(u_{l}/T)}{w_{i}} \quad (\because 合成関数の微分) \\
  &amp;amp;= \left\{ (1-t_{l})\frac{1}{1-\varphi(u_{l}/T)} - \frac{t_{l}}{\varphi(u_{l}/T)} \right\} \parfrac{\varphi(u_{l}/T)}{u_{l}} \parfrac{u_{l}}{w_{i}} \quad (\because 合成関数の微分) \\
  &amp;amp;= \frac{\varphi(u_{l}/T)(1 - t_{l}) - t_{l} \left\{ 1 - \varphi(u_{l}/T) \right\}}{\varphi(u_{l}/T) \left\{ 1 - \varphi(u_{l}/T) \right\}} \frac{1}{T} \varphi(u_{l}/T) \left\{ 1 - \varphi(u_{l}/T) \right\} (\ve{x}_{l})_{i} \\
  &amp;amp;= \frac{1}{T} \left\{ \varphi(u_{l}/T) - t_{l} \right\} (\ve{x}_{l})_{i}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が得られ, 更新量&lt;span class="math"&gt;\(\Delta \ve{w}\)&lt;/span&gt;は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \Delta \ve{w} &amp;amp;= - \eta \parfrac{E(\ve{w})}{\ve{w}} = - \eta \frac{1}{T} \sum_{l=1}^{N} \parfrac{}{\ve{w}} e_{l}(\ve{w}) \\
  &amp;amp;= - \frac{\eta}{T} \sum_{l=1}^{N}(\varphi(u_{l}/T) - t_{l}) \ve{x}_{l} = - \frac{\eta}{T} \sum_{l=1}^{N} \delta_{l} \ve{x}_{l}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とまとめられる. ここで,
&lt;span class="math"&gt;\(\delta_{l} = \varphi(u_{l}/T) - t_{l}\)&lt;/span&gt;は誤差信号と呼ばれる.
シグモイド関数から単位ステップ関数に戻すために&lt;span class="math"&gt;\(T \to 0\)&lt;/span&gt;とするが,
同時に&lt;span class="math"&gt;\(\eta \to 0\)&lt;/span&gt;として&lt;span class="math"&gt;\((\eta / T) \to \epsilon\)&lt;/span&gt;となる様な&lt;span class="math"&gt;\(\epsilon &amp;gt; 0\)&lt;/span&gt;をとって&lt;span class="math"&gt;\(\Delta \ve{w}\)&lt;/span&gt;が発散しないようにすれば,
デルタ則による重みの更新量&lt;span class="math"&gt;\(\Delta \ve{w}\)&lt;/span&gt;は,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \Delta \ve{w} = -\epsilon \sum_{l=1}^{N} \delta_{l} \ve{x}_{l} = \epsilon \sum_{l=1}^{N} \left\{ t_{l} - U(u_{l}) \right\} \ve{x}_{l}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる. この&lt;span class="math"&gt;\(\epsilon\)&lt;/span&gt;も学習率と呼ばれ,
実践においては&lt;span class="math"&gt;\(0.1\)&lt;/span&gt;から&lt;span class="math"&gt;\(0.5\)&lt;/span&gt;あたりに設定される.
この学習則は&lt;span class="math"&gt;\(\sum_{l=1}^{N}\)&lt;/span&gt;の存在により,
全てのサンプルを提示して更新するのでこれを特に一括（斉時）学習（batch
learning）と呼ぶが, 1つのサンプル毎に重みを更新するやり方もある:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \Delta \ve{w} = \epsilon \left\{ t_{l} - U(u_{l}) \right\} \ve{x}_{l}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これは逐次学習（on-line learning）と呼ばれる.
一般に逐次学習の方が収束が早い事が知られている &lt;a class="footnote-reference" href="#footnote-12" id="footnote-reference-12"&gt;[12]&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;この更新則による学習が局所最適に陥らないことを示す.
&lt;span class="math"&gt;\(\displaystyle\parfrac{e_{l}(\ve{w})}{w_{i}}\)&lt;/span&gt;を更に&lt;span class="math"&gt;\(w_{j}\)&lt;/span&gt;で偏微分し2階の偏導関数を求めると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \parfrac{ }{w_{j}}\parfrac{e_{l}(\ve{w})}{w_{i}} &amp;amp;= \parfrac{{}^{2} e_{l}(\ve{w})}{w_{i} \partial w_{j}} \\
  &amp;amp;= \frac{1}{T} \parfrac{\varphi(u_{l}/T)}{w_{j}} x_{i} = \frac{1}{T^{2}} \varphi(u_{l}/T) \left\{ 1 - \varphi(u_{l}/T) \right\} (\ve{x}_{l})_{i}(\ve{x}_{l})_{j}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となり,
&lt;span class="math"&gt;\((H)_{ij} = \displaystyle \parfrac{{}^{2} e_{l}(\ve{w})}{w_{i} \partial w_{j}}\)&lt;/span&gt;なる&lt;span class="math"&gt;\(e_{l}(\ve{w})\)&lt;/span&gt;のヘッセ行列（Hessian
matrix）&lt;span class="math"&gt;\(H\)&lt;/span&gt;は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  H = \frac{1}{T^{2}} \varphi(u_{l}/T) \left\{ 1 - \varphi(u_{l}/T) \right\} \ve{x}_{l} \ve{x}_{l}^{\mathsf{T}}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;で計算できる.
明らかに&lt;span class="math"&gt;\(\displaystyle\frac{1}{T^{2}}\varphi(u_{l}/T) \left\{ 1 - \varphi(u_{l}/T) \right\} &amp;gt; 0\)&lt;/span&gt;であり,
行列&lt;span class="math"&gt;\(\ve{x}_{l}\ve{x}_{l}^{\mathsf{T}}\)&lt;/span&gt;は任意のベクトル&lt;span class="math"&gt;\(\ve{v}\)&lt;/span&gt;に対して二次形式&lt;span class="math"&gt;\(\ve{v}^{\mathsf{T}} (\ve{x}_{l}\ve{x}_{l}^{\mathsf{T}}) \ve{v}\)&lt;/span&gt;が,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \ve{v}^{\mathsf{T}} (\ve{x}_{l}\ve{x}_{l}^{\mathsf{T}} ) \ve{v} &amp;amp;= (\ve{x}_{l}^{\mathsf{T}} \ve{v})^{\mathsf{T}} (\ve{x}_{l}^{\mathsf{T}} \ve{v}) = (\ve{x}_{l}^{\mathsf{T}} \ve{v})^{2} \geq 0\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となるので半正定値行列である. 従って,
ヘッセ行列&lt;span class="math"&gt;\(H\)&lt;/span&gt;も半正定値となり,
&lt;span class="math"&gt;\(e_{l}(\ve{w})\)&lt;/span&gt;は凸関数であることが分かり,
極小値が大域的な最小値に一致する（局所最小値が存在しない）ことが確かめられた.&lt;/p&gt;
&lt;p&gt;最後に誤差&lt;span class="math"&gt;\(E(\ve{w})\)&lt;/span&gt;として二乗誤差を用いた場合の更新量&lt;span class="math"&gt;\(\Delta \ve{w}\)&lt;/span&gt;を求めておく.
今度は&lt;span class="math"&gt;\(e_{l}(\ve{w}) = \displaystyle \frac{1}{2} (t_{l} - y_{l})^{2}\)&lt;/span&gt;とおき,
ユニットの活性化関数を一般に微分可能な関数&lt;span class="math"&gt;\(f\)&lt;/span&gt;とすると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \parfrac{ }{w_{i}} e_{l}(\ve{w}) &amp;amp;= \parfrac{e_{l}(\ve{w})}{y_{l}} \parfrac{y_{l}}{u_{l}}\parfrac{u_{l}}{w_{i}} \quad (\because 合成関数の微分) \\
  &amp;amp;= -(t_{l} - y_{l}) f^{\prime} (u_{l}) x_{i} \quad (f^{\prime} (u_{l}) \equiv \parfrac{y_{l}}{u_{l}} = \parfrac{ }{u_{l}} f(u_{l})) \\
  &amp;amp;= \delta_{l} f^{\prime}(u_{l}) x_{i}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる. 従って更新量&lt;span class="math"&gt;\(\Delta \ve{w}\)&lt;/span&gt;は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \Delta \ve{w} = - \eta \sum_{l=1}^{N} \delta_{l} f^{\prime}(u_{l}) \ve{x}_{l}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる. さて,
この学習則は局所最小値におちいる場合がある事に上で言及したが,
これは&lt;span class="math"&gt;\(e_{l}(\ve{w})\)&lt;/span&gt;の2階の偏導関数が&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \parfrac{{}^{2} e_{l}(\ve{w})}{w_{i} \partial w_{j}} &amp;amp;= \parfrac{ }{w_{j}} y_{l} f^{\prime}(u_{l}) x_{i} - (t_{l} - y_{l}) \parfrac{ }{w_{j}} f^{\prime}(u_{l}) x_{i} \\
  &amp;amp;= \left\{ (f^{\prime}(u_{l}))^{2} - (t_{l} - y_{l}) f^{\prime\prime} (u_{l}) \right\} x_{i} x_{j}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となるが,
&lt;span class="math"&gt;\((f^{\prime}(u_{l}))^{2} - (t_{l} - y_{l}) f^{\prime\prime} (u_{l})\)&lt;/span&gt;が常に非負になるとは限らないからである.
実際, &lt;span class="math"&gt;\(f\)&lt;/span&gt;をシグモイド関数とすると2階微分は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  f^{\prime\prime}(u_{l}) &amp;amp;= f^{\prime}(u_{l}) (1-f(u_{l})) - f(u_{l}) f^{\prime}(u_{l}) = f^{\prime}(u_{l}) (1 - 2 f(u_{l}))
  \\
  &amp;amp;= f(u_{l}) (1 - f(u_{l}))(1-2f(u_{l}))\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;であり, &lt;span class="math"&gt;\(t_{l} = 1\)&lt;/span&gt;とすると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  (f^{\prime}(u_{l}))^{2} - (1 - y_{l}) f^{\prime\prime} (u_{l}) &amp;amp;= (f^{\prime}(u_{l}))^{2} + f^{\prime}(u_{l})(1-2f(u_{l})) - 1 \\
  &amp;amp;= f^{\prime}(u_{l}) (f^{\prime}(u_{l}) + 1 - 2f(u_{l}) ) - 1 \\
  &amp;amp;= f(u_{l}) (1 - f(u_{l})) (-(f(u_{l}))^{2} + 1 - f(u_{l})) - 1 &amp;lt; 0\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となってしまう.
従って二乗誤差を用いる場合はヘッセ行列が半正定値行列とならず,
誤差が局所最小値におちいる場合がある.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-9"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-8"&gt;多層パーセプトロン&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;単層パーセプトロンはサンプルが直線（平面）で分離できる（線形分離可能な）問題にしか適用できない事 &lt;a class="footnote-reference" href="#footnote-13" id="footnote-reference-13"&gt;[13]&lt;/a&gt; が1969年にMinskey-Papertに指摘された.
線形分離不可能な例としてよく例に引き出されるのが図&lt;a class="reference external" href="#fig:XOR_problem"&gt;3&lt;/a&gt;の&lt;strong&gt;XOR問題&lt;/strong&gt;である.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="XOR問題" id="fig-xor-problem" src="./images/XOR_problem.eps" /&gt;
&lt;p class="caption"&gt;XOR問題&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;この問題は1本の直線では分離できず,
従って単層パーセプトロンでは正しく学習することができない.
この線形分離不可能な問題のために,
NN研究の第一次ブームは終焉を迎え最初の冬の時代が訪れた.&lt;/p&gt;
&lt;p&gt;この問題は1986年,
Rumelhart-McClelland（デビット・ラメルハート-ジェームス・マクレランド）によって提案された&lt;strong&gt;多層パーセプトロン（multi-layer
perceptron, MLP）&lt;/strong&gt;によって解決を見た.
多層パーセプトロンは図&lt;a class="reference external" href="#fig:MLP"&gt;4&lt;/a&gt;に表される様に, 入力層（input
layer）, 任意個数の中間（隠れ）層（middle(hidden) layer）,
出力層（output layer）からなる多層構造を持ち,
全てのユニット出力の活性化関数は非線形関数（大体はシグモイド関数）となっている.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="多層パーセプトロン" id="fig-mlp" src="./images/multi_layer_perceptron.eps" /&gt;
&lt;p class="caption"&gt;多層パーセプトロン&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;多層パーセプトロンが線形分離不可能な問題にも適用できるのは,
主に次の2つの理由による:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;階層構造を用いている事:
これは形式ニューロンのXOR素子で既に示唆されていたが,
ニューロンを階層的に繋いで全ての重みを可変にすれば,
1つのユニットが1つの分離結果を持つため複数の分離結果を合成することができる.&lt;/li&gt;
&lt;li&gt;ユニットの出力が非線形であること: ユニットの出力を非線形にすることで,
線形分離不可能な入力をニューロン内部で非線形変換し,
線形分離可能な問題に還元できる場合がある.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多層パーセプトロンは様々な現実的な問題に適用できる為に,
NNの第二次研究ブームを引き起こした. 現在においても,
一口にNNと言うと3層（1つの中間層）からなる多層パーセプトロン（3層NN）の事を指すことが多い.&lt;/p&gt;
&lt;div class="section" id="section-10"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-9"&gt;多層パーセプトロンの学習則 - 逆誤差伝搬法&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;全ての重みが可変となった多層パーセプトロンでは,
単層パーセプトロンにおける学習則の様に出力層の重みを更新するだけではなく,
全ての重みを逐次更新していく必要がある.
多層パーセプトロンの学習として標準的に用いられる&lt;strong&gt;逆誤差伝搬法（(error)
back-propagation method）&lt;/strong&gt;は,
出力層での誤差を順次後ろ向きに（出力&lt;span class="math"&gt;\(\to\)&lt;/span&gt;中間&lt;span class="math"&gt;\(\to\)&lt;/span&gt;入力層の順に）伝播させて重みを更新していく手法である.&lt;/p&gt;
&lt;p&gt;それでは学習則を導出していくが,
多層構造を表現する為に次の定義を導入する. まず,
入力層を第&lt;span class="math"&gt;\(1\)&lt;/span&gt;層, 入力層と繋がった中間層を第&lt;span class="math"&gt;\(2\)&lt;/span&gt;層,
第&lt;span class="math"&gt;\(2\)&lt;/span&gt;層と繋がった層を第&lt;span class="math"&gt;\(3\)&lt;/span&gt;層, &lt;span class="math"&gt;\(\dots\)&lt;/span&gt;と呼び,
出力層は第&lt;span class="math"&gt;\(n\)&lt;/span&gt;層とする.
即ち&lt;span class="math"&gt;\(n\)&lt;/span&gt;層構造の多層パーセプトロンを考える. また,
各層のユニット個数は一般に異なっても良いことにし,
第&lt;span class="math"&gt;\(k\)&lt;/span&gt;層におけるユニットの数を&lt;span class="math"&gt;\(L_{k}\)&lt;/span&gt;と表す.
第&lt;span class="math"&gt;\(k-1\)&lt;/span&gt;層における第&lt;span class="math"&gt;\(i\)&lt;/span&gt;ユニットと第&lt;span class="math"&gt;\(k\)&lt;/span&gt;層における第&lt;span class="math"&gt;\(j\)&lt;/span&gt;ユニットを繋ぐ重みを&lt;span class="math"&gt;\(w_{ij}^{k-1,k}\)&lt;/span&gt;と表し,
第&lt;span class="math"&gt;\(k\)&lt;/span&gt;層の第&lt;span class="math"&gt;\(i\)&lt;/span&gt;ユニットへの入力総量を&lt;span class="math"&gt;\(u_{i}^{k}\)&lt;/span&gt;と,
またその出力を&lt;span class="math"&gt;\(y_{i}^{k} = f(u_{i}^{k})\)&lt;/span&gt;と表す.
&lt;span class="math"&gt;\(f\)&lt;/span&gt;は微分可能な活性化関数ならば何でも良いが,
ここではシグモイド関数とする. また,
出力層に複数ユニットが存在するのでサンプルラベルも各出力ユニットに対応して用意し,
&lt;span class="math"&gt;\(i\)&lt;/span&gt;番目の出力ユニットに与えるラベルを&lt;span class="math"&gt;\(t^{l}_{i}\ (i=1,\dots,N)\)&lt;/span&gt;と表す.&lt;/p&gt;
&lt;p&gt;デルタ則の導出と同様に誤差の勾配を取ることを考える. 無論,
局所最小を回避する為に誤差関数&lt;span class="math"&gt;\(E\)&lt;/span&gt;としてKLダイバージェンスを導入する.
&lt;span class="math"&gt;\(E\)&lt;/span&gt;を&lt;span class="math"&gt;\(w_{ij}^{k-1,k}\)&lt;/span&gt;によって偏微分すると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \parfrac{E}{w_{ij}^{k-1, k}} &amp;amp;= \parfrac{E}{u_{j}^{k}} \parfrac{u_{j}^{k}}{w_{ij}^{k-1,k}} \quad (\because 偏微分の連鎖律。 u_{j}^{k} を挟み込んでいるのが逆誤差伝播のキモ。) \\
  &amp;amp;= \parfrac{E}{u_{j}^{k}} \parfrac{ }{w_{ij}^{k-1,k}} \left( \sum_{s=1}^{L_{k-1}} w_{sj}^{k-1,k} y_{s}^{k-1} \right) = \parfrac{E}{u_{j}^{k}} y_{i}^{k-1}  \\
  &amp;amp;= \parfrac{E}{y_{j}^{k}} \parfrac{y_{j}^{k}}{u_{j}^{k}} y_{i}^{k-1} \quad (\because 偏微分の連鎖律) \\
  &amp;amp;= \parfrac{E}{y_{j}^{k}} f^{\prime}(u_{j}^{k}) y_{i}^{k-1} \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで&lt;span class="math"&gt;\(\displaystyle\parfrac{E}{y_{j}^{k}}\)&lt;/span&gt;は出力層の場合（&lt;span class="math"&gt;\(k=n\)&lt;/span&gt;）と中間層の場合（&lt;span class="math"&gt;\(k&amp;lt;n\)&lt;/span&gt;）で結果が異なる.
出力層の場合は, デルタ則の結果から,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \parfrac{E}{y_{j}^{n}} &amp;amp;= \frac{1-t_{j}^{l}}{1-y_{j}^{n}} - \frac{t_{j}^{l}}{y_{j}^{n}} = \frac{y_{j}^{n}(1-t_{j}^{l}) - t_{j}^{l}(1 - y_{j}^{n})}{y_{j}^{n}(1-y_{j}^{n})} = \frac{y_{j}^{n} - t_{j}^{l}}{f^{\prime}(u_{j}^{n})} \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となり, 一方中間層の場合は, 偏微分の連鎖律（chain rule）によって,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \parfrac{E}{y_{j}^{k}} &amp;amp;= \sum_{s=1}^{L_{k+1}} \parfrac{E}{u_{s}^{k+1}} \parfrac{u_{s}^{k+1}}{y_{j}^{k}} \\
  &amp;amp;= \sum_{s=1}^{L_{k+1}} \parfrac{E}{u_{s}^{k+1}} \parfrac{}{y_{j}^{k}} \left( \sum_{t=1}^{L_{k}} w_{ts}^{k, k+1} y_{t}^{k} \right) = \sum_{s=1}^{L_{k+1}} \parfrac{E}{u_{s}^{k+1}} w_{js}^{k,k+1} \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と展開できる. これらの結果をまとめると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \parfrac{E}{w_{ij}^{k-1, k}} =
  \left\{ \begin{array}{ll}
    \displaystyle \frac{y_{j}^{n} - t_{j}^{l}}{f^{\prime}(u_{j}^{n})} f^{\prime}(u_{j}^{n}) y_{j}^{n-1} = (y_{j}^{n} - t_{l}) y_{i}^{n-1} &amp;amp; (k = n) \\
    \displaystyle \sum_{s=1}^{L_{k+1}} \parfrac{E}{u_{s}^{k+1}} w_{js}^{k,k+1} f^{\prime}(u_{j}^{k}) y_{i}^{k-1} &amp;amp; (k &amp;lt; n)
  \end{array} \right.\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となるが,
次の第&lt;span class="math"&gt;\(k\)&lt;/span&gt;層の&lt;span class="math"&gt;\(i\)&lt;/span&gt;番目のユニットの&lt;strong&gt;誤差信号&lt;/strong&gt;&lt;span class="math"&gt;\(\delta_{i}^{k}\)&lt;/span&gt;&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\begin{aligned}
  \delta_{i}^{k} &amp;amp;= \parfrac{E}{u_{i}^{k}} = \parfrac{E}{y_{i}^{k}} \parfrac{y_{i}^{k}}{u_{i}^{k}} \\
  &amp;amp;=
  \left\{ \begin{array}{ll}
    y_{i}^{n} - t_{i}^{l} &amp;amp; (k = n) \\
    \displaystyle \sum_{s=1}^{L_{k+1}} \parfrac{E}{u_{s}^{k+1}}w_{js}^{k,k+1} f^{\prime}(u_{i}^{k}) = \sum_{s=1}^{L_{k+1}} \delta_{s}^{k+1} w_{js}^{k,k+1}  f^{\prime}(u_{i}^{k}) &amp;amp; (k &amp;lt; n)
  \end{array} \right.\end{aligned}
\end{align*}
&lt;/div&gt;
&lt;p&gt;を用いれば, より簡潔に勾配を表現できる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \parfrac{E}{w_{ij}^{k-1, k}} = y_{i}^{k-1} \delta_{j}^{k}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;以上により,
逆誤差伝搬法は次の手順に従って重みを更新すれば良い事が分かる:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(k \leftarrow n\)&lt;/span&gt;とする.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;誤差信号&lt;span class="math"&gt;\(\delta_{i}^{k}\ (i = 1,\dots,L_{k})\)&lt;/span&gt;の計算を行う:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
      \delta_{i}^{k} =
      \left\{ \begin{array}{ll}
        y_{i}^{n} - t_{i}^{l} &amp;amp; (k = n) \\
        \displaystyle \sum_{s=1}^{L_{k+1}} \delta_{s}^{k+1} w_{js}^{k,k+1}  f^{\prime}(u_{i}^{k}) &amp;amp; (k &amp;lt; n)
      \end{array} \right.
    \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(k \leftarrow k-1\)&lt;/span&gt;とする.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(k = 1\)&lt;/span&gt;ならば次へ, そうでなければ2. に戻る.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;重みを更新する:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
      w_{ij}^{k-1,k} \leftarrow w_{ij}^{k-1,k} - \eta y_{i}^{k-1} \delta_{j}^{k} \quad (k=2,\dots,n,\ i = 1,\dots, L_{k-1},\ j = 1,\dots,L_{k})
    \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;これは基本となる逐次学習法であるが,
一括学習の時は&lt;span class="math"&gt;\(\delta_{i}^{n}\)&lt;/span&gt;の所でサンプルについての和を取って次のようにすれば良い:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \delta_{i}^{n} = \sum_{l=1}^{N} (y_{i}^{n} - t_{i}^{l})\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;ノーバート・ウィーナー, 池原止戈夫, 彌永昌吉, 室賀三郎, 戸田巌,
“ウィーナー サイバネティックス ―動物と機械における制御と通信”
岩波書店, 2011&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;庄野逸, &lt;a class="reference external" href="http://www.slideshare.net/HAL9801/20140705"&gt;Deep Learning
勉強会(1)&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;高橋治久, 堀田一弘, “学習理論” コロナ社, 2009&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;これは非常に単純なモデルであり,
理解や応用が簡単な為に様々な場面で用いられる.
特に機械学習では無批判にこのユニットを用いる向きがある. しかし,
このモデルは厳密にニューロンの動作を表現できてはいないことに注意が必要である.
例えば,
このモデルでは入力&lt;span class="math"&gt;\(u\)&lt;/span&gt;が強ければ常に高電位を放出する事になるが,
実際にはニューロンはパルスを放出した後は一時的に放出電位が下がる事が実験により知られている.
よりニューロンの動作を精密に表したモデルにホジキン-ハックスレー型のニューロンモデルがある[^13].&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;正例のラベルを&lt;span class="math"&gt;\(1\)&lt;/span&gt;,
負例のラベルを&lt;span class="math"&gt;\(0\)&lt;/span&gt;としたり問題に応じて都合良く決められるが,
識別できる二値なら何でもよく, 本質的な違いは存在しない.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;高橋治久, 堀田一弘, “学習理論” コロナ社, 2009&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-7"&gt;[7]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;この正規化によっても一般性は全く失われない.
&lt;span class="math"&gt;\(\ve{w}\)&lt;/span&gt;は入力の重みの比率を定めているに過ぎず,
実際&lt;span class="math"&gt;\(u = \ve{w}^{\mathsf{T}}\ve{x} + b\)&lt;/span&gt;から見れるように,
&lt;span class="math"&gt;\(\ve{w}\)&lt;/span&gt;は面（識別面という）の法ベクトルとなっている.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-8"&gt;[8]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;最も面&lt;span class="math"&gt;\(\ve{w}^{\ast}\)&lt;/span&gt;に近いベクトルの距離を表しており,
&lt;strong&gt;マージン&lt;/strong&gt;と呼ばれる. かの有名なSVMのマージンそのものである&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-9"&gt;[9]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;2つのベクトル&lt;span class="math"&gt;\(\ve{v}_{1}, \ve{v}_{2}\)&lt;/span&gt;がなす角度&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;は&lt;span class="math"&gt;\(\cos\theta = \ve{v}_{1}^{\mathsf{T}}\ve{v}_{2}/(||\ve{v}_{1}||||\ve{v}_{2}||)\)&lt;/span&gt;により求められるので,
&lt;span class="math"&gt;\(\theta=0\)&lt;/span&gt;ならば2つのベクトルは一致している（類似度が最大）と見ることができる.
角度&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;が&lt;span class="math"&gt;\(0\)&lt;/span&gt;に近い（類似度が高い）時は内積&lt;span class="math"&gt;\(\ve{v}_{1}^{\mathsf{T}}\ve{v}_{2}\)&lt;/span&gt;が高い値を取ることが分かる&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-10"&gt;[10]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;大域的な最小解とは限らない事に注意&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-11"&gt;[11]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;係数の&lt;span class="math"&gt;\(1/2\)&lt;/span&gt;に本質的な意味は無いが,
微分の際に計算を簡単にする狙いがある.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-12"&gt;[12]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;しかし, 局所最適に嵌ってしまうリスクが潜んでいる&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-13" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-13"&gt;[13]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;span class="math"&gt;\(\ve{w}\)&lt;/span&gt;は識別面の法ベクトルを表すが,
出力を単位ステップ（もしくは符号）関数とすると入力ベクトルが面の上半領域にある場合は&lt;span class="math"&gt;\(1\)&lt;/span&gt;を,
下半領域にある場合は&lt;span class="math"&gt;\(0(-1)\)&lt;/span&gt;を出力する.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="記事"></category><category term="古事記"></category><category term="機械学習"></category></entry><entry><title>最大エントロピーモデル</title><link href="/zui-da-entoropimoderu.html" rel="alternate"></link><published>2020-04-23T12:40:00+09:00</published><updated>2020-04-23T12:40:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-23:/zui-da-entoropimoderu.html</id><summary type="html">&lt;p class="first last"&gt;最大エントロピーモデルについての理論的概要。MRFよりも更に前の話！古い！&lt;/p&gt;
</summary><content type="html">&lt;p&gt;最大エントロピーモデルの導出過程、学習の更新則、素性選択についての理論的側面を述べる。記述の大部分は &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt; を参照し、一部 &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;, &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt; も参照している。&lt;/p&gt;
&lt;p&gt;最大エントロピーモデルは、データの特徴を &lt;strong&gt;素性関数(feature function)&lt;/strong&gt;
によって記述し、素性関数がある &lt;strong&gt;制約(constraint)&lt;/strong&gt;
を満たし、かつ、モデルを表現する確率分布のエントロピーが最大となる（最大エントロピー原理を満たす）モデルである。&lt;/p&gt;
&lt;p&gt;エントロピーを最大にする事により、制約を満たしながら最大エントロピーモデルの確率分布が最も一様に分布する様になり、未知データに対する確率を無下に&lt;span class="math"&gt;\(0\)&lt;/span&gt;にすることが無くなるため、高い汎用性（汎化性能）が期待できる。&lt;/p&gt;
&lt;div class="contents local topic" id="topic-1"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-2" id="toc-entry-1"&gt;モデルを表現する確率分布の導出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-3" id="toc-entry-2"&gt;最大のエントロピー原理の性質と最尤推定&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-4" id="toc-entry-3"&gt;最大エントロピーモデルの唯一存在性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-5" id="toc-entry-4"&gt;最大尤度を持つ最大エントロピーモデル&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-6" id="toc-entry-5"&gt;最大のエントロピーモデルの学習 - 反復スケーリング法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-7" id="toc-entry-6"&gt;条件付き最大エントロピーモデル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-8" id="toc-entry-7"&gt;素性の自動選択&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-9" id="toc-entry-8"&gt;脚注・参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-1"&gt;モデルを表現する確率分布の導出&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;まず、サンプル（事例）データのドメイン（定義域）を&lt;span class="math"&gt;\(X\)&lt;/span&gt;、データに付与されたラベルのドメインを&lt;span class="math"&gt;\(Y\)&lt;/span&gt;と書く。例えば、次に来る単語を予測させたい場合には、サンプル&lt;span class="math"&gt;\(X\)&lt;/span&gt;は1つ前までの単語の並び、ラベル&lt;span class="math"&gt;\(Y\)&lt;/span&gt;は今の単語となる。
データとラベルを組にすることで1つの学習サンプルが構成され、また、モデルに与える&lt;span class="math"&gt;\(m\)&lt;/span&gt;個の学習サンプルの集合&lt;span class="math"&gt;\(Z_{m} \subset 2^{X\times Y}\)&lt;/span&gt;を次で表す:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
Z_{m} = \{ (x_{1}, y_{1}), (x_{2}, y_{2}), \dots, (x_{m}, y_{m}) \}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;このようなサンプルに対し、&lt;strong&gt;素性関数（素性）&lt;/strong&gt;の集合&lt;span class="math"&gt;\({\cal F}\)&lt;/span&gt;は次で定義される:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
{\cal F} = \{ f_{i} : X \times Y \to \{0,1\}, i \in \{1,2,\dots,n\} \}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;即ち&lt;span class="math"&gt;\({\cal F}\)&lt;/span&gt;は、データとラベルの組&lt;span class="math"&gt;\((x,y) \in X \times Y\)&lt;/span&gt;を受け取って&lt;span class="math"&gt;\(\{0,1\}\)&lt;/span&gt;いずれかを返す関数の集合である。ここでは&lt;span class="math"&gt;\(f\)&lt;/span&gt;の値域は議論の簡略化のため&lt;span class="math"&gt;\(\{0,1\}\)&lt;/span&gt;としたが、値域は&lt;span class="math"&gt;\(\{0,\alpha\} (\alpha &amp;gt; 0)\)&lt;/span&gt;、即ち&lt;span class="math"&gt;\(0\)&lt;/span&gt;と&lt;span class="math"&gt;\(0\)&lt;/span&gt;以外の正数実数を取るようにもできる。また、素性が条件を満たし正の値を取る時は、素性が活性化しているという。&lt;/p&gt;
&lt;p&gt;素性の例を挙げると、&lt;span class="math"&gt;\(n\)&lt;/span&gt;個の単語列&lt;span class="math"&gt;\(w_{1},\dots,w_{n}\)&lt;/span&gt;から、直前の&lt;span class="math"&gt;\(N-1\)&lt;/span&gt;個の単語列&lt;span class="math"&gt;\(w_{n-N+1},\dots,w_{n-1}\)&lt;/span&gt;のみを用いて今の単語&lt;span class="math"&gt;\(w_{n}\)&lt;/span&gt;を予測する（&lt;span class="math"&gt;\(N\)&lt;/span&gt;-グラムの）場合は、素性は次の様に表現出来る。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f_{x_{1}x_{2}\dots x_{N}}(w_{1},\dots,w_{n-1},w_{n}) =
\left\{
  \begin{array}{ll}
    1 &amp;amp; w_{n-N+1} = x_{1}, w_{n-N+2} = x_{2}, \dots, w_{n-1} = x_{N-1}, w_{n} = x_{N} \\
    0 &amp;amp; {\rm otherwise}
  \end{array} \right.
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで&lt;span class="math"&gt;\(f\)&lt;/span&gt;のインデックス&lt;span class="math"&gt;\(x_{1}\dots x_{N}\)&lt;/span&gt;は整数との対応を適当に取ることで、容易に実現できる。&lt;/p&gt;
&lt;p&gt;最大エントロピーモデルの制約として与えられる条件は、素性の平均（期待値）が、モデルと経験確率で一致することである。この条件を数式で表現する事を考える。&lt;/p&gt;
&lt;p&gt;定義域&lt;span class="math"&gt;\(X\times Y\)&lt;/span&gt;上に定義されるモデルの確率分布を&lt;span class="math"&gt;\(P(x,y)\)&lt;/span&gt;と書き、経験確率分布を&lt;span class="math"&gt;\(\tilde{P}(x,y)\)&lt;/span&gt;と書く。ここで経験確率分布&lt;span class="math"&gt;\(\tilde{P}\)&lt;/span&gt;は、頻度確率で与える。即ち、学習サンプルに現れた&lt;span class="math"&gt;\((x,y)\)&lt;/span&gt;の組の回数を&lt;span class="math"&gt;\(C(x,y)\)&lt;/span&gt;と書くと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\tilde{P}(x,y) = \frac{C(x,y)}{m}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表せる。モデルの確率分布は後で導出する。
ある素性&lt;span class="math"&gt;\(f_{i}\)&lt;/span&gt;の分布&lt;span class="math"&gt;\(p\)&lt;/span&gt;による平均を&lt;span class="math"&gt;\(E_{p}[f_{i}]\)&lt;/span&gt;と書くと、経験分布とモデルの確率分布のそれぞれの平均は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
E_{\tilde{P}}[f_{i}] &amp;amp;= \sum_{x,y} \tilde{P}(x,y) f_{i}(x,y) \\
E_{P}[f_{i}] &amp;amp;= \sum_{x,y} P(x,y) f_{i}(x,y)
\end{align*}
&lt;/div&gt;
&lt;p&gt;と表せられ、従って制約を数式で表現すると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
E_{\tilde{P}}[f_{i}] &amp;amp;= E_{P}[f_{i}] \ \ (i=1,\dots,n) \\
\iff \sum_{x,y} \tilde{P}(x,y) f_{i}(x,y) &amp;amp;= \sum_{x,y} P(x,y) f_{i}(x,y) \ \ (i=1,\dots,n)
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。最大エントロピーモデルの候補となる集合&lt;span class="math"&gt;\({\cal P}\)&lt;/span&gt;は、全ての素性に関する制約を満たすモデルの集合となる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
{\cal P} = \{ P | E_{P}[f_{i}] = E_{\tilde{P}}[f_{i}], i = \{1,\dots,n\} \}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;明らかに、2つのモデル&lt;span class="math"&gt;\(P,P^{\prime} \in {\cal P}\)&lt;/span&gt;に対して、&lt;span class="math"&gt;\(E_{P}[f_{i}] = E_{\tilde{P}}[f_{i}] = E_{P^{\prime}}[f_{i}]\ \ (i=1,\dots,n)\)&lt;/span&gt;（候補となるモデルの素性の平均は同一）となる。&lt;/p&gt;
&lt;p&gt;更に考慮すべき点は、最大エントロピーモデルの名の通り、モデル（確率分布&lt;span class="math"&gt;\(P\)&lt;/span&gt;）のエントロピーを最大にする必要がある。モデルのエントロピーを&lt;span class="math"&gt;\(H(P)\)&lt;/span&gt;と書くと、確率分布のエントロピーの式から,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
H(P) = -\sum_{x,y}P(x,y) \log P(x,y)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表現できる。集合&lt;span class="math"&gt;\({\cal P}\)&lt;/span&gt;の中で最もエントロピーが高いものが得るべきモデル&lt;span class="math"&gt;\(P^{\ast}\)&lt;/span&gt;である:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
P^{\ast} = \underset{P \in {\cal P}}{\rm argmax}\ H(P)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この式を &lt;strong&gt;最大エントロピー原理(maximum entropy principle)&lt;/strong&gt;
と呼ぶ。集合&lt;span class="math"&gt;\({\cal P}\)&lt;/span&gt;は無限集合だが最大エントロピー原理を満たすモデルは解析的に求められ、かつ一意に存在する（後術）。&lt;/p&gt;
&lt;p&gt;最大エントロピー原理を満たすモデルの確率分布&lt;span class="math"&gt;\(P\)&lt;/span&gt;を求める事を考える。これは制約付き非線形最適化問題であることから、ラグランジェの未定定数法が適用できる。&lt;span class="math"&gt;\(P\)&lt;/span&gt;が満たすべき制約を列挙すると&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
1:&amp;amp; \quad E_{P}[f_{i}] = E_{\tilde{P}}[f_{i}] \ \ (i=1,\dots,n) \\
2:&amp;amp; \quad P(x,y) \geq 0 \\
3:&amp;amp; \quad \sum_{x,y}P(x,y) = 1
\end{align*}
&lt;/div&gt;
&lt;p&gt;であり（2,3は&lt;span class="math"&gt;\(P\)&lt;/span&gt;が確率分布となる為の条件）、&lt;span class="math"&gt;\(n\)&lt;/span&gt;個の制約に対応する未定定数を&lt;span class="math"&gt;\(\Lambda = \{\lambda_{1},\dots,\lambda_{n}\}\)&lt;/span&gt;と書くと、ラグランジアン（ラグランジュ関数）&lt;span class="math"&gt;\({\cal L}(P,\Lambda)\)&lt;/span&gt;は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
{\cal L}(P, \Lambda) &amp;amp;= H(P) + \sum_{i=1}^{n} \lambda_{i} (E_{P}[f_{i}] - E_{\tilde{P}}[f_{i}]) \\
&amp;amp;= -\sum_{x,y}P(x,y)\log P(x,y) + \sum_{i=1}^{n} \lambda_{i} \left\{ \sum_{x,y} P(x,y) f_{i}(x,y) - \sum_{x,y} \tilde{P}(x,y) f_{i}(x,y) \right\}
\end{align*}
&lt;/div&gt;
&lt;p&gt;と書ける。最大値を得るため、&lt;span class="math"&gt;\(P(x,y)\)&lt;/span&gt;によって偏微分すると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\partial {\cal L}(P,\Lambda)}{\partial P(x,y)} = -\log P(x,y) - 1 + \sum_{i=1}^{n} \lambda_{i} f_{i}(x,y)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この式を&lt;span class="math"&gt;\(0\)&lt;/span&gt;とおいて&lt;span class="math"&gt;\(P(x,y)\)&lt;/span&gt;について解くと&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
P(x,y) = \exp \left[ -1 + \sum_{i=1}^{n} \lambda_{i} f_{i}(x,y) \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を得る。確率分布が指数関数で表現される為条件2の非負条件は満たされるが、条件3の全確率が1になることが保証されていない。そこで
&lt;span class="math"&gt;\(\sum_{x,y}P(x,y) = Z_{\Lambda}\)&lt;/span&gt;なる正規化項(normalization
factor)を導入し&lt;span class="math"&gt;\(P(x,y)\)&lt;/span&gt;の&lt;span class="math"&gt;\(x,y\)&lt;/span&gt;についての総和が1になるようにする。従ってモデルの確率分布は次で表される:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
P(x,y) &amp;amp;= \frac{ \exp \left[ -1 + \sum_{i=1}^{n} \lambda_{i} f_{i}(x,y) \right] }{ \sum_{x,y} \exp \left[ -1 + \sum_{i=1}^{n} \lambda_{i} f_{i}(x,y) \right] } \\
&amp;amp;= \frac{1}{Z_{\Lambda}} \exp \left[ \sum_{i} \lambda_{i} f_{i}(x,y) \right] \\
Z_{\Lambda} &amp;amp;= \sum_{x,y} \exp \left[ \sum_{i} \lambda_{i} f_{i}(x,y) \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;（以下、&lt;span class="math"&gt;\(\sum_{i=1}^{n} \equiv \sum_{i}\)&lt;/span&gt;とする）得られた確率分布はMRF(Markov
Random
Fields、マルコフ確率場)のクリークサイズを1とした時、即ち節点ポテンシャル（連想ポテンシャル）のみを考えた結合確率に一致する。従って最大エントロピーモデルはMRFのサブクラスとして捉えられる。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-2"&gt;最大のエントロピー原理の性質と最尤推定&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最大エントロピー原理を満たすモデルは上述の議論で求められたが、このモデルが唯一に定まる事を示す。まず、上述の議論で得られた確率分布を持つモデルの集合を&lt;span class="math"&gt;\({\cal Q}\)&lt;/span&gt;と書く:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
{\cal Q} = \left\{ P \left| P(x,y) = \frac{1}{Z_{\Lambda}} \exp\left[ \sum_{i} \lambda_{i}f_{i}(x,y) \right] \right. \right\}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;集合&lt;span class="math"&gt;\({\cal Q}\)&lt;/span&gt;の要素に制約は陽に表れていない。そして、&lt;span class="math"&gt;\({\cal P,Q}\)&lt;/span&gt;と最大エントロピー原理について次の定理が成り立つ:&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-3"&gt;最大エントロピーモデルの唯一存在性&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class="math"&gt;\(P^{\ast} \in {\cal P} \cap {\cal Q}\)&lt;/span&gt;ならば,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
P^{\ast} = \underset{P \in {\cal P}}{\rm argmax} \ H(P)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成り立ち、かつ&lt;span class="math"&gt;\(P^{\ast}\)&lt;/span&gt;は唯一に定まる。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;（証明）まず補助定理として、&lt;span class="math"&gt;\(R, S \in {\cal P}, T \in {\cal Q}\)&lt;/span&gt;ならば,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\sum_{x,y} R(x,y) \log T(x,y) = \sum_{x,y} S(x,y) \log T(x,y)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を示す。&lt;span class="math"&gt;\(T \in {\cal Q}\)&lt;/span&gt;より&lt;span class="math"&gt;\(T(x,y) = \displaystyle\frac{1}{Z_{\Lambda}} \exp\left[ \sum_{i} \lambda_{i} f_{i}(x,y) \right]\)&lt;/span&gt;と表せるので、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
（左辺） &amp;amp;= \sum_{x,y} R(x,y) \left[ \sum_{i} \lambda_{i} f_{i}(x,y) - \log Z_{\Lambda} \right] = \sum_{i} \lambda_{i} \sum_{x,y} R(x,y) f_{i}(x,y) - \log Z_{\Lambda} \sum_{x,y}R(x,y) \\
&amp;amp;= \sum_{i} \lambda_{i} E_{R}[f_{i}] - \log Z_{\Lambda} \\
&amp;amp;= \sum_{i} \lambda_{i} E_{S}[f_{i}] - \log Z_{\Lambda} \ \ (\because E_{R}[f_{i}] = E_{\tilde{P}}[f_{i}] = E_{S}[f_{i}]） \\
&amp;amp;= \sum_{x,y} S(x,y) \left[\sum_{i} \lambda_{i} f_{i}(x,y) \right] - \sum_{x,y} S(x,y) \log Z_{\Lambda} \\
&amp;amp;= \sum_{x,y} S(x,y) \log T(x,y) = （右辺）
\end{align*}
&lt;/div&gt;
&lt;p&gt;補助定理を用いて、定理の証明を行う。&lt;span class="math"&gt;\(P \in {\cal P}, P^{\ast} \in {\cal P} \cap {\cal Q}\)&lt;/span&gt;とすると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
H(P^{\ast}) - H(P) &amp;amp;= -\sum_{x,y} P^{\ast}(x,y) \log P^{\ast}(x,y) + \sum_{x,y} P(x,y) \log P(x,y) \\
&amp;amp;= -\sum_{x,y} P(x,y) \log P^{\ast}(x,y) + \sum_{x,y} P(x,y) \log P(x,y) \ \ （\because 補助定理） \\
&amp;amp;= \sum_{x,y} P(x,y) \log \left[ \frac{P(x,y)}{P^{\ast}(x,y)} \right] \\
&amp;amp;= {\rm KL}(P || P^{\ast}) \geq 0\ \ （{\rm KL}:KLダイバージェンス）
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって&lt;span class="math"&gt;\(H(P^{\ast}) \geq H(P)\)&lt;/span&gt;が成立する。また&lt;span class="math"&gt;\(H(P^{\ast}) = H(P)\)&lt;/span&gt;ならばKLダイバージェンスの性質により&lt;span class="math"&gt;\(P^{\ast} = P\)&lt;/span&gt;となる。以上により、定理の成立が示された。&lt;/p&gt;
&lt;p&gt;生成モデルの学習に関連して、最大エントロピー原理を満たすモデル&lt;span class="math"&gt;\(P^{\ast}\)&lt;/span&gt;は、経験確率分布&lt;span class="math"&gt;\(\tilde{P}\)&lt;/span&gt;が与えられた時に最大尤度を持つ事も示されている。モデルの尤度の式を導く事を考えると、まず経験確率分布&lt;span class="math"&gt;\(\tilde{P}\)&lt;/span&gt;に対するモデル&lt;span class="math"&gt;\(P\)&lt;/span&gt;の経験誤差はKLダイバージェンス&lt;span class="math"&gt;\({\rm KL}(\tilde{P} || P)\)&lt;/span&gt;で与えられる &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt; ので,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
{\rm KL}(\tilde{P} || P) &amp;amp;= \sum_{x,y} \tilde{P}(x,y) \log \left[ \frac{\tilde{P}(x,y)}{P(x,y)} \right] \\
&amp;amp;= \sum_{x,y} \tilde{P}(x,y) \log \tilde{P}(x,y) - \sum_{x,y} \tilde{P}(x,y) \log P(x,y)
\end{align*}
&lt;/div&gt;
&lt;p&gt;なる。大数の弱法則より、サンプル数の極限&lt;span class="math"&gt;\(m\to \infty\)&lt;/span&gt;を取ることにより経験確率分布は標的概念の確率分布に一致し、また経験誤差は汎化誤差に一致する。今&lt;span class="math"&gt;\({\rm KL}(\tilde{P} || P) \geq 0\)&lt;/span&gt;であり、かつ、&lt;span class="math"&gt;\(\tilde{P}\)&lt;/span&gt;は観測により固定されるので、経験誤差を最小にするには下段の式の第2項を最大化すれば良いことになる。そして、下段式の第2項は対数尤度（経験対数尤度）と呼ばれる。モデル&lt;span class="math"&gt;\(P\)&lt;/span&gt;の対数尤度を&lt;span class="math"&gt;\(L(P)\)&lt;/span&gt;と書くと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
L(P) = \sum_{x,y} \tilde{P}(x,y) \log P(x,y)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表すことができる。尤度との関連として、最大エントロピー原理を満たすモデル&lt;span class="math"&gt;\(P^{\ast}\)&lt;/span&gt;は次を満たす:&lt;/p&gt;
&lt;/div&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-4"&gt;最大尤度を持つ最大エントロピーモデル&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class="math"&gt;\(P^{\ast} \in {\cal P} \cap {\cal Q}\)&lt;/span&gt;ならば、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
P^{\ast} = \underset{Q \in {\cal Q}}{\rm argmax} \ L(Q)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成り立ち、かつ&lt;span class="math"&gt;\(P^{\ast}\)&lt;/span&gt;は唯一に定まる。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;（証明）前の定理と同様の方針と、補助定理により,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
L(P^{\ast}) - L(P) &amp;amp;= \sum_{x,y} \tilde{P}(x,y) \log P^{\ast}(x,y) - \sum_{x,y} \tilde{P}(x,y) \log P(x,y) \\
&amp;amp;= \sum_{x,y} P^{\ast}(x,y) \log P^{\ast}(x,y) - \sum_{x,y} P^{\ast}(x,y) \log P(x,y) \ \ (\because 反射性 E_{\tilde{P}}[f_{i}] = E_{\tilde{P}}[f_{i}]により、\tilde{P} \in {\cal P}) \\
&amp;amp;= \sum_{x,y} P^{\ast}(x,y) \log \left[ \frac{P^{\ast}(x,y)}{P(x,y)} \right] \\
&amp;amp;= {\rm KL}(P^{\ast} || P) \geq 0
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって&lt;span class="math"&gt;\(L(P^{\ast}) \geq L(P)\)&lt;/span&gt;であり、再びKLダイバージェンスの性質により、&lt;span class="math"&gt;\(L(P^{\ast}) = L(P)\)&lt;/span&gt;ならば&lt;span class="math"&gt;\(P^{\ast} = P\)&lt;/span&gt;が成り立つので唯一性も示される。従って定理の成立が示された。&lt;/p&gt;
&lt;p&gt;定理1と2により、次の性質が成り立つ:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
P^{\ast} = \underset{P \in {\cal P}}{\rm argmax} \ H(P) = \underset{Q \in {\cal Q}}{\rm argmax} \ L(Q)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;即ち、モデルの最大エントロピー原理は最尤推定の枠組みで捉える事もでき、尤度を最大化したモデルが最大のエントロピーを持つ。よって、モデルの学習には通常の生成モデルの学習と同じ様に、&lt;span class="math"&gt;\({\cal Q}\)&lt;/span&gt;の要素で表現されるモデルの尤度最大化を考えれば良いことになる。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-5"&gt;最大のエントロピーモデルの学習 - 反復スケーリング法&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最尤推定法に基づく最大エントロピーモデルの学習は、モデルの尤度が最大になるようにモデル&lt;span class="math"&gt;\(P\)&lt;/span&gt;のパラメタ&lt;span class="math"&gt;\(\Lambda\)&lt;/span&gt;を調節してやれば良い。単純なアプローチとしては、対数尤度&lt;span class="math"&gt;\(L(P)\)&lt;/span&gt;をパラメタ&lt;span class="math"&gt;\(\Lambda=\{\lambda_{1},\cdots,\lambda_{n}\}\)&lt;/span&gt;で偏微分し、最急上昇法によって最大値を得る方法がある。実際に計算してみると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{\partial L(P)}{\partial \lambda_{i}} &amp;amp;= \sum_{x,y} \tilde{P}(x,y) \frac{\partial}{\partial \lambda_{i}} \log P(x,y) \\
&amp;amp;= \sum_{x,y} \tilde{P}(x,y) \frac{\partial}{\partial \lambda_{i}} \left[ \sum_{j} \lambda_{j} f_{j}(x,y) - \log Z_{\Lambda} \right] \\
&amp;amp;= \sum_{x,y} \tilde{P}(x,y) \left[ f_{i}(x,y) - \frac{1}{Z_{\Lambda}} \sum_{x^{\prime},y^{\prime}} f_{i}(x^{\prime},y^{\prime}) \exp \left( \sum_{j} \lambda_{j} f_{j}(x^{\prime},y^{\prime}) \right) \right] \\
&amp;amp;= \sum_{x,y} \tilde{P}(x,y) \left( f_{i}(x,y) - E_{P}[f_{i}] \right) \\
&amp;amp;= E_{\tilde{P}}[f_{i}] - E_{P}[f_{i}]
\end{align*}
&lt;/div&gt;
&lt;p&gt;であり（最適時には制約が満たされることが分かる）、ステップ&lt;span class="math"&gt;\(t\)&lt;/span&gt;におけるパラメタ&lt;span class="math"&gt;\(\lambda_{i}^{t}\)&lt;/span&gt;の更新規則は次の様に得られる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\lambda_{i}^{t+1} &amp;amp;= \lambda_{i}^{t} + \eta \frac{\partial L(P)}{\partial \lambda_{i}^{t}} \\
&amp;amp;= \lambda_{i}^{t} + \eta ( E_{\tilde{P}}[f_{i}] - E_{P}[f_{i}] )
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで&lt;span class="math"&gt;\(\eta\)&lt;/span&gt;は収束の早さを決める学習率(learning
rate)であり、ヒューリスティックに決める必要がある。
この様に再急上昇法による学習は単純だが、学習（収束）が遅く、&lt;span class="math"&gt;\(\eta\)&lt;/span&gt;を決めなければならないという問題がある。&lt;span class="math"&gt;\(\eta\)&lt;/span&gt;を大きく設定し過ぎると勾配の谷を越えてしまい発散を招き、逆に小さく設定すると学習がいつまでたっても終わらない。現状、最大エントロピーモデルの学習では、反復スケーリング法(iterative
scaling)という学習手法が伝統的に用いられている。&lt;/p&gt;
&lt;p&gt;反復スケーリング法の基本的な考え方は、まずパラメタ&lt;span class="math"&gt;\(\Lambda\)&lt;/span&gt;を&lt;span class="math"&gt;\(\Lambda+\Delta\)&lt;/span&gt;に変化させた時の対数尤度の変化量の下限&lt;span class="math"&gt;\(A(\Lambda,\Delta)\)&lt;/span&gt;を計算し、次にこの&lt;span class="math"&gt;\(A(\Lambda,\Delta)\)&lt;/span&gt;を最大にする&lt;span class="math"&gt;\(\Delta\)&lt;/span&gt;を求める事で、結果増加量を最大にするようにしている。この考え方には学習率の様なヒューリスティックは介在せず、かつ毎ステップの対数尤度の増加量を最大にするようにパラメタを更新できる。&lt;/p&gt;
&lt;p&gt;それでは反復スケーリング法の更新式を導くことを考える。各パラメタの更新量を&lt;span class="math"&gt;\(\Delta=\{\delta_{1},\cdots,\delta_{n}\}\)&lt;/span&gt;と表すものとし、まず、パラメタ更新時の対数尤度の変化量&lt;span class="math"&gt;\(L(P_{\Lambda+\Delta})-L(P_{\Lambda})\)&lt;/span&gt;は,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
L(P_{\Lambda+\Delta})-L(P_{\Lambda}) &amp;amp;= \sum_{x,y} \tilde{P}(x,y) \log P_{\Lambda+\Delta}(x,y) - \sum_{x,y} \tilde{P}(x,y) \log P_{\Lambda}(x,y) \\
&amp;amp;= \sum_{x,y} \tilde{P}(x,y) \log \left[ \frac{P_{\Lambda+\Delta}(x,y)}{P_{\Delta}(x,y)} \right] \\
&amp;amp;= \sum_{x,y} \tilde{P}(x,y) \log \left[ \frac{Z_{\Lambda}}{Z_{\Lambda+\Delta}} \frac{\exp\left[ \sum_{i}(\lambda_{i} + \delta_{i}) f_{i}(x,y) \right]}{\exp\left[ \sum_{i}\lambda_{i}f_{i}(x,y) \right] } \right] \\
&amp;amp;= \sum_{x,y} \tilde{P}(x,y) \left[ \sum_{i} \delta_{i} f_{i}(x,y) - \log\left(\frac{Z_{\Lambda+\Delta}}{Z_{\Lambda}} \right) \right] \\
&amp;amp;= \sum_{x,y} \tilde{P}(x,y) \sum_{i} \delta_{i} f_{i}(x,y) - \log \left(\frac{Z_{\Lambda+\Delta}}{Z_{\Lambda}} \right) \\
&amp;amp;\geq \sum_{x,y} \tilde{P}(x,y) \sum_{i} \delta_{i} f_{i}(x,y) + 1 - \frac{Z_{\Lambda+\Delta}}{Z_{\Lambda}} \ \ (\because -\log x \geq 1-x) \\
&amp;amp;= \sum_{x,y} \tilde{P}(x,y) \sum_{i} \delta_{i} f_{i}(x,y) + 1 - \frac{\sum_{x,y}\exp\left[ \sum_{i}(\lambda_{i} + \delta_{i})f_{i}(x,y) \right]}{\sum_{x,y}\exp\left[ \sum_{i}\lambda_{i}f_{i}(x,y) \right]} \\
&amp;amp;= \sum_{x,y} \tilde{P}(x,y) \sum_{i} \delta_{i} f_{i}(x,y) + 1 - \frac{Z_{\Lambda}\sum_{x,y}P_{\Lambda}(x,y)\exp\left[ \sum_{i}\delta_{i}f_{i}(x,y) \right]}{Z_{\Lambda} \sum_{x,y}P_{\Lambda}(x,y)} \\
&amp;amp;= \sum_{x,y} \tilde{P}(x,y) \sum_{i} \delta_{i} f_{i}(x,y) + 1 - \sum_{x,y}P_{\Lambda}(x,y)\exp\left[ \sum_{i}\delta_{i}f_{i}(x,y) \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;素性&lt;span class="math"&gt;\(f_{i}(x,y)\)&lt;/span&gt;の&lt;span class="math"&gt;\(i\)&lt;/span&gt;についての和&lt;span class="math"&gt;\(f^{\#}(x,y) = \sum_{i=1}^{n}f_{i}(x,y)\)&lt;/span&gt;を用いると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
L(P_{\Lambda+\Delta})-L(P_{\Lambda}) = \sum_{x,y} \tilde{P}(x,y) \sum_{i} \delta_{i} f_{i}(x,y) + 1 - \sum_{x,y}P_{\Lambda}(x,y)\exp\left[ \sum_{i}\frac{f_{i}(x,y)}{f^{\#}(x,y)}\delta_{i}f^{\#}(x,y) \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と書ける。今&lt;span class="math"&gt;\(f_{i}(x,y)/f^{\#}(x,y)\)&lt;/span&gt;は確率分布となることから、&lt;span class="math"&gt;\(\sum_{i}\frac{f_{i}(x,y)}{f^{\#}(x,y)}\delta_{i}f^{\#}(x,y)\)&lt;/span&gt;は&lt;span class="math"&gt;\(\delta_{i}f^{\#}(x,y)\)&lt;/span&gt;についての平均と読み取れる。更に&lt;span class="math"&gt;\(\exp\)&lt;/span&gt;は明らかに凸関数であることから、イェンセンの不等式&lt;span class="math"&gt;\(\exp(E[X]) \leq E[\exp(X)]\)&lt;/span&gt;を用いて最終的な下限の式を得る。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
L(P_{\Lambda+\Delta})-L(P_{\Lambda}) &amp;amp;\geq \sum_{x,y} \tilde{P}(x,y) \sum_{i} \delta_{i} f_{i}(x,y) + 1 - \sum_{x,y}P_{\Lambda}(x,y)\sum_{i}\frac{f_{i}(x,y)}{f^{\#}(x,y)}\exp\left[ \delta_{i}f^{\#}(x,y) \right] \\
&amp;amp;= A(\Lambda, \Delta)
\end{align*}
&lt;/div&gt;
&lt;p&gt;次に&lt;span class="math"&gt;\(A(\Lambda, \Delta)\)&lt;/span&gt;を&lt;span class="math"&gt;\(\delta_{i}\)&lt;/span&gt;で偏微分することで下限の最大化を考える。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{\partial A(\Lambda, \Delta)}{\partial \delta_{i}} &amp;amp;= \sum_{x,y} \tilde{P}(x,y) f_{i}(x,y) - \sum_{x,y} P_{\Lambda}(x,y) f_{i}(x,y) \exp \left[ \delta_{i}f^{\#}(x,y) \right] \\
&amp;amp;= E_{\tilde{P}}[f_{i}] - \sum_{x,y} P_{\Lambda}(x,y) f_{i}(x,y) \exp \left[ \delta_{i}f^{\#}(x,y) \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;この式を&lt;span class="math"&gt;\(0\)&lt;/span&gt;とおき&lt;span class="math"&gt;\(\delta_{i}\)&lt;/span&gt;について解くことで変化量を求める事ができる。この式は&lt;span class="math"&gt;\(\delta_{i}\)&lt;/span&gt;について閉じた形をしていないので、基本的には数値解析によって極値を求める。しかし、もしも任意の&lt;span class="math"&gt;\((x,y)\)&lt;/span&gt;に対し
&lt;span class="math"&gt;\(f^{\#}(x,y) = C\)&lt;/span&gt;（定数）となるならば、&lt;span class="math"&gt;\(\delta_{i}\)&lt;/span&gt;について解く事ができ、次の結果を得る。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
&amp;amp; E_{\tilde{P}}[f_{i}] - \sum_{x,y} P_{\Lambda}(x,y) f_{i}(x,y) \exp \left[ \delta_{i}f^{\#}(x,y) \right] = 0 \\
&amp;amp;\implies \exp \left[C \delta_{i} \right] \sum_{x,y} P_{\Lambda}(x,y) f_{i}(x,y) = E_{\tilde{P}}[f_{i}] \iff \exp \left[C \delta_{i} \right] = \frac{E_{\tilde{P}}[f_{i}]}{E_{P}[f_{i}]} \\
&amp;amp;\iff \delta_{i} = \frac{1}{C} \log \left( \frac{E_{\tilde{P}}[f_{i}]}{E_{P}[f_{i}]} \right)
\end{align*}
&lt;/div&gt;
&lt;p&gt;任意の&lt;span class="math"&gt;\((x,y)\)&lt;/span&gt;で&lt;span class="math"&gt;\(f^{\#}(x,y)\)&lt;/span&gt;が定数にならない場合でも、実は&lt;span class="math"&gt;\(C = \displaystyle\max_{x,y} f^{\#}(x,y)\)&lt;/span&gt;とし、新しい素性&lt;span class="math"&gt;\(f_{n+1}(x,y)\)&lt;/span&gt;を&lt;span class="math"&gt;\(f_{n+1}(x,y) = C - f^{\#}(x,y)\)&lt;/span&gt;とおけば、変更後の和&lt;span class="math"&gt;\(f^{\#\prime}(x,y)\)&lt;/span&gt;は&lt;span class="math"&gt;\(f^{\#\prime}(x,y)=C\)&lt;/span&gt;となる事が知られている。&lt;span class="math"&gt;\(f^{\#\prime}(x,y)\)&lt;/span&gt;について検算を行ってみると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
f^{\#\prime}(x,y) &amp;amp;= \sum_{i=1}^{n+1} f_{i}(x,y) = \sum_{i=1}^{n} f_{i}(x,y) + f_{n+1}(x,y)  \\
&amp;amp;=  f^{\#}(x,y) + C - f^{\#}(x,y) = C
\end{align*}
&lt;/div&gt;
&lt;p&gt;となって、定数&lt;span class="math"&gt;\(C\)&lt;/span&gt;を取ることが確かめられた。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-6"&gt;条件付き最大エントロピーモデル&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;前節までのモデルはあるパターン&lt;span class="math"&gt;\((x,y)\)&lt;/span&gt;を生成する結合確率を表現しているが、応用上は何らかの入力&lt;span class="math"&gt;\(x\)&lt;/span&gt;に対して出力&lt;span class="math"&gt;\(y\)&lt;/span&gt;の結果を得たいというケースが多い。例えば、再び単語予測の例を挙げると、一つ前までの単語を&lt;span class="math"&gt;\(x\)&lt;/span&gt;として入力として、今の単語&lt;span class="math"&gt;\(y\)&lt;/span&gt;を予測するというタスクである。そのような場合はモデルの条件付き確率&lt;span class="math"&gt;\(P(y|x)\)&lt;/span&gt;が用いられる。このモデルは&lt;span class="math"&gt;\(y\)&lt;/span&gt;の識別を行うので生成識別モデルと呼ばれ、条件付き最大エントロピーモデルはCRF(Conditional
Random Fields、条件付き確率場)のサブクラスとして捉えられる。&lt;/p&gt;
&lt;p&gt;条件付き最大エントロピーモデルの確率分布&lt;span class="math"&gt;\(P_{\Lambda}(y|x)\)&lt;/span&gt;は、&lt;span class="math"&gt;\(P_{\Lambda}(x,y)\)&lt;/span&gt;とベイズの定理から得られる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
P_{\Lambda}(y|x) &amp;amp;= \frac{P_{\Lambda}(x,y)}{P_{\Lambda}(x)} \\
&amp;amp;= \frac{\exp\left[ \sum_{i}\lambda_{i}f_{i}(x,y) \right]}{Z_{\Lambda}} \left( \sum_{y} \frac{\exp\left[ \sum_{i}\lambda_{i}f_{i}(x,y) \right]}{Z_{\Lambda}} \right)^{-1} \\
&amp;amp;= \frac{1}{Z_{\Lambda}(x)} \exp\left[ \sum_{i}\lambda_{i}f_{i}(x,y) \right] \\
Z_{\Lambda}(x) &amp;amp;= \sum_{y}\exp\left[\sum_{i}\lambda_{i}f_{i}(x,y)\right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;このモデルを用いた素性の平均&lt;span class="math"&gt;\(E_{P}[f_{i}]\)&lt;/span&gt;は次の様に計算できる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
E_{P}[f_{i}] &amp;amp;= \sum_{x,y} P(x,y) f_{i}(x,y) = \sum_{x,y} P(y|x)P(x)f_{i}(x,y) \\
&amp;amp;= \sum_{x} P(x) \sum_{y} P(y|x) f_{i}(x,y)
\end{align*}
&lt;/div&gt;
&lt;p&gt;外側の&lt;span class="math"&gt;\(P(x)\)&lt;/span&gt;の和は、考えうる全ての入力&lt;span class="math"&gt;\(x \in X\)&lt;/span&gt;についての和を取らねばならず、その計算は現実的に不可能である。従って経験確率による近似&lt;span class="math"&gt;\(P(x) \approx \tilde{P}(x)\)&lt;/span&gt;を用いて、平均は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
E_{P}[f_{i}] \approx \sum_{x}\tilde{P}(x) \sum_{y} P(y|x) f_{i}(x,y)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とする。この近似を用いることで、&lt;span class="math"&gt;\(x\)&lt;/span&gt;については学習データに現れるものだけの和を取ればよく、また&lt;span class="math"&gt;\(y\)&lt;/span&gt;についても素性関数が非零の時のみ和を取れば良ため、計算の効率化が望める。&lt;/p&gt;
&lt;p&gt;平均だけでなく、正規化項&lt;span class="math"&gt;\(Z_{\Lambda}(x)\)&lt;/span&gt;の計算もボトルネックな部分であり、効率化が望まれる。そこで、文献 &lt;a class="footnote-reference" href="#footnote-5" id="footnote-reference-5"&gt;[5]&lt;/a&gt;  &lt;a class="footnote-reference" href="#footnote-6" id="footnote-reference-6"&gt;[6]&lt;/a&gt; による効率的な正規化項の計算手法を見ていく。まず、素性関数の集合&lt;span class="math"&gt;\({\cal F}\)&lt;/span&gt;を次の2つに分割する:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
{\cal F}_{m} &amp;amp;= \{ f_{i} | \forall{w,x,y} \ f_{i}(x,y) = f_{i}(w,y) \} \ \ \text{（周辺素性(marginalized feature)の集合）} \\
{\cal F}_{c} = {\cal F}_{m}^{c} &amp;amp;= \{ f_{i} | \exists{w,x,y} \ f_{i}(x,y) \neq f_{i}(w,y) \} \ \ \text{（条件付き素性(conditional feature)の集合）}
\end{align*}
&lt;/div&gt;
&lt;p&gt;周辺素性は&lt;span class="math"&gt;\(y\)&lt;/span&gt;の値のみによって決まる素性であり、&lt;span class="math"&gt;\(y\)&lt;/span&gt;の関数として捉えられる。集合演算の性質により、&lt;span class="math"&gt;\({\cal F}\_{m} \cap {\cal F}_{c} = \emptyset\)&lt;/span&gt;は自明に成り立つ。次に、&lt;span class="math"&gt;\(y\)&lt;/span&gt;の値域&lt;span class="math"&gt;\(Y\)&lt;/span&gt;についても次の分割を行う:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
Y_{m} &amp;amp;= \{ y | \exists f_{i} \in {\cal F}_{m} \ f_{i}(y) \neq 0 \} \ \ \text{（周辺素性が活性化される$Y$の要素）} \\
Y(x) &amp;amp;= \{ y | \exists f_{i} \in {\cal F}_{c} \ f_{i}(x,y) \neq 0 \} \ \ \text{（$x$を固定した時に,条件付き素性が活性化される$Y$の要素）}
\end{align*}
&lt;/div&gt;
&lt;p&gt;定義より&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
Y_{m}^{c} = \{ y | \forall{f_{i}} \in {\cal F}_{m} \ f_{i}(y) = 0 \}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（どの周辺素性に対しても活性化されない&lt;span class="math"&gt;\(Y\)&lt;/span&gt;の要素）は自明に成り立つ。また、一般には&lt;span class="math"&gt;\(Y_{m} \cap Y(x) \neq \emptyset\)&lt;/span&gt;である。即ち周辺素性と条件付き素性を同時に活性化させる&lt;span class="math"&gt;\(Y\)&lt;/span&gt;の要素は存在する。&lt;/p&gt;
&lt;p&gt;以上の集合分割を考慮しつつ、正規化項&lt;span class="math"&gt;\(Z_{\Lambda}(x) = \sum_{y}\exp\left[\sum_{i}\lambda_{i}f_{i}(x,y)\right]\)&lt;/span&gt;の計算を考えていくが、表記の簡略化の為、文献と同じように次の表記を用いる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
z(y|x) = \exp\left[ \sum_{i}\lambda_{i} f_{i}(x,y) \right] \ ,\ z(y) = \exp\left[ \sum_{f_{i} \in {\cal F}_{m}} \lambda_{i} f_{i}(y) \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;正規化項&lt;span class="math"&gt;\(Z_{\Lambda}(x)\)&lt;/span&gt;の計算式は次のように展開される。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
Z_{\Lambda}(x) &amp;amp;= \sum_{y \in Y}z(y|x) \\
&amp;amp;= \sum_{y \in Y_{m}^{c} \cap Y(x)^{c}} z(y|x) + \sum_{y \in Y_{m} \cap Y(x)^{c}} z(y|x) + \sum_{y \in Y(x)} z(y|x) \\
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
y \in Y(x)^{c} &amp;amp;\implies z(y|x) = z(y) \\
&amp;amp;\because z(y|x) = \exp\left[ \sum_{f_{i} \in {\cal F}_{m}} \lambda_{i} f_{i}(y) + \sum_{f_{i} \in {\cal F}_{c}} \lambda_{i} 0 \right] = \exp \left[ \sum_{f_{i} \in {\cal F}_{m}} \lambda_{i} f_{i}(y) \right] = z(y)
\end{align*}
&lt;/div&gt;
&lt;p&gt;が成立するので、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
Z_{\Lambda}(x) =  \sum_{y \in Y_{m}^{c} \cap Y(x)^{c}} z(y) + \sum_{y \in Y_{m} \cap Y(x)^{c}} z(y) +\sum_{y \in Y(x)} z(y|x)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となり、さらに集合の包含関係に注目すれば、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\sum_{y \in Y} z(y) &amp;amp;= \sum_{y \in Y_{m} \cap Y(x)^{c}} z(y) + \sum_{y \in Y_{m}^{c} \cap Y(x)^{c}} z(y) + \sum_{y \in Y(x)} z(y) \\
&amp;amp;= \sum_{y \in Y_{m}} z(y) + \sum_{y \in Y_{m}^{c}} z(y) \\
\therefore \sum_{y \in Y_{m} \cap Y(x)^{c}} z(y) + \sum_{y \in Y_{m}^{c} \cap Y(x)^{c}} z(y) &amp;amp;= \sum_{y \in Y_{m}} z(y) + \sum_{y \in Y_{m}^{c}} z(y) - \sum_{y \in Y(x)} z(y)
\end{align*}
&lt;/div&gt;
&lt;p&gt;が成立するので、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
Z_{\Lambda}(x) = \sum_{y \in Y_{m}^{c}} z(y) + \sum_{y \in Y_{m}} z(y) + \sum_{y \in Y(x)} \left\{ z(y|x) -z(y) \right\}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となり、更に&lt;span class="math"&gt;\(Y_{m}^{c}\)&lt;/span&gt;の要素の性質&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
y \in Y_{m}^{c} &amp;amp;\implies z(y) = 1 \\
&amp;amp;\because z(y) = \exp\left[ \sum_{f_{i} \in {\cal F}_{m}} \lambda 0 \right] = 1
\end{align*}
&lt;/div&gt;
&lt;p&gt;を用いて、次の最終結果を得る。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
Z_{\Lambda}(x) &amp;amp;= \sum_{y \in Y_{m}^{c}} 1 + \sum_{y \in Y_{m}} z(y) + \sum_{y \in Y(x)} \left\{ z(y|x) -z(y) \right\} \\
&amp;amp;= |Y-Y_{m}| + \sum_{y \in Y_{m}}z(y) + \sum_{y \in Y(x)} \left\{ z(y|x) -z(y) \right\}
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで&lt;span class="math"&gt;\(Y-Y_{m}=Y \cap Y_{m}^{c}\)&lt;/span&gt;は集合演算の意味での差である。この計算式は、第1項と第2項は予め計算しておくことができ、しかも第3項については&lt;span class="math"&gt;\(Y\)&lt;/span&gt;の部分集合&lt;span class="math"&gt;\(Y(x)\)&lt;/span&gt;の和を考えれば良い。結果、ナイーブな計算（計算量&lt;span class="math"&gt;\(O(|X||Y|)\)&lt;/span&gt;）を行うよりも効率的（計算量&lt;span class="math"&gt;\(O(|X||Y(x)|+|X|)\)&lt;/span&gt;）に計算を行うことができる。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-7"&gt;素性の自動選択&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;前節までは、最大エントロピーモデルの学習について考えてきたが、モデルの構成要素となる素性については触れてなかった。観測された経験確率分布&lt;span class="math"&gt;\(\tilde{P}(x,y)\)&lt;/span&gt;に対し、素性の組み合わせによって実現可能な最大尤度が異なり、従って尤度が最大になる素性集合&lt;span class="math"&gt;\({\cal F}\)&lt;/span&gt;を選び出さなければならない。&lt;/p&gt;
&lt;p&gt;しかし素性の候補となる集合&lt;span class="math"&gt;\({\cal F}_{0}\)&lt;/span&gt;は非常に大きくなる為に、網羅的に全ての素性の組み合わせを試していくのは現実的に不可能である。また、サンプルで出現頻度が高い素性を選択する手法も存在するが、これでは尤度を厳密に最大化できない。そこで、逐次的にモデルの尤度が増加する様に素性を追加する手法が基本的に用いられており、その手順の概要は以下の様になる。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;モデルの素性集合&lt;span class="math"&gt;\({\cal F}\)&lt;/span&gt;を空集合とする:
&lt;span class="math"&gt;\({\cal F} \leftarrow \emptyset\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;（反復スケーリング法等の学習手法によって）素性集合&lt;span class="math"&gt;\({\cal F}\)&lt;/span&gt;における最大尤度モデル&lt;span class="math"&gt;\(P_{\cal F}\)&lt;/span&gt;を得る。&lt;/li&gt;
&lt;li&gt;素性集合の候補&lt;span class="math"&gt;\({\cal F}\_{0}\)&lt;/span&gt;の各要素&lt;span class="math"&gt;\(f_{0} \in {\cal F}_{0}\)&lt;/span&gt;について、以下を行う。
1.
素性を加えたモデルを学習し&lt;span class="math"&gt;\(P_{{\cal F} \cup f_{0}}\)&lt;/span&gt;を得る。
2. 対数尤度の増分&lt;span class="math"&gt;\(\Delta L({\cal F}, f_{0})\)&lt;/span&gt;を計算する:
&lt;span class="math"&gt;\(\Delta L({\cal F}, f_{0}) \leftarrow L(P_{{\cal F} \cup f_{0}}) - L(P_{\cal F})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最大の増分&lt;span class="math"&gt;\(\Delta L({\cal F}, \hat{f})\)&lt;/span&gt;を与える&lt;span class="math"&gt;\(\hat{f} = \underset{f \in {\cal F}_{0}}{\rm argmax}\ \Delta L({\cal F}, f)\)&lt;/span&gt;を選び出し、素性集合に加える:
&lt;span class="math"&gt;\({\cal F} \leftarrow {\cal F} \cup \hat{f}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最大増分がある閾値以下になったら終了し、それ以外は2.に戻る。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;逐次的に計算が行える為に手続き的に実行しやすいものの、結局手順3,4において&lt;span class="math"&gt;\({\cal F}_{0}\)&lt;/span&gt;を走査しているので依然として膨大な計算量が必要になる。文献 &lt;a class="footnote-reference" href="#footnote-7" id="footnote-reference-7"&gt;[7]&lt;/a&gt;  &lt;a class="footnote-reference" href="#footnote-8" id="footnote-reference-8"&gt;[8]&lt;/a&gt; では対数尤度の増分を近似的に求める手法を述べているが、それでも本質的に計算量を削減できたとは言えず、効率的な素性選択の手法については研究の対象となっていた &lt;a class="footnote-reference" href="#footnote-9" id="footnote-reference-9"&gt;[9]&lt;/a&gt;  &lt;a class="footnote-reference" href="#footnote-10" id="footnote-reference-10"&gt;[10]&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;ここでは元の文献 &lt;a class="footnote-reference" href="#footnote-11" id="footnote-reference-11"&gt;[11]&lt;/a&gt;  &lt;a class="footnote-reference" href="#footnote-12" id="footnote-reference-12"&gt;[12]&lt;/a&gt; に述べられていた、増分の近似による手法を見ていく。近似の仮定としては、元のモデル&lt;span class="math"&gt;\(P_{\cal F}\)&lt;/span&gt;とそのパラメタ集合&lt;span class="math"&gt;\(\Lambda\)&lt;/span&gt;に&lt;span class="math"&gt;\(f \in {\cal F}\)&lt;/span&gt;とそれに付随するパラメタ&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;を加えたモデル&lt;span class="math"&gt;\(P_{{\cal F} \cup f}\)&lt;/span&gt;においても、最大尤度を与える元のパラメタ&lt;span class="math"&gt;\(\Lambda\)&lt;/span&gt;は変化しないというものである。実際には素性を加える事で最大尤度を与えるパラメタ&lt;span class="math"&gt;\(\Lambda\)&lt;/span&gt;は変化するが、この変化を無視することでモデル&lt;span class="math"&gt;\(P_{{\cal F} \cup f}\)&lt;/span&gt;の最大尤度&lt;span class="math"&gt;\(L(P_{{\cal F} \cup f})\)&lt;/span&gt;の計算を回避する。素性を追加することにより尤度は増えこそすれ減ることはないので（&lt;span class="math"&gt;\(\because\)&lt;/span&gt;経験分布に適合しない素性に対しては学習の結果&lt;span class="math"&gt;\(\alpha = 0\)&lt;/span&gt;となり、元のモデルと一致するので尤度増分は0）
、近似的増分を最大にする&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;を探索する問題に帰着される。&lt;/p&gt;
&lt;p&gt;仮定の下で、素性集合&lt;span class="math"&gt;\({\cal F} \cup f\)&lt;/span&gt;に対するモデル&lt;span class="math"&gt;\(P_{{\cal F} \cup f}^{\alpha}\)&lt;/span&gt;の確率分布は次の様に書ける。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
P_{ {\cal F} \cup f}^{\alpha}(y|x) &amp;amp;= \frac{1}{Z_{\alpha}(x)} P_{\cal F} (y|x) \exp \left[ \alpha f(x,y) \right] \\
Z_{\alpha}(x) &amp;amp;= \sum_{y} P_{\cal F}(y|x) \exp \left[ \alpha f(x,y) \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;対数尤度の近似的増分&lt;span class="math"&gt;\(G_{{\cal F} \cup f}(\alpha)\)&lt;/span&gt;は,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
G_{{\cal F} \cup f}(\alpha) &amp;amp;= L(P_{{\cal F}\cup f}^{\alpha}) - L(P_{\cal F}) \\
&amp;amp;= \sum_{x,y} \tilde{P}(x,y) \log P_{{\cal F} \cup f}^{\alpha}(x,y) - \sum_{x,y} \tilde{P}(x,y) \log P_{\cal F}(x,y) \\
&amp;amp;= \sum_{x,y} \tilde{P}(x,y) \left\{ \log P_{\cal F}(x,y) + \alpha f(x,y) - \log Z_{\alpha}(x) - \log P_{\cal F}(x,y) \right\} \\
&amp;amp;= \alpha \sum_{x,y} \tilde{P}(x,y) f(x,y) - \sum_{x} \log Z_{\alpha}(x) \sum_{y} \tilde{P}(x,y) \\
&amp;amp;= \alpha E_{\tilde{P}}[f] - \sum_{x} \tilde{P}(x) \log Z_{\alpha}(x)
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる、&lt;span class="math"&gt;\(G_{{\cal F} \cup f}(0) = 0\)&lt;/span&gt;は&lt;span class="math"&gt;\(Z_{0}(x) = 1\)&lt;/span&gt;より容易に確かめられる。増分最大化の為、偏微分&lt;span class="math"&gt;\(\frac{\partial G_{{\cal F} \cup f}}{\partial \alpha} = G_{{\cal F} \cup f}^{\prime}(\alpha)\)&lt;/span&gt;を計算すると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
G_{{\cal F} \cup f}^{\prime}(\alpha) &amp;amp;= E_{\tilde{P}}[f] - \sum_{x} P(x) \frac{\partial \log Z_{\alpha}(x)}{\partial \alpha} \\
&amp;amp;= E_{\tilde{P}}[f] - \sum_{x} \tilde{P}(x) \frac{1}{Z_{\alpha}(x)} \sum_{y} P_{\cal F}(y|x) \exp\left[ \alpha f(x,y) \right] f(x,y) \\
&amp;amp;= E_{\tilde{P}}[f] - \sum_{x} \tilde{P}(x) \sum_{y} P_{ {\cal F} \cup f}^{\alpha}(y|x) f(x,y)\ \  (= E_{\tilde{P}}[f] - E_{P_{ {\cal F} \cup f}}[f]) \\
&amp;amp;= E_{\tilde{P}}[f] - \sum_{x} \tilde{P}(x) Q_{ {\cal F} \cup f}^{\alpha} (f|x)
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、文献にもあるように&lt;span class="math"&gt;\(Q_{ {\cal F} \cup f}^{\alpha} (h|x) = \sum_{y} P_{ {\cal F} \cup f}^{\alpha}(y|x) h(x,y)\)&lt;/span&gt;（分布&lt;span class="math"&gt;\(P_{ {\cal F} \cup f}\)&lt;/span&gt;による、&lt;span class="math"&gt;\(h\)&lt;/span&gt;の&lt;span class="math"&gt;\(y\)&lt;/span&gt;における平均）とおいている。&lt;span class="math"&gt;\(G_{{\cal F} \cup f}^{\prime}(0)\)&lt;/span&gt;の値は&lt;span class="math"&gt;\(P_{ {\cal F} \cup f}^{0}(y|x) = P_{\cal F}(y|x)\)&lt;/span&gt;により&lt;span class="math"&gt;\(G_{{\cal F}\cup f}^{\prime}(0) = E_{\tilde{P}}[f] - E_{P_{\cal F}}[f]\)&lt;/span&gt;となる。更に2階微分&lt;span class="math"&gt;\(G_{{\cal F} \cup f}^{\prime \prime}(\alpha)\)&lt;/span&gt;を計算すると,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
G_{{\cal F} \cup f}^{\prime \prime}(\alpha) &amp;amp;= - \sum_{x} P(x) \frac{1}{Z_{\alpha}^{2}(x)} \left[ \left\{ \sum_{y} P_{\cal F}(y|x) \exp\left[ \alpha f(x,y) \right] f^{2}(x,y) \right\} Z_{\alpha}(x) \right. \\
&amp;amp;  \left. - \left\{ \sum_{y} P_{\cal F}(y|x)\exp\left[ \alpha f(x,y) \right] f(x,y) \right\}^{2} \right] \\
&amp;amp;= - \sum_{x} \tilde{P}(x) \left[ Q_{ {\cal F} \cup f}^{\alpha} (f^{2}|x) - \left\{Q_{ {\cal F} \cup f}^{\alpha}(f|x) \right\}^{2} \right] \\
&amp;amp;= - \sum_{x} \tilde{P}(x) Q_{ {\cal F} \cup f}^{\alpha} \left( (f - Q_{ {\cal F} \cup f}^{\alpha}(f|x))^{2} | x \right)
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで最下段の式変形には、分散と平均の関係&lt;span class="math"&gt;\(E[(X-E[X])^{2}] = E[X^{2}] - \{E[X]\}^{2}\)&lt;/span&gt;を用いている。&lt;span class="math"&gt;\((f - Q_{ {\cal F} \cup f}^{\alpha}(f|x))^{2} \geq 0\)&lt;/span&gt;より、&lt;span class="math"&gt;\(G_{{\cal F} \cup f}^{\prime \prime}(\alpha) \leq 0\)&lt;/span&gt;が成立し、&lt;span class="math"&gt;\(G_{{\cal F} \cup f}(\alpha)\)&lt;/span&gt;は上に凸な関数であり、極大値がそのまま大域的な最大値となる事が分かる。&lt;/p&gt;
&lt;p&gt;上述の議論により、&lt;span class="math"&gt;\(G_{{\cal F} \cup f}^{\prime}(\alpha^{\ast}) = 0\)&lt;/span&gt;を満たす&lt;span class="math"&gt;\(\alpha^{\ast}\)&lt;/span&gt;を得れば良いことになるが、解くべき式が&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;について閉じた形をしていない為、数値解析的な手法を用いることになる。文献 &lt;a class="footnote-reference" href="#footnote-13" id="footnote-reference-13"&gt;[13]&lt;/a&gt;  &lt;a class="footnote-reference" href="#footnote-14" id="footnote-reference-14"&gt;[14]&lt;/a&gt;  &lt;a class="footnote-reference" href="#footnote-15" id="footnote-reference-15"&gt;[15]&lt;/a&gt; によると、&lt;span class="math"&gt;\(G_{{\cal F} \cup f}^{\prime}(\alpha)\)&lt;/span&gt;は&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;に対して凸関数ではないが、&lt;span class="math"&gt;\(\exp(\alpha)\)&lt;/span&gt;に関しては下に凸の減少関数、かつ&lt;span class="math"&gt;\(\exp(-\alpha)\)&lt;/span&gt;に関しては上に凸の増加関数となる事が示されているので、&lt;span class="math"&gt;\(\exp(\alpha)、\exp(-\alpha)\)&lt;/span&gt;の数列に対してニュートン法を適用する事を考える。偏微分の連鎖律を用いることで,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{\partial G_{{\cal F} \cup f}^{\prime}(\alpha)}{\partial \exp(\alpha)}  &amp;amp;= \frac{\partial G_{{\cal F} \cup f}^{\prime}(\alpha)}{\partial \alpha} \frac{\partial \alpha}{\partial \exp(\alpha)} \\
&amp;amp;= \frac{\log t}{t} G_{{\cal F} \cup f}^{\prime \prime}(\alpha) \ \ (t = \exp(\alpha)) \\
&amp;amp;= \frac{1}{t} G_{{\cal F} \cup f}^{\prime \prime}(\alpha) = \exp(-\alpha) G_{{\cal F} \cup f}^{\prime \prime}(\alpha)
\end{align*}
&lt;/div&gt;
&lt;p&gt;が成り立つので、ニュートン法の更新則は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\exp(\alpha_{n+1}) &amp;amp;= \exp(\alpha_{n}) - \frac{G_{{\cal F} \cup f}^{\prime}(\alpha_{n})}{\frac{\partial G_{{\cal F} \cup f}^{\prime}(\alpha_{n})}{\partial \exp(\alpha_{n})}} = \exp(\alpha_{n}) \left[ 1 - \frac{G_{{\cal F} \cup f}^{\prime}(\alpha_{n})}{G_{{\cal F} \cup f}^{\prime\prime}(\alpha_{n})} \right] \\
\iff \alpha_{n+1} &amp;amp;= \alpha_{n} + \log \left[ 1 - \frac{G_{{\cal F} \cup f}^{\prime}(\alpha_{n})}{G_{{\cal F} \cup f}^{\prime\prime}(\alpha_{n})} \right] \\
\exp(-\alpha_{n+1}) &amp;amp;= \exp(-\alpha_{n}) - \frac{G_{{\cal F} \cup f}^{\prime}(\alpha_{n})}{\frac{\partial G_{{\cal F} \cup f}^{\prime}(\alpha_{n})}{\partial \exp(-\alpha_{n})}} = \exp(-\alpha_{n}) \left[ 1 + \frac{G_{{\cal F} \cup f}^{\prime}(\alpha_{n})}{G_{{\cal F} \cup f}^{\prime\prime}(\alpha_{n})} \right] \\
\iff \alpha_{n+1} &amp;amp;= \alpha_{n} - \log \left[ 1 + \frac{G_{{\cal F} \cup f}^{\prime}(\alpha_{n})}{G_{{\cal F} \cup f}^{\prime\prime}(\alpha_{n})} \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。最適値&lt;span class="math"&gt;\(\alpha^{\ast}\)&lt;/span&gt;が&lt;span class="math"&gt;\(\alpha^{\ast} &amp;gt; 0\)&lt;/span&gt;の場合（&lt;span class="math"&gt;\(E_{\tilde{P}}[f] &amp;gt; E_{P_{\cal F}}[f]\)&lt;/span&gt; &lt;a class="footnote-reference" href="#footnote-16" id="footnote-reference-16"&gt;[16]&lt;/a&gt; ）には上の更新式を用いれば良く、&lt;span class="math"&gt;\(\alpha^{\ast} &amp;lt; 0\)&lt;/span&gt;の場合（&lt;span class="math"&gt;\(E_{\tilde{P}}[f] &amp;lt; E_{P_{\cal F}}[f]\)&lt;/span&gt;）には下の更新式を用いれば良い。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-9"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-8"&gt;脚注・参考文献&lt;/a&gt;&lt;/h2&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;北研二、辻井潤一、&amp;quot;確率的言語モデル&amp;quot;、東京大学出版会、1999&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;高村大也、奥村学、&amp;quot;言語処理のための機械学習入門&amp;quot;、コロナ社、2010&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;高橋治久、堀田一弘、&amp;quot;学習理論&amp;quot; コロナ社、2009&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;高橋治久、堀田一弘、&amp;quot;学習理論&amp;quot; コロナ社、2009&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;北研二、辻井潤一、&amp;quot;確率的言語モデル&amp;quot;、東京大学出版会、1999&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Wu, Jun, and Sanjeev Khudanpur, “Efficient training methods for
maximum entropy language modeling.” INTERSPEECH. 2000.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-7"&gt;[7]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;北研二、辻井潤一、&amp;quot;確率的言語モデル&amp;quot;、東京大学出版会、1999&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-8"&gt;[8]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Berger, Adam L., Vincent J, Della Pietra, and Stephen A. Della
Pietra. “A maximum entropy approach to natural language processing.”
Computational linguistics 22.1 (1996): 39-71.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-9"&gt;[9]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Zhou, Yaqian, et al.&amp;nbsp;“A fast algorithm for feature selection in
conditional maximum entropy modeling.” Proceedings of the 2003
conference on Empirical methods in natural language processing.
Association for Computational Linguistics, 2003.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-10"&gt;[10]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;谷垣宏一, 渡邉圭輔, and 石川泰,
``最大エントロピー法による発話理解のための効率的モデル構築 (&amp;lt; 特集&amp;gt;
音声言語情報処理とその応用).’’ 情報処理学会論文誌 43.7 (2002):
2138-2146.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-11"&gt;[11]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;北研二、辻井潤一、&amp;quot;確率的言語モデル&amp;quot;、東京大学出版会、1999&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-12"&gt;[12]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Berger, Adam L., Vincent J, Della Pietra, and Stephen A. Della
Pietra. “A maximum entropy approach to natural language processing.”
Computational linguistics 22.1 (1996): 39-71.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-13" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-13"&gt;[13]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;北研二、辻井潤一、&amp;quot;確率的言語モデル&amp;quot;、東京大学出版会、1999&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-14" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-14"&gt;[14]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Berger, Adam L., Vincent J, Della Pietra, and Stephen A. Della
Pietra. “A maximum entropy approach to natural language processing.”
Computational linguistics 22.1 (1996): 39-71.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-15" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-15"&gt;[15]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Pietra, Stephen Della, Vincent Della Pietra, and John Lafferty.
“Inducing features of random fields.” Pattern Analysis and Machine
Intelligence、IEEE Transactions on 19.4 (1997): 380-393.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-16" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-16"&gt;[16]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;span class="math"&gt;\(G_{{\cal F} \cup f}^{\prime}(\alpha)\)&lt;/span&gt;は&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;に関して単調減少するので、&lt;span class="math"&gt;\(G_{{\cal F} \cup f}^{\prime}(0) = E_{\tilde{P}}[f] - E_{P_{\cal F}}[f]&amp;gt;0\)&lt;/span&gt;ならば、かつその時に限り最適値&lt;span class="math"&gt;\(\alpha^{\ast}\)&lt;/span&gt;は正の値をとる。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="記事"></category><category term="機械学習"></category></entry><entry><title>SVM（サポートベクトルマシン）</title><link href="/svmsapotobekutorumashin.html" rel="alternate"></link><published>2020-04-23T12:30:00+09:00</published><updated>2020-04-23T12:30:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-23:/svmsapotobekutorumashin.html</id><summary type="html">&lt;p class="first last"&gt;SVMの導入のところまで。SVRも一応。カーネル法に関しては触れるだけ。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;strong&gt;SVM(Support Vector Machine,
サポートベクトルマシン)&lt;/strong&gt;は、深層学習の影に隠れがちではあるものの、現在使われている識別学習モデルの中でも比較的認識性能が優れ、実用に供される事はもちろん、様々な研究でも比較対象となる手法の一つである。&lt;/p&gt;
&lt;p&gt;SVMの大雑把な理論的概要を述べると、SVMは与えられた学習サンプルを最も適切に分離（識別）する境界面（&lt;strong&gt;識別面&lt;/strong&gt;）を発見する手法である。その識別面は凸計画問題に帰着して求める事ができるので、どの様なサンプルにおいても（存在するならば）最適な識別面を構成できる。&lt;/p&gt;
&lt;p&gt;本稿では、最初に基本となる線形SVMの定式化を行い、次に汎用性をより高めた非線形SVMとソフトマージンSVMを説明し、最後にSVMを回帰問題に適用したSVR(Support
Vector Regression,
サポートベクトル回帰)を説明する。最後にC言語による実装例を挙げる。&lt;/p&gt;
&lt;p&gt;SVMも知り尽くされており、文献・資料は大量に存在する。ここでは、参考書籍 &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;, &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt; を挙げる。&lt;/p&gt;
&lt;div class="contents local topic" id="topic-1"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#svm-1" id="toc-entry-1"&gt;線形SVM&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-1" id="toc-entry-2"&gt;マージンの定式化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-2" id="toc-entry-3"&gt;マージン最大化&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#kkt" id="toc-entry-4"&gt;KKT条件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#svm-2" id="toc-entry-5"&gt;非線形SVM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#svm-3" id="toc-entry-6"&gt;ソフトマージンSVM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#svr-support-vector-regression" id="toc-entry-7"&gt;SVR（Support Vector Regression, サポートベクトル回帰）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#svr" id="toc-entry-8"&gt;1ノルムSVR・双対問題の導出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#svr-2" id="toc-entry-9"&gt;2ノルムSVR・双対問題の導出&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-3" id="toc-entry-10"&gt;実装の例&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-4" id="toc-entry-11"&gt;学習&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-5" id="toc-entry-12"&gt;学習則の導出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-6" id="toc-entry-13"&gt;実装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-7" id="toc-entry-14"&gt;制約条件の考慮&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-8" id="toc-entry-15"&gt;正例と負例の双対係数の和を等しくする&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-9" id="toc-entry-16"&gt;双対係数は非負&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-10" id="toc-entry-17"&gt;識別&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-11" id="toc-entry-18"&gt;脚注&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="svm-1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-1"&gt;線形SVM&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-2"&gt;マージンの定式化&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;識別の例として、まずは図にあるような、2次元空間&lt;span class="math"&gt;\(X\times Z\)&lt;/span&gt;に存在する2クラスのサンプルデータ（以下サンプル）を仮定する。各クラスは二値のラベル付け&lt;span class="math"&gt;\(y=\{-1, 1\}\)&lt;/span&gt;がなされており、識別面（2次元空間では直線）&lt;span class="math"&gt;\(ax+bz+c=0\)&lt;/span&gt;の上半領域（&lt;span class="math"&gt;\(ax+bz+c&amp;gt;0\)&lt;/span&gt;）にラベル&lt;span class="math"&gt;\(y=1\)&lt;/span&gt;のサンプルが、下半領域（&lt;span class="math"&gt;\(ax+bz+c&amp;lt;0\)&lt;/span&gt;）にラベル&lt;span class="math"&gt;\(y=-1\)&lt;/span&gt;のサンプルが分布するようにする。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="2クラス分離の例" src="./images/2class_separation.png" /&gt;
&lt;p class="caption"&gt;2クラス分離の例&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;更に、&lt;span class="math"&gt;\(n\)&lt;/span&gt;次元空間の元（ベクトル）&lt;span class="math"&gt;\(\boldsymbol{x} \in \mathbb{R}^{n}\)&lt;/span&gt;で表されるサンプルに対しても一般化でき、&lt;span class="math"&gt;\(n\)&lt;/span&gt;次元の係数ベクトル&lt;span class="math"&gt;\(\boldsymbol{w} \in \mathbb{R}^{n}\)&lt;/span&gt;を用いることで、
識別面は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \boldsymbol{w}^{\mathsf{T}}\boldsymbol{x} + b = 0
 \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表現できる。ここで&lt;span class="math"&gt;\(b \in \mathbb{R}\)&lt;/span&gt;は切片（しきい値、
バイアス）である。&lt;/p&gt;
&lt;p&gt;概要でも述べたとおり、識別面は異なるラベルが付いたサンプルを互いに分離さえできていれば良いので、識別面の候補は無限に存在してしまう（上の2次元の例でも明らかである）。しかし、
その全てが適切な識別面とは限らない。
SVMでは、次の2点を最適な識別面の条件とする。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;各クラスの、最も識別面に近いサンプル（&lt;strong&gt;サポートベクトル&lt;/strong&gt;）までの距離を最大にする。&lt;/li&gt;
&lt;li&gt;また、 その距離を各クラスで同一にする。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この2点を満たす識別面ならば、
丁度クラス間の中心を区切ることが出来、適切な識別面といえる。
また、図に示す様に、サポートベクトル間の距離を&lt;strong&gt;マージン&lt;/strong&gt;（余白）という。
SVMは、このマージンを最大化することが目的となる。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="マージン" src="./images/margin.png" /&gt;
&lt;p class="caption"&gt;マージン&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;それでは、
マージンの定式化を考える。&lt;span class="math"&gt;\(n\)&lt;/span&gt;次元空間上に&lt;span class="math"&gt;\(N\)&lt;/span&gt;個存在するサンプルを&lt;span class="math"&gt;\(\boldsymbol{x}\_{i} \in \mathbb{R}^{n} \ (i=1, \dots, N)\)&lt;/span&gt;と書き、またそのデータに対応する二値ラベルを&lt;span class="math"&gt;\(y_{i} \in \{-1, 1\}\ (i=1, \dots, N)\)&lt;/span&gt;とかく。全てのサンプルが正しく識別されている時には、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  y_{i}(\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{i} + b) \geq 0 \quad (i = 1, \dots, N)
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が明らかに成立する。
そして、異なる2クラスのサポートベクトル&lt;span class="math"&gt;\(\boldsymbol{x}\_{s}, \boldsymbol{x}\_{t}\)&lt;/span&gt;が&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{s} + b = l , \quad \boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{t} + b = -l\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成立すると仮定する &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt; と（&lt;span class="math"&gt;\(l&amp;gt;0\)&lt;/span&gt;）、
&lt;span class="math"&gt;\(\boldsymbol{x}\_{s}\)&lt;/span&gt;と&lt;span class="math"&gt;\(\boldsymbol{x}\_{t}\)&lt;/span&gt;の、識別面に対して平行な距離がマージンとして計算できる。マージンを&lt;span class="math"&gt;\(\gamma\)&lt;/span&gt;と書くと、
平面の単位法ベクトルは&lt;span class="math"&gt;\(\boldsymbol{w}/||\boldsymbol{w}||\)&lt;/span&gt;（&lt;span class="math"&gt;\(||\boldsymbol{w}|| = \sqrt{\boldsymbol{w}^{\mathsf{T}}\boldsymbol{w}}\)&lt;/span&gt;）で与えられるので、マージンは&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  &amp;amp;  \boldsymbol{w}^{\mathsf{T}}(\boldsymbol{x}_{t} + \gamma \frac{\boldsymbol{w}}{||\boldsymbol{w}||}) + b = \boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{s} + b \nonumber \\
  &amp;amp;\iff \gamma \frac{\boldsymbol{w}^{\mathsf{T}}\boldsymbol{w}}{||\boldsymbol{w}||} = \gamma ||\boldsymbol{w}|| = (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{s}+b) - (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{t}+b) = 2l \nonumber \\
  &amp;amp;\therefore \gamma = \frac{2l}{||\boldsymbol{w}||}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;で求められる。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-3"&gt;マージン最大化&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;前節でも既に述べたが、
SVMの目的はマージン&lt;span class="math"&gt;\(\gamma\)&lt;/span&gt;を最大化することである。単純には&lt;span class="math"&gt;\(\max \gamma\)&lt;/span&gt;と書けるが、
最適化を行いやすくするため、&lt;span class="math"&gt;\(1/\gamma\)&lt;/span&gt;の最小化に置き換え、
&lt;span class="math"&gt;\(l\)&lt;/span&gt;は最適化に関与しないので&lt;span class="math"&gt;\(l=1\)&lt;/span&gt;とし、更に&lt;span class="math"&gt;\(||\boldsymbol{w}||\)&lt;/span&gt;が最小化された時は&lt;span class="math"&gt;\(\boldsymbol{w}^{\mathsf{T}}\boldsymbol{w}\)&lt;/span&gt;も最小化されるので、考えるべき最適化問題は次のように書ける:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  &amp;amp; \max_{\scriptsize \boldsymbol{w}} \gamma = \frac{2l}{||\boldsymbol{w}||} \quad \text{subject to : } y_{i}(\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{i} + b) \geq l \nonumber \\
  &amp;amp;\implies \min_{\scriptsize \boldsymbol{w}} \frac{1}{2} \boldsymbol{w}^{\mathsf{T}}\boldsymbol{w} \quad \text{subject to : } y_{i}(\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{i} + b) \geq 1 \quad (i=1, \dots, N)\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この最適化問題は、 凸計画問題 &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt; であり、不等式制約付き非線形計画問題なので、 KKT条件(Karush-Kuhn-Tucker
condition)を用いる。KKT条件はラグランジェの未定乗数法（等式制約）の一般化であり、次の定理で表される:&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="kkt"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-4"&gt;KKT条件&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\boldsymbol{v}^{\star}\)&lt;/span&gt;を&lt;span class="math"&gt;\(f(\boldsymbol{v})\)&lt;/span&gt;に関しての最適化問題の最適解とするならば、次の条件を満たす最適重みベクトル&lt;span class="math"&gt;\(\boldsymbol{\alpha}^{\star}=[\alpha_{1}^{\star}, \cdots, \alpha_{N}^{\star}]^{\mathsf{T}}\ (\alpha_{i} \geq 0)\)&lt;/span&gt;が存在する。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
      \left\{
        \begin{array}{ll}
          \displaystyle\frac{\partial{\cal L}(\boldsymbol{v}^{\star}, \boldsymbol{\alpha}^{\star})}{\partial \boldsymbol{v}} &amp;amp;=  0 \\
          \boldsymbol{\alpha}^{\star\mathsf{T}}\boldsymbol{g}(\boldsymbol{v}^{\star}) &amp;amp;= 0
        \end{array}
        \right.
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで&lt;span class="math"&gt;\(\boldsymbol{g}(\boldsymbol{v})\)&lt;/span&gt;は制約条件式&lt;span class="math"&gt;\(\boldsymbol{g}(\boldsymbol{v}) = [g_{1}(\boldsymbol{v}), \cdots, g_{N}(\boldsymbol{v})]^{\mathsf{T}}\)&lt;/span&gt;,
&lt;span class="math"&gt;\({\cal L}\)&lt;/span&gt;はラグランジアン（ラグランジェ関数）であり以下の様に表される。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
        g_{i}(\boldsymbol{v}) &amp;amp;\geq 0\ \ (i = 1, \dots, N) \\
        {\cal L}(\boldsymbol{v}, \boldsymbol{\alpha}) &amp;amp;= f(\boldsymbol{v}) + \boldsymbol{\alpha}^{\mathsf{T}}\boldsymbol{g}(\boldsymbol{v})
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\({\cal L}\)&lt;/span&gt;が凸関数ならば、最適点&lt;span class="math"&gt;\((\boldsymbol{v}^{\star}, \boldsymbol{\alpha}^{\star})\)&lt;/span&gt;は鞍点にあり、&lt;span class="math"&gt;\(\displaystyle\max_{\scriptsize \boldsymbol{v}} {\cal L}(\boldsymbol{v}, \boldsymbol{\alpha}^{\star})\)&lt;/span&gt;を主問題とする時、&lt;span class="math"&gt;\(\displaystyle\min_{\scriptsize \boldsymbol{\alpha}}{\cal L}(\boldsymbol{v}^{\star}, \boldsymbol{\alpha})\)&lt;/span&gt;を主問題に対する双対問題という。 &lt;a class="footnote-reference" href="#footnote-5" id="footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;それでは実際にKKT条件を適用し、最適化問題を主問題(式)から双対問題へ変換する事を考える。
まず制約条件から&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  g_{i}(\boldsymbol{w}) = 1 - y_{i} (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{i} + b) \leq 0\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（最小化を考えているので、
符号が逆転している事に注意）より、ラグランジアンは、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  {\cal L}(\boldsymbol{w}, \boldsymbol{\alpha}) &amp;amp;=  \frac{1}{2} \boldsymbol{w}^{\mathsf{T}}\boldsymbol{w} + \boldsymbol{\alpha}^{\mathsf{T}}\boldsymbol{g}(\boldsymbol{w})  \\
  &amp;amp;= \frac{1}{2} \boldsymbol{w}^{\mathsf{T}}\boldsymbol{w} + \sum_{i=1}^{N}\alpha_{i} \{ 1 - y_{i}(\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{i} + b) \}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表現でき、
&lt;span class="math"&gt;\({\cal L}(\boldsymbol{w}, \boldsymbol{\alpha})\)&lt;/span&gt;の&lt;span class="math"&gt;\(\boldsymbol{w}, b\)&lt;/span&gt;による偏微分は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \frac{\partial {\cal L}(\boldsymbol{w}, \boldsymbol{\alpha})}{\partial \boldsymbol{w}} = \boldsymbol{w} - \sum_{i=1}^{N} \alpha_{i}y_{i}\boldsymbol{x}_{i}, \quad \frac{\partial {\cal L}(\boldsymbol{w}, \boldsymbol{\alpha})}{\partial b} = \sum_{i=1}^{N}\alpha_{i}y_{i}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる。&lt;span class="math"&gt;\(\displaystyle\frac{\partial {\cal L}(\boldsymbol{w}^{\star}, \boldsymbol{\alpha})}{\partial \boldsymbol{w}} = \boldsymbol{0}\)&lt;/span&gt;とおくことで最適時の係数&lt;span class="math"&gt;\(\boldsymbol{w}^{\star}\)&lt;/span&gt;が求まる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \boldsymbol{w}^{\star} = \sum_{i=1}^{N} \alpha_{i}y_{i}\boldsymbol{x}_{i}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;また、&lt;span class="math"&gt;\(\displaystyle\frac{\partial {\cal L}(\boldsymbol{w}^{\star}, \boldsymbol{\alpha})}{\partial b} = 0\)&lt;/span&gt;により双対変数&lt;span class="math"&gt;\(\boldsymbol{\alpha}\)&lt;/span&gt;の制約条件が得られる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \sum_{i=1}^{N} \alpha_{i}y_{i} = 0\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これらの関係式をラグランジアンに代入することで、 双対問題式を得る:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  {\cal L}(\boldsymbol{w}^{\star}、 \boldsymbol{\alpha}) &amp;amp;= \frac{1}{2} \boldsymbol{w}^{\star\mathsf{T}}\boldsymbol{w}^{\star} + \boldsymbol{\alpha}^{\mathsf{T}} \boldsymbol{g}(\boldsymbol{w}^{\star}) \\
  &amp;amp;= \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}\boldsymbol{x}_{j}^{\mathsf{T}}\boldsymbol{x}_{i} + \sum_{i=1}^{N} \alpha_{i} \left\{ 1 - y_{i} \left( \sum_{j=1}^{N}\alpha_{j}y_{j}\boldsymbol{x}_{j}^{\mathsf{T}} \boldsymbol{x}_{i} + b \right) \right\} \\
  &amp;amp;= \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}\boldsymbol{x}_{i}^{\mathsf{T}}\boldsymbol{x}_{j} + \sum_{i=1}^{N} \alpha_{i} - b\sum_{i=1}^{N} \alpha_{i} y_{i} - \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}\boldsymbol{x}_{i}^{\mathsf{T}} \boldsymbol{x}_{j} \\
  &amp;amp;= \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}\boldsymbol{x}_{i}^{\mathsf{T}}\boldsymbol{x}_{j}\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（途中の式変形において、内積の対称性（&lt;span class="math"&gt;\(\boldsymbol{x}^{\mathsf{T}}\_{j}\boldsymbol{x}\_{i} = \boldsymbol{x}^{\mathsf{T}}\_{i}\boldsymbol{x}\_{j}\)&lt;/span&gt;）を用いている。）よって、
双対問題は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  &amp;amp; \max_{\scriptsize \boldsymbol{\alpha}} \left[ \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}\boldsymbol{x}_{i}^{\mathsf{T}}\boldsymbol{x}_{j} \right] \\
  &amp;amp; \text{subject to : } \alpha_{i} \geq 0, \ \sum_{i=1}^{N} \alpha_{i}y_{i} = 0 \quad (i = 1, \dots, N) \nonumber\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表現できる。双対問題は非負制約&lt;span class="math"&gt;\(\alpha_{i} \geq 0\)&lt;/span&gt;の中で&lt;span class="math"&gt;\(\boldsymbol{\alpha}\)&lt;/span&gt;を動かし、その最大値を得れば良いので、
主問題を直接解くよりも容易に、数値最適化によって解を求める（学習する）ことができる。実際の実装については後に述べる。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="svm-2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-5"&gt;非線形SVM&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;前節までの議論は、入力データと同じ空間（次元）で適切な識別面を発見するSVMであり、これを特に&lt;strong&gt;線形SVM&lt;/strong&gt;という。
線形SVMの場合、識別面は入力データ空間の次元&lt;span class="math"&gt;\(n\)&lt;/span&gt;に対し&lt;span class="math"&gt;\(n-1\)&lt;/span&gt;次元の平面（&lt;strong&gt;超平面&lt;/strong&gt;）であり（例:2次元空間では直線、3次元空間では平面）、図の様に、異なるクラスのサンプルが入り組んだ状態では識別面を構成できない（&lt;strong&gt;線形分離不可能&lt;/strong&gt;）。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="線形分離不可能な例" src="./images/linearly_unseparatable.png" /&gt;
&lt;p class="caption"&gt;線形分離不可能な例&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;この場合、入力データの空間&lt;span class="math"&gt;\(\mathbb{R}^{n}\)&lt;/span&gt;から高次元空間&lt;span class="math"&gt;\(\mathbb{R}^{h}\)&lt;/span&gt;(&lt;span class="math"&gt;\(h \gg n\)&lt;/span&gt;)への高次元な非線形写像（&lt;strong&gt;特徴写像&lt;/strong&gt;）&lt;span class="math"&gt;\(\boldsymbol{\phi} : \mathbb{R}^{n} \to \mathbb{R}^{h}\)&lt;/span&gt;を用いて高次元空間（特徴空間）へ写像すれば、線形分離不可能だったサンプルを一般位置 &lt;a class="footnote-reference" href="#footnote-6" id="footnote-reference-6"&gt;[6]&lt;/a&gt; に写し、識別面を構成できる（線形分離可能）ようになる（図参照）。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="特徴空間で線形分離可能になる例" src="./images/linearly_separatable_in_high_dimension.png" /&gt;
&lt;p class="caption"&gt;特徴空間で線形分離可能になる例&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;図では、入力空間は1次元（数直線）、
特徴空間は2次元（平面）である。入力空間で線形分離不可能なサンプルが、
特徴写像によって一般位置に写され、線形分離可能になっている。&lt;/p&gt;
&lt;p&gt;この様に、
入力データ次元で線形分離不可能なサンプルを、特徴写像によって写して識別面を構成し、元の次元に戻すSVMを&lt;strong&gt;非線形SVM&lt;/strong&gt;という。
この場合、識別面は曲がった形状を持つ（超曲面）。&lt;/p&gt;
&lt;p&gt;それでは非線形SVMの定式化を見ていく。特徴写像を用いてサンプルを写像することで、高次元空間内のサンプル（特徴サンプル）&lt;span class="math"&gt;\(\boldsymbol{\phi}(\boldsymbol{x}_{i})\ (i =1, \dots, N)\)&lt;/span&gt;が得られる。後は線形SVMの時と全く同様の議論を適用し、
双対問題は次の様に表現される:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  &amp;amp;\max_{\scriptsize \boldsymbol{\alpha}} \left[ \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}\boldsymbol{\phi}(\boldsymbol{x}_{i})^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}_{j}) \right] \\
  &amp;amp;\text{subject to : } \alpha_{i} \geq 0,\ \sum_{i=1}^{N} \alpha_{i}y_{i} = 0 \quad (i = 1, \dots, N) \nonumber\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;さて、 この様にして非線形SVMが実現できるが、
一般に、入力次元&lt;span class="math"&gt;\(n\)&lt;/span&gt;はもとより特徴空間の次元&lt;span class="math"&gt;\(h\)&lt;/span&gt;は非常に大きくなる（&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;次元にすらなりうる）。特徴写像&lt;span class="math"&gt;\(\boldsymbol{\phi}\)&lt;/span&gt;を構成する&lt;span class="math"&gt;\(h\)&lt;/span&gt;個の非線形な基底を用意するのは、非常に困難であり、
実用上大変な不便が生じる。
そこで、特徴写像同士の内積&lt;span class="math"&gt;\(\boldsymbol{\phi}(\boldsymbol{x}\_{i})^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}\_{j})\)&lt;/span&gt;の計算結果はノルムなので、その内積を計算するのではなく、
天下り的に、最初から内積値を与えてしまうやり方がある。 即ち、
特徴写像同士の内積値を、 &lt;strong&gt;カーネル関数&lt;/strong&gt;
&lt;span class="math"&gt;\(K : \mathbb{R}^{n} \times \mathbb{R}^{n} \to \mathbb{R}\)&lt;/span&gt;で定める:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) = \langle \boldsymbol{\phi}(\boldsymbol{x}_{i}), \boldsymbol{\phi}(\boldsymbol{x}_{j}) \rangle = \boldsymbol{\phi}(\boldsymbol{x}_{i})^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}_{j})\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで&lt;span class="math"&gt;\(K\)&lt;/span&gt;は入力データのみで記述されるので、特徴写像はカーネル関数の中に閉じ込められてしまい、
陽に現れない。
即ち、特徴写像を構成する必要がないというのが大きなメリットである。任意の関数がカーネルになるとは限らず、
マーサーの定理 &lt;a class="footnote-reference" href="#footnote-7" id="footnote-reference-7"&gt;[7]&lt;/a&gt; という条件をカーネル関数は満たす必要がある。代表的なカーネル関数を以下に挙げる:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;線形カーネル:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) = \langle \boldsymbol{x}_{i}, \boldsymbol{x}_{j} \rangle
        \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;入力次元における標準内積もカーネルとなり、 線形カーネルと呼ばれる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ガウシアン（Radial Basis Function、 RBF:放射基底関数）カーネル:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) = \exp\left(-\frac{||\boldsymbol{x}_{i}-\boldsymbol{x}_{j}||^{2}}{2\sigma^{2}}\right)
        \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;分散パラメタ&lt;span class="math"&gt;\(\sigma\)&lt;/span&gt;を伴ってガウス関数に従った分布を示す。実用上よく用いられる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;多項式カーネル:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) = (\langle \boldsymbol{x}_{i}, \boldsymbol{x}_{j} \rangle + c)^{k}
        \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;正定数&lt;span class="math"&gt;\(c\)&lt;/span&gt;と多項式の次数&lt;span class="math"&gt;\(k\)&lt;/span&gt;によって構成されるカーネルである。ガウシアンカーネルよりも性能がパラメタに依存しない特徴を持つ。&lt;/p&gt;
&lt;p&gt;カーネル関数&lt;span class="math"&gt;\(K\)&lt;/span&gt;を用いる事で、
非線形SVMの双対問題は次で表される:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  &amp;amp;\max_{\scriptsize \boldsymbol{\alpha}} \left[ \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}K(\boldsymbol{x}_{i}、 \boldsymbol{x}_{j}) \right] \\
  &amp;amp;\text{subject to : } \alpha_{i} \geq 0、\ \sum_{i=1}^{N} \alpha_{i}y_{i} = 0 \quad (i = 1, \dots, N) \nonumber\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="svm-3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-6"&gt;ソフトマージンSVM&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;前節までのSVMは、
マージンの内部にサンプルが入る事を一切許さないので、これを特に&lt;strong&gt;ハードマージンSVM&lt;/strong&gt;ということがある。カーネルを用いた非線形ハードマージンSVMは、線形分離不可能なサンプルにでも強引に曲がりくねった識別面を構成する。これは実用に供する場合に問題になることがある。
例えば、データに雑音が乗っていたり、
一部のラベルを付け間違えたりする場合であり、これらは実データを扱う場合、
往々にして起こりうる事である。この様な雑音を拾いすぎてしまうとSVMの汎化性能 &lt;a class="footnote-reference" href="#footnote-8" id="footnote-reference-8"&gt;[8]&lt;/a&gt; が悪化してしまうので、マージンの制約を緩め、一部のサンプルはマージンの内部に入っても良いようにSVMを改善する事を考える。マージンの内部にサンプルが入ることを許すSVMを&lt;strong&gt;ソフトマージンSVM&lt;/strong&gt;と呼ぶことがある。&lt;/p&gt;
&lt;p&gt;ハードマージンSVMの制約を緩める事を考える。サンプル&lt;span class="math"&gt;\(\boldsymbol{x}\_{i}\)&lt;/span&gt;に対応するスラック（緩衝）変数&lt;span class="math"&gt;\(\eta_{i} \geq 0\ (i=1, \dots, N)\)&lt;/span&gt;を用意して、
SVMの制約を&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  y_{i}(\boldsymbol{w}^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}\_{i}) + b) \geq 1 - \eta_{i} \quad (i = 1, \dots, N)\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とする（最初から、サンプルは特徴写像&lt;span class="math"&gt;\(\boldsymbol{\phi}\)&lt;/span&gt;によって写像されている場合を考える）。スラック変数はサンプルがマージンに食い込んでいる距離を表しており、もちろん、
&lt;span class="math"&gt;\(\eta_{i}\)&lt;/span&gt;は小さい方が良く、&lt;span class="math"&gt;\(\eta_{i} = 0\)&lt;/span&gt;の時はハードマージンに一致する。
そして、&lt;span class="math"&gt;\(\eta_{i}\)&lt;/span&gt;も同時に最適化に組み込んでしまう事で、ソフトマージンSVMが実現できる。
多くの文献では、スラック変数のノルムの取り方で異なる2種類のソフトマージンSVMの式を提示している:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;1ノルムソフトマージンSVM・主問題&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          &amp;amp; \min_{\scriptsize \boldsymbol{w}} \frac{1}{2} \boldsymbol{w}^{\mathsf{T}}\boldsymbol{w} + C_{1}\sum_{i=1}^{N} \eta_{i} \\ &amp;amp; \text{subject to : } y_{i}(\boldsymbol{w}^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}_{i}) + b) \geq 1 - \eta_{i}, \ \eta_{i} \geq 0 \quad (i=1, \dots, N)
        \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple" id="svm-1-1"&gt;
&lt;li&gt;2ノルムソフトマージンSVM・主問題&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          &amp;amp;\min_{\scriptsize \boldsymbol{w}} \frac{1}{2} \boldsymbol{w}^{\mathsf{T}}\boldsymbol{w} + \frac{C_{2}}{2}\sum_{i=1}^{N} \eta_{i}^{2} \quad \\ &amp;amp;\text{subject to : } y_{i}(\boldsymbol{w}^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}_{i}) + b) \geq 1 - \eta_{i} \quad (i=1, \dots, N)
        \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで、
&lt;span class="math"&gt;\(C_{1}, C_{2}\)&lt;/span&gt;はハードマージンとソフトマージンのトレードオフを与える定数 &lt;a class="footnote-reference" href="#footnote-9" id="footnote-reference-9"&gt;[9]&lt;/a&gt; で、最適な値は実験等によって求める必要がある。
双対問題の導出は、前節までの議論と同様に、
KKT条件に当てはめる事により得られる:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;1ノルムソフトマージンSVM・双対問題の導出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ラグランジアンは、
&lt;span class="math"&gt;\(\beta_{i} \geq 0\)&lt;/span&gt;なる双対変数を導入して、&lt;span class="math"&gt;\(-\beta_{i}\eta_{i} \leq 0\)&lt;/span&gt;より、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
      {\cal L}(\boldsymbol{w}, \boldsymbol{\eta}, \boldsymbol{\alpha}, \boldsymbol{\beta}) = \frac{1}{2} \boldsymbol{w}^{\mathsf{T}} \boldsymbol{w} + C_{1} \sum_{i=1}^{N}\eta_{i} + \sum_{i=1}^{N} \alpha_{i} \left\{ 1 - \eta_{i} - y_{i}(\boldsymbol{w}^{\mathsf{T}} \boldsymbol{\phi}(\boldsymbol{x}_{i}) + b) \right\} + \sum_{i=1}^{N}(-\beta_{i}\eta_{i})
    \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;より、&lt;span class="math"&gt;\({\cal L}(\boldsymbol{w}, \boldsymbol{\eta}, \boldsymbol{\alpha}, \boldsymbol{\beta})\)&lt;/span&gt;の&lt;span class="math"&gt;\(\boldsymbol{w}, b, \eta_{i},\)&lt;/span&gt;による偏微分&lt;span class="math"&gt;\(\displaystyle\frac{\partial \cal L}{\partial \boldsymbol{w}}, \frac{\partial \cal L}{\partial b}, \frac{\partial \cal L}{\partial \eta_{i}}\)&lt;/span&gt;は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
      \frac{\partial \cal L}{\partial \boldsymbol{w}} = \boldsymbol{w} - \sum_{i=1}^{N} y_{i} \alpha_{i} \boldsymbol{\phi}(\boldsymbol{x}_{i}), \quad \frac{\partial \cal L}{\partial b} = \sum_{i=1}^{N}\alpha_{i}y_{i}, \quad \frac{\partial \cal L}{\partial \eta_{i}} = C_{1} - \alpha_{i} - \beta_{i}
    \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\displaystyle\frac{\partial \cal L}{\partial \boldsymbol{w}} = \boldsymbol{0}, \frac{\partial \cal L}{\partial \eta_{i}} = 0\)&lt;/span&gt;とおくことで、最適時パラメタは、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          \boldsymbol{w}^{\star} = \sum_{i=1}^{N} y_{i} \alpha_{i} \boldsymbol{\phi}(\boldsymbol{x}_{i}), \quad C_{1} = \alpha_{i} + \beta_{i}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\boldsymbol{w}^{\star}\)&lt;/span&gt;をラグランジアンに代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          {\cal L}(\boldsymbol{w}^{\star}, \boldsymbol{\eta}^{\star}、 \boldsymbol{\alpha}、 \boldsymbol{\beta}) &amp;amp;= \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) + \sum_{i=1}^{N} (C_{1} - \alpha_{i} - \beta_{i}) \eta_{i} \\
          &amp;amp;= \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j})
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;制約条件&lt;span class="math"&gt;\(\alpha_{i}, \beta_{i} \geq 0\)&lt;/span&gt;を含めて考えると、&lt;span class="math"&gt;\(\beta_{i} = C_{1} - \alpha_{i} \geq 0\)&lt;/span&gt;より、&lt;span class="math"&gt;\(\alpha_{i}\)&lt;/span&gt;についての制約&lt;span class="math"&gt;\(0 \leq \alpha_{i} \leq C_{1}\)&lt;/span&gt;が得られ、結局、普通のSVMの双対問題に&lt;span class="math"&gt;\(\alpha_{i}\)&lt;/span&gt;についての制約を加えるだけで、1ノルムソフトマージンSVMが実現できる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;1ノルムソフトマージンSVM・双対問題&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
      &amp;amp;\max_{\scriptsize \boldsymbol{\alpha}} \left[ \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) \right] \\
      &amp;amp;\text{subject to : } 0 \leq \alpha_{i} \leq C_{1}, \ \sum_{i=1}^{N} \alpha_{i}y_{i} = 0 \quad (i = 1, \dots, N) \nonumber\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple" id="svm-1-2"&gt;
&lt;li&gt;2ノルムソフトマージンSVM・双対問題の導出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ラグランジアンは、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          {\cal L}(\boldsymbol{w}, \boldsymbol{\eta}, \boldsymbol{\alpha}) = \frac{1}{2} \boldsymbol{w}^{\mathsf{T}} \boldsymbol{w} + \frac{C_{2}}{2} \sum_{i=1}^{N}\eta_{i}^{2} + \sum_{i=1}^{N} \alpha_{i} \left\{ 1 - \eta_{i} - y_{i}(\boldsymbol{w}^{\mathsf{T}} \boldsymbol{\phi}(\boldsymbol{x}_{i}) + b) \right\}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;より、&lt;span class="math"&gt;\({\cal L}(\boldsymbol{w}, \boldsymbol{\eta}, \boldsymbol{\alpha})\)&lt;/span&gt;の&lt;span class="math"&gt;\(\boldsymbol{w}, b, \eta_{i}\)&lt;/span&gt;による偏微分&lt;span class="math"&gt;\(\displaystyle\frac{\partial \cal L}{\partial \boldsymbol{w}}, \frac{\partial \cal L}{\partial b}, \frac{\partial \cal L}{\partial \eta_{i}}\)&lt;/span&gt;は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          \frac{\partial \cal L}{\partial \boldsymbol{w}} = \boldsymbol{w} - \sum_{i=1}^{N} y_{i} \alpha_{i} \boldsymbol{\phi}(\boldsymbol{x}_{i}), \quad \frac{\partial \cal L}{\partial b} = \sum_{i=1}^{N}\alpha_{i}y_{i}, \quad \frac{\partial \cal L}{\partial \eta_{i}} = C_{2}\eta_{i} - \alpha_{i}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\displaystyle\frac{\partial \cal L}{\partial \boldsymbol{w}} = \boldsymbol{0}, \frac{\partial \cal L}{\partial \eta_{i}} = 0\)&lt;/span&gt;とおくことで、最適時パラメタは、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          \boldsymbol{w}^{\star} = \sum_{i=1}^{N} y_{i} \alpha_{i} \boldsymbol{\phi}(\boldsymbol{x}_{i}), \quad \eta_{i}^{\star} = \frac{\alpha_{i}}{C_{2}}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これをラグランジアンに代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          {\cal L}(\boldsymbol{w}^{\star}, \boldsymbol{\eta}^{\star}, \boldsymbol{\alpha}) &amp;amp;= \sum_{i=1}^{N} \alpha_{i} + \frac{1}{2C_{2}} \sum_{i=1}^{N} \alpha_{i}^{2} + \sum_{i=1}^{N} \alpha_{i} \left[ - \frac{\alpha_{i}}{C_{2}} - y_{i} \sum_{j=1}^{N} y_{j}\alpha_{j} K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) \right] + \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) \\
          &amp;amp;= \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2C_{2}} \sum_{i=1}^{N} \alpha_{i}^{2} - \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j})
        \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで&lt;span class="math"&gt;\(y_{i}y_{j} \in \{-1, 1\}\)&lt;/span&gt;に注目すれば、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          {\cal L}(\boldsymbol{w}^{\star}, \boldsymbol{\eta}^{\star}, \boldsymbol{\alpha}) = \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}\left( K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) + \frac{1}{C_{2}}\delta_{ij} \right)
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と整理できる。ここで&lt;span class="math"&gt;\(\delta_{ij}\)&lt;/span&gt;はディラックのデルタであり、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          \delta_{ij} =
          \left\{
            \begin{array}{ll}
              1 &amp;amp; i = j \\
              0 &amp;amp; otherwise
            \end{array}
            \right.
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たす。 2ノルムソフトマージンSVMも、
結局、カーネル関数を簡単に書き換える事で実現できる。&lt;/p&gt;
&lt;ul class="simple" id="svm-1-3"&gt;
&lt;li&gt;2ノルムソフトマージンSVM・双対問題&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
            &amp;amp;\max_{\scriptsize \boldsymbol{\alpha}} \left[ \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}\left(K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) + \frac{1}{C_{2}}\delta_{ij} \right) \right] \\
            &amp;amp;\text{subject to : } \alpha_{i} \geq 0, \ \sum_{i=1}^{N} \alpha_{i}y_{i} = 0 \quad (i = 1,\dots,N) \nonumber
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="svr-support-vector-regression"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-7"&gt;SVR（Support Vector Regression, サポートベクトル回帰）&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一般にSVMは識別器として用いられる事がほとんどだが、ラベルを実数とした回帰問題 &lt;a class="footnote-reference" href="#footnote-10" id="footnote-reference-10"&gt;[10]&lt;/a&gt; にも適用することができる。SVMによる回帰モデルのことを、
&lt;strong&gt;SVR&lt;/strong&gt;（Support Vector Regression, サポートベクトル回帰）という。
基本的な考え方としては、図の様に、識別面（回帰面）を中心に幅&lt;span class="math"&gt;\(2\varepsilon\)&lt;/span&gt;の“帯”に多くのサンプルが入るようにすれば良い。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="SVR" src="./images/svr.png" /&gt;
&lt;p class="caption"&gt;SVR&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;帯を考慮して制約を表現すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  | y_{i} - (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}_{i})+b) | \leq \varepsilon \quad (i = 1, \dots, N)
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる。
これはハードマージン的な制約であり、幅&lt;span class="math"&gt;\(2\varepsilon\)&lt;/span&gt;の帯に全てのサンプルが入る事を要求している。もちろん&lt;span class="math"&gt;\(\varepsilon\)&lt;/span&gt;を十分に大きくとれば全てのサンプルは帯に入るが、帯が広すぎるために自由度が大きく、
結果汎化性能の悪化に繋がってしまう。ラベルが実数となり、
雑音の影響をより受けやすくなることから、SVRにおいては、
最初からスラック変数を用いて、ソフトマージン的に定式化することが多い。&lt;/p&gt;
&lt;p&gt;スラック変数を用いて、帯から飛び出た距離&lt;span class="math"&gt;\(\eta_{i}^{+}, \eta_{i}^{-} \geq 0\)&lt;/span&gt;を次で定義する（図参照）:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\begin{aligned}
  \eta_{i}^{+} =
  \left\{ \begin{array}{ll}
    y_{i} - \varepsilon - (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}_{i})+b) &amp;amp; y_{i} \geq (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}_{i})+b) + \varepsilon \\
    0 &amp;amp; otherwise
    \end{array} \right.
  \\
  \eta_{i}^{-} =
  \left\{ \begin{array}{ll}
    (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}_{i})+b) - y_{i} - \varepsilon &amp;amp; y_{i} \leq (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}_{i})+b) - \varepsilon \\
    0 &amp;amp; otherwise
    \end{array} \right.
\end{aligned}
\end{align*}
&lt;/div&gt;
&lt;p&gt;なお、サンプルは帯からどちらか一方にしか飛び出ないので、&lt;span class="math"&gt;\(\eta_{i}^{+}, \eta_{i}^{-}\)&lt;/span&gt;のいずれか一方は必ず&lt;span class="math"&gt;\(0\)&lt;/span&gt;となり、サンプルが帯に収まっている時は両方共&lt;span class="math"&gt;\(0\)&lt;/span&gt;となる。スラック変数を用いる事で、
制約は次のように表現できる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \left\{ \begin{array}{l}
    (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}_{i})+b) - y_{i} \leq \varepsilon + \eta_{i}^{-} \\
    y_{i} - (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}_{i})+b) \leq \varepsilon + \eta_{i}^{+}
  \end{array} \right.
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ソフトマージンの時と同様に考える事で、 最適化問題が定式化できる:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;1ノルムSVR・主問題&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          &amp;amp;\min_{\scriptsize \boldsymbol{w}} \frac{1}{2} \boldsymbol{w}^{\mathsf{T}}\boldsymbol{w} + C_{1}\sum_{i=1}^{N} (\eta_{i}^{+} + \eta_{i}^{-}) \\
          &amp;amp;\text{subject to : } (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{i} + b) - y_{i} \leq \varepsilon + \eta_{i}^{-}, \ y_{i} - (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{i} + b) \leq \varepsilon + \eta_{i}^{+} \quad (i=1,\dots,N)
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple" id="svr-1"&gt;
&lt;li&gt;2ノルムSVR・主問題&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          &amp;amp;\min_{\scriptsize \boldsymbol{w}} \frac{1}{2} \boldsymbol{w}^{\mathsf{T}}\boldsymbol{w} + \frac{C_{2}}{2}\sum_{i=1}^{N} \left\{ (\eta_{i}^{+})^{2} + (\eta_{i}^{-})^{2} \right\} \\
          &amp;amp;\text{subject to : } (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{i} + b) - y_{i} \leq \varepsilon + \eta_{i}^{-}, \ y_{i} - (\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}_{i} + b) \leq \varepsilon + \eta_{i}^{+} \quad (i=1, \dots, N)
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;後はKKT条件にぶち込むだけの流れ作業である。よし、じゃあぶち込んでやるぜ！&lt;/p&gt;
&lt;div class="section" id="svr"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-8"&gt;1ノルムSVR・双対問題の導出&lt;/a&gt;&lt;/h3&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          \begin{split}
            &amp;amp;{\cal L}(\boldsymbol{w}, \boldsymbol{\eta}^{+}, \boldsymbol{\eta}^{-}, \boldsymbol{\alpha}^{+}, \boldsymbol{\alpha}^{-}, \boldsymbol{\beta}^{+}, \boldsymbol{\beta}^{-}) = \\
          &amp;amp;\frac{1}{2} \boldsymbol{w}^{\mathsf{T}} \boldsymbol{w} + C_{1} \sum_{i=1}^{N}(\eta_{i}^{+}+\eta_{i}^{-}) + \sum_{i=1}^{N}(-\beta_{i}^{+}\eta_{i}^{+} -\beta_{i}^{-}\eta_{i}^{-} ) \\
          &amp;amp;+ \sum_{i=1}^{N} \left[ \alpha_{i}^{-} \left\{ (\boldsymbol{w}^{\mathsf{T}} \boldsymbol{\phi}(\boldsymbol{x}_{i}) + b) - y_{i} - \varepsilon - \eta_{i}^{-} \right\} + \alpha_{i}^{+} \left\{ y_{i} - (\boldsymbol{w}^{\mathsf{T}} \boldsymbol{\phi}(\boldsymbol{x}_{i}) + b) - \varepsilon - \eta_{i}^{+} \right\} \right]
          \end{split}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;より、&lt;span class="math"&gt;\({\cal L}(\boldsymbol{w}, \boldsymbol{\eta}^{+}, \boldsymbol{\eta}^{-}, \boldsymbol{\alpha}^{+}, \boldsymbol{\alpha}^{-}, \boldsymbol{\beta}^{+}, \boldsymbol{\beta}^{-})\)&lt;/span&gt;の&lt;span class="math"&gt;\(\boldsymbol{w}, b, \eta_{i}^{+}, \eta_{i}^{-}\)&lt;/span&gt;による偏微分&lt;span class="math"&gt;\(\displaystyle\frac{\partial \cal L}{\partial \boldsymbol{w}}, \frac{\partial \cal L}{\partial b}, \frac{\partial \cal L}{\partial \eta_{i}^{+}}, \frac{\partial \cal L}{\partial \eta_{i}^{-}}\)&lt;/span&gt;は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          \frac{\partial \cal L}{\partial \boldsymbol{w}} = \boldsymbol{w} + \sum_{i=1}^{N}(\alpha_{i}^{-} - \alpha_{i}^{+}) \boldsymbol{\phi}(\boldsymbol{x}_{i}), \quad \frac{\partial \cal L}{\partial b} = \sum_{i=1}^{N}(\alpha_{i}^{-} - \alpha_{i}^{+}) \\
          \frac{\partial \cal L}{\partial \eta_{i}^{+}} = C_{1} - \alpha_{i}^{+} - \beta_{i}^{+}, \quad \frac{\partial \cal L}{\partial \eta_{i}^{-}} = C_{1} - \alpha_{i}^{-} - \beta_{i}^{-}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;それぞれ&lt;span class="math"&gt;\(0\)&lt;/span&gt;とおくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          \boldsymbol{w}^{\star} = \sum_{i=1}^{N} (\alpha_{i}^{+} - \alpha_{i}^{-}) \boldsymbol{\phi}(\boldsymbol{x}_{i}), \quad \sum_{i=1}^{N}(\alpha_{i}^{-} - \alpha_{i}^{+}) = 0, \quad C_{1} = \alpha_{i}^{+} + \beta_{i}^{+} = \alpha_{i}^{-} + \beta_{i}^{-}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これをラグランジアンに代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          \begin{split}
            &amp;amp;{\cal L}(\boldsymbol{w}^{\star}, \boldsymbol{\eta}^{+\star}, \boldsymbol{\eta}^{-\star}, \boldsymbol{\alpha}^{+}, \boldsymbol{\alpha}^{-}, \boldsymbol{\beta}^{+}, \boldsymbol{\beta}^{-}) = \\
            &amp;amp;\frac{1}{2} \sum_{i、j=1}^{N} (\alpha_{i}^{+} - \alpha_{i}^{-})(\alpha_{j}^{+} - \alpha_{j}^{-})K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) + C_{1} \sum_{i=1}^{N}(\eta_{i}^{+}+\eta_{i}^{-}) - \sum_{i=1}^{N}(\beta_{i}^{+}\eta_{i}^{+} + \beta_{i}^{-}\eta_{i}^{-}) \\
            &amp;amp;+\sum_{i=1}^{N} \left[ \alpha_{i}^{-}\sum_{j=1}^{N}(\alpha_{j}^{+}-\alpha_{j}^{-})K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) - \alpha_{i}^{+}\sum_{j=1}^{N}(\alpha_{j}^{+}-\alpha_{j}^{-})K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) \right] \\
            &amp;amp;+\sum_{i=1}^{N}\left[ \alpha_{i}^{-} (-\varepsilon-\eta_{i}^{-}-y_{i}) + \alpha_{i}^{+} (-\varepsilon-\eta_{i}^{+}+y_{i}) \right]
          \end{split}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(C_{1} = \alpha_{i}^{+} + \beta_{i}^{+} = \alpha_{i}^{-} + \beta_{i}^{-}\)&lt;/span&gt;を用いて整理すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          \begin{split}
            &amp;amp;{\cal L}(\boldsymbol{w}^{\star}, \boldsymbol{\eta}^{+\star}, \boldsymbol{\eta}^{-\star}, \boldsymbol{\alpha}^{+}, \boldsymbol{\alpha}^{-}, \boldsymbol{\beta}^{+}, \boldsymbol{\beta}^{-}) = \\
            &amp;amp;\sum_{i=1}^{N}(\alpha_{i}^{+}-\alpha_{i}^{-}) - \varepsilon\sum_{i=1}^{N}(\alpha_{i}^{-}+\alpha_{i}^{+}) - \frac{1}{2} \sum_{i、j=1}^{N} (\alpha_{i}^{+} - \alpha_{i}^{-})(\alpha_{j}^{+} - \alpha_{j}^{-})K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j})
          \end{split}
        \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ところで、上でも既に述べたが&lt;span class="math"&gt;\(\eta_{i}^{+}, \eta_{i}^{-}\)&lt;/span&gt;のどちらか一方は必ず&lt;span class="math"&gt;\(0\)&lt;/span&gt;となるので、その場合は対応する&lt;span class="math"&gt;\(\alpha_{i}^{+}, \alpha_{i}^{-}\)&lt;/span&gt;の制約条件はなくなり、従って、
&lt;span class="math"&gt;\(\alpha_{i}^{+}, \alpha_{i}^{-}\)&lt;/span&gt;のどちらか一方も&lt;span class="math"&gt;\(0\)&lt;/span&gt;となる。この事から&lt;span class="math"&gt;\(\alpha_{i} = \alpha_{i}^{+} - \alpha_{i}^{-}\)&lt;/span&gt;とおけば、&lt;span class="math"&gt;\(\alpha_{i}^{-} + \alpha_{i}^{+} = |\alpha_{i}|\)&lt;/span&gt;と表現できるので、双対問題は以下の様に表現できる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;1ノルムSVR・双対問題&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          &amp;amp;\max_{\scriptsize \boldsymbol{\alpha}} \left[ \sum_{i=1}^{N}y_{i}\alpha_{i} - \varepsilon\sum_{i=1}^{N}|\alpha_{i}| - \frac{1}{2} \sum_{i、j=1}^{N}\alpha_{i}\alpha_{j}K(\boldsymbol{x}_{i}、 \boldsymbol{x}_{j}) \right] \\
          &amp;amp;\text{subject to : } \sum_{i=1}^{N}\alpha_{i} = 0, \ -C_{1} \leq \alpha_{i} \leq C_{1} \quad (i = 1、\dots、N) \nonumber
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="svr-2"&gt;
&lt;span id="svr-1-1"&gt;&lt;/span&gt;&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-9"&gt;2ノルムSVR・双対問題の導出&lt;/a&gt;&lt;/h3&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
            &amp;amp;{\cal L}(\boldsymbol{w}, \boldsymbol{\eta}^{+}, \boldsymbol{\eta}^{-}, \boldsymbol{\alpha}^{+}, \boldsymbol{\alpha}^{-}) = \\
            &amp;amp;\frac{1}{2} \boldsymbol{w}^{\mathsf{T}} \boldsymbol{w} + \frac{C_{2}}{2} \sum_{i=1}^{N} \{ (\eta_{i}^{+})^{2} + (\eta_{i}^{-})^{2} \} \\
            &amp;amp;+\sum_{i=1}^{N} \left[ \alpha_{i}^{-} \left\{ (\boldsymbol{w}^{\mathsf{T}} \boldsymbol{\phi}(\boldsymbol{x}_{i}) + b) - y_{i} - \varepsilon - \eta_{i}^{-} \right\} + \alpha_{i}^{+} \left\{ y_{i} - (\boldsymbol{w}^{\mathsf{T}} \boldsymbol{\phi}(\boldsymbol{x}_{i}) + b) - \varepsilon - \eta_{i}^{+} \right\} \right]
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;より、&lt;span class="math"&gt;\({\cal L}(\boldsymbol{w}, \boldsymbol{\eta}^{+}, \boldsymbol{\eta}^{-}, \boldsymbol{\alpha}^{+}, \boldsymbol{\alpha}^{-})\)&lt;/span&gt;の&lt;span class="math"&gt;\(\boldsymbol{w}, b, \eta_{i}^{+}, \eta_{i}^{-}\)&lt;/span&gt;による偏微分&lt;span class="math"&gt;\(\displaystyle\frac{\partial \cal L}{\partial \boldsymbol{w}}, \frac{\partial \cal L}{\partial b}, \frac{\partial \cal L}{\partial \eta_{i}^{+}}, \frac{\partial \cal L}{\partial \eta_{i}^{-}}\)&lt;/span&gt;は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          \frac{\partial \cal L}{\partial \boldsymbol{w}} = \boldsymbol{w} + \sum_{i=1}^{N}(\alpha_{i}^{-} - \alpha_{i}^{+}) \boldsymbol{\phi}(\boldsymbol{x}_{i}), \quad \frac{\partial \cal L}{\partial b} = \sum_{i=1}^{N}(\alpha_{i}^{-} - \alpha_{i}^{+}) \\
          \frac{\partial \cal L}{\partial \eta_{i}^{+}} = C_{2}\eta_{i}^{+} - \alpha_{i}^{+}, \quad \frac{\partial \cal L}{\partial \eta_{i}^{-}} = C_{2}\eta_{i}^{-} - \alpha_{i}^{-}
        \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;それぞれ&lt;span class="math"&gt;\(0\)&lt;/span&gt;とおくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          \boldsymbol{w}^{\star} = \sum_{i=1}^{N} (\alpha_{i}^{+} - \alpha_{i}^{-}) \boldsymbol{\phi}(\boldsymbol{x}_{i}), \quad \sum_{i=1}^{N}(\alpha_{i}^{-} - \alpha_{i}^{+}) = 0, \quad \eta_{i}^{+\star} = \frac{\alpha_{i}^{+}}{C_{2}}, \quad \eta_{i}^{-\star} = \frac{\alpha_{i}^{-}}{C_{2}}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\boldsymbol{w}^{\star}\)&lt;/span&gt;をラグランジアンに代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          \begin{split}
            &amp;amp;{\cal L}(\boldsymbol{w}^{\star}, \boldsymbol{\eta}^{+\star}, \boldsymbol{\eta}^{-\star}, \boldsymbol{\alpha}^{+},\boldsymbol{\alpha}^{-}) = \\
            &amp;amp;\frac{1}{2} \sum_{i、j=1}^{N} (\alpha_{i}^{+} - \alpha_{i}^{-})(\alpha_{j}^{+} - \alpha_{j}^{-})K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) + \frac{1}{C_{2}} \sum_{i=1}^{N}\left\{ (\alpha_{i}^{+})^{2}+(\alpha_{i}^{-})^{2} \right\} \\
            &amp;amp;+\sum_{i=1}^{N} \left[ \alpha_{i}^{-}\sum_{j=1}^{N}(\alpha_{j}^{+}-\alpha_{j}^{-})K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) - \alpha_{i}^{+}\sum_{j=1}^{N}(\alpha_{j}^{+}-\alpha_{j}^{-})K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) \right] \\
            &amp;amp;+\sum_{i=1}^{N}\left[ \alpha_{i}^{-} (-\varepsilon - \frac{\alpha_{i}^{-}}{C_{2}} - y_{i}) + \alpha_{i}^{+} (- \varepsilon - \frac{\alpha_{i}^{+}}{C_{2}} +y_{i}) \right] \\
            &amp;amp;=\sum_{i=1}^{N} (\alpha_{i}^{+} - \alpha_{i}^{-})y_{i} - \frac{1}{2} \sum_{i、j=1}^{N}(\alpha_{i}^{+}-\alpha_{i}^{-})(\alpha_{j}^{+}-\alpha_{j}^{-})K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) \\
            &amp;amp;-\varepsilon\sum_{i=1}^{N}(\alpha_{i}^{-} + \alpha_{i}^{+}) - \frac{1}{2C_{2}}\sum_{i=1}^{N}\left\{ (\alpha_{i}^{-})^{2} + (\alpha_{i}^{+})^{2} \right\}
          \end{split}
        \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;1ノルムSVRの時と同様に、&lt;span class="math"&gt;\(\alpha_{i} = \alpha_{i}^{+} - \alpha_{i}^{-}\)&lt;/span&gt;とおくと、&lt;span class="math"&gt;\((\alpha_{i}^{+})^{2} + (\alpha_{i}^{-})^{2} = \alpha_{i}^{2}\)&lt;/span&gt;が成り立つので、双対問題は以下の様に表現できる。&lt;/p&gt;
&lt;ul class="simple" id="svr-1-2"&gt;
&lt;li&gt;2ノルムSVR・双対問題&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
          &amp;amp; \max_{\scriptsize \boldsymbol{\alpha}} \left[ \sum_{i=1}^{N}y_{i}\alpha_{i} - \varepsilon\sum_{i=1}^{N}|\alpha_{i}| - \frac{1}{2} \sum_{i, j=1}^{N}\alpha_{i}\alpha_{j}\left( K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) + \frac{1}{C_{2}} \right) \right] \\
          &amp;amp; \text{subject to : } \sum_{i=1}^{N}\alpha_{i} = 0 \quad (i = 1, \dots, N) \nonumber
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-10"&gt;実装の例&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;実装例は &lt;a class="reference external" href="https://github.com/MrAiki/SimpleSVM"&gt;ここ&lt;/a&gt;
にある。本稿では要点を絞って見ていく。&lt;/p&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-11"&gt;学習&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-12"&gt;学習則の導出&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;SVMの学習は、双対問題&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  &amp;amp;\max_{\scriptsize \boldsymbol{\alpha}} \left[ \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2} \sum_{i、j=1}^{N} \alpha_{i}\alpha_{j}y_{i}y_{j}\boldsymbol{\phi}(\boldsymbol{x}_{i})^{\mathsf{T}}\boldsymbol{\phi}(\boldsymbol{x}_{j}) \right] = \max_{\scriptsize \boldsymbol{\alpha}} {\cal L}(\boldsymbol{w}^{\star}, \boldsymbol{\alpha}) \\
  &amp;amp;\text{subject to : } \alpha_{i} \geq 0,\ \sum_{i=1}^{N} \alpha_{i}y_{i} = 0 \quad (i = 1, \dots, N)
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を解けば良いことになる。
脚注 &lt;a class="footnote-reference" href="#footnote-11" id="footnote-reference-11"&gt;[11]&lt;/a&gt; で既に触れたが、SVMのマージン最大化は凸計画問題である。従って局所最適解が存在せず、極大値が大域的な最大値に一致する。
ソフトマージンに対応する時は、1ノルムソフトマージンの際には係数に値域&lt;span class="math"&gt;\(0 \geq \alpha_{i} \geq C_{1}\ (i=1,...,N)\)&lt;/span&gt;を設け、2ノルムの際にはカーネル関数&lt;span class="math"&gt;\(K\)&lt;/span&gt;を次のように書き換えれば良い：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
K'(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) = K(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}) + \frac{\delta_{ij}}{C_{2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここでは簡単な&lt;strong&gt;最急勾配法&lt;/strong&gt;によって解を求めることを考える。
最急勾配法の原理は単純である。&lt;span class="math"&gt;\(F(\boldsymbol{\alpha}) = {\cal L}(\boldsymbol{w}^{\star}, \boldsymbol{\alpha})\)&lt;/span&gt;
とおくと、その&lt;span class="math"&gt;\(\boldsymbol{\alpha}\)&lt;/span&gt;による偏微分&lt;span class="math"&gt;\(\frac{\partial F(\boldsymbol{\alpha})}{\partial \boldsymbol{\alpha}}\)&lt;/span&gt;は&lt;strong&gt;勾配&lt;/strong&gt;、即ち&lt;span class="math"&gt;\(F(\boldsymbol{\alpha})\)&lt;/span&gt;の最も上昇する方向を指すベクトルとなるので、係数の更新量&lt;span class="math"&gt;\(\Delta\boldsymbol{\alpha}\)&lt;/span&gt;は学習率&lt;span class="math"&gt;\(\eta &amp;gt; 0\)&lt;/span&gt;を用いて&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\Delta \boldsymbol{\alpha} = \eta \frac{\partial F(\boldsymbol{\alpha})}{\partial \boldsymbol{\alpha}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とすれば良い &lt;a class="footnote-reference" href="#footnote-12" id="footnote-reference-12"&gt;[12]&lt;/a&gt; 。学習の収束判定は、例えば&lt;span class="math"&gt;\(||\Delta \boldsymbol{\alpha}||\)&lt;/span&gt;が十分小さくなった時とすれば良く、その時は極大値が得られている。
実際に&lt;span class="math"&gt;\(\frac{\partial F(\boldsymbol{\alpha})}{\partial \boldsymbol{\alpha}}\)&lt;/span&gt;を計算することを考える。&lt;span class="math"&gt;\(\frac{\partial F(\boldsymbol{\alpha})}{\partial \alpha_{i}}\ (i=1,...,N)\)&lt;/span&gt;は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
\frac{\partial F(\boldsymbol{\alpha})}{\partial \alpha_{i}} &amp;amp;= 1 - \frac{1}{2} \frac{\partial}{\partial \alpha_{i}} \left( \alpha_{1} \alpha_{1} y_{1} y_{1} \boldsymbol{x}_{1}^{\mathsf{T}} \boldsymbol{x}_{1} + ... + \alpha_{i} \alpha_{1} y_{i} y_{1} \boldsymbol{x}_{i}^{\mathsf{T}} \boldsymbol{x}_{1} + ... + \alpha_{i} \alpha_{N} y_{i} y_{N} \boldsymbol{x}_{i}^{\mathsf{T}} \boldsymbol{x}_{N} + ... + \alpha_{1} \alpha_{i} y_{1} y_{i} \boldsymbol{x}_{1}^{\mathsf{T}} \boldsymbol{x}_{i} + ... + \alpha_{N} \alpha_{i} y_{N} y_{i} \boldsymbol{x}_{N}^{\mathsf{T}} \boldsymbol{x}_{i} + ... + \alpha_{N} \alpha_{N} y_{N} y_{N} \boldsymbol{x}_{N}^{\mathsf{T}} \boldsymbol{x}_{N} \right) \\
    &amp;amp;= 1 - \sum_{j=1}^{N} \alpha_{j} y_{i} y_{j} \boldsymbol{x}_{i}^{\mathsf{T}} \boldsymbol{x}_{j}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;よって、ステップ&lt;span class="math"&gt;\(t\)&lt;/span&gt;時の係数&lt;span class="math"&gt;\(\alpha_{i}(t)\ (i=1,...,N)\)&lt;/span&gt;について以下の更新規則に従って学習を行えば良い：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\alpha_{i}(t+1) = \alpha_{i}(t) + \eta \left( 1 - \sum_{j=1}^{N} \alpha_{j} y_{i} y_{j} \boldsymbol{x}_{i}^{\mathsf{T}} \boldsymbol{x}_{j} \right)
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-13"&gt;実装&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;学習を行っている箇所を抜粋すると次の様になる：&lt;/p&gt;
&lt;pre class="code c literal-block"&gt;
&lt;span class="cm"&gt;/* 勾配値の計算 */&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="n"&gt;diff_dist&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i_x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="n"&gt;diff_sum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i_y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="cm"&gt;/* C2を踏まえたカーネル関数値を計算 */&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="n"&gt;kernel_val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GRAM_MATRIX_AT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;gram_matrix&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
      &lt;/span&gt;&lt;span class="n"&gt;kernel_val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;soft_margin_C2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="n"&gt;diff_sum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_y&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_label&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_y&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;kernel_val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="n"&gt;diff_sum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_label&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_x&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="n"&gt;diff_dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;diff_sum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="n"&gt;diff_dist&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;diff_sum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;diff_sum&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;

&lt;/span&gt;&lt;span class="cm"&gt;/* 双対係数の更新 */&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_label&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="cm"&gt;/* printf(&amp;quot;dual_coef[%d]:%f -&amp;gt; &amp;quot;, i_sample, handle-&amp;gt;dual_coef[i_sample]); */&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;learning_rate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;diff_dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SMPSVM_MOMENT_RATE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pre_diff_dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="cm"&gt;/* printf(&amp;quot;%f \n&amp;quot;, handle-&amp;gt;dual_coef[i_sample]); */&lt;/span&gt;&lt;span class="w"&gt;

  &lt;/span&gt;&lt;span class="cm"&gt;/* 非数,無限チェック */&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;isnan&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;isinf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Detected NaN or Inf Dual-Coffience. &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;既にコメントが付いているが、特筆すべき点について補足する。&lt;/p&gt;
&lt;pre class="code c literal-block"&gt;
&lt;span class="cm"&gt;/* C2を踏まえたカーネル関数値を計算 */&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="n"&gt;kernel_val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GRAM_MATRIX_AT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;gram_matrix&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;予め計算しておいたカーネル関数値をグラム行列から取り出している。学習中は何度もカーネル関数値を計算するため、グラム行列を用意しておくことで若干高速化できる。&lt;/p&gt;
&lt;pre class="code c literal-block"&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="n"&gt;kernel_val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;soft_margin_C2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;2ノルムソフトマージンのカーネル関数値を加味している。2ノルムソフトマージンを使用しない場合は&lt;tt class="docutils literal"&gt;soft_margin_C2 == FLT_MAX&lt;/tt&gt;となっているため、無視できる。&lt;/p&gt;
&lt;pre class="code c literal-block"&gt;
&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;learning_rate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;diff_dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SMPSVM_MOMENT_RATE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pre_diff_dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;係数更新を行っている。ここでは、単純な最急勾配分のみだけではなく、前回の勾配値に定数を乗じて加えた&lt;strong&gt;モーメント法&lt;/strong&gt;を使用している。一般にモーメント法を使用したほうが学習が早くなることが知られている。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-14"&gt;制約条件の考慮&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;学習則は単純に見えても実装時に落とし穴になるのが制約条件である。&lt;/p&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-15"&gt;正例と負例の双対係数の和を等しくする&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;KKT条件から導かれる&lt;span class="math"&gt;\(\boldsymbol{\alpha}\)&lt;/span&gt;についての制約&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\sum_{i=1}^{N} \alpha_{i}y_{i} = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を実現するのが案外難しい。上の制約から、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  &amp;amp;\sum_{y_{i}=1} \alpha_{i} - \sum_{y_{i}=-1} \alpha_{i} = 0  \\
  &amp;amp;\iff \sum_{y_{i}=1} \alpha_{i} = \sum_{y_{i}=-1} \alpha_{i}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が導かれるため、正例と負例の双対係数の和は等しくなる事が分かる。
本実装では、&lt;span class="math"&gt;\(\alpha_{i}y_{i}\)&lt;/span&gt;の平均を取り、全係数&lt;span class="math"&gt;\(\alpha_{i}\ (i=1,...,N)\)&lt;/span&gt;をその平均に寄せることで上記の制約を満たすように係数を修正している。&lt;/p&gt;
&lt;pre class="code c literal-block"&gt;
&lt;span class="cm"&gt;/* 制約1: 正例と負例の双対係数和を等しくする. */&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="n"&gt;dual_coef_average&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="n"&gt;dual_coef_average&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_label&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="n"&gt;dual_coef_average&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_label&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dual_coef_average&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_label&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;この制約を満たすための実装はこの限りではない。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-9"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-16"&gt;双対係数は非負&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;双対係数は非負でなければならないため、負になった係数は全て0に修正してしまう。
学習が進むに連れて0の係数が増えていくが、それはSVMの持つスパース学習の効果が現れている状態である。学習が収束した時、0に潰れず非負値となった係数に対応するサンプルが&lt;strong&gt;サポートベクトル&lt;/strong&gt;である。&lt;/p&gt;
&lt;pre class="code c literal-block"&gt;
&lt;span class="cm"&gt;/* 制約2: 双対係数は非負 */&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="n"&gt;coef_dist&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;soft_margin_C1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="cm"&gt;/* C1ノルムの制約を適用 */&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;soft_margin_C1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="cm"&gt;/* ここで最終結果が出る. 前回との変化を計算 */&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="n"&gt;coef_diff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pre_dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="n"&gt;coef_dist&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coef_diff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;coef_diff&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;本実装では、非負条件に咥えて1ノルムソフトマージンの制約も追加で判定している。1ノルムソフトマージンを使用しない時は&lt;tt class="docutils literal"&gt;soft_margin_C1 == FLT_MAX&lt;/tt&gt;となっているため、無視できる。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-10"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-17"&gt;識別&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="#マージンの定式化"&gt;マージンの定式化&lt;/a&gt;で述べたが、SVMのクラス識別は出力値&lt;span class="math"&gt;\(y\)&lt;/span&gt;の正負によって判断する &lt;a class="footnote-reference" href="#footnote-13" id="footnote-reference-13"&gt;[13]&lt;/a&gt; 。SVMの出力式&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
g(\boldsymbol{x}, \boldsymbol{w}) = \boldsymbol{w}^{\mathsf{T}} \boldsymbol{x} + b
\end{equation*}
&lt;/div&gt;
&lt;p&gt;に、KKT条件における最適条件&lt;span class="math"&gt;\(\boldsymbol{w}^{\star} = \sum_{i=1}^{N} \alpha_{i}y_{i}\boldsymbol{x}_{i}\)&lt;/span&gt;を代入すれば、次の&lt;strong&gt;双対表現&lt;/strong&gt;が得られる：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
g(\boldsymbol{x}, \boldsymbol{w}^{\star}) = \sum_{i=1}^{N} \alpha_{i} y_{i} K(\boldsymbol{x}_{i}, \boldsymbol{x}) + b
\end{equation*}
&lt;/div&gt;
&lt;p&gt;識別の際には、学習済みの係数&lt;span class="math"&gt;\(\boldsymbol{\alpha}\)&lt;/span&gt;を使用して上式を計算し、その正負を判定すれば良い。実装としては次の様になる：&lt;/p&gt;
&lt;pre class="code c literal-block"&gt;
&lt;span class="cm"&gt;/* ネットワーク出力計算 */&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="n"&gt;network_output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="cm"&gt;/* 係数が正に相当するサンプル（サポートベクトル）
   * のみを計算する */&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="n"&gt;network_output&lt;/span&gt;&lt;span class="w"&gt;
      &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_label&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dual_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;
      &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;kernel_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sample_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;normalized_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data_dim&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;kernel_parameter&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;

&lt;/span&gt;&lt;span class="cm"&gt;/* 識別 */&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;network_output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="section-11"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-18"&gt;脚注&lt;/a&gt;&lt;/h2&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;高村大也、 奥村学、 “言語処理のための機械学習入門”、 コロナ社、 2010&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;高橋治久、 堀田一弘、 “学習理論” コロナ社、 2009&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;くどいかもしれないが、
サポートベクトルは最も識別面に近いサンプルなので、この仮定により&lt;span class="math"&gt;\(y_{i}(\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}+b) \geq l \quad (i=1, \dots, N)\)&lt;/span&gt;が成り立つ。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;（証明） -
最適化対象について、&lt;span class="math"&gt;\(\displaystyle \frac{1}{2}\boldsymbol{w}^{\mathsf{T}}\boldsymbol{w} = \frac{1}{2} \sum_{i=1}^{n} w_{i}^{2}\)&lt;/span&gt;より（&lt;span class="math"&gt;\(\boldsymbol{w}=[w_{1}\dots w_{n}]^\mathsf{T}\)&lt;/span&gt;）、
明らかに下に凸である。 -
制約条件について、&lt;span class="math"&gt;\(W_{i} = \{ \boldsymbol{w} | y_{i}(\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}\_{i}+b) \geq 1 \}\)&lt;/span&gt;とおくと、&lt;span class="math"&gt;\(\forall \boldsymbol{w}^{\prime}, \boldsymbol{w}^{\prime\prime} \in W_{i}, \forall t \in [0, 1]\)&lt;/span&gt;に対して、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned} y_{i} \left[ \left( t\boldsymbol{w}^{\prime\mathsf{T}} + (1-t) \boldsymbol{w}^{\prime\prime\mathsf{T}} \right) \boldsymbol{x}\_{i} + b \right] = y_{i} \left[ t(\boldsymbol{w}^{\prime\mathsf{T}}\boldsymbol{x}\_{i} - \boldsymbol{w}^{\prime\prime\mathsf{T}}\boldsymbol{x}\_{i}) + \boldsymbol{w}^{\prime\prime\mathsf{T}}\boldsymbol{x}\_{i} + b \right] \\
            = y_{i} \left[ t\left( (\boldsymbol{w}^{\prime\mathsf{T}}\boldsymbol{x}\_{i} + b) - (\boldsymbol{w}^{\prime\prime\mathsf{T}}\boldsymbol{x}\_{i} + b) \right) + \boldsymbol{w}^{\prime\prime\mathsf{T}}\boldsymbol{x}\_{i} + b \right] \\
            = t y_{i} (\boldsymbol{w}^{\prime\mathsf{T}}\boldsymbol{x}\_{i} + b) + (1-t) y_{i}(\boldsymbol{w}^{\prime\prime\mathsf{T}}\boldsymbol{x}\_{i} + b) \\
            \geq t + (1-t) = 1\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;よって、&lt;span class="math"&gt;\(t\boldsymbol{w}^{\prime} + (1-t) \boldsymbol{w}^{\prime\prime} \in W_{i}\)&lt;/span&gt;より&lt;span class="math"&gt;\(W_{i}\)&lt;/span&gt;は凸集合。
最適化問題においては、
&lt;span class="math"&gt;\(W_{i}\)&lt;/span&gt;の共通部分&lt;span class="math"&gt;\(\bigcap_{i=1}^{N} W_{i}\)&lt;/span&gt;を考えれば良く、
&lt;strong&gt;凸集合の積集合もまた凸集合&lt;/strong&gt; なので、
制約条件も凸集合となる。以上の2点より、 マージン最大化は凸計画問題。
（凸集合の積集合もまた凸集合であることの証明）2つの凸集合を&lt;span class="math"&gt;\(A_{1},A_{2}\)&lt;/span&gt;とする。
両者の集合の積&lt;span class="math"&gt;\(A_{1}\cap A_{2}\)&lt;/span&gt;が空集合ならば、
空集合は凸集合と定義されるので命題は成立する。
一般に&lt;span class="math"&gt;\(A_{1}\cap A_{2}\)&lt;/span&gt;から2点&lt;span class="math"&gt;\(x,y\)&lt;/span&gt;をとると,
&lt;span class="math"&gt;\(x, y\)&lt;/span&gt;を結ぶ線分は、
&lt;span class="math"&gt;\(A_{1}, A_{2}\)&lt;/span&gt;は共に凸集合なので、
&lt;span class="math"&gt;\(A_{1}\)&lt;/span&gt;にも&lt;span class="math"&gt;\(A_{2}\)&lt;/span&gt;にも属していて飛び出ることはない。
これは集合の積&lt;span class="math"&gt;\(A_{1}\cap A_{2}\)&lt;/span&gt;が凸集合であることを示している。&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;（鞍点&lt;span class="math"&gt;\((\boldsymbol{v}^{\star}, \boldsymbol{\alpha}^{\star})\)&lt;/span&gt;が最適点となる事の証明）
&lt;span class="math"&gt;\((\boldsymbol{v}^{\star}, \boldsymbol{\alpha}^{\star})\)&lt;/span&gt;は鞍点なので、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned} {\cal L}(\boldsymbol{v}, \boldsymbol{\alpha}^{\star}) \leq {\cal L}(\boldsymbol{v}^{\star}, \boldsymbol{\alpha}^{\star}) \leq {\cal L}(\boldsymbol{v}^{\star}, \boldsymbol{\alpha}) \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たす。
従って右側の不等式から&lt;span class="math"&gt;\(\boldsymbol{\alpha}^{\star\mathsf{T}}\boldsymbol{g}(\boldsymbol{v}^{\star}) \leq \boldsymbol{\alpha}^{\mathsf{T}}\boldsymbol{g}(\boldsymbol{v}^{\star})\)&lt;/span&gt;が任意の&lt;span class="math"&gt;\(\boldsymbol{\alpha}\)&lt;/span&gt;で成立する。
即ち&lt;span class="math"&gt;\(\boldsymbol{\alpha} = \boldsymbol{0}\)&lt;/span&gt;の時、
&lt;span class="math"&gt;\(g_{i}(\boldsymbol{v}^{\star}) \geq 0\)&lt;/span&gt;と併せて&lt;span class="math"&gt;\(\boldsymbol{\alpha}^{\star\mathsf{T}}\boldsymbol{g}(\boldsymbol{v}^{\star}) = 0\)&lt;/span&gt;が成立する。
更に、 ここで関係式&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned} {\cal L}(\boldsymbol{v}, \boldsymbol{\alpha}^{\star}) - {\cal L}(\boldsymbol{v}^{\star}, \boldsymbol{\alpha}^{\star}) \leq \left( \frac{\partial {\cal L}(\boldsymbol{v}^{\star}, \boldsymbol{\alpha})}{\partial \boldsymbol{v}} \right)^{\mathsf{T}} (\boldsymbol{v} - \boldsymbol{v}^{\star}) \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を用いる（証明は後術）と、
鞍点であることから&lt;span class="math"&gt;\(\displaystyle\frac{\partial {\cal L}(\boldsymbol{v}^{\star}, \boldsymbol{\alpha})}{\partial \boldsymbol{v}} = \boldsymbol{0}\)&lt;/span&gt;であり、
また、
&lt;span class="math"&gt;\(\boldsymbol{\alpha}^{\star\mathsf{T}}\boldsymbol{g}(\boldsymbol{v}^{\star}) = 0\)&lt;/span&gt;より、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned} {\cal L}(\boldsymbol{v}, \boldsymbol{\alpha}^{\star}) - {\cal L}(\boldsymbol{v}^{\star}, \boldsymbol{\alpha}^{\star}) &amp;amp;= {\cal L}(\boldsymbol{v}, \boldsymbol{\alpha}^{\star}) - f(\boldsymbol{v}^{\star}) \leq 0 \iff f(\boldsymbol{v}^{\star}) \geq {\cal L}(\boldsymbol{v}, \boldsymbol{\alpha}^{\star}) \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成り立つ。 更に、
もとより&lt;span class="math"&gt;\(\boldsymbol{\alpha}^{\star\mathsf{T}}\boldsymbol{g}(\boldsymbol{v}) \geq 0\)&lt;/span&gt;なので、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned} f(\boldsymbol{v}) \leq f(\boldsymbol{v}) + \boldsymbol{\alpha}^{\star\mathsf{T}}\boldsymbol{g}(\boldsymbol{v}) = {\cal L}(\boldsymbol{v}, \boldsymbol{\alpha}^{\star}) \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;従って&lt;span class="math"&gt;\(f(\boldsymbol{v}^{\star}) \geq f(\boldsymbol{v})\)&lt;/span&gt;が任意の&lt;span class="math"&gt;\(\boldsymbol{v}\)&lt;/span&gt;で成立し、&lt;span class="math"&gt;\((\boldsymbol{v}^{\star}, \boldsymbol{\alpha}^{\star})\)&lt;/span&gt;が最適点となる事が示された。
次いで(＊)を証明する。&lt;span class="math"&gt;\({\cal L}(\boldsymbol{v}, \boldsymbol{\alpha})\)&lt;/span&gt;が凸関数ならば、
&lt;span class="math"&gt;\({\cal L}(t\boldsymbol{v}^{\prime}+(1-t)\boldsymbol{v}^{\prime\prime}, \boldsymbol{\alpha}^{\star}) \geq t {\cal L}(\boldsymbol{v}^{\prime}, \boldsymbol{\alpha}^{\star}) + (1-t) {\cal L}(\boldsymbol{v}^{\prime}, \boldsymbol{\alpha}^{\star})\)&lt;/span&gt;が&lt;span class="math"&gt;\(t \in [0,1]\)&lt;/span&gt;で成立する。
よって、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
t{\cal L}(\boldsymbol{v}^{\prime}, \boldsymbol{\alpha}^{\star}) \leq t{\cal L}(\boldsymbol{v}^{\prime\prime}, \boldsymbol{\alpha}^{\star}) - {\cal L}(\boldsymbol{v}^{\prime\prime}, \boldsymbol{\alpha}^{\star}) + {\cal L}(t\boldsymbol{v}^{\prime}+(1-t)\boldsymbol{v}^{\prime\prime}, \boldsymbol{\alpha}^{\star}) \iff {\cal L}(\boldsymbol{v}^{\prime}, \boldsymbol{\alpha}^{\star}) \leq {\cal L}(\boldsymbol{v}^{\prime\prime}, \boldsymbol{\alpha}^{\star}) + \frac{{\cal L}(\boldsymbol{v}^{\prime\prime} + t(\boldsymbol{v}^{\prime}-\boldsymbol{v}^{\prime\prime}), \boldsymbol{\alpha}^{\star}) - {\cal L}(\boldsymbol{v}^{\prime\prime}, \boldsymbol{\alpha}^{\star})}{t}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで&lt;span class="math"&gt;\(t \to 0\)&lt;/span&gt;ならしめれば、
方向微分と勾配の関係式より、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
{\cal L}(\boldsymbol{v}^{\prime}, \boldsymbol{\alpha}^{\star}) - {\cal L}(\boldsymbol{v}^{\prime\prime}, \boldsymbol{\alpha}^{\star}) \leq \left( \frac{\partial {\cal L}(\boldsymbol{v}^{\prime\prime}, \boldsymbol{\alpha}^{\star})}{\partial \boldsymbol{v}} \right)^{\mathsf{T}} (\boldsymbol{v}^{\prime} - \boldsymbol{v}^{\prime\prime})
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;を得る。&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;互いに同一平面上&lt;strong&gt;以外&lt;/strong&gt;の位置にある事。
例えば、2次元空間では同一直線上以外の位置であり、3次元空間では同一平面上以外の位置である。異なるクラスのサンプルが一般位置にあれば、もとより線形分離可能である。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-7"&gt;[7]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;有限個数&lt;span class="math"&gt;\(N&amp;lt;\infty\)&lt;/span&gt;のサンプルに対し、&lt;span class="math"&gt;\((\boldsymbol{G})\_{ij} = K(\boldsymbol{x}\_{i}, \boldsymbol{x}\_{j})\)&lt;/span&gt;、即ち&lt;span class="math"&gt;\((i,j)\)&lt;/span&gt;成分の値が&lt;span class="math"&gt;\(K(\boldsymbol{x}\_{i}, \boldsymbol{x}\_{j})\)&lt;/span&gt;となっている行列&lt;span class="math"&gt;\(\boldsymbol{G}\)&lt;/span&gt;をグラム（カーネル）行列という。特徴写像が有限次元ならば、グラム行列が（有限）正定値行列ならば&lt;span class="math"&gt;\(K\)&lt;/span&gt;はカーネル関数となる。特徴写像が無限次元の場合のカーネル関数の条件がマーサーの定理である。
その内容は、入力空間&lt;span class="math"&gt;\(X\subset \mathbb{R}^{n}\)&lt;/span&gt;が有界閉集合（&lt;span class="math"&gt;\(\iff\)&lt;/span&gt;コンパクト）であるとし、対象な連続関数&lt;span class="math"&gt;\(K\)&lt;/span&gt;が正定値、即ち任意の二乗可積分（二乗積分可能）な関数&lt;span class="math"&gt;\(f\)&lt;/span&gt;に対し&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \int_{X\times X}K(x, z)f(x)f(z)dxdz \geq 0\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ならば、ヒルベルト空間の正規直交基底&lt;span class="math"&gt;\(\phi_{j}\ (j=1, 2, \dots)\)&lt;/span&gt;で次式が一様収束するものが存在する場合、&lt;span class="math"&gt;\(K\)&lt;/span&gt;はカーネル関数である。&lt;/p&gt;
&lt;div class="last math"&gt;
\begin{equation*}
\begin{aligned} K(x, z) = \sum_{j=1}^{\infty} \phi_{j}(x)\phi_{j}(z) \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-8"&gt;[8]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;サンプルに現れない未知のデータでももれなく識別できる能力&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-9"&gt;[9]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;双対問題において、
&lt;span class="math"&gt;\(C_{1}, C_{2} \to \infty\)&lt;/span&gt;とすると、ハードマージンSVMに一致することが分かる&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-10"&gt;[10]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;サンプルに最も当てはまる曲線（面）を探す問題。もう少し形式的に言うと、各サンプル&lt;span class="math"&gt;\(\boldsymbol{x}\_{i}\)&lt;/span&gt;でのラベル&lt;span class="math"&gt;\(y_{i}\)&lt;/span&gt;の平均値を表す関数&lt;span class="math"&gt;\(f\)&lt;/span&gt;を学習する問題。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-11"&gt;[11]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;（証明） -
最適化対象について、&lt;span class="math"&gt;\(\displaystyle \frac{1}{2}\boldsymbol{w}^{\mathsf{T}}\boldsymbol{w} = \frac{1}{2} \sum_{i=1}^{n} w_{i}^{2}\)&lt;/span&gt;より（&lt;span class="math"&gt;\(\boldsymbol{w}=[w_{1}\dots w_{n}]^\mathsf{T}\)&lt;/span&gt;）、
明らかに下に凸である。 -
制約条件について、&lt;span class="math"&gt;\(W_{i} = \{ \boldsymbol{w} | y_{i}(\boldsymbol{w}^{\mathsf{T}}\boldsymbol{x}\_{i}+b) \geq 1 \}\)&lt;/span&gt;とおくと、&lt;span class="math"&gt;\(\forall \boldsymbol{w}^{\prime}, \boldsymbol{w}^{\prime\prime} \in W_{i}, \forall t \in [0, 1]\)&lt;/span&gt;に対して、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned} y_{i} \left[ \left( t\boldsymbol{w}^{\prime\mathsf{T}} + (1-t) \boldsymbol{w}^{\prime\prime\mathsf{T}} \right) \boldsymbol{x}\_{i} + b \right] = y_{i} \left[ t(\boldsymbol{w}^{\prime\mathsf{T}}\boldsymbol{x}\_{i} - \boldsymbol{w}^{\prime\prime\mathsf{T}}\boldsymbol{x}\_{i}) + \boldsymbol{w}^{\prime\prime\mathsf{T}}\boldsymbol{x}\_{i} + b \right] \\
            = y_{i} \left[ t\left( (\boldsymbol{w}^{\prime\mathsf{T}}\boldsymbol{x}\_{i} + b) - (\boldsymbol{w}^{\prime\prime\mathsf{T}}\boldsymbol{x}\_{i} + b) \right) + \boldsymbol{w}^{\prime\prime\mathsf{T}}\boldsymbol{x}\_{i} + b \right] \\
            = t y_{i} (\boldsymbol{w}^{\prime\mathsf{T}}\boldsymbol{x}\_{i} + b) + (1-t) y_{i}(\boldsymbol{w}^{\prime\prime\mathsf{T}}\boldsymbol{x}\_{i} + b) \\
            \geq t + (1-t) = 1\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;よって、&lt;span class="math"&gt;\(t\boldsymbol{w}^{\prime} + (1-t) \boldsymbol{w}^{\prime\prime} \in W_{i}\)&lt;/span&gt;より&lt;span class="math"&gt;\(W_{i}\)&lt;/span&gt;は凸集合。
最適化問題においては、
&lt;span class="math"&gt;\(W_{i}\)&lt;/span&gt;の共通部分&lt;span class="math"&gt;\(\bigcap_{i=1}^{N} W_{i}\)&lt;/span&gt;を考えれば良く、
&lt;strong&gt;凸集合の積集合もまた凸集合&lt;/strong&gt; なので、
制約条件も凸集合となる。以上の2点より、 マージン最大化は凸計画問題。
（凸集合の積集合もまた凸集合であることの証明）2つの凸集合を&lt;span class="math"&gt;\(A_{1},A_{2}\)&lt;/span&gt;とする。
両者の集合の積&lt;span class="math"&gt;\(A_{1}\cap A_{2}\)&lt;/span&gt;が空集合ならば、
空集合は凸集合と定義されるので命題は成立する。
一般に&lt;span class="math"&gt;\(A_{1}\cap A_{2}\)&lt;/span&gt;から2点&lt;span class="math"&gt;\(x,y\)&lt;/span&gt;をとると,
&lt;span class="math"&gt;\(x, y\)&lt;/span&gt;を結ぶ線分は、
&lt;span class="math"&gt;\(A_{1}, A_{2}\)&lt;/span&gt;は共に凸集合なので、
&lt;span class="math"&gt;\(A_{1}\)&lt;/span&gt;にも&lt;span class="math"&gt;\(A_{2}\)&lt;/span&gt;にも属していて飛び出ることはない。
これは集合の積&lt;span class="math"&gt;\(A_{1}\cap A_{2}\)&lt;/span&gt;が凸集合であることを示している。&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-12"&gt;[12]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;ただし学習率&lt;span class="math"&gt;\(\eta\)&lt;/span&gt;の決め方は問題依存である。一般に、&lt;span class="math"&gt;\(\eta\)&lt;/span&gt;が小さすぎると学習が進行せず、大きすぎると極値を飛び越えてしまい学習が収束しない。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-13" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-13"&gt;[13]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;span class="math"&gt;\(y = 0\)&lt;/span&gt;の場合の判断を明確にしている書類がない。ここでは正と判定する。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="記事"></category><category term="機械学習"></category></entry><entry><title>MCMC（マルコフ連鎖モンテカルロ）法</title><link href="/mcmcmarukohulian-suo-montekarurofa.html" rel="alternate"></link><published>2020-04-23T12:20:00+09:00</published><updated>2020-04-30T14:30:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-23:/mcmcmarukohulian-suo-montekarurofa.html</id><summary type="html">&lt;p class="first last"&gt;MCMC法の概要について。実装はなく、ちょっと理論寄り。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;本稿ではMCMC法の解説のため、MC法による積分の計算方法（モンテカルロ積分）から、MCMCによる手法の概要を見ていく。MCMC法は有名かつ知り尽くされた手法で、多くの良質な説明資料 &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt;, &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;, &lt;a class="footnote-reference" href="#footnote-3" id="footnote-reference-3"&gt;[3]&lt;/a&gt;, &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-4"&gt;[4]&lt;/a&gt;, &lt;a class="footnote-reference" href="#footnote-5" id="footnote-reference-5"&gt;[5]&lt;/a&gt; が存在している。従ってここの説明は読まずに、資料を見てもらった方が理解が早いかもしれない。&lt;/p&gt;
&lt;p&gt;一般に &lt;strong&gt;MC（Monte-Calro, モンテカルロ）法&lt;/strong&gt;
は、サンプリング（サンプルを乱数から生成すること）によってシミュレーションや数値計算を行う手法である。特に確率分布が関わる積分値 &lt;a class="footnote-reference" href="#footnote-6" id="footnote-reference-6"&gt;[6]&lt;/a&gt; を近似的に求めるMC法はモンテカルロ積分と呼ばれる。モンテカルロ積分は確率的な推論の一種であり、大数の法則 &lt;a class="footnote-reference" href="#footnote-7" id="footnote-reference-7"&gt;[7]&lt;/a&gt; によって、十分なサンプル数をとれば近似精度をいくらでも良くする事ができる。サンプリングの手間がある為、近似分布をあらかじめ仮定する様な決定論的な推論よりも遥かに推論が遅い。しかし、MCは近似分布が求められないような場合にも適用可能であり、汎用性が高いと言える。&lt;/p&gt;
&lt;p&gt;MC法によって原理的には任意の解を求められるが、十分なサンプル数の要求というのが大きな問題を孕んでいる。サンプリングの自由度（範囲及び次元）が大きくなると、解の計算にあまり寄与しない（無駄な）サンプルが増えてしまう。計算を現実的かつ効率的に行うためには、サンプルの選択が重要になる。&lt;/p&gt;
&lt;p&gt;そして &lt;strong&gt;MCMC（Markov Chain Monte-Calro, マルコフ連鎖モンテカルロ）法&lt;/strong&gt;
は、新しいサンプルを以前に生成したサンプルに確率的に依存して（サンプルの列がマルコフ連鎖となる様に）生成するMC法である。MCMCでは、新しく生成したサンプルを採択（採用）するか棄却（捨てる）するかも確率的に判断する。この手続きによって、無駄なサンプルを極力減らすようにサンプリングを実行することができる。&lt;/p&gt;
&lt;div class="contents local topic" id="topic-1"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mc" id="toc-entry-1"&gt;MC法による積分 - モンテカルロ積分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-1" id="toc-entry-2"&gt;重点サンプリング&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mcmc-1" id="toc-entry-3"&gt;MCMC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-2" id="toc-entry-4"&gt;遷移確率の条件 - 詳細釣り合い条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-3" id="toc-entry-5"&gt;メトロポリス-ヘイスティングス法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-4" id="toc-entry-6"&gt;ギブスサンプリング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#mcmc-2" id="toc-entry-7"&gt;MCMCによる最適化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-5" id="toc-entry-8"&gt;焼きなまし法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-6" id="toc-entry-9"&gt;補足&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-7" id="toc-entry-10"&gt;エルゴード的なマルコフ連鎖の定常分布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-8" id="toc-entry-11"&gt;詳細釣り合い条件の証明&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-9" id="toc-entry-12"&gt;脚注&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="mc"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-1"&gt;MC法による積分 - モンテカルロ積分&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;確率変数を&lt;span class="math"&gt;\(d\)&lt;/span&gt;次元の実数値ベクトル &lt;a class="footnote-reference" href="#footnote-8" id="footnote-reference-8"&gt;[8]&lt;/a&gt;
&lt;span class="math"&gt;\(\boldsymbol{x} = [x_{1},\dots,x_{d}]^{\mathsf{T}} \in X \subset \mathbb{R}^{d}\)&lt;/span&gt;とする。ここで&lt;span class="math"&gt;\(X\)&lt;/span&gt;は全事象 &lt;a class="footnote-reference" href="#footnote-9" id="footnote-reference-9"&gt;[9]&lt;/a&gt;
の集合である。&lt;span class="math"&gt;\(\boldsymbol{x}\)&lt;/span&gt;の確率分布を&lt;span class="math"&gt;\(r(\boldsymbol{x})\)&lt;/span&gt;とし、関数&lt;span class="math"&gt;\(h\)&lt;/span&gt;の確率分布&lt;span class="math"&gt;\(r\)&lt;/span&gt;による平均（期待値）&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
I = \int_{X} h(\boldsymbol{x})r(\boldsymbol{x}) d\boldsymbol{x} = \mathrm{E}_{r}[h(\boldsymbol{x})] \tag{1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を求めることを考える。ここで、&lt;span class="math"&gt;\(\mathrm{E}_{p}[\cdot]\)&lt;/span&gt;は確率分布&lt;span class="math"&gt;\(p\)&lt;/span&gt;による平均を表す。&lt;span class="math"&gt;\(I\)&lt;/span&gt;において、関数&lt;span class="math"&gt;\(h\)&lt;/span&gt;の形に制約を与えておらず積分として様々な値が計算できる。例を挙げると:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h(\boldsymbol{x}) = \boldsymbol{x}\)&lt;/span&gt; :
この場合は&lt;span class="math"&gt;\(\mathrm{E}_{r}[\boldsymbol{x}]\)&lt;/span&gt;、即ち&lt;span class="math"&gt;\(\boldsymbol{x}\)&lt;/span&gt;の平均を求める&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(h(\boldsymbol{x}) = (\boldsymbol{x} - \mathrm{E_{r}}[\boldsymbol{x}])(\boldsymbol{x} - \mathrm{E_{r}}[\boldsymbol{x}])^{\mathsf{T}}\)&lt;/span&gt;
: &lt;span class="math"&gt;\(\boldsymbol{x}\)&lt;/span&gt;の分散を求める&lt;/li&gt;
&lt;li&gt;… その他  &lt;a class="footnote-reference" href="#footnote-10" id="footnote-reference-10"&gt;[10]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;もし&lt;span class="math"&gt;\(r(\boldsymbol{x})\)&lt;/span&gt;が既知で、分布&lt;span class="math"&gt;\(r\)&lt;/span&gt;から簡単に独立にサンプリングできる &lt;a class="footnote-reference" href="#footnote-11" id="footnote-reference-11"&gt;[11]&lt;/a&gt; ならば、&lt;span class="math"&gt;\(r(\boldsymbol{x})\)&lt;/span&gt;からの独立な（他のサンプルに依存して生成しない）&lt;span class="math"&gt;\(n\)&lt;/span&gt;個のサンプルを&lt;span class="math"&gt;\(\boldsymbol{x}_{1}, \boldsymbol{x}_{2}, \dots, \boldsymbol{x}_{n}\)&lt;/span&gt;と書くと、&lt;span class="math"&gt;\(I\)&lt;/span&gt;の標本平均による近似値&lt;span class="math"&gt;\(\hat{I}\)&lt;/span&gt;は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\hat{I} = \frac{1}{n} \sum_{i=1}^{n} h(\boldsymbol{x}_{i}) \tag{2}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;で計算できる。大数の法則により、サンプル数の極限を取れば標本平均は真の平均に一致する:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\lim_{n \to \infty} \hat{I} = I
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この様にして平均を求める方法を &lt;strong&gt;モンテカルロ積分(Monte-Carlo
Integration)&lt;/strong&gt; という。一般にモンテカルロ法(Monte-Carlo
Method)はサンプリングによってシミュレーションや数値計算を行う事を指す。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-2"&gt;重点サンプリング&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;モンテカルロ積分によって、原理的には&lt;span class="math"&gt;\(\hat{I}\)&lt;/span&gt;を多くのサンプルで計算する事で&lt;span class="math"&gt;\(I\)&lt;/span&gt;を精度良く計算できる。しかし実際確率分布&lt;span class="math"&gt;\(r(\boldsymbol{x})\)&lt;/span&gt;は複雑であることが多く、その場合&lt;span class="math"&gt;\(r(\boldsymbol{x})\)&lt;/span&gt;から直接サンプリングするのは困難となる。そこで、より簡単でサンプリング可能な確率分布（&lt;strong&gt;提案分布&lt;/strong&gt;
という）&lt;span class="math"&gt;\(q(\boldsymbol{x})\)&lt;/span&gt;を用意して、そこからサンプリングする事を考える。&lt;span class="math"&gt;\(q(\boldsymbol{x})\)&lt;/span&gt;を使えば、&lt;span class="math"&gt;\(I\)&lt;/span&gt;は次の様に変形できる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
I = \int_{X} h(\boldsymbol{x})\frac{r(\boldsymbol{x})}{q(\boldsymbol{x})} q(\boldsymbol{x}) d\boldsymbol{x} = \mathrm{E}_{q}\left[ h(\boldsymbol{x})\frac{r(\boldsymbol{x})}{q(\boldsymbol{x})} \right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;モンテカルロ積分の時と同じ様にに考え、次は&lt;span class="math"&gt;\(\boldsymbol{x}_{1},\dots,\boldsymbol{x}_{n}\)&lt;/span&gt;を&lt;span class="math"&gt;\(q(\boldsymbol{x})\)&lt;/span&gt;からの独立な&lt;span class="math"&gt;\(n\)&lt;/span&gt;個のサンプルにすれば、&lt;span class="math"&gt;\(I\)&lt;/span&gt;の近似値&lt;span class="math"&gt;\(\hat{I}_{IS}\)&lt;/span&gt;として&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\hat{I}_{IS} = \frac{1}{n} \sum_{i=1}^{n} h(\boldsymbol{x}_{i}) \frac{r(\boldsymbol{x}_{i})}{q(\boldsymbol{x}_{i})} = \frac{1}{n} \sum_{i=1}^{n} h(\boldsymbol{x}_{i}) w(\boldsymbol{x}_{i}) \tag{3}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が得られる。ここで&lt;span class="math"&gt;\(w(\boldsymbol{x}_{i}) = r(\boldsymbol{x}_{i})/q(\boldsymbol{x}_{i})\)&lt;/span&gt;はサンプル&lt;span class="math"&gt;\(\boldsymbol{x}_{i}\)&lt;/span&gt;に対する重みと見ることができる。この様に、重みが付いたサンプルで平均を求める手法を
&lt;strong&gt;重点サンプリング(Importance Sampling)&lt;/strong&gt;
という。重点サンプリングにおいても、&lt;span class="math"&gt;\(q(\boldsymbol{x})\)&lt;/span&gt;がある条件を満たしていれば、大数の法則によって&lt;span class="math"&gt;\(\displaystyle\lim_{n \to \infty} \hat{I}_{IS} = I\)&lt;/span&gt;となることが保証されている。&lt;/p&gt;
&lt;div class="section" id="mcmc-1"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-3"&gt;MCMC&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;重点サンプリングの考え方によって、確率分布&lt;span class="math"&gt;\(r\)&lt;/span&gt;が複雑でも替わりに提案分布&lt;span class="math"&gt;\(q\)&lt;/span&gt;を用いてサンプリングを行えばモンテカルロ積分が計算できる事が確かめられた。しかし、&amp;quot;
&lt;span class="math"&gt;\(r\)&lt;/span&gt;より簡単でサンプリング可能な&lt;span class="math"&gt;\(q\)&lt;/span&gt;&amp;quot;
を構成する事自体が一般に困難である。特に次元&lt;span class="math"&gt;\(d\)&lt;/span&gt;が増加すれば&lt;span class="math"&gt;\(r\)&lt;/span&gt;が複雑になるのはもちろん、全事象&lt;span class="math"&gt;\(X\)&lt;/span&gt;の自由度が増加し次元の呪い &lt;a class="footnote-reference" href="#footnote-12" id="footnote-reference-12"&gt;[12]&lt;/a&gt; を引き起こす。即ち、&lt;span class="math"&gt;\(r\)&lt;/span&gt;を&lt;span class="math"&gt;\(q\)&lt;/span&gt;で良く近似出来てない時に毎回独立にサンプリングを行っていると、空間&lt;span class="math"&gt;\(X\)&lt;/span&gt;から当てずっぽうなサンプルを取得しているのと同様な状態になる。&lt;/p&gt;
&lt;p&gt;そこで、簡単な提案分布&lt;span class="math"&gt;\(q\)&lt;/span&gt;を用いて、かつ逐次的に以前のサンプルを使用して新しくサンプルを生成する手法が90年代以降使われる様になってきた。この場合、サンプル列はマルコフ連鎖(Markov
Chain)をなす。そして、マルコフ連鎖で生成したサンプルによるMC法をMCMC（Markov
Chain
Monte-Calro）法という。サンプル間の独立性は担保されなくなる為にMC法の基本原理が成立しなくなるが、提案分布（マルコフ連鎖の遷移確率）がある性質を満たせば、十分なサンプル数で確率分布&lt;span class="math"&gt;\(r\)&lt;/span&gt;からのサンプリングが実現できる。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-4"&gt;遷移確率の条件 - 詳細釣り合い条件&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;概要でも既に述べたが、MCMCは生成したサンプル列がマルコフ連鎖をなすように生成する。今、サンプル列&lt;span class="math"&gt;\(\boldsymbol{x}_{0}, \boldsymbol{x}_{1}, \dots\)&lt;/span&gt;はマルコフ連鎖をなすので、生成した時刻（ステップ）で実際に観測した状態を&lt;span class="math"&gt;\(\boldsymbol{e}_{0}, \boldsymbol{e}_{1}, \dots \ (\boldsymbol{e}_{i} \in X \ i=0,1,\dots)\)&lt;/span&gt;と書くと、任意の時刻&lt;span class="math"&gt;\(n \geq 0\)&lt;/span&gt;で、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
P(\boldsymbol{x}_{n+1} = \boldsymbol{e}_{n+1}|\boldsymbol{x}_{0} = \boldsymbol{e}_{0}, \boldsymbol{x}_{1} = \boldsymbol{e}_{1}, \dots, \boldsymbol{x}_{n} = \boldsymbol{e}_{n}) = P(\boldsymbol{x}_{n+1} = \boldsymbol{e}_{n+1}|\boldsymbol{x}_{n} = \boldsymbol{e}_{n})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成り立つ（この性質をマルコフ性 &lt;a class="footnote-reference" href="#footnote-13" id="footnote-reference-13"&gt;[13]&lt;/a&gt; という）。即ち、サンプルは直前のサンプルのみに依存して生成する。この様にサンプルを生成する場合、実はマルコフ連鎖が
&lt;strong&gt;エルゴード的(ergodic)&lt;/strong&gt;
という性質を満たせば、大量のサンプルを用いた時にある分布（&lt;strong&gt;定常分布&lt;/strong&gt;）&lt;span class="math"&gt;\(\pi\)&lt;/span&gt;からサンプリングしているのと同様になる。&lt;/p&gt;
&lt;p&gt;マルコフ連鎖がエルゴード的であるとは、規約性（どの状態からでも任意の状態へ遷移できる）と正再帰性（任意の状態へ何回でも遷移できる）非周期性（任意の状態は一回の遷移で元に戻れる）を全て同時に満たすことを言う &lt;a class="footnote-reference" href="#footnote-14" id="footnote-reference-14"&gt;[14]&lt;/a&gt;。
エルゴード的なマルコフ連鎖と定常分布&lt;span class="math"&gt;\(\pi\)&lt;/span&gt;の関係は、次の定理で表せる:&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;&lt;strong&gt;マルコフ連鎖の収束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;マルコフ連鎖&lt;span class="math"&gt;\(\boldsymbol{x}_{0}, \boldsymbol{x}_{1}, \dots\)&lt;/span&gt;がエルゴード的であり、その遷移確率行列を&lt;span class="math"&gt;\(\boldsymbol{P}\)&lt;/span&gt;とおく。&lt;span class="math"&gt;\(\pi\)&lt;/span&gt;を&lt;span class="math"&gt;\(\boldsymbol{P}\)&lt;/span&gt;の定常（不変）分布とした時、任意の初期状態から始まるマルコフ連鎖はサンプル数の極限において定常分布&lt;span class="math"&gt;\(\pi\)&lt;/span&gt;に収束する。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;ここで遷移確率行列&lt;span class="math"&gt;\(\boldsymbol{P}\)&lt;/span&gt;とは、その&lt;span class="math"&gt;\((i,j)\)&lt;/span&gt;要素&lt;span class="math"&gt;\((\boldsymbol{P})\_{ij} = p_{ij}\ (i,j \in X)\)&lt;/span&gt;が任意の時刻&lt;span class="math"&gt;\(t \geq 0\)&lt;/span&gt;で&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\boldsymbol{P})_{ij} = p_{ij} = P(\boldsymbol{x}_{t+1}=j|\boldsymbol{x}_{t}=i)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たすような行列である &lt;a class="footnote-reference" href="#footnote-15" id="footnote-reference-15"&gt;[15]&lt;/a&gt;。
また、定常分布とは時刻が経過しようとも不変なマルコフ連鎖（一般に確率過程）の各状態の確率分布である &lt;a class="footnote-reference" href="#footnote-16" id="footnote-reference-16"&gt;[16]&lt;/a&gt;。即ち、十分に長いマルコフ連鎖を観測すれば、どの状態にいる傾向があるのかを定常分布によって知ることができる。&lt;/p&gt;
&lt;p&gt;上記の議論により、マルコフ連鎖がエルゴード的であればサンプリングが定常分布に従う事は分かったが、次は遷移確率の設計が問題となる。遷移確率を規約性と正再帰性と非周期性とを満たすように設定するのは案外容易 &lt;a class="footnote-reference" href="#footnote-17" id="footnote-reference-17"&gt;[17]&lt;/a&gt; であるが、それだけでは定常分布の存在のみを保証するので、その定常分布が希望する分布に一致するとは限らない。次に問題となるのは、希望の確率分布&lt;span class="math"&gt;\(r\)&lt;/span&gt;を定常分布とするように遷移確率を設計することである。その問題は次の
&lt;strong&gt;詳細釣り合い条件(detailed balance condition)&lt;/strong&gt;
という条件によって解決できる。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;&lt;strong&gt;詳細釣り合い条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;希望する確率分布&lt;span class="math"&gt;\(r\)&lt;/span&gt;と遷移確率&lt;span class="math"&gt;\(p\)&lt;/span&gt;が次の条件を満たす時、そのマルコフ連鎖の定常分布&lt;span class="math"&gt;\(\pi\)&lt;/span&gt;は&lt;span class="math"&gt;\(r\)&lt;/span&gt;に一致する:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
r_{i} p_{ij} = r_{j} p_{ji}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで&lt;span class="math"&gt;\(r_{i} = r(\boldsymbol{x} = i)\)&lt;/span&gt;である（証明は&lt;a class="reference external" href="#詳細釣り合い条件の証明"&gt;補足&lt;/a&gt;に示した）。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;詳細釣り合い条件を満たす遷移確率を用いさえすれば、十分大きな&lt;span class="math"&gt;\(m&amp;gt;0\)&lt;/span&gt;を取った時に、マルコフ連鎖&lt;span class="math"&gt;\(\boldsymbol{x}_{m}, \boldsymbol{x_{m+1}},\dots\)&lt;/span&gt;は&lt;span class="math"&gt;\(r\)&lt;/span&gt;からのサンプルとなる。
次の節で紹介するアルゴリズムの遷移確率は、いずれも詳細釣り合い条件を満たすように設計されている。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-5"&gt;メトロポリス-ヘイスティングス法&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;メトロポリス-ヘイスティングス法は、サンプルは重点サンプリングの時と同じように提案分布によって生成し、そして新しく生成したサンプルを
&lt;strong&gt;採択&lt;/strong&gt;（採用）するか、もしくは &lt;strong&gt;棄却&lt;/strong&gt; （捨てる）のかを
&lt;strong&gt;採択確率(acceptance rate)&lt;/strong&gt;
と呼ばれる確率によって決め、採択された場合は新しい状態に遷移し、棄却された場合には遷移は行わずに（状態を変えずに）もう一度サンプリングし直す、という手続きを繰り返す手法である。&lt;/p&gt;
&lt;p&gt;メトロポリス-ヘイスティングス法の更新規則を導出してみる。
まず、状態&lt;span class="math"&gt;\(i \in X\)&lt;/span&gt;から状態&lt;span class="math"&gt;\(j \in X\)&lt;/span&gt;に遷移する時の提案分布を条件付き確率&lt;span class="math"&gt;\(q(\boldsymbol{x}_{n+1}=j|\boldsymbol{x}_{n}=i) = q_{ij}\)&lt;/span&gt;と書き、また状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;にいる時に状態&lt;span class="math"&gt;\(j\)&lt;/span&gt;を採択する確率（採択確率）を&lt;span class="math"&gt;\(\alpha(i \to j)\)&lt;/span&gt;と表す。すると、&lt;span class="math"&gt;\(i\)&lt;/span&gt;から&lt;span class="math"&gt;\(j\)&lt;/span&gt;への遷移確率&lt;span class="math"&gt;\(p_{ij}\)&lt;/span&gt;は&lt;span class="math"&gt;\(q_{ij}\)&lt;/span&gt;と&lt;span class="math"&gt;\(\alpha(i \to j)\)&lt;/span&gt;の積で表せる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
p_{ij} = q_{ij} \alpha(i \to j) \tag{4}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;そして、詳細釣り合い条件から、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{p_{ij}}{p_{ji}} = \frac{r_{j}}{r_{i}} &amp;amp;\iff \frac{q_{ij}\alpha(i \to j)}{q_{ji}\alpha(j \to i)} = \frac{r_{j}}{r_{i}} \\
&amp;amp;\iff \frac{\alpha(i \to j)}{\alpha(j \to i)} = \frac{r_{j}q_{ji}}{r_{i}q_{ij}}
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。採択確率はこの条件を満たす様に設計する。メトロポリス-ヘイスティングス法では特に、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\alpha(i \to j) = \min \left( 1, \frac{r_{j}q_{ji}}{r_{i}q_{ij}} \right) \tag{5}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とする &lt;a class="footnote-reference" href="#footnote-18" id="footnote-reference-18"&gt;[18]&lt;/a&gt;。アルゴリズムの実行中には、この式によって採択確率を計算し、&lt;span class="math"&gt;\([0,1]\)&lt;/span&gt;の範囲の一様乱数を発生させて採択/棄却を判断する。&lt;/p&gt;
&lt;p&gt;これでメトロポリス-ヘイスティングス法が実行できるが、その利点を2つ挙げる:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(r\)&lt;/span&gt;が厳密計算出来なくても良い
&lt;span class="math"&gt;\(r\)&lt;/span&gt;は一般に複雑なので直接的な計算は難しいが、上の採択確率の式は確率の比率のみに注目している。従って分布が厳密に計算できなくてもアルゴリズムを実行できる。比率さえ一致すれば良いので、分布&lt;span class="math"&gt;\(r\)&lt;/span&gt;の近似分布&lt;span class="math"&gt;\(\hat{r}\)&lt;/span&gt;として&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\hat{r} = \frac{1}{Z_{r}} r
\end{equation*}
&lt;/div&gt;
&lt;p&gt;としても良い事になる(&lt;span class="math"&gt;\(Z_{r}\)&lt;/span&gt;:正規化定数)。特に、近似分布をボルツマン-ギブス分布&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\hat{r}(\boldsymbol{x}) = \frac{1}{Z_{r}} \exp(-r(\boldsymbol{x})/T)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とする場合が多い。ここで、&lt;span class="math"&gt;\(T&amp;gt;0\)&lt;/span&gt;は温度パラメタ &lt;a class="footnote-reference" href="#footnote-19" id="footnote-reference-19"&gt;[19]&lt;/a&gt; である。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(q_{ij} = q_{ji}\)&lt;/span&gt;が成り立つ場合には、より簡単にサンプリングできる
&lt;span class="math"&gt;\(q_{ij} = q_{ji}\)&lt;/span&gt;が成立する提案分布で有名なものに&lt;strong&gt;酔歩連鎖(random
walk chain)&lt;/strong&gt;がある:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
q_{ij} = {\cal N}(i, \sigma^{2}\boldsymbol{I})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;即ち平均（中心）を現在状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;、分散を&lt;span class="math"&gt;\(\sigma\)&lt;/span&gt; &lt;a class="footnote-reference" href="#footnote-20" id="footnote-reference-20"&gt;[20]&lt;/a&gt;
とした正規分布からの乱択でサンプリングを行う &lt;a class="footnote-reference" href="#footnote-21" id="footnote-reference-21"&gt;[21]&lt;/a&gt; 。
正規分布以外でも、&lt;span class="math"&gt;\(i\)&lt;/span&gt;を平均とした一様分布、多変量&lt;span class="math"&gt;\(t\)&lt;/span&gt;分布でも実行できる。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-6"&gt;ギブスサンプリング&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ギブスサンプリング(Gibbs Sampling,
熱浴法とも)は提案分布の変数を1個ずつ更新していく手法である。
主に多次元確率分布 &lt;a class="footnote-reference" href="#footnote-22" id="footnote-reference-22"&gt;[22]&lt;/a&gt; の推定に用いられる事が多い。説明のため、現在の状態を組&lt;span class="math"&gt;\(\boldsymbol{x} = (x_{1}, x_{2}, \dots, x_{d})\)&lt;/span&gt;と書く。状態の更新の際には、変数を1つ選び出し &lt;a class="footnote-reference" href="#footnote-23" id="footnote-reference-23"&gt;[23]&lt;/a&gt; て&lt;span class="math"&gt;\(x_{i} \to x_{i}^{\prime}\)&lt;/span&gt;と遷移させる(&lt;span class="math"&gt;\(i=1,\dots,d\)&lt;/span&gt;)。更新後の状態を&lt;span class="math"&gt;\(\boldsymbol{x}^{\prime} = (x_{1}, \dots, x_{i-1}, x_{i}^{\prime}, x_{i+1}, \dots, x_{d})\)&lt;/span&gt;と書く。ここで、遷移確率&lt;span class="math"&gt;\(q(\boldsymbol{x}^{\prime}|\boldsymbol{x})\)&lt;/span&gt;は次で定義される:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
q(\boldsymbol{x}^{\prime}|\boldsymbol{x}) &amp;amp;= \frac{r(\boldsymbol{x}^{\prime})}{\sum_{x_{i}} r(\boldsymbol{x})} \\
&amp;amp;= r(x^{\prime}_{i}|x_{1},\dots,x_{i-1},x_{i+1},\dots,x_{d}) \quad (\because ベイズの定理)
\end{align*}
&lt;/div&gt;
&lt;p&gt;即ち、選択した変数&lt;span class="math"&gt;\(x_{i}\)&lt;/span&gt;以外を全て``固定’’した確率分布&lt;span class="math"&gt;\(r\)&lt;/span&gt;から&lt;span class="math"&gt;\(x_{i}^{\prime}\)&lt;/span&gt;を新しくサンプリングする。上記右辺が計算できる場合にのみ、ギブスサンプリングは適用可能となる。&lt;/p&gt;
&lt;p&gt;この更新規則が詳細釣り合い条件を満たすことは、再びベイズの定理を用いて、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
r(\boldsymbol{x})q(\boldsymbol{x}^{\prime}|\boldsymbol{x}) &amp;amp;= r(\boldsymbol{x}) r(x^{\prime}_{i}|x_{1},\dots,x_{i-1},x_{i+1},\dots,x_{d}) \\
&amp;amp;= r(\boldsymbol{x})\frac{r(\boldsymbol{x}^{\prime})}{\sum_{{x}_{i}}r(\boldsymbol{x})} = r(\boldsymbol{x}^{\prime}) \frac{r(\boldsymbol{x})}{\sum_{x_{i}^{\prime}}r(\boldsymbol{x}^{\prime})} \\
&amp;amp;= r(\boldsymbol{x}^{\prime}) q(\boldsymbol{x}|\boldsymbol{x}^{\prime})
\end{align*}
&lt;/div&gt;
&lt;p&gt;により確認できる。また、メトロポリス-ヘイスティングス法の採択確率の式から、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\alpha(\boldsymbol{x} \to \boldsymbol{x}^{\prime}) &amp;amp;= \min \left(1, \frac{r(\boldsymbol{x}^{\prime})q(\boldsymbol{x}|\boldsymbol{x}^{\prime})}{r(\boldsymbol{x})q(\boldsymbol{x}^{\prime}|\boldsymbol{x})} \right) \\
&amp;amp;= \min (1, 1) = 1
\end{align*}
&lt;/div&gt;
&lt;p&gt;となり、ギブスサンプリングはメトロポリス-ヘイスティングス法で採択確率を&lt;span class="math"&gt;\(1\)&lt;/span&gt;（必ず採択）するようにした特別の場合である事が分かる。採択/棄却の手順を踏まくくても良く、しかも遷移確率&lt;span class="math"&gt;\(q\)&lt;/span&gt;は予め計算できるので、高速な推定ができるようになっている。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mcmc-2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-7"&gt;MCMCによる最適化&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;MCMCは関数最適化に用いることもできる。今、サンプリングを行う確率分布をボルツマン-ギブス分布&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
r(\boldsymbol{x}) = \frac{1}{Z_{r}} \exp(-f(\boldsymbol{x})/T)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とした時、定義式により、&lt;span class="math"&gt;\(f(\boldsymbol{x})\)&lt;/span&gt;が小さな値を与える点ではその確率&lt;span class="math"&gt;\(r(\boldsymbol{x})\)&lt;/span&gt;は同時に大きくことが即座に観察できる。従って、MCMCによって&lt;span class="math"&gt;\(r(\boldsymbol{x})\)&lt;/span&gt;からのサンプリングを行えば、&lt;span class="math"&gt;\(f(\boldsymbol{x})\)&lt;/span&gt;が小さな値をとる点を集中してサンプリングできる事から、&lt;span class="math"&gt;\(f(\boldsymbol{x})\)&lt;/span&gt;の最小化（最大化の場合は&lt;span class="math"&gt;\(-f(\boldsymbol{x})\)&lt;/span&gt;の最小化に置き換えれば良い）を考える事ができる。実際、関数&lt;span class="math"&gt;\(f\)&lt;/span&gt;の最小値を与える点を&lt;span class="math"&gt;\(\boldsymbol{x}^{\ast}\)&lt;/span&gt;と表せば、サンプル数&lt;span class="math"&gt;\(N\)&lt;/span&gt;の極限において最小値&lt;span class="math"&gt;\(f(\boldsymbol{x}^{\ast})\)&lt;/span&gt;が確率1で得られる事:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\lim_{N \to \infty} P(\min(f(\boldsymbol{x}_{1}), f(\boldsymbol{x}_{2}), \dots, f(\boldsymbol{x}_{N})) = f(\boldsymbol{x}^{\ast})) = 1
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が示せる。以下、その証明を示す。&lt;/p&gt;
&lt;p&gt;（証明）
MCMCにおいて、定常分布を&lt;span class="math"&gt;\(r\)&lt;/span&gt;とする様に（詳細釣り合い条件を満たす様に）サンプリングを行う。この時マルコフ連鎖&lt;span class="math"&gt;\(\boldsymbol{x}_{1}, \boldsymbol{x}_{2}, \dots, \boldsymbol{x}_{n},\dots\)&lt;/span&gt;は、十分大きな&lt;span class="math"&gt;\(n &amp;gt; 1\)&lt;/span&gt;においては&lt;span class="math"&gt;\(r(\boldsymbol{x})\)&lt;/span&gt;からのサンプルとみなせる。関数&lt;span class="math"&gt;\(f\)&lt;/span&gt;に最小値&lt;span class="math"&gt;\(f(\boldsymbol{x}^{\ast})\)&lt;/span&gt;が存在すれば、&lt;span class="math"&gt;\(\boldsymbol{x}^{\ast}\)&lt;/span&gt;をサンプリングする確率&lt;span class="math"&gt;\(r(\boldsymbol{x}^{\ast})\)&lt;/span&gt;も存在が保証され、分布の中で最大の確率を与えている。従って、&lt;span class="math"&gt;\(n\)&lt;/span&gt;回目以降のマルコフ連鎖&lt;span class="math"&gt;\(\boldsymbol{x}_{n}, \boldsymbol{x}_{n+1},\dots\)&lt;/span&gt;において、&lt;span class="math"&gt;\(m \geq n\)&lt;/span&gt;回目に初めて&lt;span class="math"&gt;\(\boldsymbol{x}^{\ast}\)&lt;/span&gt;がサンプリングできる確率&lt;span class="math"&gt;\(P(\boldsymbol{x}_{m} = \boldsymbol{x}^{\ast})\)&lt;/span&gt;は、幾何分布と同じ様に、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
P(\boldsymbol{x}_{m} = \boldsymbol{x}^{\ast}) = r(\boldsymbol{x})\left\{ 1-r(\boldsymbol{x}^{\ast}) \right\}^{m-n}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;によって計算できる。また、初めて&lt;span class="math"&gt;\(\boldsymbol{x^{\ast}}\)&lt;/span&gt;がサンプリングできるまでの回数が&lt;span class="math"&gt;\(N \geq n\)&lt;/span&gt;回以内となる確率は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
P(\boldsymbol{x}_{n} = \boldsymbol{x}^{\ast}) + P(\boldsymbol{x}_{n+1} = \boldsymbol{x}^{\ast}) + \dots + P(\boldsymbol{x}_{N} = \boldsymbol{x}^{\ast}) &amp;amp;=  \sum_{m=n}^{N} P(\boldsymbol{x}_{N} = \boldsymbol{x}^{\ast}) \\
&amp;amp;= \sum_{k=0}^{N-n} r(\boldsymbol{x}^{\ast})\left\{ 1-r(\boldsymbol{x}^{\ast}) \right\}^{k}
\end{align*}
&lt;/div&gt;
&lt;p&gt;となる。
ここでサンプル数の極限&lt;span class="math"&gt;\(N \to \infty\)&lt;/span&gt;をとると、初項&lt;span class="math"&gt;\(r(\boldsymbol{x}^{\ast})\)&lt;/span&gt;、項比&lt;span class="math"&gt;\(1-r(\boldsymbol{x}^{\ast})\)&lt;/span&gt;とした等比級数の和の公式より、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\lim_{N \to \infty} \sum_{k=0}^{N-n} r(\boldsymbol{x}^{\ast})\left\{ 1-r(\boldsymbol{x}^{\ast}) \right\}^{k} = \frac{r(\boldsymbol{x}^{\ast})}{1-\left\{1-r(\boldsymbol{x}^{\ast})\right\}} = 1
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が得られる。即ち、サンプリングを無限に繰り返せば&lt;span class="math"&gt;\(\boldsymbol{x}^{\ast}\)&lt;/span&gt;が確率1で得られることが示された。この結果は、サンプルの関数列&lt;span class="math"&gt;\(f(\boldsymbol{x}_{1}), f(\boldsymbol{x}_{2}), \dots\)&lt;/span&gt;の中に少なくとも1つ&lt;span class="math"&gt;\(f(\boldsymbol{x}^{\ast})\)&lt;/span&gt;が存在する事と同値である。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-8"&gt;焼きなまし法&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以上でMCMCによる最適化が理論的に可能なことが示されたが、最適化の際に特に問題となるのは分布&lt;span class="math"&gt;\(r\)&lt;/span&gt;の温度パラメタ&lt;span class="math"&gt;\(T\)&lt;/span&gt;である。&lt;span class="math"&gt;\(T\)&lt;/span&gt;が大きければ、&lt;span class="math"&gt;\(\exp\)&lt;/span&gt;内部の&lt;span class="math"&gt;\(f(\boldsymbol{x})\)&lt;/span&gt;の値に影響されず&lt;span class="math"&gt;\(r(\boldsymbol{x})\)&lt;/span&gt;は一様分布に近くなり、一様乱数からのサンプリングと殆ど変わらなくなる。逆に&lt;span class="math"&gt;\(T\)&lt;/span&gt;が&lt;span class="math"&gt;\(0\)&lt;/span&gt;に近いと&lt;span class="math"&gt;\(r(\boldsymbol{x})\)&lt;/span&gt;は&lt;span class="math"&gt;\(f(\boldsymbol{x})\)&lt;/span&gt;の値に大きく影響されるが、サンプリングが特定の場所だけに集中してしまって局所最適値しか得られない場合がある。この様に&lt;span class="math"&gt;\(T\)&lt;/span&gt;は適切に決定する必要があるが、&lt;span class="math"&gt;\(T\)&lt;/span&gt;の適切な決定法は存在せず、問題依存となる場合が多い。&lt;/p&gt;
&lt;p&gt;そこで、最初は&lt;span class="math"&gt;\(T\)&lt;/span&gt;（温度）を高い状態から初めてサンプリングの度に少しずつ&lt;span class="math"&gt;\(T\)&lt;/span&gt;を下げていくやり方があり、これを焼きなまし法（Simulated
Annealing,
SA）と呼ぶ。この様に&lt;span class="math"&gt;\(T\)&lt;/span&gt;を変化させると最初は空間全体の中から大雑把な&lt;span class="math"&gt;\(f\)&lt;/span&gt;の値を取得し、後に最適値の近傍を集中してサンプリングすることができるために効率的な探索が期待できる。証明は省くが、温度パラメタの系列&lt;span class="math"&gt;\(T_{1}, T_{2}, \dots\)&lt;/span&gt;が次の条件を満たせばサンプリングによって&lt;span class="math"&gt;\(\boldsymbol{x}^{\ast}\)&lt;/span&gt;が得られる事（収束定理）が示されている:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\sum_{n=1}^{\infty} \exp(-D/T_{n}) = \infty
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで、&lt;span class="math"&gt;\(D\)&lt;/span&gt;は問題によって決まる定数である。&lt;/p&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-9"&gt;補足&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-10"&gt;エルゴード的なマルコフ連鎖の定常分布&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上記の議論で、「マルコフ連鎖がエルゴード的ならば、一意な定常分布が存在する」という事に触れた。この定理についての証明を述べていくが、準備として確率過程についての用語や記法の定義、基本的な定理の証明を行う。大方の証明は&lt;a class="reference external" href="http://www-lsm.naist.jp/~kasahara/lecture/isp/part1.pdf"&gt;ここ&lt;/a&gt;を参照した。なお、状態空間（全事象）&lt;span class="math"&gt;\(X\)&lt;/span&gt;は有限集合であるとする。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;&lt;strong&gt;離散時間マルコフ連鎖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;確率過程（サンプル列）
&lt;span class="math"&gt;\(\boldsymbol{x}_{0}, \boldsymbol{x}_{1}, \dots\)&lt;/span&gt;
が次を満たす時、離散時間マルコフ連鎖という。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\forall n \geq 0, \forall i_{0}, \dots, i_{n+1} \in X.\ P(\boldsymbol{x}_{n+1} = i_{n+1} |\boldsymbol{x}_{0} = i_{0}, \boldsymbol{x}_{1} = i_{1}, \dots, \boldsymbol{x}_{n} = i_{n}) = P(\boldsymbol{x}_{n+1}=i_{n+1}|\boldsymbol{x}_{n}=i_{n})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;またこの性質をマルコフ性という。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;!-- 空白のためのコメント... --&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;&lt;strong&gt;遷移確率の斉時性、nステップ遷移確率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任意の状態&lt;span class="math"&gt;\(i,j \in X\)&lt;/span&gt;と非負整数&lt;span class="math"&gt;\(n \geq 0\)&lt;/span&gt;に対して&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
p_{ij}(n) = P(\boldsymbol{x}_{n+1}=j|\boldsymbol{x}_{n}=i)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を、状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;から状態&lt;span class="math"&gt;\(j\)&lt;/span&gt;への遷移確率という。&lt;span class="math"&gt;\(p_{ij}(n)\)&lt;/span&gt;が&lt;span class="math"&gt;\(n\)&lt;/span&gt;と独立で常に&lt;span class="math"&gt;\(p_{ij}(n) = p_{ij}(0) = p_{ij}\)&lt;/span&gt;となる時、離散時間マルコフ連鎖は斉時であるという。今後、遷移確率は&lt;span class="math"&gt;\(p_{ij}\)&lt;/span&gt;を用いて表す。また、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
p_{ij}^{(n)} = P(\boldsymbol{x}_{n}=j|\boldsymbol{x}_{0}=i)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;は状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;から始まって&lt;span class="math"&gt;\(n\)&lt;/span&gt;ステップ後に状態が&lt;span class="math"&gt;\(j\)&lt;/span&gt;になる確率を表しており、&lt;span class="math"&gt;\(n\)&lt;/span&gt;ステップ遷移確率と呼ぶ。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;!-- 空白のためのコメント... --&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;&lt;strong&gt;チャップマン−コルモゴロフ方程式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任意の状態&lt;span class="math"&gt;\(i,j \in X\)&lt;/span&gt;に対し、&lt;span class="math"&gt;\(n\)&lt;/span&gt;ステップ遷移確率&lt;span class="math"&gt;\(p_{ij}^{(n)}\)&lt;/span&gt;は次を満たす:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
p_{ij}^{(n)} = \sum_{r \in X} p_{ir}^{(k)}p_{rj}^{(n-k)} \quad 0 \leq k \leq n
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（証明）&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
p_{ij}^{(n)} &amp;amp;= P(\boldsymbol{x}_{n}=j|\boldsymbol{x}_{0}=i) =  \sum_{r \in X} P(\boldsymbol{x}_{n}=j, \boldsymbol{x}_{k}=r|\boldsymbol{x}_{0}=i) \quad (\because 確率分布の周辺化) \\
&amp;amp;= \sum_{r\in S} P(\boldsymbol{x}_{n}=j|\boldsymbol{x}_{k}=r, \boldsymbol{x}_{0}=i) P(\boldsymbol{x}_{k}=r|\boldsymbol{x}_{0}=i) \quad (\because ベイズの定理) \\
&amp;amp;= \sum_{r\in S} P(\boldsymbol{x}_{n}=j|\boldsymbol{x}_{k}=r) P(\boldsymbol{x}_{k}=r|\boldsymbol{x}_{0}=i) \quad (\because マルコフ性) \\
&amp;amp;= \sum_{r\in S} P(\boldsymbol{x}_{n-k}=j|\boldsymbol{x}_{0}=r) P(\boldsymbol{x}_{k}=r|\boldsymbol{x}_{0}=i) \quad (\because 斉時性) \\
&amp;amp;= \sum_{r\in S} p_{rj}^{(n-k)}p_{ir}^{(k)}
\end{align*}
&lt;/div&gt;
&lt;hr class="docutils" /&gt;
&lt;!-- 空白のためのコメント... --&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;&lt;strong&gt;到達可能、連結&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ある状態&lt;span class="math"&gt;\(i,j \in X\)&lt;/span&gt;に対して&lt;span class="math"&gt;\(p_{ij}^{(n)} &amp;gt; 0\)&lt;/span&gt;なる非負整数&lt;span class="math"&gt;\(n \geq 0\)&lt;/span&gt;が存在する時、状態&lt;span class="math"&gt;\(j\)&lt;/span&gt;は状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;から到達可能であると言い、&lt;span class="math"&gt;\(i\to j\)&lt;/span&gt;と表す。
また&lt;span class="math"&gt;\(i \to j \land j \to i\)&lt;/span&gt;ならば、&lt;span class="math"&gt;\(i\)&lt;/span&gt;と&lt;span class="math"&gt;\(j\)&lt;/span&gt;は連結しているといい、&lt;span class="math"&gt;\(i \leftrightarrow j\)&lt;/span&gt;と表す。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;連結関係は、反射性(&lt;span class="math"&gt;\(i \leftrightarrow i\)&lt;/span&gt;)、対称性(&lt;span class="math"&gt;\(i \leftrightarrow j \Leftrightarrow j \leftrightarrow i\)&lt;/span&gt;)、推移性(&lt;span class="math"&gt;\(i \leftrightarrow j \land j \leftrightarrow k \Rightarrow i \leftrightarrow k\)&lt;/span&gt;)が成り立つ。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;&lt;strong&gt;連結クラス（連結成分）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(X\)&lt;/span&gt;の部分集合&lt;span class="math"&gt;\(C \subseteq X\)&lt;/span&gt;において、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i \in C \land j \in C \implies i \leftrightarrow j\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(i \in C \land i \leftrightarrow j \implies j \in C\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が常に成立する時、&lt;span class="math"&gt;\(C\)&lt;/span&gt;を&lt;span class="math"&gt;\(X\)&lt;/span&gt;の連結クラス（連結成分）という。定義より、&lt;span class="math"&gt;\(C\)&lt;/span&gt;の要素は互いに連結している。また、連結クラス&lt;span class="math"&gt;\(C\)&lt;/span&gt;の任意の状態&lt;span class="math"&gt;\(i \in C\)&lt;/span&gt;から&lt;span class="math"&gt;\(j \notin C\)&lt;/span&gt;に到達できない時、&lt;span class="math"&gt;\(C\)&lt;/span&gt;は閉じていると言う。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;!-- 空白のためのコメント... --&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;&lt;strong&gt;規約性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(X\)&lt;/span&gt;内の全ての状態が単一の閉じた連結クラスに属する、即ち&lt;span class="math"&gt;\(X\)&lt;/span&gt;の全ての要素が互いに連結している時、そのマルコフ連鎖は規約であるという。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;!-- 空白のためのコメント... --&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;&lt;strong&gt;周期性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;状態&lt;span class="math"&gt;\(i \in X\)&lt;/span&gt;に対して&lt;span class="math"&gt;\(p_{ii}^{(n)} &amp;gt; 0\)&lt;/span&gt;となる（&lt;span class="math"&gt;\(n\)&lt;/span&gt;ステップ後に元の状態に戻る）&lt;span class="math"&gt;\(n\)&lt;/span&gt;の最大公約数&lt;span class="math"&gt;\(d\)&lt;/span&gt;を、状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;の周期と呼ぶ。&lt;span class="math"&gt;\(d = 1\)&lt;/span&gt;の時は状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;は非周期的と呼ばれ、&lt;span class="math"&gt;\(d \geq 2\)&lt;/span&gt;の時は周期的であると呼ばれる。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;!-- 空白のためのコメント... --&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;&lt;strong&gt;再帰的、過渡的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;確率変数&lt;span class="math"&gt;\(T_{j}\)&lt;/span&gt;を次で定義する:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
T_{j} = \min_{n} \{ n &amp;gt; 0 | \boldsymbol{x}_{n} = j \}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;即ち、離散時間マルコフ連鎖が初めて状態&lt;span class="math"&gt;\(j\)&lt;/span&gt;を訪れる時刻を表す。また、&lt;span class="math"&gt;\(T_{i}\)&lt;/span&gt;を用いて次の値を定義する:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
f_{i} &amp;amp;= P(T_{i} &amp;lt; \infty | \boldsymbol{x}_{0} = i) = \sum_{n=1}^{\infty}P(T_{i} = n|\boldsymbol{x}_{0}=i) \\
m_{i} &amp;amp;= \mathrm{E}[T_{i}|\boldsymbol{x}_{0}=i] = \sum_{k=0}^{\infty} k P(T_{i}=k|\boldsymbol{x}_{0}=i)
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(f_{i}\)&lt;/span&gt;は将来状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;に戻ってくる確率を表しており、&lt;span class="math"&gt;\(f_{i}=1\)&lt;/span&gt;ならば確率&lt;span class="math"&gt;\(1\)&lt;/span&gt;で状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;を訪れる（無限にしばしば訪れる）ので状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;は再帰的であるという。&lt;span class="math"&gt;\(f_{i} &amp;lt; 1\)&lt;/span&gt;ならば状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;は過渡的であるという。また、&lt;span class="math"&gt;\(m_{i}\)&lt;/span&gt;は初期状態が&lt;span class="math"&gt;\(i\)&lt;/span&gt;の時に、再び状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;に戻るまでの時間の期待値を表しており、&lt;span class="math"&gt;\(m_{i} &amp;lt; \infty\)&lt;/span&gt;ならば状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;は正再帰的（有限時間で&lt;span class="math"&gt;\(i\)&lt;/span&gt;に戻る）であるといい、&lt;span class="math"&gt;\(m_{i} = \infty\)&lt;/span&gt;ならば状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;は零再帰的であるという。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;!-- 空白のためのコメント... --&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;&lt;strong&gt;エルゴード的な離散時間マルコフ連鎖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;離散時間マルコフ連鎖&lt;span class="math"&gt;\(\boldsymbol{x}_{0}, \boldsymbol{x}_{1},\dots\)&lt;/span&gt;が規約かつ正再帰かつ非周期的であるならば、この離散時間マルコフ連鎖はエルゴード的とも呼ばれる&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;ここまでで用語の定義は揃ったので、それではエルゴード的なマルコフ連鎖の定常分布の存在についての定理を証明する。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;&lt;strong&gt;エルゴード的な離散時間マルコフ連鎖の定常分布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;離散時間マルコフ連鎖&lt;span class="math"&gt;\(\boldsymbol{x}_{0}, \boldsymbol{x}_{1}, \dots\)&lt;/span&gt;がエルゴード的ならば、任意の状態&lt;span class="math"&gt;\(i, j \in X\)&lt;/span&gt;について次が成り立つ:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\displaystyle\lim_{n \to \infty} p_{ij}^{(n)} = \lim_{n \to \infty} p_{jj}^{(n)} = \frac{1}{m_{j}} = \pi_{j}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\pi_{j}\)&lt;/span&gt;は&lt;span class="math"&gt;\(\displaystyle \pi_{j} = \sum_{i \in X} \pi_{i} p_{ij}\)&lt;/span&gt;と&lt;span class="math"&gt;\(\displaystyle\sum_{j \in X}\pi_{j} = 1\)&lt;/span&gt;を満たす解であり、唯一に定まる。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2.を満たす&lt;span class="math"&gt;\(\pi_{j}\)&lt;/span&gt;を極限分布（定常状態分布）と言う。&lt;/p&gt;
&lt;p&gt;一方、初期分布として&lt;span class="math"&gt;\(P(\boldsymbol{x}_{0} = j) = \pi_{j}\)&lt;/span&gt;を持つ離散時間マルコフ連鎖では、任意の&lt;span class="math"&gt;\(n \geq 1\)&lt;/span&gt;に対して&lt;span class="math"&gt;\(P(\boldsymbol{x}_{n}=j) = \pi_{j}\)&lt;/span&gt;が成り立ち、&lt;span class="math"&gt;\(\boldsymbol{x}_{n}\)&lt;/span&gt;は&lt;span class="math"&gt;\(n\)&lt;/span&gt;と独立した分布を持つ。この様に、時間に関して不変な分布&lt;span class="math"&gt;\(\pi_{j} = P(\boldsymbol{x}_{n} = j)\ n = 0,1,\dots\)&lt;/span&gt;を
&lt;strong&gt;定常分布&lt;/strong&gt; と呼ぶ。&lt;/p&gt;
&lt;p&gt;（証明）まず1.から考える。最初に&lt;span class="math"&gt;\(i\neq j\)&lt;/span&gt;なる状態に対して&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
u_{k} = P(T_{j} = k|\boldsymbol{x}_{0} = i)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を（初期状態が&lt;span class="math"&gt;\(i\)&lt;/span&gt;で、初めて&lt;span class="math"&gt;\(j\)&lt;/span&gt;に訪れる時刻が&lt;span class="math"&gt;\(k\)&lt;/span&gt;となる確率）おく。この時、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
p_{ij}^{(1)} &amp;amp;= u_{1} \\
p_{ij}^{(2)} &amp;amp;= u_{2} + u_{1} p_{jj}^{(1)} \\
p_{ij}^{(3)} &amp;amp;= u_{3} + u_{2}p_{jj}^{(1)} + u_{1}p_{jj}^{(2)} \\
&amp;amp;\vdots
\end{align*}
&lt;/div&gt;
&lt;p&gt;の観察により、&lt;span class="math"&gt;\(n \geq 1\)&lt;/span&gt;なる&lt;span class="math"&gt;\(n\)&lt;/span&gt;に対して帰納的に&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
p_{ij}^{(n)} = \sum_{k=1}^{n} u_{k} p_{jj}^{(n-k)}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成立する（最初の&lt;span class="math"&gt;\(k\)&lt;/span&gt;ステップで状態&lt;span class="math"&gt;\(j\)&lt;/span&gt;に行き、その後&lt;span class="math"&gt;\(n-k\)&lt;/span&gt;ステップ後に再び&lt;span class="math"&gt;\(j\)&lt;/span&gt;に行く）ことが分かる。また、任意の&lt;span class="math"&gt;\(i\)&lt;/span&gt;と&lt;span class="math"&gt;\(j\)&lt;/span&gt;は連結している（&lt;span class="math"&gt;\(i \leftrightarrow j\)&lt;/span&gt;）ので、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\sum_{k=1}^{\infty} u_{k} = P(\exists n \geq 0.\ \boldsymbol{x}_{n} = j | \boldsymbol{x}_{0} =i) = 1
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;から始まり、&lt;span class="math"&gt;\(j\)&lt;/span&gt;へいつかは訪れる確率は&lt;span class="math"&gt;\(1\)&lt;/span&gt;）が成り立つ。一方&lt;span class="math"&gt;\(p_{jj}^{(n)}\)&lt;/span&gt;は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
p_{jj}^{(n)} &amp;amp;= P(\boldsymbol{x}_{n} = j|\boldsymbol{x}_{0}=j) \\
&amp;amp;= \sum_{k=1}^{n}P(\boldsymbol{x}_{n}=j, T_{j} = k|\boldsymbol{x}_{0}=j) \quad (\because 確率分布の周辺化) \\
&amp;amp;= \sum_{k=1}^{n}P(\boldsymbol{x}_{n}=j|T_{j}=k, \boldsymbol{x}_{0}=j)P(T_{j}=k|\boldsymbol{x}_{0}=j) \quad (\because ベイズの定理) \\
&amp;amp;= \sum_{k=1}^{n}P(\boldsymbol{x}_{n}=j|\boldsymbol{x}_{k}=j, \boldsymbol{x}_{0}=j)P(T_{j}=k|\boldsymbol{x}_{0}=j) \quad (\because T_{j} = k \implies \boldsymbol{x}_{k} = j) \\
&amp;amp;= \sum_{k=1}^{n}P(\boldsymbol{x}_{n}=j|\boldsymbol{x}_{k}=j)P(T_{j}=k|\boldsymbol{x}_{0}=j) \quad (\because マルコフ性) \\
&amp;amp;= \sum_{k=1}^{n}p_{jj}^{(n-k)} u_{k}
\end{align*}
&lt;/div&gt;
&lt;p&gt;と展開できる。数列&lt;span class="math"&gt;\(p_{jj}^{(n)}\)&lt;/span&gt;の極限&lt;span class="math"&gt;\(\displaystyle\lim_{n \to \infty} p_{jj}^{(n)}\)&lt;/span&gt;を求める為、ここでは数列の
&lt;strong&gt;母関数&lt;/strong&gt;を定義し、（片側）Z変換の最終値定理  &lt;a class="footnote-reference" href="#footnote-24" id="footnote-reference-24"&gt;[24]&lt;/a&gt;
を用いる。その為、今、&lt;span class="math"&gt;\(\displaystyle G(z) = \sum_{n=0}^{\infty}p_{jj}^{(n)}z^{n},\ U(z) = \sum_{n=1}^{\infty}u_{n}z^{n}\)&lt;/span&gt;なる母関数を定義し、上式の両辺に&lt;span class="math"&gt;\(z^{n}\)&lt;/span&gt;を掛けて&lt;span class="math"&gt;\(n=1,2,\dots\)&lt;/span&gt;についての和を取ると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
（左辺）\sum_{n=1}^{\infty} p_{jj}^{(n)}z^{n} &amp;amp;= \sum_{n=1}^{\infty} p_{jj}^{(n)}z^{n} = \sum_{n=0}^{\infty}p_{jj}^{(n)}z^{n} - p_{jj}^{(0)} \\
&amp;amp;= G(z) - 1 \\
（右辺）\sum_{n=1}^{\infty} \sum_{k=1}^{n} p_{jj}^{(n-k)}u_{k}z^{n} &amp;amp;= \sum_{n=1}^{\infty} \sum_{k=1}^{n} p_{jj}^{(n-k)}z^{n-k}u_{k}z^{k} \\
&amp;amp;= G(z)U(z) \\
\therefore G(z) &amp;amp;= \frac{1}{1-U(z)}
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで、右辺式の最後の式変形には冪級数の積の公式 &lt;a class="footnote-reference" href="#footnote-25" id="footnote-reference-25"&gt;[25]&lt;/a&gt; を用いている。最終値定理を適用する事を考えると、この場合は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\lim_{n \to \infty} p_{jj}^{(n)} = \lim_{z \to 1}(1-z)G(z)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成立する &lt;a class="footnote-reference" href="#footnote-26" id="footnote-reference-26"&gt;[26]&lt;/a&gt;
ので、&lt;span class="math"&gt;\(\displaystyle\lim_{n \to \infty} p_{jj}^{(n)}\)&lt;/span&gt;の結果として、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\lim_{n \to \infty} p_{jj}^{(n)} &amp;amp;= \lim_{z \to 1}(1-z)G(z) = \lim_{z \to 1}\frac{1-z}{1-U(z)} \\
&amp;amp;= \lim_{z \to 1}\frac{\frac{d(1-z)}{dz}}{\frac{d(1-U(z))}{dz}} \quad (\because ロピタルの定理) \\
&amp;amp;= \lim_{z \to 1}\frac{1}{\frac{dU(z)}{dz}} = \frac{1}{m_{j}} = \pi_{j} \\
\because \lim_{z \to 1} \frac{dU(z)}{dz} &amp;amp;= \lim_{z \to 1}\sum_{n=1}^{\infty}n u_{n} z^{n-1} = \lim_{z \to 1}\sum_{n=0}^{\infty} n u_{n} z^{n} = \sum_{n=0}^{\infty}n u_{n} = m_{j}
\end{align*}
&lt;/div&gt;
&lt;p&gt;が得られる。さて、この結果より、任意の正数&lt;span class="math"&gt;\(\epsilon &amp;gt; 0\)&lt;/span&gt;に対して&lt;span class="math"&gt;\(n \geq N\)&lt;/span&gt;なる全ての&lt;span class="math"&gt;\(n\)&lt;/span&gt;が&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
|p_{jj}^{(n)} - \pi_{j}| \leq \frac{\epsilon}{2} \quad かつ \quad \sum_{k = N+1}^{\infty} u_{k} \leq \frac{\epsilon}{2}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を同時に満たすような&lt;span class="math"&gt;\(N\)&lt;/span&gt;を取ることができる。今、&lt;span class="math"&gt;\(n \geq 2N\)&lt;/span&gt;に対し、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
|p_{ij}^{(n)} - \pi_{j}| &amp;amp;= | \sum_{k=1}^{n} u_{k} p_{jj}^{(n-k)} - \pi_{j}| = | \sum_{k=1}^{n} u_{k} p_{jj}^{(n-k)} - \sum_{k=1}^{\infty}u_{k}\pi_{j}| \\
&amp;amp;= |\sum_{k=1}^{n-N}u_{k}(p_{jj}^{(n-k)}-\pi_{j}) + \sum_{k=n-N+1}^{n} u_{k}(p_{jj}^{(n-k)} - \pi_{j}) -\sum_{k=n+1}^{\infty}u_{k}\pi_{j}| \\
&amp;amp;\leq \sum_{k=1}^{n-N}u_{k}|p_{jj}^{(n-k)}-\pi_{j}| + \sum_{k=n-N+1}^{n} u_{k}|p_{jj}^{(n-k)} - \pi_{j}| + \sum_{k=n+1}^{\infty}|u_{k}\pi_{j}| \\
&amp;amp;\leq \sum_{k=1}^{n-N}u_{k}\frac{\epsilon}{2} + \sum_{k=n-N+1}^{n} u_{k} + \sum_{k=n+1}^{\infty}u_{k} = \frac{\epsilon}{2}\sum_{k=1}^{n-N}u_{k} + \sum_{k=n-N+1}^{\infty} u_{k} \\
&amp;amp;\leq \frac{\epsilon}{2} + \frac{\epsilon}{2} = \epsilon
\end{align*}
&lt;/div&gt;
&lt;p&gt;よって、&lt;span class="math"&gt;\(\displaystyle \lim_{n \to \infty} p_{ij}^{(n)} = \pi_{j} = \lim_{n \to \infty} p_{jj}^{(n)}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;次に2.
の&lt;span class="math"&gt;\(\pi_{j}\)&lt;/span&gt;の一意性を示す。まず、&lt;span class="math"&gt;\(\displaystyle \sum_{j \in X}p_{ij}^{(n)} = 1\)&lt;/span&gt;（どこかの状態には確率1で遷移している）より、この式で&lt;span class="math"&gt;\(n \to \infty\)&lt;/span&gt;ならしめれば、1.
により&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\sum_{j \in X} \pi_{j} = 1
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を得る。また、&lt;span class="math"&gt;\(a_{j}(n) = P(\boldsymbol{x}_{n} = j)\)&lt;/span&gt;（時刻&lt;span class="math"&gt;\(n\)&lt;/span&gt;で状態&lt;span class="math"&gt;\(j\)&lt;/span&gt;を訪れる確率）とおくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
a_{j}(n) &amp;amp;= \sum_{i \in X}P(\boldsymbol{x}_{0}=i)P(\boldsymbol{x}_{n}=j|\boldsymbol{x}_{0}=i) = \sum_{i \in X}P(\boldsymbol{x}_{0}=i)p_{ij}^{(n)} \\
\therefore \lim_{n \to \infty} a_{j}(n) &amp;amp;= \sum_{i \in X}P(\boldsymbol{x}_{0}=i) \lim_{n \to \infty}p_{ij}^{(n)} = \pi_{j} \sum_{i \in X} P(\boldsymbol{x}_{0} = i) = \pi_{j}
\end{align*}
&lt;/div&gt;
&lt;p&gt;が成立し、チャップマン−コルモゴロフ方程式により、&lt;span class="math"&gt;\(n, m \geq0\)&lt;/span&gt;なる整数に対し、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
a_{j}(m+n) &amp;amp;= \sum_{r \in X}P(\boldsymbol{x}_{0}=r)P(\boldsymbol{x_{m+n}}=j|\boldsymbol{x}_{0}=r) = \sum_{r \in X} P(\boldsymbol{x}_{0} = r) p_{rj}^{(m+n)} \\
&amp;amp;= \sum_{r \in X} P(\boldsymbol{x}_{0}=r) \sum_{i \in X} p_{ri}^{(m)}p_{ij}^{(n)} \quad (\because チャップマン-コルモゴロフ方程式を使用) \\
&amp;amp;= \sum_{i \in X}\sum_{r \in X}P(\boldsymbol{x}_{0}=r)p_{ri}^{(m)} p_{ij}^{(n)} = \sum_{i \in X} a_{i}(m) p_{ij}^{(n)}
\end{align*}
&lt;/div&gt;
&lt;p&gt;この式の両辺を&lt;span class="math"&gt;\(m \to \infty\)&lt;/span&gt;ならしめれば、極限と和の交換法則より、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\pi_{j} = \sum_{i \in X}\pi_{i} p_{ij}^{(n)}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を得る。特に&lt;span class="math"&gt;\(n=1\)&lt;/span&gt;とすれば、&lt;span class="math"&gt;\(\displaystyle \pi_{j} = \sum_{i \in X} \pi_{j} p_{ij}\)&lt;/span&gt;が得られる。
次に一意性を示す。今、&lt;span class="math"&gt;\(\pi_{i}^{\prime}\ (i \in X)\)&lt;/span&gt;が、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\pi_{j}^{\prime} = \sum_{i \in X}\pi_{i}^{\prime} p_{ij} \quad かつ \quad \sum_{i \in X} \pi_{i}^{\prime} = 1
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たすとする。上述の議論により、全ての正整数&lt;span class="math"&gt;\(n \geq 0\)&lt;/span&gt;に対し、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\pi_{j}^{\prime} = \sum_{i \in X}\pi_{i}^{\prime} p_{ij}^{(n)}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を得る。&lt;span class="math"&gt;\(n \to \infty\)&lt;/span&gt;とすると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\pi_{j}^{\prime} = \left(\sum_{i \in X}\pi_{i}^{\prime}\right) \pi_{j} = \pi_{j}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となって、一意性が示される。&lt;/p&gt;
&lt;/div&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-11"&gt;詳細釣り合い条件の証明&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最後に詳細釣り合い条件を示す。今、確率分布&lt;span class="math"&gt;\(r\)&lt;/span&gt;と遷移確率が&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
r_{i} p_{ij} = r_{j} p_{ji}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を満たしているとする。この時両辺ともに状態&lt;span class="math"&gt;\(i\)&lt;/span&gt;について和をとると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\sum_{i \in X} r_{i} p_{ij} = r_{j} \sum_{i \in X} p_{ji} = r_{j}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;2.により、&lt;span class="math"&gt;\(r\)&lt;/span&gt;は定常分布の解となっている事が分かる。&lt;/p&gt;
&lt;div class="section" id="section-9"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-12"&gt;脚注&lt;/a&gt;&lt;/h3&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://ebsa.ism.ac.jp/ebooks/sites/default/files/ebook/1881/pdf/vol3_ch10.pdf"&gt;古澄英雄, 「21世紀の統計科学」第Ⅲ巻 第10章
マルコフ連鎖モンテカルロ法入門&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://www-lsm.naist.jp/~kasahara/lecture/isp/part1.pdf"&gt;笠原正治,
確率過程論基礎&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://www.r.dl.itc.u-tokyo.ac.jp/~nakagawa/SML1/sampling1.pdf"&gt;中川裕志,
マルコフ連鎖モンテカルロ法&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://maildbs.c.u-tokyo.ac.jp/~fukushima/FSwiki/wiki.cgi?action=ATTACH&amp;amp;page=%BD%B8%C3%E6%B9%D6%B5%C1%A1%F7%C5%EC%B9%A9%C2%E7&amp;amp;file=TIT-2005-huku.pdf"&gt;福島孝治,
マルコフ連鎖モンテカルロ法の実践&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-5"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://www.slideshare.net/teramonagi/ss-5190440"&gt;tera monagi,
マルコフ連鎖モンテカルロ法入門-1&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-6"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;主に、確率分布の平均（期待値）、分散が対象となる&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-7"&gt;[7]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;十分な回数の独立な試行を行った経験分布は理論的（真の）分布に一致する、という法則。例えばコイン投げをひたすら繰り返せば、表及び裏が出る
&lt;strong&gt;頻度の比率&lt;/strong&gt;
はそれぞれ&lt;span class="math"&gt;\(1/2\)&lt;/span&gt;に近づいていく。厳密には大数の法則は2種類（強、弱法則）あり、確率の応用において非常に非常に重要な法則であるが、ここでは説明をしない。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-8"&gt;[8]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;確率変数のとる値が実数値でなくとも、事象が有限個存在（&lt;span class="math"&gt;\(\iff\)&lt;/span&gt;全事象が有限集合）する場合（例。サイコロとかコインを投げる試行）は議論で用いている分布を離散確率分布で考えれば良い。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-9"&gt;[9]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;起こりえる全ての事象の集合。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-10"&gt;[10]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;他の個人的に興味深い例：強化学習において&lt;span class="math"&gt;\(X\)&lt;/span&gt;を選択した行動列の集合、&lt;span class="math"&gt;\(h:X \to \mathbb{R}\)&lt;/span&gt;を報酬関数とすれば、&lt;span class="math"&gt;\(h(\boldsymbol{x})\)&lt;/span&gt;で行動列の報酬が計算でき、&lt;span class="math"&gt;\(I\)&lt;/span&gt;の計算結果は報酬の期待値となる。報酬の期待値が計算できることはエージェントの行動決定において大変有用である。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-11"&gt;[11]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;一様分布や正規分布等のよく知られた分布は、サンプリングアルゴリズムも確立されている。一様分布はメルセンヌ・ツイスタ、正規分布にはボックス-ミューラー法といった具合である。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-12" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-12"&gt;[12]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;空間の次元が増加すると、その空間の自由度が直感に反して &lt;strong&gt;指数的&lt;/strong&gt;
に増加すること。例えば、ユークリッド空間で一辺の長さが&lt;span class="math"&gt;\(a\)&lt;/span&gt;の&lt;span class="math"&gt;\(n\)&lt;/span&gt;次元超立方体を占める直径&lt;span class="math"&gt;\(a\)&lt;/span&gt;の超球体の割合を計算してみると&lt;span class="math"&gt;\(\frac{\sqrt{(\pi(a/2)^{2})^{n}}}{a^{n} \Gamma(\frac{n}{2}+1)}\)&lt;/span&gt;であり、&lt;span class="math"&gt;\(n\)&lt;/span&gt;を増加させると階乗オーダー（即ち、指数オーダーよりも早く）で減少する事が分かる。従って、一様乱数を用いていると、&lt;span class="math"&gt;\(n\)&lt;/span&gt;次元空間で超球体の内部にサンプルが入る確率が階乗オーダーで小さくなる。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-13" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-13"&gt;[13]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;厳密には、直前の1つのサンプルのみに依存するので1階マルコフ性と呼ばれる。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-14" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-14"&gt;[14]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;詳細は&lt;a class="reference external" href="#補足"&gt;補足&lt;/a&gt;で述べる。一般にエルゴード的とは、長時間に渡って観測した状態の平均（長時間平均）と、状態空間の平均（位相平均）が一致するという事を表す概念である。エルゴード理論がある様に、厳密な数学理論が展開されるが、ここではマルコフ連鎖以外については詳しくは説明しない（筆者がついていけてない）。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-15" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-15"&gt;[15]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;連続な状態空間では、遷移確率行列の代わりに&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
P(\boldsymbol{x}_{t+1} \in C|\boldsymbol{x}_{t} = \boldsymbol{e}_{t}) = \int_{C} T(\boldsymbol{e}_{t}, \boldsymbol{y}) d \boldsymbol{y} \quad C \subset X, \boldsymbol{e}_{t} \in X
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;となる様な条件付き確率分布&lt;span class="math"&gt;\(T(\boldsymbol{x}, \boldsymbol{y})\)&lt;/span&gt;（遷移核）を用いれば良い。&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-16" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-16"&gt;[16]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;形式的に書くと、状態&lt;span class="math"&gt;\(j \in X\)&lt;/span&gt;の定常分布&lt;span class="math"&gt;\(\pi_{j}\)&lt;/span&gt;は&lt;span class="math"&gt;\(\pi_{j} = P(\boldsymbol{x}_{n} = j)\ n=0,1,\dots\)&lt;/span&gt;と表される。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-17" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-17"&gt;[17]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;例えば、現在状態を中心とした正規分布からでの乱択でも3つの性質を満たし、マルコフ連鎖はエルゴード的となる。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-18" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-18"&gt;[18]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;これが詳細釣り合い条件を満たすことは、場合分けにより分かる:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\alpha(i \to j) = 1\)&lt;/span&gt;の時： &lt;span class="math"&gt;\(\alpha(j \to i) = \frac{r_{i}q_{ij}}{r_{j}q_{ji}}\)&lt;/span&gt;となるので、&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
p_{ji} = q_{ji} \alpha(j \to i) = q_{ji} \frac{r_{i}q_{ij}}{r_{j}q_{ji}} = \frac{r_{i}}{r_{j}}q_{ij} = \frac{r_{i}}{r_{j}} p_{ij}  \iff r_{i}p_{ij} = r_{j}p_{ji}
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\alpha(i \to j) = \frac{r_{j}q_{ji}}{r_{i}q_{ij}}\)&lt;/span&gt;の時： &lt;span class="math"&gt;\(\alpha(j \to i) = 1\)&lt;/span&gt;となるので、&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="last math"&gt;
\begin{equation*}
p_{ij} = q_{ij} \alpha(i \to j) = q_{ij} \frac{r_{j}q_{ji}}{r_{i}q_{ij}} = \frac{r_{j}}{r_{i}}q_{ji} = \frac{r_{j}}{r_{i}} p_{ji}  \iff r_{i}p_{ij} = r_{j}p_{ji}
\end{equation*}
&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-19" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-19"&gt;[19]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;温度パラメタの調節は非常に難しい事が知られている。実験結果を見て経験的に設定される事がほとんどである。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-20" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-20"&gt;[20]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;分散パラメタの調節も非常に難しい。分散を大きくすると遷移幅（ステップサイズという）が大きくなって定常分布に落ち着くまでに時間が掛かり、分散を小さくし過ぎると遷移の動きが小さく、探索が十分に行われない危険性がある。一般に分散パラメタと温度パラメタにはトレードオフの関係がある。&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-21" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-21"&gt;[21]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(q_{ij} = q_{ji}\)&lt;/span&gt;が成立する理由は、この場合&lt;span class="math"&gt;\(j\)&lt;/span&gt;は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
j = i + \varepsilon \quad \varepsilon \sim {\cal N}(\boldsymbol{0}, \sigma^{2} \boldsymbol{I})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と書けるので、平均が&lt;span class="math"&gt;\(\boldsymbol{0}\)&lt;/span&gt;かつ正規分布の対称性により、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
i = j - \varepsilon = j + \varepsilon
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;よって&lt;span class="math"&gt;\(q_{ij} = {\cal N}(i, \sigma^{2}\boldsymbol{I}) = {\cal N}(j, \sigma^{2}\boldsymbol{I}) = q_{ji}\)&lt;/span&gt;を満たす&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-22" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-22"&gt;[22]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;機械学習では、ベイジアンネットワークやボルツマンマシン（深層学習の一部）等のモデル学習に使われる&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-23" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-23"&gt;[23]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;毎回ランダムで選んでも、順番に全変数を1個ずつ選んでも良い&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-24" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-24"&gt;[24]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;数列&lt;span class="math"&gt;\(a_{n}\)&lt;/span&gt;の母関数を&lt;span class="math"&gt;\(F(z) = \displaystyle\sum_{n=0}^{\infty}a_{n}z^{n}\)&lt;/span&gt;とする。今、複素数&lt;span class="math"&gt;\(s \in \mathbb{C}\)&lt;/span&gt;を用いて&lt;span class="math"&gt;\(z = \exp(-s)\)&lt;/span&gt;とおき、&lt;span class="math"&gt;\(n\)&lt;/span&gt;の和を&lt;span class="math"&gt;\(t\)&lt;/span&gt;の積分に置き換えると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F(\exp(-s)) = \int_{0}^{\infty} a_{t}\exp(-st) dt
\end{equation*}
&lt;/div&gt;
&lt;p class="last"&gt;これは数列&lt;span class="math"&gt;\(a_{t}\)&lt;/span&gt;のラプラス変換に他ならない。従ってラプラス変換の最終値定理を適用できる。離散の場合のラプラス変換を（片側）Z変換と呼ぶ。&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-25" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-25"&gt;[25]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;2つの冪級数を&lt;span class="math"&gt;\(\displaystyle\sum_{n=0}^{\infty}a_{n}z^{n}, \sum_{n=0}^{\infty}b_{n}z^{n}\)&lt;/span&gt;とし、積の結果を&lt;span class="math"&gt;\(\displaystyle\sum_{n=0}^{\infty}c_{n}z^{n}\)&lt;/span&gt;とする。等号を立てると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\left(\sum_{n=0}^{\infty}a_{n}z^{n}\right)\left(\sum_{n=0}^{\infty}b_{n}z^{n} \right) &amp;amp;= a_{0}b_{0}z^{0} + (a_{0}b_{1} + a_{1}b_{0})z^{1} + (a_{0}b_{2}+a_{1}b_{1}+a_{2}b_{0})z^{2} + \dots \\
  &amp;amp;= \sum_{n=0}^{\infty}c_{n}z^{n} = c_{0}z^{0} + c_{1}z^{1} + c_{2}z^{2} + \dots
\end{align*}
&lt;/div&gt;
&lt;p class="last"&gt;係数比較により、&lt;span class="math"&gt;\(c_{0} = a_{0}b_{0},\ c_{1} = a_{0}b_{1} + a_{1}b_{0},\ \dots\)&lt;/span&gt;が成立し、よって&lt;span class="math"&gt;\(c_{n} = \displaystyle \sum_{k=0}^{n}a_{k}b_{n-k}\)&lt;/span&gt;となる。ここの例では、&lt;span class="math"&gt;\(a_{k} = u_{k}z^{k},\ b_{k} = p_{jj}^{(k)}z^{k}\)&lt;/span&gt;とおけば良い。&lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-26" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-26"&gt;[26]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;p class="first"&gt;（証明）母関数（Z変換）を&lt;span class="math"&gt;\(F(z) = \displaystyle \sum_{n=0}^{\infty}a_{n}z^{n}\)&lt;/span&gt;とおくと、&lt;/p&gt;
&lt;div class="last math"&gt;
\begin{align*}
\lim_{z \to 1} (1-z) F(z) &amp;amp;= \lim_{z \to 1}(1-z) \sum_{n=0}^{\infty} a_{n}z^{n} = \lim_{z \to 1} \sum_{n=0}^{\infty} a_{n} (z^{n} - z^{n+1}) = \lim_{z \to 1} \lim_{n \to \infty} \sum_{k=0}^{n} a_{k} (z^{k} - z^{k+1}) \\
&amp;amp;= \lim_{z \to 1} \lim_{n \to \infty} \sum_{k=0}^{n} (a_{k} - a_{k-1}) z^{k} \quad (\because a_{-1} = 0, また a_{0}(z^{0}-z^{1}) + a_{1}(z^{1}-z^{2}) +\dots = a_{0}z^{0} + (a_{0}-a_{1})z^{1} + \dots) \\
&amp;amp;= \lim_{n \to \infty} \sum_{k=0}^{n} (a_{k} - a_{k-1}) = \lim_{n \to \infty} a_{n}
\end{align*}
&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="記事"></category><category term="統計"></category></entry><entry><title>LPC（Linear Predictive Coding, 線形予測符号化）</title><link href="/lpclinear-predictive-coding-xian-xing-yu-ce-fu-hao-hua.html" rel="alternate"></link><published>2020-04-23T12:10:00+09:00</published><updated>2020-04-23T12:10:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-23:/lpclinear-predictive-coding-xian-xing-yu-ce-fu-hao-hua.html</id><summary type="html">&lt;p class="first last"&gt;線形予測符号化についての理論的概要とかんたんな実装例。ハイパー古い技術。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;線形予測分析等とも言及される。&lt;/p&gt;
&lt;p&gt;英語版で決定的に簡単な資料は&lt;a class="reference external" href="http://www.emptyloop.com/technotes/A%20tutorial%20on%20linear%20prediction%20and%20Levinson-Durbin.pdf"&gt;ここ&lt;/a&gt;で見れます。ここの解説はその日本語訳以下の何かです。英語が読める人はそっちを見たほうが絶対早いです。&lt;/p&gt;
&lt;p&gt;ここよりも良い資料が有ります：（&lt;a class="reference external" href="http://aidiary.hatenablog.com/entry/20120415/1334458954"&gt;人工知能に関する断創録&lt;/a&gt;）&lt;/p&gt;
&lt;div class="contents local topic" id="topic-1"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-1" id="toc-entry-1"&gt;アルゴリズムの導出&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-2" id="toc-entry-2"&gt;問題設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-3" id="toc-entry-3"&gt;誤差の最小化&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-4" id="toc-entry-4"&gt;偏微分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#levinson-durbin-levinson-durbin-recursion" id="toc-entry-5"&gt;Levinson-Durbin再帰（Levinson-Durbin recursion）へ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#levinson-durbin" id="toc-entry-6"&gt;Levinson-Durbin再帰&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#k-1" id="toc-entry-7"&gt;k=1の時&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#k" id="toc-entry-8"&gt;一般のkの時&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-5" id="toc-entry-9"&gt;アルゴリズム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-6" id="toc-entry-10"&gt;補足&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-7" id="toc-entry-11"&gt;周波数特性の導出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-8" id="toc-entry-12"&gt;標本自己相関の計算&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-9" id="toc-entry-13"&gt;参考資料リスト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-10" id="toc-entry-14"&gt;実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-11" id="toc-entry-15"&gt;実験&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-1"&gt;アルゴリズムの導出&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-2"&gt;問題設定&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;時間について離散化した信号が&lt;span class="math"&gt;\(y_{0}, y_{1}, ..., y_{n}\)&lt;/span&gt;として得られたとする。ここで、&lt;span class="math"&gt;\(y_{n}\)&lt;/span&gt;を直前の&lt;span class="math"&gt;\(y_{i}\ (i=0,...,n-1)\)&lt;/span&gt;によって予測する事を考える。&lt;/p&gt;
&lt;p&gt;予測にあたって、線形予測では&lt;span class="math"&gt;\(k\)&lt;/span&gt;個の係数&lt;span class="math"&gt;\(a_{1},...,a_{k}\)&lt;/span&gt;を用いた単純な線形結合&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
-a_{1}y_{n-1} - a_{2}y_{n-2} - ... - a_{k}y_{n-k} = - \sum_{i=1}^{k} a_{i} y_{n-i}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;によって&lt;span class="math"&gt;\(y_{n}\)&lt;/span&gt;を近似する：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
y_{n} \approx - \sum_{i=1}^{k} a_{i} y_{n-i}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（係数に負号&lt;span class="math"&gt;\(-\)&lt;/span&gt;が付いているのは、システムのフィードバック係数として捉えた時は負を付けるのが常識となっているからと考えられる。全ての係数の符号を反転させれば通常の和に戻るので、以下の導出にとって本質的な問題にならない。）&lt;/p&gt;
&lt;p&gt;予測の&lt;strong&gt;誤差&lt;/strong&gt;は、全ての&lt;span class="math"&gt;\(n\)&lt;/span&gt;における&lt;strong&gt;二乗誤差&lt;/strong&gt;の和&lt;span class="math"&gt;\(E\)&lt;/span&gt;によって測る：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{split}
E &amp;amp;= \sum_{n=-\infty}^{\infty} \left[ y_{n} - \left\{ -\sum_{i=1}^{k} a_{i} y_{n-i} \right\} \right]^{2} \\
&amp;amp;= \sum_{n=-\infty}^{\infty} \left\{ y_{n} + \sum_{i=1}^{k}a_{i}y_{n-i} \right\}^{2}
\end{split}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで&lt;span class="math"&gt;\(a_{0} = 1\)&lt;/span&gt;と定義すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
E = \sum_{n=-\infty}^{\infty} \left\{\sum_{i=0}^{k}a_{i}y_{n-i}\right\}^{2}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とまとめられる。後は、この&lt;span class="math"&gt;\(E\)&lt;/span&gt;を最小化するように係数&lt;span class="math"&gt;\(a_{1},...,a_{k}\)&lt;/span&gt;を定めれば良い。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-3"&gt;誤差の最小化&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-4"&gt;偏微分&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;誤差の最小化を考える。常套手段ではあるが、&lt;span class="math"&gt;\(E\)&lt;/span&gt;を&lt;span class="math"&gt;\(a_{j} \ (j=1,...,k)\)&lt;/span&gt;によって偏微分し、その結果を&lt;span class="math"&gt;\(0\)&lt;/span&gt;とおいて解くことを考える。まず、&lt;span class="math"&gt;\(E\)&lt;/span&gt;の偏微分は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{split}
\frac{\partial E}{\partial a_{j}} &amp;amp;= \sum_{n=-\infty}^{\infty} \frac{\partial}{\partial a_{j}} \left\{\sum_{i=0}^{k}a_{i}y_{n-i} \right\}^{2} \\
&amp;amp;= \sum_{n=-\infty}^{\infty} \frac{\partial}{\partial a_{j}} \left\{ a_{0}y_{n} + ... + a_{j}y_{n-j} + ... + a_{k}y_{n-k} \right\}^{2} \\
&amp;amp;= \sum_{n=-\infty}^{\infty} 2 y_{n-j} \sum_{i=0}^{k}a_{i}y_{n-i} \\
&amp;amp;= 2 \sum_{i=0}^{k}a_{i} \sum_{n=-\infty}^{\infty} y_{n-j} y_{n-i} \quad (\because \text{和の順序交換}) \\
&amp;amp;= 2 \sum_{i=0}^{k}a_{i} \sum_{n^{\prime}=-\infty}^{\infty} y_{n^{\prime}} y_{n^{\prime}+j-i} \quad (n^{\prime} = n-j \ \text{とおいた})
\end{split}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで、&lt;span class="math"&gt;\(R_{l}\)&lt;/span&gt;を次の式で定義する：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
R_{l} = \sum_{n=-\infty}^{\infty} y_{n} y_{n+l}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;（&lt;strong&gt;自己相関&lt;/strong&gt;
という。）&lt;span class="math"&gt;\(R_{l}\)&lt;/span&gt;を用いることで、偏微分の結果は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\partial E}{\partial a_{j}} = 2 \sum_{i=0}^{k} a_{i}R_{|j-i|}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表せる。&lt;/p&gt;
&lt;p&gt;次に、&lt;span class="math"&gt;\(\displaystyle\frac{\partial E}{\partial a_{j}} = 0\ (j=1,...,k)\)&lt;/span&gt;とおいて解く事を考える。和の前に付いている係数&lt;span class="math"&gt;\(2\)&lt;/span&gt;は両辺&lt;span class="math"&gt;\(2\)&lt;/span&gt;で割ることで消すことが出来る。その上で&lt;span class="math"&gt;\(j=1,...,k\)&lt;/span&gt;での式を並べてみると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{split}
a_{0}R_{|0-1|} + a_{1}R_{|1-1|} + ... + a_{k}R_{|k-1|} &amp;amp;= 0 \\
a_{0}R_{|0-2|} + a_{1}R_{|1-2|} + ... + a_{k}R_{|k-2|} &amp;amp;= 0 \\
\vdots \\
a_{0}R_{|0-k|} + a_{1}R_{|1-k|} + ... + a_{k}R_{|k-k|} &amp;amp;= 0 \\
\end{split}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;より、行列形式で&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{bmatrix}
R_{1} &amp;amp; R_{0} &amp;amp; R_{1} &amp;amp; ... &amp;amp; R_{k-1} \\
R_{2} &amp;amp; R_{1} &amp;amp; R_{0} &amp;amp; ... &amp;amp; R_{k-2} \\
\vdots &amp;amp;      &amp;amp;  &amp;amp; \ddots   &amp;amp; \vdots  \\
R_{k} &amp;amp; R_{k-1} &amp;amp; R_{k-2} &amp;amp; ... &amp;amp; R_{0}
\end{bmatrix}
\begin{bmatrix}
1 \\ a_{1} \\ a_{2} \\ \vdots \\ a_{k}
\end{bmatrix}
= \vec{0}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表せられる。以下、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
M =
\begin{bmatrix}
R_{1} &amp;amp; R_{0} &amp;amp; ... &amp;amp; R_{k-1} \\
R_{2} &amp;amp; R_{1} &amp;amp; ... &amp;amp; R_{k-2} \\
\vdots &amp;amp;      &amp;amp;  \ddots &amp;amp; \vdots  \\
R_{k} &amp;amp; R_{k-1} &amp;amp; ... &amp;amp; R_{0}
\end{bmatrix}
\ , \
\vec{a}_{k} =
\begin{bmatrix}
1 \\ a_{1} \\ a_{2} \\ \vdots \\ a_{k}
\end{bmatrix}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;として、&lt;span class="math"&gt;\(M\vec{a}_{k} = \vec{0}\)&lt;/span&gt;を解くことを考える。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="levinson-durbin-levinson-durbin-recursion"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-5"&gt;Levinson-Durbin再帰（Levinson-Durbin recursion）へ&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;上までで求まった連立方程式&lt;span class="math"&gt;\(M\vec{a}\_{k+1} = \vec{0}\)&lt;/span&gt;をもう少し整理していく。数値解法的には、&lt;span class="math"&gt;\(M\)&lt;/span&gt;は正方行列にしておくのが望ましい。そこで、&lt;span class="math"&gt;\(M\)&lt;/span&gt;の一番上の行に&lt;span class="math"&gt;\([R_{0} R_{1} ... R_{k}]\)&lt;/span&gt;を追加すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\begin{split}
M\vec{a}_{k} &amp;amp;=
\begin{bmatrix}
R_{1} &amp;amp; R_{0} &amp;amp; ... &amp;amp; R_{k-1} \\
R_{2} &amp;amp; R_{1} &amp;amp; ... &amp;amp; R_{k-2} \\
\vdots &amp;amp;      &amp;amp;  \ddots &amp;amp; \vdots  \\
R_{k} &amp;amp; R_{k-1} &amp;amp; ... &amp;amp; R_{0}
\end{bmatrix}
\begin{bmatrix}
1 \\ a_{1} \\ a_{2} \\ \vdots \\ a_{k}
\end{bmatrix}
\\&amp;amp;=
\begin{bmatrix}
R_{0} &amp;amp; R_{1} &amp;amp; ... &amp;amp; R_{k}   \\
R_{1} &amp;amp; R_{0} &amp;amp; ... &amp;amp; R_{k-1} \\
\vdots &amp;amp;       &amp;amp; \ddots   &amp;amp; \vdots  \\
R_{k} &amp;amp; R_{k-1} &amp;amp; ... &amp;amp; R_{0}
\end{bmatrix}
\begin{bmatrix}
1 \\ a_{1} \\ a_{2} \\ \vdots \\ a_{k}
\end{bmatrix}
-\begin{bmatrix}
\sum_{i=0}^{k}a_{i}R_{i} \\ 0 \\ 0 \\ \vdots \\ 0
\end{bmatrix}
= \vec{0}
\end{split}
\end{align*}
&lt;/div&gt;
&lt;p&gt;と変形できる。よって、次の連立方程式を解くことに帰着できる：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{bmatrix}
R_{0} &amp;amp; R_{1} &amp;amp; ... &amp;amp; R_{k}   \\
R_{1} &amp;amp; R_{0} &amp;amp; ... &amp;amp; R_{k-1} \\
\vdots &amp;amp;       &amp;amp; \ddots   &amp;amp; \vdots  \\
R_{k} &amp;amp; R_{k-1} &amp;amp; ... &amp;amp; R_{0}
\end{bmatrix}
\begin{bmatrix}
1 \\ a_{1} \\ a_{2} \\ \vdots \\ a_{k}
\end{bmatrix}
=\begin{bmatrix}
\sum_{i=0}^{k}a_{i}R_{i} \\ 0 \\ 0 \\ \vdots \\ 0
\end{bmatrix}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この連立方程式を高速に解くアルゴリズムが、Levinson-Durbin再帰法である。以下、&lt;span class="math"&gt;\(e_{k} = \sum_{i=0}^{k} a_{i} R_{i}\)&lt;/span&gt;とし、また行列&lt;span class="math"&gt;\(N_{k}\)&lt;/span&gt;を次で定義する：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
N_{k} =
\begin{bmatrix}
R_{0} &amp;amp; R_{1} &amp;amp; ... &amp;amp; R_{k}   \\
R_{1} &amp;amp; R_{0} &amp;amp; ... &amp;amp; R_{k-1} \\
\vdots &amp;amp;       &amp;amp; \ddots   &amp;amp; \vdots  \\
R_{k} &amp;amp; R_{k-1} &amp;amp; ... &amp;amp; R_{0}
\end{bmatrix}
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="levinson-durbin"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-6"&gt;Levinson-Durbin再帰&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;このアルゴリズムは、数学的帰納法によく似ている：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(k=1\)&lt;/span&gt;の場合で係数を求める&lt;/li&gt;
&lt;li&gt;一般の&lt;span class="math"&gt;\(k\)&lt;/span&gt;で係数が求まったとし、その結果から&lt;span class="math"&gt;\(k+1\)&lt;/span&gt;で係数を求める&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（&lt;a class="reference external" href="http://www.emptyloop.com/technotes/A%20tutorial%20on%20linear%20prediction%20and%20Levinson-Durbin.pdf"&gt;参考資料&lt;/a&gt;で筆者は、「Levinson-Durbin帰納法と言ったほうがいいんじゃないか」と書いてあった。）ここでは、1.および2.の場合の解をそれぞれ見ていく。&lt;/p&gt;
&lt;div class="section" id="k-1"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-7"&gt;k=1の時&lt;/a&gt;&lt;/h4&gt;
&lt;div class="math"&gt;
\begin{equation*}
\vec{a}_{1}=
\begin{bmatrix}
 1 \\
 a_{1}
\end{bmatrix}
,\
N_{1}\vec{a}_{1}=
\begin{bmatrix}
 e_{1} \\
 0
\end{bmatrix}
,\
N_{1}=
\begin{bmatrix}
 R_{0} &amp;amp; R_{1} \\
 R_{1} &amp;amp; R_{0}
\end{bmatrix}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;より、実際に&lt;span class="math"&gt;\(N_{1}\vec{a}_{1}\)&lt;/span&gt;を計算してみると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
N_{1}\vec{a}_{1}=
\begin{bmatrix}
 R_{0} + R_{1}a_{1} \\
 R_{1} + R_{0}a_{1}
\end{bmatrix}=
\begin{bmatrix}
 e_{1} \\
 0
\end{bmatrix}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;より、&lt;span class="math"&gt;\(e_{1} = R_{0} + R_{1}a_{1}\)&lt;/span&gt;、及び&lt;span class="math"&gt;\(R_{1} + R_{0}a_{1} = 0\)&lt;/span&gt;から&lt;span class="math"&gt;\(a_{1} = -\displaystyle\frac{R_{1}}{R_{0}}\)&lt;/span&gt;と求められる。（&lt;span class="math"&gt;\(R_{0} = \displaystyle\sum_{n=-\infty}^{\infty}y_{n}^{2} &amp;gt; 0\)&lt;/span&gt;より、至る所ゼロ除算の心配はない）&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="k"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-8"&gt;一般のkの時&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;仮定として、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
N_{k}\vec{a}_{k}=
\begin{bmatrix}
R_{0} &amp;amp; R_{1} &amp;amp; ... &amp;amp; R_{k}   \\
R_{1} &amp;amp; R_{0} &amp;amp; ... &amp;amp; R_{k-1} \\
\vdots &amp;amp;       &amp;amp; \ddots   &amp;amp; \vdots  \\
R_{k} &amp;amp; R_{k-1} &amp;amp; ... &amp;amp; R_{0}
\end{bmatrix}
\begin{bmatrix}
1 \\ a_{1} \\ a_{2} \\ \vdots \\ a_{k}
\end{bmatrix}
=\begin{bmatrix}
e_{k} \\ 0 \\ 0 \\ \vdots \\ 0
\end{bmatrix}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成立していたとする。&lt;span class="math"&gt;\(k+1\)&lt;/span&gt;の時、行列&lt;span class="math"&gt;\(N_{k+1}\)&lt;/span&gt;は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
N_{k+1}=
\begin{bmatrix}
R_{0} &amp;amp; R_{1} &amp;amp; ... &amp;amp; R_{k} &amp;amp; R_{k+1}   \\
R_{1} &amp;amp; R_{0} &amp;amp; ... &amp;amp; R_{k-1} &amp;amp; R_{k} \\
\vdots &amp;amp;       &amp;amp; \ddots  &amp;amp; &amp;amp; \vdots  \\
R_{k} &amp;amp; R_{k-1} &amp;amp; ... &amp;amp; R_{0} &amp;amp; R_{1} \\
R_{k+1} &amp;amp; R_{k} &amp;amp; ... &amp;amp; R_{1} &amp;amp; R_{0}
\end{bmatrix}=
\left[
\begin{array}{cccc|c}
 &amp;amp; &amp;amp; &amp;amp; &amp;amp; R_{k+1}   \\
 &amp;amp; N_{k} &amp;amp; &amp;amp; &amp;amp; R_{k} \\
 &amp;amp; &amp;amp; &amp;amp; &amp;amp; \vdots  \\
 &amp;amp; &amp;amp; &amp;amp; &amp;amp; R_{1} \\\hline
R_{k+1} &amp;amp; R_{k} &amp;amp; ... &amp;amp; R_{1} &amp;amp; R_{0}
\end{array}
\right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となり、&lt;span class="math"&gt;\(N_{k}\)&lt;/span&gt;の行・列共に1つ増えた行列となる。&lt;/p&gt;
&lt;p&gt;一方の&lt;span class="math"&gt;\(\vec{a}_{k+1}\)&lt;/span&gt;は未知である。そこで、技巧的ではあるが次&lt;span class="math"&gt;\(\vec{a}\_{k}\)&lt;/span&gt;を&lt;span class="math"&gt;\(0\)&lt;/span&gt;を追加する事で拡張した次のベクトル&lt;span class="math"&gt;\(\vec{u}\_{k+1}, \vec{v}\_{k+1}\)&lt;/span&gt;を用いる事を考える：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\vec{u}_{k+1}=
\begin{bmatrix}
1 \\ a_{1} \\ a_{2} \\ \vdots \\ a_{k} \\ 0
\end{bmatrix}\ ,\
\vec{v}_{k+1}=
\begin{bmatrix}
0 \\ a_{k} \\ \vdots \\ a_{2} \\ a_{1} \\ 1
\end{bmatrix}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\vec{u}\_{k+1}, \vec{v}\_{k+1}\)&lt;/span&gt;は互いに要素を反転したベクトルである（互いに&lt;strong&gt;一次独立&lt;/strong&gt;で有ることにも注目）。これら&lt;span class="math"&gt;\(\vec{u}\_{k+1}, \vec{v}\_{k+1}\)&lt;/span&gt;を用いて&lt;span class="math"&gt;\(N\_{k+1}\vec{u}\_{k+1}\)&lt;/span&gt;と&lt;span class="math"&gt;\(N_{k+1}\vec{v}\_{k+1}\)&lt;/span&gt;を計算すると、まず&lt;span class="math"&gt;\(N\_{k+1}\vec{u}\_{k+1}\)&lt;/span&gt;は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\begin{split}
N_{k+1}\vec{u}_{k+1}&amp;amp;=
\left[
\begin{array}{cccc|c}
 &amp;amp; &amp;amp; &amp;amp; &amp;amp; R_{k+1}   \\
 &amp;amp; N_{k} &amp;amp; &amp;amp; &amp;amp; R_{k} \\
 &amp;amp; &amp;amp; &amp;amp; &amp;amp; \vdots  \\
 &amp;amp; &amp;amp; &amp;amp; &amp;amp; R_{1} \\\hline
R_{k+1} &amp;amp; R_{k} &amp;amp; ... &amp;amp; R_{1} &amp;amp; R_{0}
\end{array}
\right]
\begin{bmatrix}
1 \\ a_{1} \\ a_{2} \\ \vdots \\ a_{k} \\ 0
\end{bmatrix}\\
&amp;amp;=
\begin{bmatrix}
 \\  \\ N_{k}\vec{a}_{k} \\  \\  \\ \hline [R_{k+1} R_{k} ... R_{1}] \vec{a}_{k}
\end{bmatrix}=
\begin{bmatrix}
e_{k} \\ 0 \\ \vdots \\ 0 \\  \displaystyle\sum_{j=0}^{k} a_{j} R_{k+1-j}
\end{bmatrix}
\end{split}
\end{align*}
&lt;/div&gt;
&lt;p&gt;であり、もう一方の&lt;span class="math"&gt;\(N\_{k+1}\vec{v}\_{k+1}\)&lt;/span&gt;は、&lt;span class="math"&gt;\(N\_{k+1}\)&lt;/span&gt;が&lt;strong&gt;対称行列&lt;/strong&gt;なので&lt;span class="math"&gt;\(N\_{k+1}\vec{u}\_{k+1}\)&lt;/span&gt;の結果を反転したベクトルとなる：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
N_{k+1}\vec{v}_{k+1}=
\begin{bmatrix}
\displaystyle\sum_{j=0}^{k} a_{j} R_{k+1-j} \\ 0 \\ \vdots \\ 0 \\ e_{k}
\end{bmatrix}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;そして、&lt;span class="math"&gt;\(\vec{a}\_{k+1}\)&lt;/span&gt;は&lt;span class="math"&gt;\(\vec{u}\_{k+1}\)&lt;/span&gt;と&lt;span class="math"&gt;\(\vec{v}\_{k+1}\)&lt;/span&gt;の線形結合で表現できる：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\vec{a}_{k+1} = \vec{u}_{k+1} + \lambda \vec{v}_{k+1} \quad (\lambda : 実数)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これは、実際に&lt;span class="math"&gt;\(N\_{k+1}(\vec{u}\_{k+1} + \lambda \vec{v}\_{k+1})\)&lt;/span&gt;を計算することで確かめられる：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
N_{k+1}(\vec{u}_{k+1} + \lambda \vec{v}_{k+1}) = N_{k+1}\vec{u}_{k+1} + N_{k+1}\lambda \vec{v}_{k+1}=
\begin{bmatrix}
e_{k} + \lambda \displaystyle\sum_{j=0}^{k} a_{j} R_{k+1-j} \\ 0 \\ \vdots \\ 0 \\ \displaystyle\sum_{j=0}^{k} a_{j} R_{k+1-j} + \lambda e_{k}
\end{bmatrix}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで&lt;span class="math"&gt;\(\lambda = - \displaystyle\frac{\sum_{j=0}^{k} a_{j} R_{k+1-j}}{e_{k}}\)&lt;/span&gt;とすれば、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
N_{k+1}(\vec{u}_{k+1} + \lambda \vec{v}_{k+1}) =
\begin{bmatrix}
e_{k} - \lambda^{2} e_{k} \\ 0 \\ \vdots \\ 0 \\ \displaystyle\sum_{j=0}^{k} a_{j} R_{k+1-j} - \displaystyle\sum_{j=0}^{k} a_{j} R_{k+1-j}
\end{bmatrix}=
\begin{bmatrix}
(1-\lambda^{2}) e_{k} \\ 0 \\ \vdots  \\ 0
\end{bmatrix}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となって&lt;span class="math"&gt;\(e\_{k+1}\)&lt;/span&gt;が求まる。同時に右辺の結果を与える&lt;span class="math"&gt;\(\lambda\)&lt;/span&gt;は唯一つしか存在しないので、この時の&lt;span class="math"&gt;\(\vec{u}\_{k+1} + \lambda \vec{v}\_{k+1}\)&lt;/span&gt;は&lt;span class="math"&gt;\(\vec{a}\_{k+1}\)&lt;/span&gt;と一致する。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-9"&gt;アルゴリズム&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以上の導出結果をまとめると、&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(k=1\)&lt;/span&gt;の時：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
a_{1} = - \frac{R_{1}}{R_{0}} \ , \ e_{1} = R_{0} + R_{1}a_{1}
\end{equation*}
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(k\)&lt;/span&gt;が求まった時、&lt;span class="math"&gt;\(k+1\)&lt;/span&gt;は：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="math"&gt;
\begin{equation*}
\lambda = - \displaystyle\frac{\sum_{j=0}^{k}a_{j}R_{k+1-j}}{e_{k}} \ , \ e_{k+1} = (1-\lambda^{2})e_{k}\ ,\ \vec{a}_{k+1} = \vec{u}_{k+1} + \lambda \vec{v}_{k+1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
R_{l} = \sum_{n=-\infty}^{\infty} y_{n}y_{n+l}\ ,\
\vec{u}_{k+1}=
\begin{bmatrix}
1 \\ a_{1} \\ \vdots \\ a_{k} \\ 0
\end{bmatrix}\ ,\
\vec{v}_{k+1}=
\begin{bmatrix}
0 \\ a_{k} \\ \vdots \\ a_{1} \\ 1
\end{bmatrix}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となる。&lt;/p&gt;
&lt;p&gt;自己相関&lt;span class="math"&gt;\(R_{l}\)&lt;/span&gt;は過去から未来までの無限の信号和になっているので現実の計算機では計算出来ない。実際には自己相関の代わりに次の&lt;strong&gt;標本自己相関&lt;/strong&gt;&lt;span class="math"&gt;\(\tilde{R}\_{l}\)&lt;/span&gt;を用いる：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\tilde{R}_{l} = \sum_{i=0}^{n} y_{i}y_{i-l} \quad (l = 0, ..., k)
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-10"&gt;補足&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-11"&gt;周波数特性の導出&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;近似式は誤差項&lt;span class="math"&gt;\(e_{n}\)&lt;/span&gt;を用いて次の等式で書き表せる：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{split}
y_{n} = - a_{1}y_{n-1} - a_{2}y_{n-2} - \dots -a_{k}y_{n-k} + e_{n} \\
y_{n} = - \sum_{i=1}^{k} a_{i}y_{n-k} + e_{n}
\end{split}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この式を両辺z変換すると、次の伝達関数を得る：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{split}
Y(z) = - \sum_{i=1}^{k} a_{i}z^{-i}Y(z) + E(z) \\
\iff \frac{Y(z)}{E(z)} = \frac{1}{1+ \sum_{i=1}^{k}a_{i}z^{-i}}
\end{split}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この結果は、予測誤差を入力することで出力音声が得られるシステムを表している。人間の声帯から発せられた音声を&lt;span class="math"&gt;\(E(z)\)&lt;/span&gt;とすれば、この伝達関数は声道の共鳴する特性をモデル化していると考えることができる。共鳴が発生する周波数では伝達関数のパワー（振幅、ゲイン）が高くなり、この結果からフォルマント分析を行うことができる。&lt;/p&gt;
&lt;p&gt;伝達関数の周波数特性を求めるには、z変換の結果に&lt;span class="math"&gt;\(z=\exp(j\omega), (\omega=2\pi f:角周波数)\)&lt;/span&gt;を代入する：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{split}
\frac{Y(z)}{E(z)} = \frac{1}{1+ \sum_{i=1}^{k} a_{i} \exp(-j i \omega) }
\end{split}
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-12"&gt;標本自己相関の計算&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;標本自己相関は自分自身との相関を計算するので&lt;span class="math"&gt;\(O(N^{2})\)&lt;/span&gt;の計算量があるが、ウィーナー・ヒンチンの定理（信号のパワースペクトラムは、その自己相関に等しい）を使って自己相関を計算すれば、実質FFTと同等の計算量&lt;span class="math"&gt;\(O(N \log N)\)&lt;/span&gt;で抑えることもできる。但し、巡回畳み込みや、パワースペクトラムの平均処理を考慮する必要がある。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-9"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-13"&gt;参考資料リスト&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LPCについて：&lt;a class="reference external" href="http://ahclab.naist.jp/lecture/2014/sp/material/sp2nd-2.pdf"&gt;東京大学
音情報処理論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ウィーナー・ヒンチンの定理：&lt;a class="reference external" href="http://manabukano.brilliant-future.net/lecture/appliedmathF2/slide/Slide07_PowerSpctrum.pdf"&gt;京都大学
工業数学&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-10"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-14"&gt;実装&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;実装はC言語です（リファレンスはLLで書くべきだった…）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;float.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* （標本）自己相関の計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;calc_auto_correlation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Levinson-Durbin再帰計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nf"&gt;levinson_durbin_recursion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lpc_coef&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* サンプル数 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_delay&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* LPC係数の数 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predict&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;auto_cor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;coff&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* 波形の生成 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;4.0f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.05&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* 自己相関・Levinson-Durbin再帰計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;calc_auto_correlation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;auto_cor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;levinson_durbin_recursion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;auto_cor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_delay&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* 予測テスト */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="cm"&gt;/* 最初のmax_delayステップ分は元信号を単純コピー */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;predict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="cm"&gt;/* 以降は予測 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;predict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_delay&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;predict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coff&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* 誤差計算・結果表示 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;No:%d Data: %f Predict: %f &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;predict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Error : %f &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predict&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;auto_cor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coff&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;levinson_durbin_recursion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lpc_coef&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;u_vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;v_vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a_vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;e_vec&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lpc_coef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Data or result pointer point to NULL. &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;   * 0次自己相関（信号の二乗和）が0に近い場合、入力信号は無音と判定&lt;/span&gt;
&lt;span class="cm"&gt;   * =&amp;gt; 予測誤差, LPC係数は全て0として無音出力システムを予測.&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fabs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FLT_EPSILON&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;lpc_coef&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* 初期化 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;a_vec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* a_0, a_k+1を含めるとmax_order+2 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;e_vec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* e_0, e_k+1を含めるとmax_order+2 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;u_vec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;v_vec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;u_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;v_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* 最初のステップの係数をセット */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;a_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;e_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;a_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;e_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;u_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;u_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;v_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;v_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* 再帰処理 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;e_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* u_vec, v_vecの更新 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;u_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;v_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;u_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;u_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;v_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;v_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* resultの更新 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;a_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;u_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;v_vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_delay&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* 結果の取得 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;memcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lpc_coef&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a_vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u_vec&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v_vec&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a_vec&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e_vec&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;calc_auto_correlation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delay_time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Max order(%zu) is larger than number of samples(%zu). &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Data or result pointer point to NULL. &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* （標本）自己相関の計算 */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delay_time&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delay_time&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max_order&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delay_time&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;delay_time&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delay_time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num_sample&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;auto_corr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;delay_time&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i_sample&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;delay_time&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-11"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-15"&gt;実験&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;実際に走らせた結果のグラフは以下。 &lt;img alt="result" src="./images/lpc_result.png" /&gt;&lt;/p&gt;
&lt;p&gt;原信号が簡単すぎたのか、係数は少なめでも十分に予測できている。しかし、適当な係数の数の取り方を決める手法がないと、実信号で使い物になりそうにない。とりあえず、自己相関を使いこなしたN.
Wiener is GOD.（結言）&lt;/p&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="記事"></category><category term="LPC"></category><category term="信号処理"></category><category term="ロスレス音声"></category></entry><entry><title>離散フーリエ変換（DFT）</title><link href="/li-san-huriebian-huan-dft.html" rel="alternate"></link><published>2020-04-23T12:00:00+09:00</published><updated>2020-04-23T12:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-23:/li-san-huriebian-huan-dft.html</id><summary type="html">&lt;p class="first last"&gt;教科書で出てくる離散フーリエ変換の式が出てくるところまでの導出。超関数に関しては不完全。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;離散時間かつ離散周波数でのフーリエ変換を離散フーリエ変換という。&lt;/p&gt;
&lt;div class="contents local topic" id="topic-1"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-1" id="toc-entry-1"&gt;準備：時間領域で離散化すると、周波数領域では周期的になる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-2" id="toc-entry-2"&gt;離散フーリエ変換・離散フーリエ逆変換&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-3" id="toc-entry-3"&gt;離散化の仮定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#section-4" id="toc-entry-4"&gt;離散フーリエ変換の導出&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-1"&gt;準備：時間領域で離散化すると、周波数領域では周期的になる&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class="math"&gt;\(f(t)\)&lt;/span&gt;を離散化した信号を&lt;span class="math"&gt;\(g(t)\)&lt;/span&gt;とおく。離散化には、サンプリング周期&lt;span class="math"&gt;\(t_{s}\)&lt;/span&gt;の周期的デルタ関数&lt;span class="math"&gt;\(\delta_{t_{s}}(t)\)&lt;/span&gt;を用いて&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
g(t) = f(t) \delta_{t_s}(t) = \sum_{n=-\infty}^{\infty} f(t) \delta(t - nt_{s})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;とする。デルタ関数&lt;span class="math"&gt;\(\delta(t)\)&lt;/span&gt;は関数&lt;span class="math"&gt;\(f(t)\)&lt;/span&gt;に対して次が成り立つ（超）関数である：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\int^{\infty}_{-\infty} f(t) \delta(t) dt = f(0)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(t_{s}\)&lt;/span&gt;の逆数はサンプリングレート（&lt;span class="math"&gt;\(f_{s} = 1/t_{s}\)&lt;/span&gt;）そのものである。また、周期的デルタ関数の（複素）フーリエ級数は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
\delta_{t_{s}}(t) &amp;amp;= \sum_{n=-\infty}^{\infty} c_{n} \exp(j\omega_{s}t)dt \\
c_{n} &amp;amp;= \frac{1}{t_{s}} \int^{t_{s}/2}_{-t_{s}/2} \delta_{t_{s}}(t) \exp(-jn\omega_{s}t)dt
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と表せる。ここで&lt;span class="math"&gt;\(\omega_{s}=2\pi/t_{s}\)&lt;/span&gt;（サンプリング角周波数）である。&lt;span class="math"&gt;\(c_{n}\)&lt;/span&gt;の計算を考えると、積分範囲&lt;span class="math"&gt;\([-t_{s}/2, t_{s}/2]\)&lt;/span&gt;に唯一つのインパルスが存在する事に留意すれば、次の結果を得る：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
c_{n} = \frac{1}{t_{s}} \int^{t_{s}/2}_{-t_{s}/2} \delta(t) \exp(-jn\omega_{s}t)dt = \frac{1}{t_{s}}\exp(0) = \frac{1}{t_{s}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;よって、周期的デルタ関数の複素フーリエ級数は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\delta_{t_s}(t) = \frac{1}{t_{s}} \sum_{n=-\infty}^{\infty} \exp(j n \omega_{s} t) = \frac{1}{t_{s}} \sum_{n=-\infty}^{\infty} \exp(j 2\pi n t)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;であり、この結果を用いると、&lt;span class="math"&gt;\(g(t)\)&lt;/span&gt;のフーリエ変換&lt;span class="math"&gt;\({\cal F}[g(t)]\)&lt;/span&gt;は、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{split}
{\cal F}[g(t)] &amp;amp;= \frac{1}{t_{s}} \sum_{n=-\infty}^{\infty} {\cal F} \left[ f(t) \exp(j n \omega_{s} t) \right] \\
&amp;amp;= \frac{1}{t_{s}} \sum_{n=-\infty}^{\infty} \int_{-\infty}^{\infty} f(t) \exp[ -j (\omega - n\omega_{s}) t] dt
\\
&amp;amp;= \frac{1}{t_{s}} \sum_{n=-\infty}^{\infty} F(\omega - n\omega_{s})
\end{split}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで、&lt;span class="math"&gt;\(F(\omega)\)&lt;/span&gt;は&lt;span class="math"&gt;\(f(t)\)&lt;/span&gt;をフーリエ変換した結果を表している。この結果は、離散化した信号のフーリエ変換は周波数領域で&lt;strong&gt;周期&lt;/strong&gt; &lt;span class="math"&gt;\(\omega_{s}\)&lt;/span&gt; &lt;strong&gt;で&lt;/strong&gt; &lt;span class="math"&gt;\(F(\omega)\)&lt;/span&gt; &lt;strong&gt;を繰り返す&lt;/strong&gt;事を示している。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-2"&gt;離散フーリエ変換・離散フーリエ逆変換&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-3"&gt;離散化の仮定&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;時間領域で離散化した信号&lt;span class="math"&gt;\(f[n]\)&lt;/span&gt;を次の様に定義する：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f[n] = f(nt_{s}) \quad n = 0,...,N-1
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで、&lt;span class="math"&gt;\(N\)&lt;/span&gt;はサンプリング個数である。重要な仮定として、&lt;span class="math"&gt;\(f(t)\)&lt;/span&gt;は&lt;span class="math"&gt;\(N\)&lt;/span&gt;このサンプリング期間で周期的であるとする。即ち、&lt;span class="math"&gt;\(f(t)\)&lt;/span&gt;の周期を&lt;span class="math"&gt;\(T\)&lt;/span&gt;とおくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
T = Nt_{s}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;が成立する。更に、&lt;strong&gt;周波数領域についても&lt;/strong&gt;&lt;span class="math"&gt;\(\omega_{s}\)&lt;/span&gt;&lt;strong&gt;を&lt;/strong&gt;&lt;span class="math"&gt;\(N\)&lt;/span&gt;&lt;strong&gt;分割&lt;/strong&gt;
し、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\omega_{k} = \frac{\omega_{s}}{N} k = \frac{2\pi}{Nt_{s}}k \quad k = 0,...,N-1
\end{equation*}
&lt;/div&gt;
&lt;p&gt;として、周波数領域で離散化した信号&lt;span class="math"&gt;\(F[k]\)&lt;/span&gt;を次の様に定義する：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F[k] = F(\omega_{k}) \quad k = 0,...,N-1
\end{equation*}
&lt;/div&gt;
&lt;p&gt;分割の個数&lt;span class="math"&gt;\(N\)&lt;/span&gt;が時間領域と周波数領域で異なる場合、変換対が対称にならないので高速フーリエ変換の時に不都合が生じる。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-4"&gt;離散フーリエ変換の導出&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;離散化の仮定のもとで、フーリエ変換は次の様に計算できる：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F[k] = \int_{-\infty}^{\infty} f(t) \exp(-j\omega_{k}t) dt = \int_{-\infty}^{\infty} f(t) \exp\left(-j\frac{2\pi k}{Nt_{s}} t \right) dt
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(f(t)\)&lt;/span&gt;は周期&lt;span class="math"&gt;\(T\)&lt;/span&gt;で繰り返すので、積分範囲は1周期分とする（なぜ一周期か：フーリエ係数の仮定から。係数は1周期の積分で良い。三角関数の完全性を見よ）：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F[k] = \int^{T}_{0} f(t) \exp \left(-j \frac{2\pi k}{Nt_{s}} t \right)dt
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(t = nt_{s}\)&lt;/span&gt;と変数変換すると（&lt;span class="math"&gt;\(n\)&lt;/span&gt;を積分変数とする）、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F[k] = t_{s}\int^{N}_{0} f(nt_{s}) \exp \left(-j \frac{2\pi k}{N} n\right)dn
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この積分は、次の和で近似できる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
F[k] \approx t_{s}\sum^{N-1}_{n=0} f(nt_{s}) \exp \left(-j \frac{2\pi k}{N} n\right) = t_{s} \sum^{N-1}_{n=0} f[n] \exp \left(-j \frac{2\pi nk}{N} \right)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この式が離散フーリエ変換の式となる。逆変換については、複素フーリエ級数&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left\{ \begin{array}{l}
f(nt_{s})  = \displaystyle \sum_{k=-\infty}^{\infty} c_{n} \exp(j\omega_{k}kn t) \\
c_{n} = \displaystyle \frac{1}{T} \int^{T}_{0} f(t) \exp(-j n\omega_{k} t) dt
\end{array} \right.
\end{equation*}
&lt;/div&gt;
&lt;p&gt;から、&lt;span class="math"&gt;\(c_{n}\)&lt;/span&gt;を消去すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
f(nt_{s}) = \sum_{k=-\infty}^{\infty} \left\{ \frac{1}{T} \int^{T}_{0} f(t) \exp\left( -j \frac{2\pi kt}{T} \right) dt \right\} \exp\left( \frac{j2\pi k}{T} nt_{s} \right) \\
f(nt_{s}) = \frac{\omega_{s}}{2 \pi N} \sum_{k=-\infty}^{\infty} F[k] \exp\left(j \frac{2\pi nk}{N} \right)
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(F[k]\)&lt;/span&gt;の周期は&lt;span class="math"&gt;\(\omega_{s}\)&lt;/span&gt;なので、1周期分は&lt;span class="math"&gt;\(k = 0,...,N-1\)&lt;/span&gt;となる。再び1周期分のみを考えると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f[n] = \frac{\omega_{s}}{2 \pi N} \sum_{k=0}^{N-1} F[k] \exp\left(j \frac{2\pi nk}{N} \right)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;この式が離散フーリエ逆変換の式となる。変換の式をまとめると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left\{ \begin{array}{l}
\displaystyle F[k] = t_{s} \sum^{N-1}_{n=0} f[n] \exp \left(-j \frac{2\pi nk}{N} \right) \\
\displaystyle f[n] = \frac{\omega_{s}}{2 \pi N} \sum_{k=0}^{N-1} F[k] \exp\left(j \frac{2\pi nk}{N} \right)
\end{array} \right.
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これがフーリエ変換対となり、一方に他方を代入するとちゃんと逆に戻る事が確認できる：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{split}
f[n] &amp;amp;= \frac{\omega_{s}}{2\pi N}\sum_{k=0}^{N-1}F[k]\exp\left(j\frac{2\pi nk}{N}\right) \\
&amp;amp;= \frac{2\pi t_{s}}{2\pi t_{s}N}\sum_{k=0}^{N-1}\left\{ \sum^{N-1}_{n^\prime=0} f[n^\prime] \exp \left(-j \frac{2\pi n^\prime k}{N} \right) \right\} \exp\left(j\frac{2\pi nk}{N}\right) \\
&amp;amp;= \frac{1}{N} \sum_{n^{\prime}=0}^{N-1} f[n^\prime] \sum_{k=0}^{N-1} \exp\left[ -j (n-n^\prime) \frac{2\pi k}{N} \right]
\end{split}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\sum_{k=0}^{N-1} \exp\left[ -j (n-n^\prime) \frac{2\pi k}{N} \right]\)&lt;/span&gt;の値ついては&lt;span class="math"&gt;\(k\)&lt;/span&gt;の積分&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\int^{N}_{0} \exp\left[ -j (n-n^\prime) \frac{2\pi k}{N} \right] dk
\end{equation*}
&lt;/div&gt;
&lt;p&gt;と考えれば、&lt;span class="math"&gt;\(n=n^\prime\)&lt;/span&gt;の時は明らかに&lt;span class="math"&gt;\(N\)&lt;/span&gt;であり、残りの&lt;span class="math"&gt;\(n \neq n^\prime\)&lt;/span&gt;の時は&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{split}
\int^{N}_{0} \exp\left[ -j (n-n^\prime) \frac{2\pi k}{N} \right] dk
&amp;amp;= - \frac{1}{j(n-n^\prime)\frac{2\pi}{N}}
\left[ \exp\left[ -j(n-n^\prime)\frac{2\pi k}{N} \right] \right]_{0}^{N} \\
&amp;amp;= - \frac{1}{j(n-n^\prime)\frac{2\pi}{N}} \left\{ \exp[-j2(n-n^\prime)\pi] - \exp(0)\right\} \\
&amp;amp;= 0
\end{split}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;となるので、最終的に&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{1}{N} \sum_{n^{\prime}=0}^{N-1} f[n^\prime] \sum_{k=0}^{N-1} \exp\left[ -j (n-n^\prime) \frac{2\pi k}{N} \right] = \frac{1}{N} f[n] N = f[n]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;を得る。
また&lt;span class="math"&gt;\(t_{s}=1\)&lt;/span&gt;とおくと、&lt;span class="math"&gt;\(\omega_{s} = 2\pi\)&lt;/span&gt;となって、DFTのよく見る変換式が得られる：&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left\{ \begin{array}{l}
\displaystyle F[k] = \sum^{N-1}_{n=0} f[n] \exp \left(-j \frac{2\pi nk}{N} \right) \\
\displaystyle f[n] = \frac{1}{N} \sum_{k=0}^{N-1} F[k] \exp\left(j \frac{2\pi nk}{N} \right)
\end{array} \right.
\end{equation*}
&lt;/div&gt;
&lt;p&gt;これらの式を実装するのは簡単である。じゃあ、実装しようか…（暗黒微笑）&lt;/p&gt;
&lt;p&gt;（デルタ関数から導く方法だと、どうしても正規化定数&lt;span class="math"&gt;\(1/N\)&lt;/span&gt;が出てこない。正規化定数は本質的では無いとかいうけど、計算上は無視できない。）&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="記事"></category><category term="DFT"></category><category term="信号処理"></category></entry><entry><title>Signed-LMSの2階微分 その2</title><link href="/signed-lmsno2jie-wei-fen-sono2.html" rel="alternate"></link><published>2020-04-22T11:34:00+09:00</published><updated>2020-04-22T12:10:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-22:/signed-lmsno2jie-wei-fen-sono2.html</id><summary type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;早速既存研究が無いか見ている。二乗誤差最小化のLMSでもヘ …&lt;/p&gt;</summary><content type="html">&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;早速既存研究が無いか見ている。二乗誤差最小化のLMSでもヘッセ行列の逆行列の計算負荷が高いから使わん、という論調がほとんど。Signed-LMSについては今の所、微分してるところも見てない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pt.slideshare.net/mentelibre/neural-network-widrowhoff-learning-adaline-hagan-lms"&gt;NEURAL NETWORK Widrow-Hoff Learning Adaline Hagan LMS&lt;/a&gt; 観測分散行列がヘッセ行列に一致することが書いてあった。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www1.coe.neu.edu/~erdogmus/publications/J013_NEUNET_SpIssueIJCNN03_EWCLMS_Yadu.pdf"&gt;Stochastic error whitening algorithm for linear filter estimation with noisy data&lt;/a&gt; 評価関数として絶対値が入ったものを使っている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://faculty.cord.edu/kamel/09S-380/Presentations/LMS.pdf"&gt;The Least Mean Squares Algorithm&lt;/a&gt; 分かりやすめな解説。そうか、ウィーナーフィルタか。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;行列 &lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}}\)&lt;/span&gt; が正則にならない件について、これ正則化すればいいんじゃねと思い立つ。要は &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; を正則化パラメータとして &lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}} + \lambda \ve{I}\)&lt;/span&gt; に対して逆行列を求めていく。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;多分、係数側に正則項を追加することになるはず。&lt;span class="math"&gt;\(\min \mathrm{E}[|\varepsilon(n)|] + \lambda ||\ve{h}||_{2}\)&lt;/span&gt; のような定式化か？&lt;/li&gt;
&lt;li&gt;それでも逆行列 &lt;span class="math"&gt;\((\ve{X}\ve{X}^{\mathsf{T}} + \lambda \ve{I})^{-1}\)&lt;/span&gt; を求めるのは骨が折れそう。そこで、自然勾配学習で使っていた適応的自然勾配学習法（ &lt;a class="reference external" href="https://bsi-ni.brain.riken.jp/database/file/274/280.pdf"&gt;Singularities Affect Dynamics of Learning in Neuromanifolds&lt;/a&gt; より）が使えそう。具体的には、次の式で自然勾配を適応的に求めていく。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{G}_{t+1}^{-1} = (1 + \varepsilon_{t}) \ve{G}_{t}^{-1} - \varepsilon_{t} \ve{G}_{t}^{-1} \parfrac{J(\ve{h})}{\ve{h}} \left( \ve{G}_{t}^{-1} \parfrac{J(\ve{h})}{\ve{h}} \right)^{\mathsf{T}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで &lt;span class="math"&gt;\(\varepsilon_{t}\)&lt;/span&gt; は小さな定数。『情報幾何の新展開』では、カルマンフィルタ由来らしい。うーん、もう試してみたいな。&lt;/p&gt;
&lt;div class="section" id="ve-x-ve-x-mathsf-t-lambda-ve-i"&gt;
&lt;h2&gt;（念の為） &lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}} + \lambda \ve{I}\)&lt;/span&gt; が正則行列になる理由&lt;/h2&gt;
&lt;p&gt;すぐに思い出せなくてヒヤッとしたのでここで示しておく。&lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}}\)&lt;/span&gt; は対称行列だから、直交行列 &lt;span class="math"&gt;\(\ve{P}\)&lt;/span&gt; （&lt;span class="math"&gt;\(\ve{P}^{-1} = \ve{P}^{\mathsf{T}}\)&lt;/span&gt; ）と固有値を並べた対角行列 &lt;span class="math"&gt;\(\ve{\Lambda}\)&lt;/span&gt; を用いて、&lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}} = \ve{P}^{\mathsf{T}} \ve{\Lambda} \ve{P}\)&lt;/span&gt; と対角化できる。よって、&lt;span class="math"&gt;\(\lambda &amp;gt; 0\)&lt;/span&gt; なる定数を用いた時、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{X}\ve{X}^{\mathsf{T}} + \lambda \ve{I} &amp;amp;= \ve{P}^{\mathsf{T}} \ve{\Lambda} \ve{P} + \lambda \ve{P}^{\mathsf{T}} \ve{P} \\
&amp;amp;= \ve{P}^{\mathsf{T}} \ve{\Lambda} \ve{P} + \ve{P}^{\mathsf{T}} \lambda \ve{I} \ve{P} \\
&amp;amp;= \ve{P}^{\mathsf{T}} (\ve{\Lambda} + \lambda \ve{I}) \ve{P}
\end{align*}
&lt;/div&gt;
&lt;p&gt;また、任意のベクトル &lt;span class="math"&gt;\(\ve{v}\)&lt;/span&gt; を使った時、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{v}^{\mathsf{T}} \ve{X} \ve{X}^{\mathsf{T}} \ve{v} &amp;amp;= (\ve{X}^{\mathsf{T}} \ve{v})^{\mathsf{T}} \ve{X}^{\mathsf{T}} \ve{v} = ||\ve{X}^{\mathsf{T}} \ve{v} ||_{2}^{2} \\
\ve{v}^{\mathsf{T}} \ve{X} \ve{X}^{\mathsf{T}} \ve{v} &amp;amp;= \ve{v}^{\mathsf{T}} \ve{P}^{\mathsf{T}} \ve{\Lambda} \ve{P} \ve{v} = \sum_{i}^{N} \ve{\Lambda}_{ii} (\ve{Pv})_{i}^{2} \\
\Rightarrow ||\ve{X}^{\mathsf{T}} \ve{v} ||_{2}^{2} &amp;amp;= \sum_{i}^{N} \ve{\Lambda}_{ii} (\ve{Pv})_{i}^{2} \geq 0
\end{align*}
&lt;/div&gt;
&lt;p&gt;の関係式が成り立つ。最後の不等式が成り立つには、全ての &lt;span class="math"&gt;\(i\)&lt;/span&gt; に対して &lt;span class="math"&gt;\(\ve{\Lambda}_{ii} \geq 0\)&lt;/span&gt; でなければならない。よって &lt;span class="math"&gt;\(\ve{XX}^{\mathsf{T}}\)&lt;/span&gt; の固有値は全て非負。&lt;/p&gt;
&lt;p&gt;ここで &lt;span class="math"&gt;\(\ve{P}^{\mathsf{T}} (\ve{\Lambda} + \lambda \ve{I}) \ve{P}\)&lt;/span&gt; に注目すると、全ての固有値に &lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; が足されていることが分かる。&lt;span class="math"&gt;\(\lambda\)&lt;/span&gt; は正だから、 &lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}} + \lambda \ve{I}\)&lt;/span&gt; の固有値は全て正になり正定値行列となる。正定値行列は正則だから、 &lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}} + \lambda \ve{I}\)&lt;/span&gt; は正則行列。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;フィッシャー情報行列とヘッセ行列と分散行列の絡みについて&lt;/h2&gt;
&lt;p&gt;以下の記事が非常にわかりやすい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiseodd.github.io/techblog/2018/03/11/fisher-information/"&gt;Fisher Information Matrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiseodd.github.io/techblog/2018/03/14/natural-gradient/"&gt;Natural Gradient Descent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;結論、ラプラス分布に従う残差を仮定した最尤推定において、観測分散行列はフィッシャー情報行列に一致し、その逆行列は自然勾配に該当するはず。つうかニュートン法の特殊ケースに見えるがどうなんでしょ。フィッシャー情報行列がヘッセ行列に見えるんだが、定義通り（対数尤度のヘッセ行列）そうだよな。指数族の最尤推定をニュートン法で解こうとしたら全部自然勾配学習法にならね？&lt;/p&gt;
&lt;div class="section" id="todo"&gt;
&lt;h3&gt;TODO&lt;/h3&gt;
&lt;p&gt;評価のことを考えて行きたい。固定した信号（答えが分かっている信号。乱数固定。）を使ったときに、誤差平面と勾配はどうなっている？フィルタの次元は2ぐらいにして、フィルタを固定して各統計量がどうなっているかプロットする。まずは絶対値残差と勾配の観察が重要に思える（もちろん、2次の最小化ケースも重要）。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;評価がまとまったら結果共有に入りたい。&lt;/li&gt;
&lt;li&gt;OMPを使う。&lt;/li&gt;
&lt;li&gt;メッセージパッシング使えない？&lt;ul&gt;
&lt;li&gt;何らかの確率モデル化をせよ、というふうに受け取った。&lt;/li&gt;
&lt;li&gt;AMP, Survay-Propagation（三村さん、樺島さん）がありえる。&lt;/li&gt;
&lt;li&gt;→ AMP, Survay-Propagationについて調査すべし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;いろんな論文で自然勾配をどうやって定義しているか要観察。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category><category term="Fisher Information Matrix"></category><category term="Hessian"></category><category term="Natural Gradient"></category></entry><entry><title>残差勾配 \(\mathrm{E}[\varepsilon(n) x(n - m)]\) の挙動観察/Signed-LMSの目的関数の2階微分</title><link href="/can-chai-gou-pei-mathrmevarepsilonn-xn-m-noju-dong-guan-cha-signed-lmsnomu-de-guan-shu-no2jie-wei-fen.html" rel="alternate"></link><published>2020-04-21T12:10:00+09:00</published><updated>2020-04-21T12:10:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-21:/can-chai-gou-pei-mathrmevarepsilonn-xn-m-noju-dong-guan-cha-signed-lmsnomu-de-guan-shu-no2jie-wei-fen.html</id><summary type="html">&lt;div class="section" id="mathrm-e-varepsilon-n-x-n-m"&gt;
&lt;h2&gt;残差勾配 &lt;span class="math"&gt;\(\mathrm{E}[\varepsilon(n) x(n - m)]\)&lt;/span&gt; の挙動観察&lt;/h2&gt;
&lt;p&gt;&lt;span class="math"&gt;\(m\)&lt;/span&gt; が大きいときは無視できるのでは？ なお、長時間平均値は0に収束しているこ …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="mathrm-e-varepsilon-n-x-n-m"&gt;
&lt;h2&gt;残差勾配 &lt;span class="math"&gt;\(\mathrm{E}[\varepsilon(n) x(n - m)]\)&lt;/span&gt; の挙動観察&lt;/h2&gt;
&lt;p&gt;&lt;span class="math"&gt;\(m\)&lt;/span&gt; が大きいときは無視できるのでは？ なお、長時間平均値は0に収束していることを見た。
&lt;span class="math"&gt;\(m\)&lt;/span&gt; をずらした時の平均値の様子を見る。どこかで影響が小さくなって打ち切れるはず。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ガチャガチャ弄ってるってるけど示唆があんまりない。&lt;/li&gt;
&lt;li&gt;低次（〜10）の係数は大きく変動する傾向。しかし、次に述べるピッチなどに影響しているのか、全てに当てはまる傾向ではない。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\mathrm{E}[\varepsilon(n) x(n - m)]\)&lt;/span&gt; は &lt;span class="math"&gt;\(m\)&lt;/span&gt; を大きくすれば単調減少するわけではない。音源依存で傾向が異なる。ピッチ？か何かに反応して大きくなる場合がある。&lt;/li&gt;
&lt;li&gt;同一発音区間では、フィルタ係数の符号は同一になる傾向が見られる。単一のsin波を等価させたときはわかりやすい。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="440.0Hzのsin波に対する各タップの平均勾配変化グラフ" src="./images/sin_mean_gradient.png" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;440.0Hzのsin波に対する各タップの平均勾配変化&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="ボイス対する各タップの平均勾配変化グラフ" src="./images/voice_mean_gradient.png" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;ボイス対する各タップの平均勾配変化&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="ピアノ演奏に対する各タップの平均勾配変化グラフ" src="./images/ruriko_mean_gradient.png" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;ピアノ演奏に対する各タップの平均勾配変化&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="signed-lms2"&gt;
&lt;h2&gt;Signed-LMSの目的関数の2階微分&lt;/h2&gt;
&lt;p&gt;勇気を出してやってみる。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;符号関数を &lt;span class="math"&gt;\(\tanh(Tx)\)&lt;/span&gt; で近似して微分してみる（&lt;span class="math"&gt;\(T\)&lt;/span&gt; は温度パラメータで、&lt;span class="math"&gt;\(\tanh(Tx)\)&lt;/span&gt; を &lt;span class="math"&gt;\(T \to \infty\)&lt;/span&gt; ならしめれば符号関数に近づく）と、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{d}{dx} \tanh(Tx) = T (\tanh(Tx))^{\prime} = T(1 - \tanh^{2}(Tx))
\end{equation*}
&lt;/div&gt;
&lt;p&gt;さて、 &lt;span class="math"&gt;\(1 - \tanh^{2}(Tx)\)&lt;/span&gt; に注目すると、&lt;span class="math"&gt;\(T\)&lt;/span&gt; の極限では &lt;span class="math"&gt;\(x = 0\)&lt;/span&gt; を除き0を取るが、&lt;span class="math"&gt;\(x = 0\)&lt;/span&gt; において1を取る。よってこれはインパルス関数になる（極限と微分操作を交換したけどやかましいことは暗黙で...）。&lt;/p&gt;
&lt;p&gt;符号関数を微分するとインパルス関数が出てくることについては &lt;a class="reference external" href="https://teenaka.at.webry.info/201301/article_10.html"&gt;超関数的微分_δ関数関連（２）&lt;/a&gt; を見るのが早いかも。以下では、その話に従って、&lt;span class="math"&gt;\(\frac{d}{dx} \mathrm{sign}(x) = 2\delta(x)\)&lt;/span&gt; とする。&lt;/p&gt;
&lt;p&gt;さて、今一度評価関数 &lt;span class="math"&gt;\(\mathrm{E}[|\varepsilon(n)|]\)&lt;/span&gt; の偏微分と2階の偏導関数を考える。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\parfrac{}{h(m)} \mathrm{E}[|\varepsilon(n)|] &amp;amp;= \mathrm{E}\left[ \parfrac{}{h(m)} |\varepsilon(n)| \right] \\
&amp;amp;= \mathrm{E}\left[ \left\{ \parfrac{}{h(m)} \varepsilon(n) \right\} \mathrm{sign}[\varepsilon(n)] \right] \\
&amp;amp;= -\mathrm{E}\left[ \mathrm{sign}[\varepsilon(n)]  x(n - m) \right] \\
\frac{\partial^{2}}{\partial h(m) \partial h(k)} \mathrm{E}[|\varepsilon(n)|] &amp;amp;= - \parfrac{}{h(k)} \mathrm{E}\left[ \mathrm{sign}[\varepsilon(n)]  x(n - m) \right] \\
&amp;amp;= - \mathrm{E}\left[ \left\{ \parfrac{}{h(k)} \varepsilon(n) \right\} 2\delta(\varepsilon(n)) x(n - m) \right] \\
&amp;amp;= 2\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;ここで &lt;span class="math"&gt;\(\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right]\)&lt;/span&gt; に注目する。これは &lt;span class="math"&gt;\(\varepsilon(n) = 0\)&lt;/span&gt; のときだけ和を取る演算だ。&lt;span class="math"&gt;\(\sum\)&lt;/span&gt; を用いると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\mathrm{E}\left[ \delta(\varepsilon(n)) x(n - m) x(n - k) \right] = \lim_{N \to \infty} \frac{1}{N} \sum_{n = 1, \varepsilon(n) = 0}^{N} x(n - m) x(n - k)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;という計算に該当する。厳密計算は &lt;span class="math"&gt;\(\varepsilon(n) = 0\)&lt;/span&gt; なる &lt;span class="math"&gt;\(n\)&lt;/span&gt; を見つけたら足していく感じでいいと思うけど、今は &lt;span class="math"&gt;\(\varepsilon(n)\)&lt;/span&gt; はラプラス分布に従うと仮定している。だからラプラス分布に従って &lt;span class="math"&gt;\(P(\varepsilon(n) = 0) = \frac{1}{2\lambda}\)&lt;/span&gt; （分散 &lt;span class="math"&gt;\(2\lambda^{2}\)&lt;/span&gt; ）の重み付けをして計算してしまって良いように見えるのだがどうなんだろう。なんか怪しくて考え続けている。&lt;/p&gt;
&lt;p&gt;もし適応フィルタに組み込むなら、残差が0になったら上の式に従ってヘッセ行列を更新し、ニュートン法を使い続ける。これは試してみたい。問題はヘッセ行列が逆行列を持つかというところ…4-20で半正定値であることは確認したが正定値とは限らない。共役勾配法を検討する必要があるかも。&lt;span class="math"&gt;\(\ve{X}\ve{X}^{\mathsf{T}}\)&lt;/span&gt; は正則になるとは思えない…。（軽く試したけどすぐにだめな例が見つかった。）&lt;/p&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h3&gt;他の頂いたアイディア&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;周波数領域に一旦飛ばすのはあり？&lt;ul&gt;
&lt;li&gt;ありだけど計算量が高い。圧縮率が上がるのであれば大アリ。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;確率的PCAとか使えない？辞書は小さくて済む。&lt;/li&gt;
&lt;li&gt;線形ダイナミクスにより上手く定式化できない？&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h4&gt;優先度低&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;出す学会については先生に聞くこと。&lt;ul&gt;
&lt;li&gt;相談する機会はどこかで絶対に必要。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;著作権処理済み音源データベースについて相談&lt;ul&gt;
&lt;li&gt;→ 自分で情報をまとめて、申し込んでいいかというところまで進めるべし。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://staff.aist.go.jp/m.goto/PAPER/SIGMUS200205goto.pdf"&gt;RWC 研究用音楽データベース: 音楽ジャンルデータベースと楽器音データベース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://staff.aist.go.jp/m.goto/RWC-MDB/index-j.html"&gt;RWC研究用音楽データベース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;→ 進めた。動けるようになったら書類をまとめていく。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Donohoさんなどが圧縮センシングの文脈で既にやりきってない？&lt;ul&gt;
&lt;li&gt;ありえる。調査すべし。&lt;/li&gt;
&lt;li&gt;→ ライス大学では成果をすべて公開しているから見るだけ見たほうが良い。&lt;/li&gt;
&lt;li&gt;→ &lt;a class="reference external" href="http://dsp.rice.edu/cs/"&gt;http://dsp.rice.edu/cs/&lt;/a&gt; を見よ。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://hal.archives-ouvertes.fr/hal-00424165/document"&gt;Compressed sensing block MAP-LMS adaptive filter for sparse channel estimation and a bayesian Cramer-Rao bound&lt;/a&gt; 残差はガウス分布としてるけどクラメル-ラオ下限との絡みを述べている。何か重要そう。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.dbabacan.info/papers/babacan_CS.pdf"&gt;Bayesian Compressive Sensing Using Laplace Priors&lt;/a&gt; これもパラメータの事前分布にラプラス分布を導入してベイズ推定するもの。残差ではないはず。&lt;/li&gt;
&lt;li&gt;「L1」, 「Laplace」, 「residual」, 「lossless」で検索したけどスパース解を求めるものばかり。今のところはセーフ？&lt;/li&gt;
&lt;li&gt;→ 継続して調査はする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="SignedLMS"></category></entry><entry><title>IRLSの更新式について</title><link href="/irlsnogeng-xin-shi-nitsuite.html" rel="alternate"></link><published>2020-04-20T14:10:00+09:00</published><updated>2020-04-21T12:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-20:/irlsnogeng-xin-shi-nitsuite.html</id><summary type="html">&lt;p&gt;MathJaxの環境を確認しつつ使用中。プリアンブルが無いけどページ内で一回 &lt;tt class="docutils literal"&gt;newcommand&lt;/tt&gt; を行えばずっと使えるみたい。便利。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\newcommand …&lt;/div&gt;</summary><content type="html">&lt;p&gt;MathJaxの環境を確認しつつ使用中。プリアンブルが無いけどページ内で一回 &lt;tt class="docutils literal"&gt;newcommand&lt;/tt&gt; を行えばずっと使えるみたい。便利。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\newcommand\innerp[2]{\langle #1, #2 \rangle}
\newcommand\ve[1]{\boldsymbol{#1}}
\newcommand\parfrac[2]{\frac{\partial #1}{\partial #2}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;逐次的更新の件について。IRLSでは以下の評価関数 &lt;span class="math"&gt;\(J(\ve{\beta})\)&lt;/span&gt; の最小化を考える。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
J(\ve{\beta}) = \sum^{M}_{i = 1} w_{i} (y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}})^{2}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここで &lt;span class="math"&gt;\(M\)&lt;/span&gt; は観測数。これは二次式だから評価関数は凸関数になる。早速 &lt;span class="math"&gt;\(\ve{\beta}\)&lt;/span&gt; で偏微分してみると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\parfrac{}{\ve{\beta}} J(\ve{\beta}) &amp;amp;= \sum^{M}_{i = 1} w_{i} 2 \left(- \frac{\partial}{\partial \ve{\beta}} \innerp{\ve{\beta}}{\ve{x}_{i}} \right) (y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}}) \\
 &amp;amp;= -2 \sum^{M}_{i = 1} w_{i} (y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}}) \ve{x}_{i}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\parfrac{}{\ve{\beta}} J(\ve{\beta}) = 0\)&lt;/span&gt; とおくと、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\sum_{i = 1}^{M} w_{i} \innerp{\ve{\beta}}{\ve{x}_{i}} \ve{x}_{i} &amp;amp;= \sum_{i = 1}^{M} w_{i} y_{i} \ve{x}_{i} \\
\iff
\left[ \ve{x}_{1} ... \ve{x}_{M} \right]
\left[
 \begin{array}{c}
   w_{1} \innerp{\ve{\beta}}{\ve{x}_{1}} \\
   \vdots     \\
   w_{M} \innerp{\ve{\beta}}{\ve{x}_{M}}
 \end{array}
\right]
&amp;amp;=
\left[ \ve{x}_{1} ... \ve{x}_{M} \right]
\left[
 \begin{array}{c}
   w_{1}y_{1} \\
   \vdots     \\
   w_{M}y_{M}
 \end{array}
\right]
\\
\iff
\left[ \ve{x}_{1} ... \ve{x}_{M} \right]
\left[
 \begin{array}{ccc}
   w_{1}  &amp;amp; \dots  &amp;amp; 0      \\
   \vdots &amp;amp; \ddots &amp;amp; \vdots \\
   0      &amp;amp; \dots  &amp;amp; w_{M}
 \end{array}
\right]
\left[
 \begin{array}{c}
   \innerp{\ve{\beta}}{\ve{x}_{1}} \\
   \vdots     \\
   \innerp{\ve{\beta}}{\ve{x}_{M}}
 \end{array}
\right]
&amp;amp;=
\left[ \ve{x}_{1} ... \ve{x}_{M} \right]
\left[
 \begin{array}{ccc}
   w_{1}  &amp;amp; \dots  &amp;amp; 0      \\
   \vdots &amp;amp; \ddots &amp;amp; \vdots \\
   0      &amp;amp; \dots  &amp;amp; w_{M}
 \end{array}
\right]
\left[
 \begin{array}{c}
   y_{1} \\
   \vdots     \\
   y_{M}
 \end{array}
\right]
\\
\iff
\left[ \ve{x}_{1} ... \ve{x}_{M} \right]
\left[
 \begin{array}{ccc}
   w_{1}  &amp;amp; \dots  &amp;amp; 0      \\
   \vdots &amp;amp; \ddots &amp;amp; \vdots \\
   0      &amp;amp; \dots  &amp;amp; w_{M}
 \end{array}
\right]
\left[
 \begin{array}{c}
   \ve{x}_{1}^{\mathsf{T}} \\
   \vdots     \\
   \ve{x}_{M}^{\mathsf{T}}
 \end{array}
\right]
\ve{\beta}
&amp;amp;=
\left[ \ve{x}_{1} ... \ve{x}_{M} \right]
\left[
 \begin{array}{ccc}
   w_{1}  &amp;amp; \dots  &amp;amp; 0      \\
   \vdots &amp;amp; \ddots &amp;amp; \vdots \\
   0      &amp;amp; \dots  &amp;amp; w_{M}
 \end{array}
\right]
\ve{y}
\\
\iff
\ve{X} \ve{W} \ve{X}^{\mathsf{T}} \ve{\beta} &amp;amp;= \ve{X} \ve{W} \ve{y}
\end{align*}
&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\ve{X}\ve{W}\ve{X}^{\mathsf{T}}\)&lt;/span&gt; が正則（TODO: &lt;span class="math"&gt;\(\ve{X}\)&lt;/span&gt; が行フルランク、かつ &lt;span class="math"&gt;\(\ve{W}\)&lt;/span&gt; が正則なら行けそうに見えるけど本当か？）の場合は閉形式で係数が求まる:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{\beta} = (\ve{X} \ve{W} \ve{X}^{\mathsf{T}})^{-1} \ve{X} \ve{W} \ve{y}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ここまでは一般論。さて、更新式に注目する。&lt;span class="math"&gt;\(\beta_{j}\)&lt;/span&gt; だけで偏微分してみると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\parfrac{J(\ve{\beta})}{\beta_{j}} &amp;amp;= \sum_{i = 1}^{M} \parfrac{}{\beta_{j}} w_{i} (y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}})^{2} \\
&amp;amp;= -2 \sum_{i = 1}^{M} w_{i} (\ve{x}_{i})_{j} (y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}})
\end{align*}
&lt;/div&gt;
&lt;p&gt;残差のL1ノルム最小化を考えるときは &lt;span class="math"&gt;\(w_{i} = \frac{1}{|y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}}|}\)&lt;/span&gt; とおくので代入すると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\parfrac{J(\ve{\beta})}{\beta_{j}} = -2 \sum_{i = 1}^{M} (\ve{x}_{i})_{j} \mathrm{sign}(y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;瞬間値（&lt;/strong&gt; &lt;span class="math"&gt;\(M=1\)&lt;/span&gt; &lt;strong&gt;とする）を考えるとSigned-LMSの更新式そのものになっている。&lt;/strong&gt; 和を取ると平均操作に近いから、LMSアルゴリズムと考えていることは同じ。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\parfrac{J(\ve{\beta})}{\beta_{j}}\)&lt;/span&gt; を更に &lt;span class="math"&gt;\(\beta_{k}\)&lt;/span&gt; で偏微分してみると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{\partial^{2} J(\ve{\beta})}{\partial \beta_{j} \partial \beta_{k}} &amp;amp;= -2 \sum_{i = 1}^{M} w_{i} (\ve{x}_{i})_{j} \parfrac{}{\beta_{k}} (y_{i} - \innerp{\ve{\beta}}{\ve{x}_{i}}) \\
&amp;amp;= 2 \sum_{i = 1}^{M} w_{i} (\ve{x}_{i})_{j} (\ve{x}_{i})_{k} \\
&amp;amp;= 2 \left[ (\ve{x}_{1})_{j} \dots (\ve{x}_{M})_{j} \right]
 \left[
  \begin{array}{c}
    w_{1} (\ve{x}_{1})_{k} \\
    \vdots     \\
    w_{M} (\ve{x}_{M})_{k}
  \end{array}
 \right]
 = 2 \left[ (\ve{x}_{1})_{j} \dots (\ve{x}_{M})_{j} \right] \ve{W}
 \left[
  \begin{array}{c}
    (\ve{x}_{1})_{k} \\
    \vdots     \\
    (\ve{x}_{M})_{k}
  \end{array}
 \right]
\end{align*}
&lt;/div&gt;
&lt;p&gt;2次式が出てくるのがわかる（&lt;span class="math"&gt;\(\ve{W}\)&lt;/span&gt; は計量だ）。そして &lt;span class="math"&gt;\((\ve{H})_{jk} = \frac{\partial^{2} J(\ve{\beta})}{\partial \beta_{j} \partial \beta_{k}}\)&lt;/span&gt; なるヘッセ行列 &lt;span class="math"&gt;\(\ve{H}\)&lt;/span&gt; は以下:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\ve{H} = 2 \ve{X} \ve{W} \ve{X}^{\mathsf{T}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;ヘッセ行列の性質により関数の最小値・最大値の存在がわかる。対称行列なのは間違いない（&lt;span class="math"&gt;\((\ve{X})_{ij} = (\ve{X})_{ji}\)&lt;/span&gt; は自明）。（固有値分解とは見れない。&lt;span class="math"&gt;\(\ve{H}\)&lt;/span&gt; は &lt;span class="math"&gt;\(N \times N\)&lt;/span&gt; の行列であるのに対して、&lt;span class="math"&gt;\(\ve{X}\)&lt;/span&gt; は &lt;span class="math"&gt;\(N \times M\)&lt;/span&gt; の行列。&lt;span class="math"&gt;\(\ve{X} \ve{X}^{\mathsf{T}}\)&lt;/span&gt; は平均化、除算を抜いた分散共分散行列になり半正定値行列。）また、任意のベクトル &lt;span class="math"&gt;\(\ve{v}\)&lt;/span&gt; に対して、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\ve{v}^{\mathsf{T}} \ve{X} \ve{W} \ve{X}^{\mathsf{T}} \ve{v} &amp;amp;= \ve{v}^{\mathsf{T}} \ve{X} \ve{W}^{1/2} \ve{W}^{1/2} \ve{X}^{\mathsf{T}} \ve{v} \\
&amp;amp;= (\ve{W}^{1/2} \ve{X}^{\mathsf{T}} \ve{v})^{\mathsf{T}} \ve{W}^{1/2} \ve{X}^{\mathsf{T}} \ve{v} \\
&amp;amp;= || \ve{W}^{1/2} \ve{X}^{\mathsf{T}} \ve{v} ||_{2}^{2} \geq 0
\end{align*}
&lt;/div&gt;
&lt;p&gt;だから、&lt;span class="math"&gt;\(\ve{W}\)&lt;/span&gt; が半正定値（&lt;span class="math"&gt;\(\iff\)&lt;/span&gt; すべての重みが非負）ならばヘッセ行列は半正定値行列で、極小値が最小値になる。また、&lt;span class="math"&gt;\(J(\ve{\beta})\)&lt;/span&gt; は凸関数（半正定値だから狭義の凸関数ではない）。
もう少しヘッセ行列を見る。ヘッセ行列を上手く使えたらニュートン法で解けそうな気がして。&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
(\ve{H})_{jk} = 2 \sum_{i = 1}^{M} w_{i} (\ve{x}_{i})_{j} (\ve{x}_{i})_{k}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;より、スペクトル分解的に見ると、&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\frac{1}{2} \ve{H} &amp;amp;=
w_{1} \left[
  \begin{array}{ccc}
    (\ve{x}_{1})_{1}^{2}  &amp;amp; \dots &amp;amp; (\ve{x}_{1})_{1} (\ve{x}_{1})_{N} \\
    \vdots &amp;amp; \ddots &amp;amp; \vdots \\
    (\ve{x}_{1})_{N} (\ve{x}_{1})_{1} &amp;amp; \dots &amp;amp; (\ve{x}_{1})_{N}^{2} \\
  \end{array}
 \right]
 + \dots +
 w_{M} \left[
  \begin{array}{ccc}
    (\ve{x}_{M})_{1}^{2}  &amp;amp; \dots &amp;amp; (\ve{x}_{M})_{1} (\ve{x}_{M})_{N} \\
    \vdots &amp;amp; \ddots &amp;amp; \vdots \\
    (\ve{x}_{M})_{N} (\ve{x}_{M})_{1} &amp;amp; \dots &amp;amp; (\ve{x}_{M})_{N}^{2} \\
  \end{array}
 \right] \\
 &amp;amp;= w_{1} \ve{x}_{1} \ve{x}_{1}^{\mathsf{T}} + \dots + w_{M} \ve{x}_{M} \ve{x}_{M}^{\mathsf{T}} \\
 &amp;amp;= \sum_{i = 1}^{M} w_{i} \ve{x}_{i} \ve{x}_{i}^{\mathsf{T}}
\end{align*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;信号処理的には &lt;span class="math"&gt;\(\ve{x}_{1}, \ve{x}_{2}, \dots \ve{x}_{M}\)&lt;/span&gt; は系列で現れる。&lt;/li&gt;
&lt;li&gt;LMSフィルタでは &lt;span class="math"&gt;\(i = 1\)&lt;/span&gt; の時だけを考えていたと考えられれる。 &lt;span class="math"&gt;\(i = 2,\dots,M\)&lt;/span&gt; のときの影響は少ないのではないかと思う。&lt;/li&gt;
&lt;li&gt;FIRフィルタを考えるのならば、各 &lt;span class="math"&gt;\(\ve{x}_{1}\)&lt;/span&gt; は入ってきた1次元信号データを時系列順に並べたものだから、直前のベクトル &lt;span class="math"&gt;\(\ve{x}_{2}\)&lt;/span&gt; を使えそうな構造に見える。&lt;/li&gt;
&lt;li&gt;上の仮定を使ってヘッセ行列の逆行列 &lt;span class="math"&gt;\(\ve{H}^{-1}\)&lt;/span&gt; を逐次近似計算できない？&lt;/li&gt;
&lt;li&gt;分散共分散行列がほぼヘッセ行列になってるけどこれは何？&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.iim.cs.tut.ac.jp/~kanatani/papers/jcov.pdf"&gt;金谷さんの解説&lt;/a&gt; にそれとなく解説がある。フィッシャー情報行列との関連もある。。。クラメル・ラオの下限についてわかりやすい説明あり。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://web.econ.keio.ac.jp/staff/bessho/lecture/09/091014ML.pdf"&gt;最尤法&lt;/a&gt; にもそれとなく解説あり。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://oku.edu.mie-u.ac.jp/~okumura/stat/141115.html"&gt;奥村さん&lt;/a&gt; もあり。観測からヘッセ行列を構成できる？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そして自然勾配のアイディアが出てくる。自然勾配を使ったLMSアルゴリズムは…あった…&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://scholarsmine.mst.edu/cgi/viewcontent.cgi?referer=https://www.google.com/&amp;amp;httpsredir=1&amp;amp;article=2780&amp;amp;context=ele_comeng_facwork"&gt;Normalized Natural Gradient Adaptive Filtering for Sparse and Nonsparse Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.76.7538&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;甘利先生による解説&lt;/a&gt; で、LMSアルゴリズム含めて大まかなところはだいたい言ってる。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.researchgate.net/profile/Ligang_Liu3/publication/44098179_On_Improvement_of_Proportionate_Adaptive_Algorithms_for_Sparse_Impulse_Response/links/00b495315266ab9cfd000000.pdf"&gt;高知工科大学の博論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ワンチャンスL1残差最小化はやってないかも。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;前のMTGで言われたことの整理&lt;/li&gt;
&lt;li&gt;分散行列、ヘッセ行列、フィッシャー情報行列、自然勾配の整理&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiseodd.github.io/techblog/2018/03/11/fisher-information/"&gt;Fisher Information Matrix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OMPが気になる。試してみたい。&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="IRLS"></category><category term="L1ノルム"></category><category term="LAD"></category></entry><entry><title>IRLS(Iteratively Reweighted Least Squares) その2</title><link href="/irlsiteratively-reweighted-least-squares-sono2.html" rel="alternate"></link><published>2020-04-19T19:30:00+09:00</published><updated>2020-04-20T14:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-19:/irlsiteratively-reweighted-least-squares-sono2.html</id><summary type="html">&lt;p&gt;理論ばっかり追っていて悶々してきたので、IRLSでL1残差最小化が解けないか実験してみる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/kibo35/sparse-modeling/blob/master/ch05.ipynb"&gt;第5章 厳密解から近似解へ …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;理論ばっかり追っていて悶々してきたので、IRLSでL1残差最小化が解けないか実験してみる。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/kibo35/sparse-modeling/blob/master/ch05.ipynb"&gt;第5章 厳密解から近似解へ&lt;/a&gt; に『スパースモデリング』5章のPython実装あり。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/kibo35/items/66ec4479b0899ea4987d#irlsの概要"&gt;スパースモデリング：第3章 追跡アルゴリズム&lt;/a&gt; は『スパースモデリング』3章のPython実装。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IRLSの実装は &lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=2ahUKEwi4wZXEhe3oAhUZMd4KHZrzDqQQFjAAegQIARAB&amp;amp;url=https%3A%2F%2Fis.cuni.cz%2Fwebapps%2Fzzp%2Fdownload%2F130215341&amp;amp;usg=AOvVaw3Cxgr7_WLuDQqhL1aKQl9f"&gt;カレル大学卒論&lt;/a&gt; を参考に。Pythonで簡単にできた。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt;

&lt;span class="c1"&gt;# IRLS法によりPhi @ x = yのスパース解を求める&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;irls_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Phi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;EPSILON&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;8.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;# 重みの計算&lt;/span&gt;
    &lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Phi&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flatten&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="c1"&gt;# 小さくなりすぎた重みは打ち切る&lt;/span&gt;
    &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;EPSILON&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPSILON&lt;/span&gt;
    &lt;span class="c1"&gt;# 対角行列に展開&lt;/span&gt;
    &lt;span class="n"&gt;W&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;diag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;# 更新後の係数: Phi.T @ W @ Phi @ x = Phi.T @ W @ y の解&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linalg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;solve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Phi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;W&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;Phi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Phi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;W&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;DIMENSION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="n"&gt;NUM_SAMPLES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;
    &lt;span class="n"&gt;NUM_ITERATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;

    &lt;span class="c1"&gt;# 解ベクトル&lt;/span&gt;
    &lt;span class="n"&gt;X_ANSWER&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reshape&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;DIMENSION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;DIMENSION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;xhistory&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;DIMENSION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NUM_ITERATION&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;# 観測を生成&lt;/span&gt;
    &lt;span class="n"&gt;Phi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NUM_SAMPLES&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DIMENSION&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Phi&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;X_ANSWER&lt;/span&gt;
    &lt;span class="c1"&gt;# 加法的雑音を重畳&lt;/span&gt;
    &lt;span class="c1"&gt;# yrand = y + numpy.random.normal(0, 0.3, (NUM_SAMPLES, 1))&lt;/span&gt;
    &lt;span class="n"&gt;yrand&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;laplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NUM_SAMPLES&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NUM_ITERATION&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;emp_error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NUM_ITERATION&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# IRLSを繰り返し適用&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NUM_ITERATION&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;irls_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Phi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;yrand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;xhistory&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reshape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linalg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;norm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Phi&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;NUM_SAMPLES&lt;/span&gt;
        &lt;span class="n"&gt;emp_error&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linalg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;norm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;yrand&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Phi&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;ord&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;NUM_SAMPLES&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;実装は楽だったけど、誤差解析が沼。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;誤差を重畳してみると、真の誤差と経験誤差が当然一致しない。&lt;/li&gt;
&lt;li&gt;経験誤差的には局所解に入っている印象。&lt;/li&gt;
&lt;li&gt;サンプル数が少ないと大域最小解に入らないケースあり（経験誤差曲面の最小値が真の誤差の曲面の最小値に不一致）&lt;/li&gt;
&lt;li&gt;経験誤差の曲面は二次曲線に見える。（2次式の最小化を考えているから当然のはず。）&lt;/li&gt;
&lt;li&gt;最小二乗解よりも誤差が悪い時がある。最小二乗解はorder=2とすれば良くて、その時重み行列Wは単位行列になり、普通の最小二乗法と一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;思いつき:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;IRLSは評価関数の最小化を考える時閉形式で求まるので何も考えない。パラメータに関してもう一度微分できるのでニュートン法使えそう。&lt;/li&gt;
&lt;li&gt;フィルタのときのように逐次的に求められない？&lt;ul&gt;
&lt;li&gt;パラメータ全てではなく1こずつ。サンプルについても1こずつ。更新していく。評価関数の最小化は平均値の最小化に見受けられるので、逐次的に更新しても良いように見える。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日は遅いのでもう寝る。&lt;/p&gt;
</content><category term="雑記"></category><category term="LAD"></category><category term="IRLS"></category><category term="L1ノルム"></category></entry><entry><title>IRLS(Iteratively Reweighted Least Squares)</title><link href="/irlsiteratively-reweighted-least-squares.html" rel="alternate"></link><published>2020-04-18T17:30:00+09:00</published><updated>2020-04-19T00:19:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-18:/irlsiteratively-reweighted-least-squares.html</id><summary type="html">&lt;p&gt;LAD(Least Absolute Deviation)を近似的・逐次的に解く方法としてのIRLSについて調査。そういえば基本的な原理を抑えていなかった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://retrofocus28.blogspot.com/2015/09/iteratively-reweighted-least-squares.html"&gt;Iteratively Reweighted …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;LAD(Least Absolute Deviation)を近似的・逐次的に解く方法としてのIRLSについて調査。そういえば基本的な原理を抑えていなかった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://retrofocus28.blogspot.com/2015/09/iteratively-reweighted-least-squares.html"&gt;Iteratively Reweighted Least Squares　についてサクッと。&lt;/a&gt; 文字通りサクッとしたまとめ。OMPを使って解いているというのがとても気になる&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cnx.org/contents/krkDdys0&amp;#64;12/Iterative-Reweighted-Least-Squares"&gt;Iterative Reweighted Least Squares&lt;/a&gt; 導入から解法まで。しかしなぜ解が求まるのかは不明。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cedar.buffalo.edu/~srihari/CSE574/Chap4/4.3.3-IRLS.pdf"&gt;Iterative Reweighted Least Squares&lt;/a&gt; バッファロー大の講義資料？これも何故解けるのかはちゃんと書いてない。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.maths.lth.se/matematiklth/personal/fredrik/Session3.pdf"&gt;Iterative Reweighted Least Squares&lt;/a&gt; これが一番いいかも。なぜ解けるかもざっくり証明がある。&lt;ul&gt;
&lt;li&gt;そこで出てきたsupergradient（優勾配？劣勾配に対応している？）がよくわからん。資料のすぐ下に解説があったけど。 &lt;a class="reference external" href="http://www.its.caltech.edu/~kcborder/Notes/Supergrad.pdf"&gt;Supergradients&lt;/a&gt; に定義はあったけど幾何学的イメージが欲しい。&lt;/li&gt;
&lt;li&gt;Weiszfeld Algorithmsという幾何中央値を求めるアルゴリズムは &lt;a class="reference external" href="http://users.cecs.anu.edu.au/~trumpf/pubs/aftab_hartley_trumpf_PAMI2014.pdf"&gt;Generalized Weiszfeld Algorithms for Lq Optimization&lt;/a&gt; に解説あり。しかしこの論文いいこと言ってる。「Generalized Weiszfeld Algorithms」は圧縮センシングとは異なりスパース表現を求めるわけではない。スパース性は担保されなくても、よりL1ノルムの意味で小さい解を求める。&lt;/li&gt;
&lt;li&gt;なぜ、IRLSとLMSアルゴリズムを結びつける研究がないのか。IRLSの逐次適用によってもフィルタ係数を更新していけそうだけど。試してみるし、類似研究が無いか引き続き調べる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;『スパースモデリング』の5章にも記述はある。しかし残差のL1最小化ではない。&lt;/p&gt;
</content><category term="雑記"></category><category term="LAD"></category><category term="IRLS"></category><category term="L1ノルム"></category></entry><entry><title>LAD(Least Absolute Deviation)</title><link href="/ladleast-absolute-deviation.html" rel="alternate"></link><published>2020-04-17T23:00:00+09:00</published><updated>2020-04-17T23:00:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-17:/ladleast-absolute-deviation.html</id><summary type="html">&lt;p&gt;LAD(Least Absolute Deviation)を見ている。これは、残差をL1ノルムにした回帰問題一般のこと。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=2ahUKEwi4wZXEhe3oAhUZMd4KHZrzDqQQFjAAegQIARAB&amp;amp;url=https%3A%2F%2Fis.cuni.cz%2Fwebapps%2Fzzp%2Fdownload%2F130215341&amp;amp;usg=AOvVaw3Cxgr7_WLuDQqhL1aKQl9f"&gt;カレル大学卒論&lt;/a&gt; が結構まとまっている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://core.ac.uk/download/pdf/81785239.pdf"&gt;最尤 …&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;LAD(Least Absolute Deviation)を見ている。これは、残差をL1ノルムにした回帰問題一般のこと。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=2ahUKEwi4wZXEhe3oAhUZMd4KHZrzDqQQFjAAegQIARAB&amp;amp;url=https%3A%2F%2Fis.cuni.cz%2Fwebapps%2Fzzp%2Fdownload%2F130215341&amp;amp;usg=AOvVaw3Cxgr7_WLuDQqhL1aKQl9f"&gt;カレル大学卒論&lt;/a&gt; が結構まとまっている。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://core.ac.uk/download/pdf/81785239.pdf"&gt;最尤推定による近似的手法&lt;/a&gt; は軽く読んだ。各傾きと切片を固定して逐次更新していく。更新時は中央値を拾ってくる。うーん中央値だと高速推定が厳しい。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ラプラス分布の最尤推定しようとしてもがく。対数尤度とって見てみても、単純な絶対値和が出て止まるし、反復スケーリング法を参考に、パラメータの増分を加えた時の対数尤度の下限を求めようとしたが上手く行かず。4時間飛ばす。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="最尤推定の計算のあがき" src="./images/IMG_3828.jpg" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;最尤推定の計算のあがき&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;あがいて「A maximum likelihood approach to least absolute deviation regression」を引用している文献を漁ったら辞書学習をL1にしているやつが、やっぱりいた。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://winsty.net/papers/onndl.pdf"&gt;Online Robust Non-negative Dictionary Learning for Visual Tracking&lt;/a&gt; パーティクルフィルターを使っておる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上の文献で使ってるHuber Loss結構すごくね？この誤差に基づくLMSアルゴリズムねえの？→「Robust Huber adaptive filter」だけど中身を読めず…&lt;/p&gt;
&lt;p&gt;また、 &lt;a class="reference external" href="https://www.ml.uni-saarland.de/Lectures/CVX-SS10/ConvexOptimization-07-07-10.pdf"&gt;Convex Optimization and Modeling&lt;/a&gt; を読んでたらHuber損失はL1とL2の中間的な性質を示すようで、0に集中しなくなりそうな印象を受けた。&lt;/p&gt;
</content><category term="雑記"></category><category term="LAD"></category><category term="L1ノルム"></category></entry><entry><title>LMSフィルターの挙動観察</title><link href="/lmshuirutanoju-dong-guan-cha.html" rel="alternate"></link><published>2020-04-16T23:20:00+09:00</published><updated>2020-04-16T23:20:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-16:/lmshuirutanoju-dong-guan-cha.html</id><summary type="html">&lt;p&gt;&lt;span class="math"&gt;\(\mathrm{E}[\mathrm{sign}[e(n)]x(n-m)]\)&lt;/span&gt; の挙動を追いたい。色々な信号に対して、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(m\)&lt;/span&gt; が十分大きいとき、0に近づくかどうか&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;を知りたい。もし0 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;span class="math"&gt;\(\mathrm{E}[\mathrm{sign}[e(n)]x(n-m)]\)&lt;/span&gt; の挙動を追いたい。色々な信号に対して、&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(m\)&lt;/span&gt; が十分大きいとき、0に近づくかどうか&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;を知りたい。もし0に近づくならば有効な過程として解法に使える。
しかしその前に、LMSフィルター自体の挙動を追いたい。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;残差はどの様に減る？残差の時系列は？&lt;ul&gt;
&lt;li&gt;ステップサイズにより収束の度合い（残差の分布）が違う...&lt;/li&gt;
&lt;li&gt;当然、フィルタ次数でも収束の度合い（残差の分布）が違う&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;残差分布はどうなってる？Signed-LMSでラプラス分布に近づいてる？&lt;ul&gt;
&lt;li&gt;これは本当のようで、Signed-LMSの方が裾が細い残差分布が得られている。&lt;/li&gt;
&lt;li&gt;単純な正弦波に対してはLMSのほうが残差が小さくなるが、ボイスやピアノ音源に対しては圧倒的にSignLMSの方が性能が良い（残差のヒストグラムを見ると、裾が狭い）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\mathrm{E}[\mathrm{sign}[e(n)]x(n-m)]\)&lt;/span&gt;, &lt;span class="math"&gt;\(\mathrm{E}[e(n)x(n-m)]\)&lt;/span&gt; は両方とも0。&lt;ul&gt;
&lt;li&gt;逐次計算していったら、音源非依存で0に近づいていく&lt;/li&gt;
&lt;li&gt;当然だよな…そもそもの過程として入力と雑音は無相関と仮定しているのだから。&lt;ul&gt;
&lt;li&gt;仮定しているのだからは正しくなくて、無相関にするようにフィルタ係数を更新しているが正しい。&lt;/li&gt;
&lt;li&gt;無相関になったときに勾配が0で最急勾配法が止まる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;なんか絶対値誤差最小化ってどっかで見たよな…と思っていたら、&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Least_absolute_deviations"&gt;https://en.wikipedia.org/wiki/Least_absolute_deviations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;修士のときに一回戦っていた。&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=2ahUKEwi4wZXEhe3oAhUZMd4KHZrzDqQQFjAAegQIARAB&amp;amp;url=https%3A%2F%2Fis.cuni.cz%2Fwebapps%2Fzzp%2Fdownload%2F130215341&amp;amp;usg=AOvVaw3Cxgr7_WLuDQqhL1aKQl9f"&gt;カレル大学卒論&lt;/a&gt; が結構まとまっている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(L_{1}\)&lt;/span&gt; ノルム最小化を近接オペレータの繰り返し適用で解けんじゃね？と思っている&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://yamagensakam.hatenablog.com/entry/2018/02/14/075106"&gt;近接勾配法とproximal operator&lt;/a&gt; を読んだが、パラメータ正則化だけだな&lt;/li&gt;
&lt;li&gt;パラメータ正則化はあるけど、残差をスパースにするのがない。なんで？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="雑記"></category><category term="LMS"></category><category term="LMS Algorithm"></category></entry><entry><title>続・古いロスレス音声コーデックの調査</title><link href="/sok-gu-irosuresuyin-sheng-kodetsukunodiao-cha.html" rel="alternate"></link><published>2020-04-10T23:18:00+09:00</published><updated>2020-04-10T23:18:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-10:/sok-gu-irosuresuyin-sheng-kodetsukunodiao-cha.html</id><summary type="html">&lt;p&gt;古いロスレス音声コーデックと理論の概要を取りまとめた雑誌の特集があった:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.eie.polyu.edu.hk/~enyhchan/ce_ac_p1.pdf"&gt;Lossless Compression of Digital Audio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理論としてもその通り …&lt;/p&gt;</summary><content type="html">&lt;p&gt;古いロスレス音声コーデックと理論の概要を取りまとめた雑誌の特集があった:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.eie.polyu.edu.hk/~enyhchan/ce_ac_p1.pdf"&gt;Lossless Compression of Digital Audio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理論としてもその通りだし、雑誌発行時点(1998)からさしたるブレークスルーが無いように見える。&lt;/p&gt;
&lt;p&gt;AudioPak, OggSquish, Philips, Sonarc, WAという謎のコーデック現る…。いったい何個あるんだ。&lt;/p&gt;
</content><category term="雑記"></category><category term="Lossless Audio"></category><category term="ロスレス音声"></category></entry><entry><title>古いロスレス音声コーデックの調査/スパース適応フィルタ</title><link href="/gu-irosuresuyin-sheng-kodetsukunodiao-cha-supasushi-ying-huiruta.html" rel="alternate"></link><published>2020-04-08T16:45:00+09:00</published><updated>2020-04-08T23:45:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-08:/gu-irosuresuyin-sheng-kodetsukunodiao-cha-supasushi-ying-huiruta.html</id><summary type="html">&lt;p&gt;ロスレス音声の歴史を探るために古いロスレス音声コーデックの情報を探っている。以下のサイトが &lt;a class="reference external" href="https://wiki.hydrogenaud.io/index.php?title=Lossless_comparison"&gt;Hydrogenaudioでの比較&lt;/a&gt; よ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ロスレス音声の歴史を探るために古いロスレス音声コーデックの情報を探っている。以下のサイトが &lt;a class="reference external" href="https://wiki.hydrogenaud.io/index.php?title=Lossless_comparison"&gt;Hydrogenaudioでの比較&lt;/a&gt; よりも古い内容を扱っている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.firstpr.com.au/audiocomp/lossless/index.html"&gt;Lossless Compression of Audio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;見つけたロスレス音声コーデックを一覧する。というかほぼ &lt;a class="reference external" href="https://www.rarewares.org/rrw/about.php"&gt;Really Rare Wares&lt;/a&gt; 様へのリンク。&lt;/p&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;古めのロスレス音声コーデック&lt;/h2&gt;
&lt;div class="section" id="rkau-rk-audio"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.rarewares.org/rrw/rkau.php"&gt;RKAU(RK Audio)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;古い比較において優秀な圧縮率を誇っていた。当時のMonkey's Audioよりも上。サイトを覗いたら exe と dll のみの配布だった。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.archive.org/web/20020124045327/http://rksoft.virtualave.net/rkau.html"&gt;RKAUのホームページ（魚拓）&lt;/a&gt; を見ても特に情報なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="audiozip"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.rarewares.org/rrw/audiozip.php"&gt;AudioZip&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;これも圧縮率が比較的優秀。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://web.archive.org/web/20020207080740/http://www.csp.ntu.edu.sg:8000/MMS/MMCProjects.htm"&gt;AudioZipのホームページ（魚拓）&lt;/a&gt; を見てもこちらも特に情報なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="wavarc"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://www.firstpr.com.au/audiocomp/lossless/wavarc/0readme.html"&gt;WavArc&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;こちらも最大圧縮率(-c5)を選択するとそれなりに優秀な結果を出していた。このページにexeとドキュメントをまとめたzipもあり。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="wavezip"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.rarewares.org/rrw/wavezip.php"&gt;WaveZip&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;圧縮率よりは速度重視のコーデックのようだ。MUSICompress というアルゴリズムの実装。 &lt;a class="reference external" href="https://www.rarewares.org/rrw/files/lossless/musi_txt.txt"&gt;WaveZipのデータシート&lt;/a&gt; によると符号化にはLZ(Lampel-Ziv)を使用しているようだ。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.firstpr.com.au/audiocomp/lossless/index.html#wavezip"&gt;WaveZipの概要&lt;/a&gt; が比較サイトに掲載されていた。どうやら、入力波形を近似波形と誤差波形に分けて符号化するようだ。WaveZipではHu&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="lpac-ltac"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.rarewares.org/rrw/lpac.php"&gt;LPAC/LTAC&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;LPACはMPEG4-ALSの前身。LPACの前身がLTAC。LPACの平均的な圧縮率は優秀なようだ。 &lt;a class="reference external" href="https://web.archive.org/web/20060213124711/http://www.nue.tu-berlin.de/wer/liebchen/lpac.html"&gt;LPAC（魚拓）&lt;/a&gt; に以前公開していたサイトあり。&lt;/p&gt;
&lt;p&gt;LTAC(Lossless Transform Audio Compression)は名前の通り変換符号化に基づくロスレス音声圧縮コーデック、LPAC(Lossless Predictive Audio Compression)は予測に基づくロスレス音声圧縮コーデック。&lt;/p&gt;
&lt;p&gt;LPACに ベルリン工科大学、Real Networks、NTT の改良が加わってMPEG4-ALSが出来上がり、それ以降LPACの開発は停止されている。この経緯については &lt;a class="reference external" href="https://web.archive.org/web/20060212123059/http://www.nue.tu-berlin.de/forschung/projekte/lossless/mp4als.html"&gt;MPEG4-ALS（魚拓）&lt;/a&gt; に記述あり。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="shorten"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://archive.is/Z8k97"&gt;Shorten（魚拓）&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;おそらくロスレス音声の最古参にして基礎。なんと執筆時点（2020-04-08）でも &lt;tt class="docutils literal"&gt;brew&lt;/tt&gt; でインストールできた（ &lt;a class="reference external" href="https://linux.die.net/man/1/shorten"&gt;Shortenのmanページ&lt;/a&gt; もあるから各Linuxディストリビューションで使えるものと想像する）。エンコード速度はピカイチ。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=9797AA37C32F12179AF0803D8C2B22D2?doi=10.1.1.53.7337&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;Shortenの論文&lt;/a&gt; （テクニカルレポート）もある。この論文で、今のロスレス音声につながる重要な事実に幾つか触れている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;音声信号は準定常（短い区間では定常とみなせる）だからブロックに分けてエンコード/デコードすべき。&lt;/li&gt;
&lt;li&gt;音声のモデル化には線形予測(LPC, Linear Predictive Coding)が使える。&lt;/li&gt;
&lt;li&gt;残差信号はガウス分布よりもラプラス分布に従っていると見える。その符号化にはライス符号を使うのが良い。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この時点で既にラプラス分布を仮定したパラメータ設定を行っているからかなりの慧眼。他のロスレス音声コーデックはShortenを発展させたものに過ぎないと見える。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;所感&lt;/h2&gt;
&lt;p&gt;どうも2000年代前半までは各自でロスレス音声コーデックを作り、各自で最強を謳っていたらしい。&lt;/p&gt;
&lt;p&gt;歴史を雑にまとめると、1994年にShortenの論文が出てから、それよりも圧縮率の良いもの、圧縮速度（展開速度）が早いものが開発されて混沌に突入し上記のコーデックが現れた。その後、Monkey's Audio, WavPack, FLAC, LPAC（MPEG4-ALS）が生き残り、2000年以降はLa（更新停止）, TAK, TTA, ALAC（更新停止）, WMAL(Windows Media Audio Lossless), 2010年以降はOptimFROGが出現しているようだ。&lt;/p&gt;
&lt;p&gt;気になるのは比較サイトの &lt;a class="reference external" href="http://www.firstpr.com.au/audiocomp/lossless/index.html#rice"&gt;Rice Coding, AKA Rice Packing, Elias Gamma codes and other approaches&lt;/a&gt; である。Rice符号よりも効率の良いとされるPod符号の紹介がある。要観察。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h2&gt;スパース適応フィルタ&lt;/h2&gt;
&lt;p&gt;LPCの定式化をスパースにする試みは多くなされている。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.cs.tut.fi/~tabus/2013GhidoTabus.pdf"&gt;Sparse Modeling for Lossless Audio Compression&lt;/a&gt; : Ghidoさん（OptimFROGの人）の試み&lt;ul&gt;
&lt;li&gt;貪欲法によりスパース解を求めている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.jstage.jst.go.jp/article/jasj/71/11/71_KJ00010109335/_pdf/-char/ja"&gt;スパース表現に基づく音声音響符号化&lt;/a&gt; : NTTの試み&lt;ul&gt;
&lt;li&gt;最小二乗解を求めるのではなくL1最小化に置き換えた定式化を行う。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;でも、TTAがやっているような適応フィルタをスパース解に近づける手法はまだロスレス音声に対してやっていないように見える。
スパースな解を目指してフィルタ係数を更新する適応フィルタはスパース適応フィルタ(Sparse Adaptive Filters)というようで、2000年代以降に研究が進んでいるようだ。&lt;/p&gt;
&lt;p&gt;最も基本的な適応フィルタであるLMS(Least Mean Square)フィルタは名前の通り二乗誤差最小化に立脚している。
スパース適応フィルタの主な用途はエコーキャンセル、ブラインド話者分離、複数話者特定ではあるが、やはり変換後の分布がスパースになるというのは大きい。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://signal.ee.bilkent.edu.tr/defevent/papers/cr1256.pdf"&gt;スパース適応フィルタの最近のサーベイ論文&lt;/a&gt; を流し読みした。スパース適応フィルタは、変数更新のときに1部の変数だけ更新する方法と、スパース最適化に従って更新するやり方の2つがあった。PNLMS(Proportionate NLMS), IPNLMS(Improved PNLMS)が後者の定式化で興味あり。引き続き見ていく。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://arxiv.org/pdf/1012.5066.pdf"&gt;Regularized Least-Mean-Square Algorithms&lt;/a&gt; には正則化を入れたLMSアルゴリズムの解説あり。LASSOにモチベーションを受けた最適化アルゴリズムが &lt;a class="reference external" href="https://wiki.eecs.umich.edu/global/data/hero/images/7/7b/Yilun-icassp2-09.pdf"&gt;ZA-LMS&lt;/a&gt; や &lt;a class="reference external" href="http://azadproject.ir/wp-content/uploads/2017/01/2018-Online-Sparse-System-Identification-and-Signal-Reconstruction-Using-Projections-.pdf"&gt;APWL1&lt;/a&gt; として提案されている。&lt;/p&gt;
&lt;/div&gt;
</content><category term="雑記"></category><category term="SLA"></category><category term="Lossless Audio"></category><category term="ロスレス音声"></category><category term="スパース符号化"></category></entry><entry><title>ブログ導入</title><link href="/burogudao-ru.html" rel="alternate"></link><published>2020-04-02T18:00:00+09:00</published><updated>2020-04-02T21:34:00+09:00</updated><author><name>aiki</name></author><id>tag:None,2020-04-02:/burogudao-ru.html</id><summary type="html">&lt;p&gt;GitHub io + Pelican を使ってみた。しばらくこちらで日報を書きたい。
GitHub io + Pelicanは以下の記事を参考にしている。まだあんまり分かっ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;GitHub io + Pelican を使ってみた。しばらくこちらで日報を書きたい。
GitHub io + Pelicanは以下の記事を参考にしている。まだあんまり分かってない。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/yusukew62/items/7b01d2370cdbe170b28d"&gt;Python製静的HTMLジェネレータのPelicanでGitHub Pagesを公開する方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/ririli/items/0e06b21cb709beae4514"&gt;GitHub Pagesで静的サイトを簡単に作る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://qiita.com/saira/items/71faa202efb4320cb41d"&gt;Python製 Pelican を使ってサクッとブログを公開する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.pelicanthemes.com"&gt;Pelicanのテーマ集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/getpelican/pelican-themes/issues/460#issuecomment-346652986"&gt;テーマ導入時にハマったので参考にしたissue comment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日は（というか3月末）からSLAの高速化作業とまとめをしていた。&lt;/p&gt;
&lt;p&gt;格子型フィルタ演算はどうしても1乗算型にできず。次数演算を4次数にしてSSE演算するのがやっと。
SSE化するときに、スカラー演算とベクトル演算が混じったときに処理負荷が大きく上がってハマった。
&lt;a class="reference external" href="https://stackoverflow.com/questions/10313397/where-does-the-sse-instructions-outperform-normal-instructions"&gt;StackOverFlowの記事&lt;/a&gt; では &lt;cite&gt;_mm_set_epi32&lt;/cite&gt; のコストが高い旨記述あり。 &lt;cite&gt;_mm_loadu_si128&lt;/cite&gt; の使用に置き換えた。
&lt;a class="reference external" href="https://stackoverflow.com/questions/24446516/performance-worsens-when-using-sse-simple-addition-of-integer-arrays"&gt;他の記事&lt;/a&gt; で言及があってようやく分かった。全てをベクトル演算化したところ、処理負荷は4/5倍になった。あんまり早くなっていない。遺憾。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://herumi.in.coocan.jp/prog/gcc-and-vc.html"&gt;gccとVC&lt;/a&gt; にはgccとVisual Studioの挙動の差異について色々と書いてあった。&lt;/p&gt;
</content><category term="雑記"></category><category term="SLA"></category><category term="SSE"></category><category term="test"></category><category term="pelican"></category><category term="githubio"></category></entry></feed>